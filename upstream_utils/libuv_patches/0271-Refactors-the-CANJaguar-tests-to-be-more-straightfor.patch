From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jonathan Leitschuh <jlleitschuh@wpi.edu>
Date: Thu, 7 Aug 2014 16:05:14 -0400
Subject: [PATCH 0271/6262] Refactors the CANJaguar tests to be more
 straightforward.

Adds a brownout test from C++ (Ignored)

Change-Id: I81e04e20fb08cd9da7401d9c0e9fa6faf1fff0de
---
 wpilibj/wpilibJavaIntegrationTests/pom.xml    |  22 +--
 .../first/wpilibj/can/AbstractCANTest.java    |   2 +-
 .../can/CANCurrentQuadEncoderModeTest.java    |   4 +-
 .../wpi/first/wpilibj/can/CANDefaultTest.java |  75 ++++++--
 .../can/CANPercentQuadEncoderModeTest.java    | 167 ++++++++++--------
 .../can/CANPositionPotentiometerModeTest.java |  82 +++++----
 .../can/CANSpeedQuadEncoderModeTest.java      |   6 +-
 .../can/CANVoltageQuadEncoderModeTest.java    | 130 ++++++--------
 8 files changed, 272 insertions(+), 216 deletions(-)

diff --git a/wpilibj/wpilibJavaIntegrationTests/pom.xml b/wpilibj/wpilibJavaIntegrationTests/pom.xml
index d4a3dc7c6e89d2e8a828291066aaadea4e21703c..2718621ed44b57f6f8b7b9cf997bce897685494e 100644
--- a/wpilibj/wpilibJavaIntegrationTests/pom.xml
+++ b/wpilibj/wpilibJavaIntegrationTests/pom.xml
@@ -29,11 +29,11 @@
 			<artifactId>hamcrest-all</artifactId>
 			<version>1.3</version>
 		</dependency>
-		<!--dependency>
-		    <groupId>com.googlecode.junit-toolbox</groupId>
-		    <artifactId>junit-toolbox</artifactId>
-		    <version>1.8</version>
-		</dependency-->
+		<dependency>
+			<groupId>com.googlecode.junit-toolbox</groupId>
+			<artifactId>junit-toolbox</artifactId>
+			<version>2.0</version>
+		</dependency>
 	</dependencies>
 
 	<profiles>
@@ -114,12 +114,12 @@
 									<version>1.3</version>
 									<type>jar</type>
 								</artifactItem>
-								<!--artifactItem>
-								    <groupId>com.googlecode.junit-toolbox</groupId>
-								    <artifactId>junit-toolbox</artifactId>
-								    <version>1.8</version>
-								    <type>jar</type>
-								</artifactItem-->
+								<artifactItem>
+									<groupId>com.googlecode.junit-toolbox</groupId>
+									<artifactId>junit-toolbox</artifactId>
+									<version>2.0</version>
+									<type>jar</type>
+								</artifactItem>
 							</artifactItems>
 							<outputDirectory>${project.build.directory}/classes</outputDirectory>
 						</configuration>
diff --git a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/AbstractCANTest.java b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/AbstractCANTest.java
index 60f26d26654946d8efe4910bd9c163868e8363c2..bbf16501d327c8edc6fd96b7ee63fea9f3291060 100644
--- a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/AbstractCANTest.java
+++ b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/AbstractCANTest.java
@@ -28,7 +28,7 @@ public abstract class AbstractCANTest extends AbstractComsSetup{
 	public static final double kMotorTimeSettling = 10;
 	public static final double kPotentiometerSettlingTime = 10.0;
 	public static final double kEncoderSettlingTime = 0.50;
-	public static final double kEncoderSpeedTolerance = 30.0;
+	public static final double kEncoderSpeedTolerance = 20.0;
 	public static final double kLimitSettlingTime = 20.0; //timeout in seconds
 	public static final double kStartupTime = 0.50;
 	public static final double kEncoderPositionTolerance = .75;
diff --git a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANCurrentQuadEncoderModeTest.java b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANCurrentQuadEncoderModeTest.java
index 2671ce2951fd843764dd193cf42d8b74efa2321a..0af2fdf3bb1385f0807be89f92b77965a533a888 100644
--- a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANCurrentQuadEncoderModeTest.java
+++ b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANCurrentQuadEncoderModeTest.java
@@ -74,7 +74,7 @@ public class CANCurrentQuadEncoderModeTest extends AbstractCANTest {
 			}
 		}
 
-		assertEquals(setpoint, getME().getMotor().getOutputCurrent(), kCurrentTolerance);
+		assertEquals("The desired output current was not reached",setpoint, getME().getMotor().getOutputCurrent(), kCurrentTolerance);
 	}
 	
 	@Test
@@ -90,7 +90,7 @@ public class CANCurrentQuadEncoderModeTest extends AbstractCANTest {
 			}
 		}
 
-		assertEquals(Math.abs(setpoint), getME().getMotor().getOutputCurrent(), kCurrentTolerance);
+		assertEquals("The desired output current was not reached", Math.abs(setpoint), getME().getMotor().getOutputCurrent(), kCurrentTolerance);
 	}
 
 }
diff --git a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANDefaultTest.java b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANDefaultTest.java
index ef750089d9229cbb4090d8e2ccd4cded44966397..db9d2c467eef66678784bfd34d23982ec7972d4f 100644
--- a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANDefaultTest.java
+++ b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANDefaultTest.java
@@ -13,12 +13,16 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 
-import java.util.logging.Level;
+import java.util.concurrent.TimeUnit;
 import java.util.logging.Logger;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
+import com.googlecode.junittoolbox.PollingWait;
+import com.googlecode.junittoolbox.RunnableAssert;
+
 import edu.wpi.first.wpilibj.CANJaguar;
 import edu.wpi.first.wpilibj.Timer;
 
@@ -28,6 +32,9 @@ import edu.wpi.first.wpilibj.Timer;
  */
 public class CANDefaultTest extends AbstractCANTest{
 	private static final Logger logger = Logger.getLogger(CANDefaultTest.class.getName());
+	
+	private static final double kSpikeTime = .5;
+	
 	@Override
 	protected Logger getClassLogger() {
 		return logger;
@@ -92,37 +99,77 @@ public class CANDefaultTest extends AbstractCANTest{
 	
 	@Test
 	public void testFakeLimitSwitchForwards() {
+		//Given
 		getME().getMotor().configLimitMode(CANJaguar.LimitMode.SwitchInputsOnly);
 		getME().getMotor().enableControl();
-		assertTrue("CAN Jaguar did not start with the Forward Limit Switch low", getME().getMotor().getForwardLimitOK());
+		assertTrue("[TEST SETUP] CANJaguar did not start with the Forward Limit Switch low", getME().getMotor().getForwardLimitOK());
+		
+		//When
 		getME().getForwardLimit().set(true);
 		
-		delayTillInCorrectStateWithMessage(Level.FINE, kLimitSettlingTime+10, "Forward Limit settling", new BooleanCheck(){@Override
-			public boolean getAsBoolean(){
+		//Then
+		PollingWait wait = new PollingWait().timeoutAfter((long)kLimitSettlingTime, TimeUnit.SECONDS).pollEvery(1, TimeUnit.MILLISECONDS);
+		wait.until(new RunnableAssert("Setting the CANJAguar forward limit switch high") {
+			@Override
+			public void run() throws Exception {
 				getME().getMotor().set(0);
-				return !getME().getMotor().getForwardLimitOK();
+				assertFalse("Setting the forward limit switch high did not cause the forward limit switch to trigger", getME().getMotor().getForwardLimitOK());
 			}
 		});
-		
-		assertFalse("Setting the forward limit switch high did not cause the forward limit switch to trigger after " + kLimitSettlingTime + " seconds", getME().getMotor().getForwardLimitOK());
 	}
 
 	
 	@Test
 	public void testFakeLimitSwitchReverse() {
+		//Given
 		getME().getMotor().configLimitMode(CANJaguar.LimitMode.SwitchInputsOnly);
 		getME().getMotor().enableControl();
-		assertTrue("CAN Jaguar did not start with the Reverse Limit Switch low", getME().getMotor().getReverseLimitOK());
+		assertTrue("[TEST SETUP] CANJaguar did not start with the Reverse Limit Switch low", getME().getMotor().getReverseLimitOK());
+		//When
 		getME().getReverseLimit().set(true);
 		
-		delayTillInCorrectStateWithMessage(Level.FINE, kLimitSettlingTime+10, "Reverse Limit settling", new BooleanCheck(){@Override
-			public boolean getAsBoolean(){
+		//Then
+		PollingWait wait = new PollingWait().timeoutAfter((long)kLimitSettlingTime, TimeUnit.SECONDS).pollEvery(1, TimeUnit.MILLISECONDS);
+		wait.until(new RunnableAssert("Setting the CANJAguar reverse limit switch high") {
+			@Override
+			public void run() throws Exception {
 				getME().getMotor().set(0);
-				return !getME().getMotor().getReverseLimitOK();
+				assertFalse("Setting the reverse limit switch high did not cause the forward limit switch to trigger", getME().getMotor().getReverseLimitOK());
 			}
 		});
+	}
+	
+	@Ignore("Brown out not working needs further testing")
+	@Test
+	public void testPositionModeVerifiesOnBrownOut() {
+		final double setpoint = 10.0;
 		
-		assertFalse("Setting the reverse limit switch high did not cause the reverse limit switch to trigger after " + kLimitSettlingTime + " seconds", getME().getMotor().getReverseLimitOK());
-	}	
-
+		//Given
+		getME().getMotor().setPositionMode(CANJaguar.kQuadEncoder, 360, 10.0, 0.1, 0.0);
+		getME().getMotor().enableControl();
+		setCANJaguar(kMotorTime, 0.0);
+		
+		getME().powerOn();
+		
+		//When
+		/* Turn the spike off and on again */
+		
+		getME().powerOff();
+		Timer.delay(kSpikeTime);
+		getME().powerOn();
+		Timer.delay(kSpikeTime);
+		
+		PollingWait wait = new PollingWait().timeoutAfter(15, TimeUnit.SECONDS).pollEvery(1, TimeUnit.MILLISECONDS);
+		/* The jaguar should automatically get set to quad encoder position mode,
+			so it should be able to reach a setpoint in a couple seconds. */
+		
+		wait.until(new RunnableAssert("Waiting for CANJaguar to reach set-point") {
+			@Override
+			public void run() throws Exception {
+				getME().getMotor().set(setpoint);
+				assertEquals("CANJaguar should have resumed PID control after power cycle",
+						setpoint, getME().getMotor().getPosition(), kEncoderPositionTolerance);
+			}
+		});
+	}
 }
diff --git a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANPercentQuadEncoderModeTest.java b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANPercentQuadEncoderModeTest.java
index 77966e9b21d2dda4f7c087308a653c8c9d3fcf33..3360d04279fbd97901432bf2a13743a574a6b89c 100644
--- a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANPercentQuadEncoderModeTest.java
+++ b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANPercentQuadEncoderModeTest.java
@@ -1,8 +1,8 @@
 /*----------------------------------------------------------------------------*/
-/* Copyright (c) FIRST 2008-2014. All Rights Reserved.                        */
+/* Copyright (c) FIRST 2008-2014. All Rights Reserved.						*/
 /* Open Source Software - may be modified and shared by FRC teams. The code   */
 /* must be accompanied by the FIRST BSD license file in the root directory of */
-/* the project.                                                               */
+/* the project.															   */
 /*----------------------------------------------------------------------------*/
 package edu.wpi.first.wpilibj.can;
 
@@ -10,8 +10,11 @@ import static org.hamcrest.Matchers.greaterThan;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.lessThan;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
 
+import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
@@ -19,6 +22,9 @@ import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
 
+import com.googlecode.junittoolbox.PollingWait;
+import com.googlecode.junittoolbox.RunnableAssert;
+
 import edu.wpi.first.wpilibj.CANJaguar;
 import edu.wpi.first.wpilibj.Timer;
 
@@ -82,39 +88,45 @@ public class CANPercentQuadEncoderModeTest extends AbstractCANTest{
 	
 	@Test
 	public void testRotateForward() {
+		//Given
 		getME().getMotor().enableControl();
 		final double initialPosition = getME().getMotor().getPosition();
-	    /* Drive the speed controller briefly to move the encoder */
+		//When
+		/* Drive the speed controller briefly to move the encoder */
 		runMotorForward();
-		BooleanCheck correctState = new BooleanCheck(){@Override
-			public boolean getAsBoolean(){
-				runMotorForward();//Calls set every time before we check the value
-				return initialPosition < getME().getMotor().getPosition();
-			}
-		};
-		delayTillInCorrectStateWithMessage(Level.FINE, kMotorTimeSettling, "Position incrementing", correctState);
-	    stopMotor();
 
-	    /* The position should have increased */
-	    assertThat("CAN Jaguar position should have increased after the motor moved", getME().getMotor().getPosition(), is(greaterThan(initialPosition)));
+		//Then
+		PollingWait wait = new PollingWait().timeoutAfter((long)kMotorTimeSettling, TimeUnit.SECONDS).pollEvery(1, TimeUnit.MILLISECONDS);
+		wait.until(new RunnableAssert("CANJaguar position incrementing") {
+			@Override
+			public void run() throws Exception {
+				runMotorForward();
+				assertThat("CANJaguar position should have increased after the motor moved", getME().getMotor().getPosition(), is(greaterThan(initialPosition)));
+			}
+		});
+		
+		stopMotor();
 	}
 	
 	@Test
 	public void testRotateReverse() {
+		//Given
 		getME().getMotor().enableControl();
 		final double initialPosition = getME().getMotor().getPosition();
-	    /* Drive the speed controller briefly to move the encoder */
-	    runMotorReverse();
-	    delayTillInCorrectStateWithMessage(Level.FINE, kMotorTimeSettling, "Position decrementing", new BooleanCheck(){@Override
-	    	public boolean getAsBoolean(){
-	    			runMotorReverse();//Calls set every time before we check the value
-	    			return initialPosition > getME().getMotor().getPosition();
-	    		}
-	    });
-	    stopMotor();
-
-	    /* The position should have decreased */
-	    assertThat( "CAN Jaguar position should have decreased after the motor moved", getME().getMotor().getPosition(), is(lessThan(initialPosition)));
+		//When
+		/* Drive the speed controller briefly to move the encoder */
+		runMotorReverse();
+		
+		//Then
+		PollingWait wait = new PollingWait().timeoutAfter((long)kMotorTimeSettling, TimeUnit.SECONDS).pollEvery(1, TimeUnit.MILLISECONDS);
+		wait.until(new RunnableAssert("CANJaguar position decrementing") {
+			@Override
+			public void run() throws Exception {
+				runMotorReverse();
+				assertThat("CANJaguar position should have decreased after the motor moved", getME().getMotor().getPosition(), is(lessThan(initialPosition)));
+			}
+		});
+		stopMotor();
 	}
 	
 	/**
@@ -131,12 +143,16 @@ public class CANPercentQuadEncoderModeTest extends AbstractCANTest{
 		stopMotor();
 		Timer.delay(kEncoderSettlingTime);
 		
-		delayTillInCorrectStateWithMessage(Level.FINE, kLimitSettlingTime, "Concurrent Limit settling", new BooleanCheck(){@Override
-			public boolean getAsBoolean(){return !getME().getMotor().getForwardLimitOK() && getME().getMotor().getReverseLimitOK();}});
-		
-		/* Make sure we limits are recognized by the Jaguar. */
-		//assertFalse("The forward limit switch did not settle after " + kLimitSettlingTime + " seconds",getME().getMotor().getForwardLimitOK());
-		//assertTrue("The reverse limit switch did not settle after " + kLimitSettlingTime + " seconds", getME().getMotor().getReverseLimitOK());
+		PollingWait wait = new PollingWait().timeoutAfter((long)kLimitSettlingTime, TimeUnit.SECONDS).pollEvery(1, TimeUnit.MILLISECONDS);
+		/* Wait until the limits are recognized by the CANJaguar. */
+		wait.until(new RunnableAssert("Waiting for the forward and reverse limit switches to be in the correct state") {
+			@Override
+			public void run() throws Exception {
+				stopMotor();
+				assertFalse("[TEST SETUP] The forward limit switch is not in the correct state",getME().getMotor().getForwardLimitOK());
+				assertTrue("[TEST SETUP]The reverse limit switch is not in the correct state", getME().getMotor().getReverseLimitOK());
+			}
+		});
 
 		final double initialPosition = getME().getMotor().getPosition();
 		
@@ -170,18 +186,18 @@ public class CANPercentQuadEncoderModeTest extends AbstractCANTest{
 
 		stopMotor();
 		Timer.delay(kEncoderSettlingTime);
-		
-		delayTillInCorrectStateWithMessage(Level.FINE, kLimitSettlingTime, "Concurrent Limit settling", new BooleanCheck(){@Override
-		public boolean getAsBoolean(){
+
+		PollingWait limitWait = new PollingWait().timeoutAfter((long)kLimitSettlingTime, TimeUnit.SECONDS).pollEvery(1, TimeUnit.MILLISECONDS);
+		/* Wait until the limits are recognized by the CANJaguar. */
+		limitWait.until(new RunnableAssert("Waiting for the forward and reverse limit switches to be in the correct state") {
+			@Override
+			public void run() throws Exception {
 				stopMotor();
-				return !getME().getMotor().getForwardLimitOK() && getME().getMotor().getReverseLimitOK();
+				assertFalse("[TEST SETUP] The forward limit switch is not in the correct state",getME().getMotor().getForwardLimitOK());
+				assertTrue("[TEST SETUP] The reverse limit switch is not in the correct state", getME().getMotor().getReverseLimitOK());
 			}
 		});
-		
-		/* Make sure we limits are still recognized by the Jaguar. */
-		//assertFalse("The forward limit switch did not settle after " + kLimitSettlingTime + " seconds",getME().getMotor().getForwardLimitOK());
-		//assertTrue("The reverse limit switch did not settle after " + kLimitSettlingTime + " seconds", getME().getMotor().getReverseLimitOK());
-		
+
 		final double initialPosition = getME().getMotor().getPosition();
 		
 		//When
@@ -190,19 +206,20 @@ public class CANPercentQuadEncoderModeTest extends AbstractCANTest{
 		 * move, since only the forward switch is activated.
 		 */
 		setCANJaguar(kMotorTime, -1);
-		delayTillInCorrectStateWithMessage(Level.FINE, kMotorTimeSettling, "Encoder drive reverse settling", new BooleanCheck(){@Override
-			public boolean getAsBoolean(){
+		//Then
+		PollingWait wait = new PollingWait().timeoutAfter((long)kMotorTimeSettling, TimeUnit.SECONDS).pollEvery(1, TimeUnit.MILLISECONDS);
+		wait.until(new RunnableAssert("Waiting for the encoder to update") {
+			@Override
+			public void run() throws Exception {
 				runMotorReverse();
-				return getME().getMotor().getPosition() != initialPosition;
+				assertThat(
+						"CAN Jaguar should have moved in reverse while the forward limit was on",
+						getME().getMotor().getPosition(), is(lessThan(initialPosition)));
 			}
+			
 		});
 		stopMotor();
 
-		//Then
-		/* The position should have decreased */
-		assertThat(
-				"CAN Jaguar should have moved in reverse while the forward limit was on",
-				getME().getMotor().getPosition(), is(lessThan(initialPosition)));
 	}
 
 	/**
@@ -220,16 +237,16 @@ public class CANPercentQuadEncoderModeTest extends AbstractCANTest{
 		stopMotor();
 		Timer.delay(kEncoderSettlingTime);
 		
-		delayTillInCorrectStateWithMessage(Level.FINE, kLimitSettlingTime, "Concurrent Limit settling", new BooleanCheck(){@Override
-			public boolean getAsBoolean(){
+		PollingWait wait = new PollingWait().timeoutAfter((long)kLimitSettlingTime, TimeUnit.SECONDS).pollEvery(1, TimeUnit.MILLISECONDS);
+		/* Wait until the limits are recognized by the CANJaguar. */
+		wait.until(new RunnableAssert("Waiting for the forward and reverse limit switches to be in the correct state") {
+			@Override
+			public void run() throws Exception {
 				stopMotor();
-				return getME().getMotor().getForwardLimitOK() && !getME().getMotor().getReverseLimitOK();
+				assertTrue("[TEST SETUP] The forward limit switch is not in the correct state",getME().getMotor().getForwardLimitOK());
+				assertFalse("[TEST SETUP] The reverse limit switch is not in the correct state", getME().getMotor().getReverseLimitOK());
 			}
 		});
-		
-		/* Make sure we limits are recognized by the Jaguar. */
-		//assertTrue("The forward limit switch did not settle after " + kLimitSettlingTime + " seconds", getME().getMotor().getForwardLimitOK());
-		//assertFalse("The reverse limit switch did not settle after " + kLimitSettlingTime + " seconds",getME().getMotor().getReverseLimitOK());
 
 		final double initialPosition = getME().getMotor().getPosition();
 		
@@ -253,6 +270,9 @@ public class CANPercentQuadEncoderModeTest extends AbstractCANTest{
 	 * Test if we can limit the Jaguar to only moving forwards with a fake limit
 	 * switch.
 	 */
+	/**
+	 * 
+	 */
 	@Test
 	public void shouldRotateForward_WhenFakeLimitSwitchReversesIsTripped() {
 		//Given
@@ -261,17 +281,18 @@ public class CANPercentQuadEncoderModeTest extends AbstractCANTest{
 		getME().getReverseLimit().set(true);
 		getME().getMotor().enableControl();
 		
-		delayTillInCorrectStateWithMessage(Level.FINE, kLimitSettlingTime, "Concurrent Limit settling", new BooleanCheck(){@Override
-		public boolean getAsBoolean(){
-			stopMotor();
-			return getME().getMotor().getForwardLimitOK() && !getME().getMotor().getReverseLimitOK();
+		PollingWait limitWait = new PollingWait().timeoutAfter((long)kLimitSettlingTime, TimeUnit.SECONDS).pollEvery(1, TimeUnit.MILLISECONDS);
+		/* Wait until the limits are recognized by the CANJaguar. */
+		limitWait.until(new RunnableAssert("Waiting for the forward and reverse limit switches to be in the correct state") {
+			@Override
+			public void run() throws Exception {
+				stopMotor();
+				assertTrue("[TEST SETUP] The forward limit switch is not in the correct state",getME().getMotor().getForwardLimitOK());
+				assertFalse("[TEST SETUP] The reverse limit switch is not in the correct state", getME().getMotor().getReverseLimitOK());
 			}
 		});
+
 		final double initialPosition = getME().getMotor().getPosition();
-		
-		/* Make sure we limits are still recognized by the Jaguar. */
-		//assertTrue("The forward limit switch did not settle after " + kLimitSettlingTime + " seconds", getME().getMotor().getForwardLimitOK());
-		//assertFalse("The reverse limit switch did not settle after " + kLimitSettlingTime + " seconds",getME().getMotor().getReverseLimitOK());
 
 		//When
 		/*
@@ -279,20 +300,20 @@ public class CANPercentQuadEncoderModeTest extends AbstractCANTest{
 		 * move, since only the reverse switch is activated.
 		 */
 		setCANJaguar(kMotorTime, 1);
-		Timer.delay(kMotorTime);
-		delayTillInCorrectStateWithMessage(Level.FINE, kMotorTimeSettling, "Encoder drive forward settling", new BooleanCheck(){@Override
-			public boolean getAsBoolean(){
+		//Then
+		/* The position should have increased */
+		PollingWait wait = new PollingWait().timeoutAfter((long)kMotorTimeSettling, TimeUnit.SECONDS).pollEvery(1, TimeUnit.MILLISECONDS);
+		wait.until(new RunnableAssert("Waiting for the encoder to update") {
+			@Override
+			public void run() throws Exception {
 				runMotorForward();
-				return getME().getMotor().getPosition() != initialPosition;
+				assertThat(
+						"CAN Jaguar should have moved forwards while the reverse limit was on",
+						getME().getMotor().getPosition(), is(greaterThan(initialPosition)));
 			}
+			
 		});
 		stopMotor();
-		
-		//Then
-		/* The position should have increased */
-		assertThat(
-				"CAN Jaguar should have moved forwards while the reverse limit was on",
-				getME().getMotor().getPosition(), is(greaterThan(initialPosition)));
 	}
 	
 	@Ignore("Encoder is not yet wired to the FPGA")
diff --git a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANPositionPotentiometerModeTest.java b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANPositionPotentiometerModeTest.java
index 4be54789f7f1f061f626674a2f500968e4a05e5f..38053b90071aa3593ca084db0b6f0b6f30960c3b 100644
--- a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANPositionPotentiometerModeTest.java
+++ b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANPositionPotentiometerModeTest.java
@@ -1,8 +1,8 @@
 /*----------------------------------------------------------------------------*/
-/* Copyright (c) FIRST 2008-2014. All Rights Reserved.                        */
+/* Copyright (c) FIRST 2008-2014. All Rights Reserved.						*/
 /* Open Source Software - may be modified and shared by FRC teams. The code   */
 /* must be accompanied by the FIRST BSD license file in the root directory of */
-/* the project.                                                               */
+/* the project.															   */
 /*----------------------------------------------------------------------------*/
 package edu.wpi.first.wpilibj.can;
 
@@ -11,13 +11,16 @@ import static org.hamcrest.Matchers.is;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;
 
-import java.util.logging.Level;
+import java.util.concurrent.TimeUnit;
 import java.util.logging.Logger;
 
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
 
+import com.googlecode.junittoolbox.PollingWait;
+import com.googlecode.junittoolbox.RunnableAssert;
+
 import edu.wpi.first.wpilibj.CANJaguar;
 import edu.wpi.first.wpilibj.Timer;
 import edu.wpi.first.wpilibj.fixtures.MotorEncoderFixture;
@@ -30,9 +33,7 @@ public class CANPositionPotentiometerModeTest extends AbstractCANTest {
 	private static final Logger logger = Logger.getLogger(CANPositionPotentiometerModeTest.class.getName());
 	
 	private static final double kStoppedValue = 0;
-	private static final double kRunningValue = 1;
 	
-	private static final int rotationRange = 360;
 	private static final int defaultPotAngle = 180;
 	private static final double maxPotVoltage = 3.0;
 	
@@ -82,13 +83,13 @@ public class CANPositionPotentiometerModeTest extends AbstractCANTest {
 	@Test
 	public void testRotateForward() {
 		int initialPosition = getME().getEncoder().get();
-	    /* Drive the speed controller briefly to move the encoder */
+		/* Drive the speed controller briefly to move the encoder */
 		getME().getMotor().set(kStoppedValue);
-	    Timer.delay(kMotorTimeSettling);
-	    getME().getMotor().set(defaultPotAngle);
+		Timer.delay(kMotorTimeSettling);
+		getME().getMotor().set(defaultPotAngle);
 
-	    /* The position should have increased */
-	    assertThat("CAN Jaguar position should have increased after the motor moved", getME().getEncoder().get(), is(greaterThan(initialPosition)));
+		/* The position should have increased */
+		assertThat("CAN Jaguar position should have increased after the motor moved", getME().getEncoder().get(), is(greaterThan(initialPosition)));
 		
 	}
 	
@@ -99,13 +100,13 @@ public class CANPositionPotentiometerModeTest extends AbstractCANTest {
 	@Test
 	public void testRotateReverse() {
 		int initialPosition = getME().getEncoder().get();
-	    /* Drive the speed controller briefly to move the encoder */
+		/* Drive the speed controller briefly to move the encoder */
 		getME().getMotor().set(kStoppedValue);
-	    Timer.delay(kMotorTimeSettling);
-	    getME().getMotor().set(defaultPotAngle);
+		Timer.delay(kMotorTimeSettling);
+		getME().getMotor().set(defaultPotAngle);
 
-	    /* The position should have increased */
-	    assertThat("CAN Jaguar position should have increased after the motor moved", getME().getEncoder().get(), is(greaterThan(initialPosition)));
+		/* The position should have increased */
+		assertThat("CAN Jaguar position should have increased after the motor moved", getME().getEncoder().get(), is(greaterThan(initialPosition)));
 		
 	}
 	
@@ -115,29 +116,38 @@ public class CANPositionPotentiometerModeTest extends AbstractCANTest {
 	 */
 	@Test
 	public void testFakePotentiometerPosition() {
-		//When have we reached the correct state for this test?
-		BooleanCheck correctState = new BooleanCheck(){@Override
-		public boolean getAsBoolean(){
-			getME().getMotor().set(0);
-			return Math.abs(getME().getFakePot().getVoltage() - getME().getMotor().getPosition()*3) < kPotentiometerPositionTolerance*3;
+		//TODO When https://github.com/Pragmatists/JUnitParams/issues/5 is resolved make this test parameterized
+		
+		//Given
+		PollingWait wait = new PollingWait().timeoutAfter((long)kPotentiometerSettlingTime, TimeUnit.SECONDS).pollEvery(1, TimeUnit.MILLISECONDS);
+		RunnableAssert assertion = new RunnableAssert("Waiting for potentiometer position to be correct"){
+			@Override
+			public void run() throws Exception {
+				getME().getMotor().set(0);
+				assertEquals("CAN Jaguar should have returned the potentiometer position set by the analog output",
+				             getME().getFakePot().getVoltage() , getME().getMotor().getPosition()*3 , kPotentiometerPositionTolerance*3);
 			}
 		};
-
-	    getME().getFakePot().setVoltage(0.0f);
-	    delayTillInCorrectStateWithMessage(Level.FINE, kPotentiometerSettlingTime, "Potentiometer position settling", correctState);
-	    assertEquals("CAN Jaguar should have returned the potentiometer position set by the analog output", getME().getFakePot().getVoltage() , getME().getMotor().getPosition()*3 , kPotentiometerPositionTolerance*3);
-
-	    getME().getFakePot().setVoltage(1.0f);
-	    delayTillInCorrectStateWithMessage(Level.FINE, kPotentiometerSettlingTime, "Potentiometer position settling", correctState);
-	    assertEquals("CAN Jaguar should have returned the potentiometer position set by the analog output", getME().getFakePot().getVoltage() , getME().getMotor().getPosition()*3 , kPotentiometerPositionTolerance*3);
-
-	    getME().getFakePot().setVoltage(2.0f);
-	    delayTillInCorrectStateWithMessage(Level.FINE, kPotentiometerSettlingTime, "Potentiometer position settling", correctState);
-	    assertEquals("CAN Jaguar should have returned the potentiometer position set by the analog output", getME().getFakePot().getVoltage() , getME().getMotor().getPosition()*3 , kPotentiometerPositionTolerance*3);
-
-	    getME().getFakePot().setVoltage(3.0f);
-	    delayTillInCorrectStateWithMessage(Level.FINE, kPotentiometerSettlingTime, "Potentiometer position settling", correctState);
-	    assertEquals("CAN Jaguar should have returned the potentiometer position set by the analog output", getME().getFakePot().getVoltage() , getME().getMotor().getPosition()*3 , kPotentiometerPositionTolerance*3);
+		
+		//When
+		getME().getFakePot().setVoltage(0.0);
+		//Then
+		wait.until(assertion);
+		
+		//When
+		getME().getFakePot().setVoltage(1.0);
+		//Then
+		wait.until(assertion);
+		
+		//When
+		getME().getFakePot().setVoltage(2.0);
+		//Then
+		wait.until(assertion);
+		
+		//When
+		getME().getFakePot().setVoltage(3.0);
+		//Then
+		wait.until(assertion);
 	}
 	
 }
diff --git a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANSpeedQuadEncoderModeTest.java b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANSpeedQuadEncoderModeTest.java
index ca0828952957eaf54a726544591a11577b8f6fc3..c69935125262463828d4844b0a6146a37e1c8569 100644
--- a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANSpeedQuadEncoderModeTest.java
+++ b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANSpeedQuadEncoderModeTest.java
@@ -29,7 +29,7 @@ public class CANSpeedQuadEncoderModeTest extends AbstractCANTest {
 	/** The stopped value in rev/min */
 	private static final double kStoppedValue = 0;
 	/** The running value in rev/min */
-	private static final double kRunningValue = 2000;
+	private static final double kRunningValue = 200;
 	
 	@Override
 	protected Logger getClassLogger() {
@@ -61,7 +61,7 @@ public class CANSpeedQuadEncoderModeTest extends AbstractCANTest {
 		double initialPosition = getME().getMotor().getPosition();
 		setCANJaguar(kMotorTime, speed);
 		assertEquals("The motor did not reach the required speed in speed mode", speed, getME().getMotor().getSpeed(), kEncoderSpeedTolerance);
-		assertThat("The motor did not move forward in speed mode", initialPosition, is(lessThan(getME().getMotor().getPosition())));
+		assertThat("The motor did not move forward in speed mode", getME().getMotor().getPosition(), is(greaterThan(initialPosition)));
 	}
 	
 	/**
@@ -74,7 +74,7 @@ public class CANSpeedQuadEncoderModeTest extends AbstractCANTest {
 		double initialPosition = getME().getMotor().getPosition();
 		setCANJaguar(kMotorTime, speed);
 		assertEquals("The motor did not reach the required speed in speed mode", speed, getME().getMotor().getSpeed(), kEncoderSpeedTolerance);
-		assertThat("The motor did not move in reverse in speed mode", initialPosition, is(greaterThan(getME().getMotor().getPosition())));
+		assertThat("The motor did not move in reverse in speed mode", getME().getMotor().getPosition(), is(lessThan(initialPosition)));
 	}
 	
 }
diff --git a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANVoltageQuadEncoderModeTest.java b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANVoltageQuadEncoderModeTest.java
index 86485c21b8bdee8dbec36786baa24fc94b50cd47..b966a3c00e5e67ce1d12d79d32af6953827803fd 100644
--- a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANVoltageQuadEncoderModeTest.java
+++ b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/can/CANVoltageQuadEncoderModeTest.java
@@ -12,12 +12,15 @@ import static org.hamcrest.Matchers.lessThan;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;
 
-import java.util.logging.Level;
+import java.util.concurrent.TimeUnit;
 import java.util.logging.Logger;
 
 import org.junit.Before;
 import org.junit.Test;
 
+import com.googlecode.junittoolbox.PollingWait;
+import com.googlecode.junittoolbox.RunnableAssert;
+
 import edu.wpi.first.wpilibj.CANJaguar;
 import edu.wpi.first.wpilibj.Timer;
 
@@ -34,6 +37,8 @@ public class CANVoltageQuadEncoderModeTest extends AbstractCANTest {
 	
 	private static final double kVoltageTolerance = .25;
 	
+	private static final PollingWait kWait = new PollingWait().timeoutAfter((long)kMotorTimeSettling, TimeUnit.SECONDS).pollEvery(1, TimeUnit.MILLISECONDS);
+	
 	/* (non-Javadoc)
 	 * @see edu.wpi.first.wpilibj.can.AbstractCANTest#stopMotor()
 	 */
@@ -83,70 +88,67 @@ public class CANVoltageQuadEncoderModeTest extends AbstractCANTest {
 	}
 	
 	
-	@Test
-	public void testMaxOutputVoltagePositive(){
-		//given
-		double maxVoltage = 5;
+	/**
+	 * Sets up the test to have the CANJaguar running at the target voltage
+	 * @param targetValue the target voltage
+	 * @param wait the PollingWait to to use to wait for the setup to complete with
+	 */
+	private void setupMotorVoltageForTest(final double targetValue, PollingWait wait){
 		getME().getMotor().enableControl();
-		runMotorForward(); //Sets the output to be #kRunningValue
-		runMotorForward();
-		setCANJaguar(1, kRunningValue);
-		delayTillInCorrectStateWithMessage(Level.FINE, kMotorTimeSettling, "Voltage settling to max", new BooleanCheck(){
+		setCANJaguar(1, targetValue);
+		wait.until(new RunnableAssert("[SETUP] Waiting for the output voltage to match the set output value") {
 			@Override
-			public boolean getAsBoolean(){
-				runMotorForward();
-				return Math.abs((Math.abs(getME().getMotor().getOutputVoltage()) - kRunningValue)) < 1;
+			public void run() throws Exception {
+				getME().getMotor().set(targetValue);
+				assertEquals("[TEST SETUP] The output voltage should have matched the set value", targetValue, getME().getMotor().getOutputVoltage(), 0.5);
+				assertEquals("[TEST SETUP] The set value did not match the get value", targetValue, getME().getMotor().get(), 0.5);
 			}
 		});
-		assertEquals(kRunningValue, getME().getMotor().get(), 0.00000001);
+	}
+	
+	
+	@Test
+	public void testMaxOutputVoltagePositive(){
+		//given
+		double maxVoltage = 5;
+		
+		setupMotorVoltageForTest(kRunningValue, kWait);
+		
 		final double fastSpeed = getME().getMotor().getSpeed();
 		
 		//when
 		getME().getMotor().configMaxOutputVoltage(maxVoltage);
 		
 		setCANJaguar(1, kRunningValue);
-		delayTillInCorrectStateWithMessage(Level.FINE, kMotorTimeSettling, "SpeedReducing settling to max", new BooleanCheck(){
+		//Then
+		kWait.until(new RunnableAssert("Waiting for the speed to reduce using max output voltage") {
 			@Override
-			public boolean getAsBoolean(){
+			public void run() throws Exception {
 				runMotorForward();
-				return fastSpeed > getME().getMotor().getSpeed();
+				assertThat("Speed did not reduce when the max output voltage was set", fastSpeed, is(greaterThan(getME().getMotor().getSpeed())));
 			}
 		});
-		//then
-		assertThat("Speed did not reduce when the max output voltage was set", fastSpeed, is(greaterThan(getME().getMotor().getSpeed())));
+		
 	}
 	
 	@Test
 	public void testMaxOutputVoltagePositiveSetToZeroStopsMotor(){
 		//given
-		double maxVoltage = 0;
-		getME().getMotor().enableControl();
-		runMotorForward(); //Sets the output to be #kRunningValue
-		runMotorForward();
-		setCANJaguar(1, kRunningValue);
-		delayTillInCorrectStateWithMessage(Level.FINE, kMotorTimeSettling, "Voltage settling to max", new BooleanCheck(){
-			@Override
-			public boolean getAsBoolean(){
-				runMotorForward();
-				return Math.abs((Math.abs(getME().getMotor().getOutputVoltage()) - kRunningValue)) < 1;
-			}
-		});
-		assertEquals(kRunningValue, getME().getMotor().get(), 0.00000001);
-		final double fastSpeed = getME().getMotor().getSpeed();
+		final double maxVoltage = 0;
 		
+		setupMotorVoltageForTest(kRunningValue, kWait);
 		//when
 		getME().getMotor().configMaxOutputVoltage(maxVoltage);
 		
 		setCANJaguar(1, kRunningValue);
-		delayTillInCorrectStateWithMessage(Level.FINE, kMotorTimeSettling, "SpeedReducing settling to max", new BooleanCheck(){
+		//then
+		kWait.until(new RunnableAssert("Waiting for the speed to reduce to zero using max output voltage") {
 			@Override
-			public boolean getAsBoolean(){
+			public void run() throws Exception {
 				runMotorForward();
-				return getME().getMotor().getSpeed() == 0;
+				assertEquals("Speed did not go to zero when the max output voltage was set to " + maxVoltage, 0, getME().getMotor().getSpeed(), kEncoderSpeedTolerance);
 			}
 		});
-		//then
-		assertEquals("Speed did not go to zero when the max output voltage was set to " + maxVoltage, 0, getME().getMotor().getSpeed(), kEncoderSpeedTolerance);
 	}
 	
 	
@@ -154,67 +156,43 @@ public class CANVoltageQuadEncoderModeTest extends AbstractCANTest {
 	public void testMaxOutputVoltageNegative(){
 		//given
 		double maxVoltage = 5;
-		getME().getMotor().enableControl();
-		runMotorReverse(); //Sets the output to be #kRunningValue
 		
-		setCANJaguar(1, -kRunningValue);
-		delayTillInCorrectStateWithMessage(Level.FINE, kMotorTimeSettling, "Voltage settling to max", new BooleanCheck(){
-			@Override
-			public boolean getAsBoolean(){
-				runMotorReverse();
-				return Math.abs((Math.abs(getME().getMotor().getOutputVoltage()) - kRunningValue)) < 1;
-			}
-		});
-		assertEquals(-kRunningValue, getME().getMotor().get(), 0.00000001);
+		setupMotorVoltageForTest(-kRunningValue, kWait);
 		final double fastSpeed = getME().getMotor().getSpeed();
 		
 		//when
 		getME().getMotor().configMaxOutputVoltage(maxVoltage);
-		
-		
 		setCANJaguar(1, -kRunningValue);
-		delayTillInCorrectStateWithMessage(Level.FINE, kMotorTimeSettling, "SpeedReducing settling to max", new BooleanCheck(){
+		
+		//then
+		kWait.until(new RunnableAssert("Waiting for the speed to reduce using max output voltage") {
+			
 			@Override
-			public boolean getAsBoolean(){
+			public void run() throws Exception {
 				runMotorReverse();
-				return fastSpeed < getME().getMotor().getSpeed();
+				assertThat("Speed did not reduce when the max output voltage was set", fastSpeed, is(lessThan(getME().getMotor().getSpeed())));
 			}
 		});
-		//then
-		assertThat("Speed did not reduce when the max output voltage was set", fastSpeed, is(lessThan(getME().getMotor().getSpeed())));
 	}
 	
 	@Test
 	public void testMaxOutputVoltageNegativeSetToZeroStopsMotor(){
 		//given
-		double maxVoltage = 0;
-		getME().getMotor().enableControl();
-		runMotorForward(); //Sets the output to be #kRunningValue
-		runMotorForward();
-		setCANJaguar(1, kRunningValue);
-		delayTillInCorrectStateWithMessage(Level.FINE, kMotorTimeSettling, "Voltage settling to max", new BooleanCheck(){
-			@Override
-			public boolean getAsBoolean(){
-				runMotorForward();
-				return Math.abs((Math.abs(getME().getMotor().getOutputVoltage()) - kRunningValue)) < 1;
-			}
-		});
-		assertEquals(kRunningValue, getME().getMotor().get(), 0.00000001);
-		final double fastSpeed = getME().getMotor().getSpeed();
+		final double maxVoltage = 0;
+		setupMotorVoltageForTest(-kRunningValue, kWait);
 		
 		//when
 		getME().getMotor().configMaxOutputVoltage(maxVoltage);
+		setCANJaguar(1, -kRunningValue);
 		
-		setCANJaguar(1, kRunningValue);
-		delayTillInCorrectStateWithMessage(Level.FINE, kMotorTimeSettling, "SpeedReducing settling to max", new BooleanCheck(){
+		//Then
+		kWait.until(new RunnableAssert("Waiting for the speed to reduce to zero using max output voltage") {
 			@Override
-			public boolean getAsBoolean(){
-				runMotorForward();
-				return getME().getMotor().getSpeed() == 0;
+			public void run() throws Exception {
+				runMotorReverse();
+				assertEquals("Speed did not go to zero when the max output voltage was set to " + maxVoltage, 0, getME().getMotor().getSpeed(), kEncoderSpeedTolerance);
 			}
 		});
-		//then
-		assertEquals("Speed did not go to zero when the max output voltage was set to " + maxVoltage, 0, getME().getMotor().getSpeed(), kEncoderSpeedTolerance);
 	}
 
 }
