From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: thomasclark <tjclark@wpi.edu>
Date: Thu, 12 Jun 2014 11:17:57 -0400
Subject: [PATCH 0092/6262] C++ PCM integration tests

Change-Id: I1ad0090edf0c8986ca8f1bfc78c936c5dd55c432
---
 .../include/TestBench.h                       |  13 +-
 .../src/DIOLoopTest.cpp                       |  25 ++--
 .../wpilibC++IntegrationTests/src/PCMTest.cpp | 119 ++++++++++++++++++
 3 files changed, 143 insertions(+), 14 deletions(-)
 create mode 100644 wpilibc/wpilibC++IntegrationTests/src/PCMTest.cpp

diff --git a/wpilibc/wpilibC++IntegrationTests/include/TestBench.h b/wpilibc/wpilibC++IntegrationTests/include/TestBench.h
index b4aadbb5c01a3701a7feabefd3a20c64f6af7df2..defd80e31ba4f879b8ddefa020f13d5e334f3d48 100644
--- a/wpilibc/wpilibC++IntegrationTests/include/TestBench.h
+++ b/wpilibc/wpilibC++IntegrationTests/include/TestBench.h
@@ -13,7 +13,8 @@ class TestBench {
 public:
 	/* Analog channels */
 	static const uint32_t kCameraGyroChannel = 0;
-	
+	static const uint32_t kFakeCompressorChannel = 1;
+
 	/* DIO channels */
 	static const uint32_t kTalonEncoderChannelA = 0;
 	static const uint32_t kTalonEncoderChannelB = 1;
@@ -25,12 +26,16 @@ public:
 	static const uint32_t kLoop1InputChannel = 7;
 	static const uint32_t kLoop2OutputChannel = 8;
 	static const uint32_t kLoop2InputChannel = 9;
-	
+
 	/* PWM channels */
-	static const uint32_t kTalonChannel = 0;
 	static const uint32_t kVictorChannel = 1;
 	static const uint32_t kJaguarChannel = 2;
 	static const uint32_t kCameraPanChannel = 8;
 	static const uint32_t kCameraTiltChannel = 9;
-};
 
+	/* MXP digital channels */
+	static const uint32_t kTalonChannel = 10;
+	static const uint32_t kFakePressureSwitchChannel = 11;
+	static const uint32_t kFakeSolenoid1Channel = 12;
+	static const uint32_t kFakeSolenoid2Channel = 13;
+};
diff --git a/wpilibc/wpilibC++IntegrationTests/src/DIOLoopTest.cpp b/wpilibc/wpilibC++IntegrationTests/src/DIOLoopTest.cpp
index ad8b2fc209615053612cebb64c36d329d06c0b1a..5aac0b2f2041e1f3b73d6e3c09751016f528923b 100644
--- a/wpilibc/wpilibC++IntegrationTests/src/DIOLoopTest.cpp
+++ b/wpilibc/wpilibC++IntegrationTests/src/DIOLoopTest.cpp
@@ -9,6 +9,8 @@
 #include "gtest/gtest.h"
 #include "TestBench.h"
 
+static const double kDelayTime = 0.1;
+
 /**
  * A fixture with a digital input and a digital output physically wired
  * together.
@@ -17,17 +19,17 @@ class DIOLoopTest : public testing::Test {
 protected:
 	DigitalInput *m_input;
 	DigitalOutput *m_output;
-	
+
 	virtual void SetUp() {
 		m_input = new DigitalInput(TestBench::kLoop1InputChannel);
 		m_output = new DigitalOutput(TestBench::kLoop1OutputChannel);
 	}
-	
+
 	virtual void TearDown() {
 		delete m_input;
 		delete m_output;
 	}
-	
+
 	void Reset() {
 		m_output->Set(false);
 	}
@@ -39,12 +41,14 @@ protected:
  */
 TEST_F(DIOLoopTest, Loop) {
 	Reset();
-	
+
 	m_output->Set(false);
+  Wait(kDelayTime);
 	EXPECT_FALSE(m_input->Get()) << "The digital output was turned off, but "
 		<< "the digital input is on.";
-	
+
 	m_output->Set(true);
+  Wait(kDelayTime);
 	EXPECT_TRUE(m_input->Get()) << "The digital output was turned on, but "
 		<< "the digital input is off.";
 }
@@ -55,18 +59,19 @@ TEST_F(DIOLoopTest, Loop) {
  */
 TEST_F(DIOLoopTest, FakeCounter) {
 	Reset();
-	
+
 	Counter counter(m_input);
 	counter.Start();
-	
+
 	EXPECT_EQ(0, counter.Get()) << "Counter did not initialize to 0.";
-	
+
 	/* Count 100 ticks.  The counter value should be 100 after this loop. */
 	for(int i = 0; i < 100; i++) {
 		m_output->Set(true);
 		m_output->Set(false);
 	}
-	
+  
+  Wait(kDelayTime);
+
 	EXPECT_EQ(100, counter.Get()) << "Counter did not count up to 100.";
 }
-
diff --git a/wpilibc/wpilibC++IntegrationTests/src/PCMTest.cpp b/wpilibc/wpilibC++IntegrationTests/src/PCMTest.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..ddc86f60fa0a9323715a95a8d387c4c8718bc828
--- /dev/null
+++ b/wpilibc/wpilibC++IntegrationTests/src/PCMTest.cpp
@@ -0,0 +1,119 @@
+/*----------------------------------------------------------------------------*/
+/* Copyright (c) FIRST 2014. All Rights Reserved.                             */
+/* Open Source Software - may be modified and shared by FRC teams. The code   */
+/* must be accompanied by the FIRST BSD license file in the root directory of */
+/* the project.                                                               */
+/*----------------------------------------------------------------------------*/
+
+#include "WPILib.h"
+#include "gtest/gtest.h"
+#include "TestBench.h"
+
+/* The PCM switches the compressor up to 2 seconds after the pressure switch
+  changes. */
+static const double kCompressoDelayTime = 2.0;
+
+/* Solenoids should change much more quickly */
+static const double kSolenoidDelayTime = 0.1;
+
+/* The voltage divider on the test bench should bring the compressor output
+  to around these values. */
+static const double kCompressorOnVoltage = 5.00;
+static const double kCompressorOffVoltage = 1.68;
+
+class PCMTest : public testing::Test {
+protected:
+  Compressor *m_compressor;
+
+  DigitalOutput *m_fakePressureSwitch;
+  AnalogChannel *m_fakeCompressor;
+
+  Solenoid *m_solenoid1, *m_solenoid2;
+  DigitalInput *m_fakeSolenoid1, *m_fakeSolenoid2;
+
+  virtual void SetUp() {
+    m_compressor = new Compressor();
+
+    m_fakePressureSwitch = new DigitalOutput(TestBench::kFakePressureSwitchChannel);
+    m_fakeCompressor = new AnalogChannel(TestBench::kFakeCompressorChannel);
+
+    m_solenoid1 = new Solenoid(1);
+    m_solenoid2 = new Solenoid(2);
+
+    m_fakeSolenoid1 = new DigitalInput(TestBench::kFakeSolenoid1Channel);
+    m_fakeSolenoid2 = new DigitalInput(TestBench::kFakeSolenoid2Channel);
+  }
+
+  virtual void TearDown() {
+    delete m_compressor;
+    delete m_fakePressureSwitch;
+    delete m_fakeCompressor;
+    delete m_solenoid1;
+    delete m_solenoid2;
+    delete m_fakeSolenoid1;
+    delete m_fakeSolenoid2;
+  }
+
+  void Reset() {
+    m_compressor->Stop();
+    m_fakePressureSwitch->Set(false);
+    m_solenoid1->Set(false);
+    m_solenoid2->Set(false);
+  }
+};
+
+/**
+ * Test if the compressor turns on and off when the pressure switch is toggled
+ */
+TEST_F(PCMTest, PressureSwitch) {
+  Reset();
+
+  m_compressor->SetClosedLoopControl(true);
+
+  // Turn on the compressor
+  m_fakePressureSwitch->Set(true);
+  Wait(kCompressoDelayTime);
+  EXPECT_NEAR(kCompressorOnVoltage, m_fakeCompressor->GetVoltage(), 0.1)
+    << "Compressor did not turn on when the pressure switch turned on.";
+
+  // Turn off the compressor
+  m_fakePressureSwitch->Set(false);
+  Wait(kCompressoDelayTime);
+  EXPECT_NEAR(kCompressorOffVoltage, m_fakeCompressor->GetVoltage(), 0.1)
+    << "Compressor did not turn off when the pressure switch turned off.";
+}
+
+/**
+ * Test if the correct solenoids turn on and off when they should
+ */
+TEST_F(PCMTest, Solenoid) {
+  Reset();
+
+  // Turn both solenoids off
+  m_solenoid1->Set(false);
+  m_solenoid2->Set(false);
+  Wait(kSolenoidDelayTime);
+  EXPECT_TRUE(m_fakeSolenoid1->Get()) << "Solenoid #1 did not turn off";
+  EXPECT_TRUE(m_fakeSolenoid2->Get()) << "Solenoid #2 did not turn off";
+
+  // Turn one solenoid on and one off
+  m_solenoid1->Set(true);
+  m_solenoid2->Set(false);
+  Wait(kSolenoidDelayTime);
+  EXPECT_FALSE(m_fakeSolenoid1->Get()) << "Solenoid #1 did not turn on";
+  EXPECT_TRUE(m_fakeSolenoid2->Get()) << "Solenoid #2 did not turn off";
+
+  // Turn one solenoid on and one off
+  m_solenoid1->Set(true);
+  m_solenoid2->Set(false);
+  Wait(kSolenoidDelayTime);
+  EXPECT_FALSE(m_fakeSolenoid1->Get()) << "Solenoid #1 did not turn on";
+  EXPECT_TRUE(m_fakeSolenoid2->Get()) << "Solenoid #2 did not turn off";
+
+  // Turn both on
+  m_solenoid1->Set(true);
+  m_solenoid2->Set(true);
+  Wait(kSolenoidDelayTime);
+  EXPECT_FALSE(m_fakeSolenoid1->Get()) << "Solenoid #1 did not turn on";
+  EXPECT_FALSE(m_fakeSolenoid2->Get()) << "Solenoid #2 did not turn on";
+}
