From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Thomas Clark <tjclark@wpi.edu>
Date: Mon, 20 Oct 2014 10:41:01 -0400
Subject: [PATCH 0421/6262] Set RobotBase instance in constructor [artf3652]

Also, remove the dead code that appeared to set the singleton instance,
but isn't actually run.

Change-Id: I1967026295b97f0c5e64256f2c701569da2a2091
---
 wpilibc/wpilibC++Devices/include/RobotBase.h | 18 -----
 wpilibc/wpilibC++Devices/src/RobotBase.cpp   | 72 +-------------------
 2 files changed, 3 insertions(+), 87 deletions(-)

diff --git a/wpilibc/wpilibC++Devices/include/RobotBase.h b/wpilibc/wpilibC++Devices/include/RobotBase.h
index be0711132c6b538b487e913edd3d08a7547c6c26..535b78bcd356deed4b9a82169127f03213522e19 100644
--- a/wpilibc/wpilibC++Devices/include/RobotBase.h
+++ b/wpilibc/wpilibC++Devices/include/RobotBase.h
@@ -10,23 +10,6 @@
 
 class DriverStation;
 
-#ifdef __vxworks
-#define START_ROBOT_CLASS(_ClassName_) \
-	RobotBase *FRC_userClassFactory() \
-	{ \
-	    cout << "Instantiating " #_ClassName_ "...\n";\
-		RobotBase* rb= new _ClassName_();\
-	    cout << "...Instantiated " #_ClassName_ "\n";\
-		return rb;\
-	} \
-	extern "C" { \
-		int32_t FRC_UserProgram_StartupLibraryInit() \
-		{ \
-			RobotBase::startRobotTask((FUNCPTR)FRC_userClassFactory); \
-			return 0; \
-		} \
-	}
-#else
 #define START_ROBOT_CLASS(_ClassName_) \
 	int main() \
 	{ \
@@ -36,7 +19,6 @@ class DriverStation;
 		(new _ClassName_())->StartCompetition(); \
 		return 0; \
 	}
-#endif
 
 /**
  * Implement a Robot Program framework.
diff --git a/wpilibc/wpilibC++Devices/src/RobotBase.cpp b/wpilibc/wpilibC++Devices/src/RobotBase.cpp
index 57022bd72292f3d36599f2f8cad901b66f740be1..ce610139f6b9271464b9d03071094dca091987e5 100644
--- a/wpilibc/wpilibC++Devices/src/RobotBase.cpp
+++ b/wpilibc/wpilibC++Devices/src/RobotBase.cpp
@@ -41,7 +41,7 @@ RobotBase &RobotBase::getInstance()
  * Constructor for a generic robot program.
  * User code should be placed in the constuctor that runs before the Autonomous or Operator
  * Control period starts. The constructor will run to completion before Autonomous is entered.
- * 
+ *
  * This must be used to ensure that the communications code starts. In the future it would be
  * nice to put this code into it's own task that loads on boot so ensure that it runs.
  */
@@ -52,6 +52,8 @@ RobotBase::RobotBase()
 	m_ds = DriverStation::GetInstance();
 	RobotState::SetImplementation(DriverStation::GetInstance()); \
 	HLUsageReporting::SetImplementation(new HardwareHLReporting()); \
+
+	RobotBase::setInstance(this);
 }
 
 /**
@@ -121,74 +123,6 @@ bool RobotBase::IsNewDataAvailable()
 	return m_ds->IsNewControlData();
 }
 
-/**
- * Static interface that will start the competition in the new task.
- */
-void RobotBase::robotTask(FUNCPTR factory, Task *task)
-{
-	RobotBase::setInstance((RobotBase*)factory());
-	RobotBase::getInstance().m_task = task;
-	RobotBase::getInstance().StartCompetition();
-}
-
-/**
- * 
- * Start the robot code.
- * This function starts the robot code running by spawning a task. Currently tasks seemed to be
- * started by LVRT without setting the VX_FP_TASK flag so floating point context is not saved on
- * interrupts. Therefore the program experiences hard to debug and unpredictable results. So the
- * LVRT code starts this function, and it, in turn, starts the actual user program.
- */
-void RobotBase::startRobotTask(FUNCPTR factory)
-{
-#ifdef SVN_REV
-	if (strlen(SVN_REV))
-	{
-		printf("WPILib was compiled from SVN revision %s\n", SVN_REV);
-	}
-	else
-	{
-		printf("WPILib was compiled from a location that is not source controlled.\n");
-	}
-#else
-	printf("WPILib was compiled without -D'SVN_REV=nnnn'\n");
-#endif
-
-#ifdef __vxworks
-	// Check for startup code already running
-	int32_t oldId = taskNameToId(const_cast<char*>("FRC_RobotTask"));
-	if (oldId != ERROR)
-	{
-		// Find the startup code module.
-		char moduleName[256];
-		moduleNameFindBySymbolName("FRC_UserProgram_StartupLibraryInit", moduleName);
-		MODULE_ID startupModId = moduleFindByName(moduleName);
-		if (startupModId != NULL)
-		{
-			// Remove the startup code.
-			unldByModuleId(startupModId, 0);
-			printf("!!!   Error: Default code was still running... It was unloaded for you... Please try again.\n");
-			return;
-		}
-		// This case should no longer get hit.
-		printf("!!!   Error: Other robot code is still running... Unload it and then try again.\n");
-		return;
-	}
-#endif
-
-	// Let the framework know that we are starting a new user program so the Driver Station can disable.
-	HALNetworkCommunicationObserveUserProgramStarting();
-
-	// Let the Usage Reporting framework know that there is a C++ program running
-	HALReport(HALUsageReporting::kResourceType_Language, HALUsageReporting::kLanguage_CPlusPlus);
-
-	// Start robot task
-	// This is done to ensure that the C++ robot task is spawned with the floating point
-	// context save parameter.
-	Task *task = new Task("RobotTask", (FUNCPTR)RobotBase::robotTask, Task::kDefaultPriority, 64000);
-	task->Start((int32_t)factory, (int32_t)task);
-}
-
 /**
  * This class exists for the sole purpose of getting its destructor called when the module unloads.
  * Before the module is done unloading, we need to delete the RobotBase derived singleton.  This should delete
