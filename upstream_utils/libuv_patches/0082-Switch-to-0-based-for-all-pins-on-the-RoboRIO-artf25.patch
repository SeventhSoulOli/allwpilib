From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: thomasclark <tjclark@wpi.edu>
Date: Tue, 10 Jun 2014 12:33:59 -0400
Subject: [PATCH 0082/6262] Switch to 0-based for all pins on the RoboRIO
 [artf2564]

Change-Id: I249965a9d55aec53b7d8a9be3ba5cc43500ddda4
---
 hal/lib/Athena/Analog.cpp                     | 28 +++++-----
 hal/lib/Athena/Digital.cpp                    | 54 +++++++++----------
 wpilibc/wpilibC++/include/DriverStation.h     |  2 +-
 wpilibc/wpilibC++/lib/AnalogChannel.cpp       |  6 +--
 wpilibc/wpilibC++/lib/AnalogModule.cpp        |  2 +-
 wpilibc/wpilibC++/lib/DigitalInput.cpp        |  2 +-
 wpilibc/wpilibC++/lib/DigitalModule.cpp       | 42 +++++++--------
 wpilibc/wpilibC++/lib/PWM.cpp                 |  4 +-
 wpilibc/wpilibC++/lib/Relay.cpp               |  8 +--
 wpilibc/wpilibC++/lib/SensorBase.cpp          |  8 +--
 .../include/TestBench.h                       | 32 +++++------
 .../edu/wpi/first/wpilibj/AnalogChannel.java  |  7 ++-
 .../edu/wpi/first/wpilibj/AnalogModule.java   |  2 +-
 .../edu/wpi/first/wpilibj/DigitalModule.java  | 36 ++++++-------
 .../edu/wpi/first/wpilibj/DigitalSource.java  |  6 +--
 .../edu/wpi/first/wpilibj/DriverStation.java  |  2 +-
 .../main/java/edu/wpi/first/wpilibj/PWM.java  |  4 +-
 .../java/edu/wpi/first/wpilibj/Relay.java     | 12 ++---
 .../edu/wpi/first/wpilibj/SensorBase.java     |  6 +--
 .../edu/wpi/first/wpilibj/test/TestBench.java | 36 ++++++-------
 20 files changed, 149 insertions(+), 150 deletions(-)

diff --git a/hal/lib/Athena/Analog.cpp b/hal/lib/Athena/Analog.cpp
index 2b7a22a8de6cbfe735e4c5b974a1593ced702928..0b5de30172f39fae39818403bdab71adc13d6ebf 100644
--- a/hal/lib/Athena/Analog.cpp
+++ b/hal/lib/Athena/Analog.cpp
@@ -17,7 +17,7 @@ static const float kDefaultSampleRate = 50000.0;
 static const uint32_t kAnalogPins = 8;
 
 static const uint32_t kAccumulatorNumChannels = 2;
-static const uint32_t kAccumulatorChannels[] = {1, 2};
+static const uint32_t kAccumulatorChannels[] = {0, 1};
 
 struct AnalogPort {
   Port port;
@@ -59,11 +59,11 @@ void* initializeAnalogPort(void* port_pointer, int32_t *status) {
   AnalogPort* analog_port = new AnalogPort();
   analog_port->port = *port;
   if (isAccumulatorChannel(analog_port, status)) {
-    analog_port->accumulator = tAccumulator::create(port->pin - 1, status);
+    analog_port->accumulator = tAccumulator::create(port->pin, status);
   } else analog_port->accumulator = NULL;
 
   // Set default configuration
-  analogSystem->writeScanList(port->pin - 1, port->pin - 1, status);
+  analogSystem->writeScanList(port->pin, port->pin, status);
   setAnalogAverageBits(analog_port, kDefaultAverageBits, status);
   setAnalogOversampleBits(analog_port, kDefaultOversampleBits, status);
   return analog_port;
@@ -82,12 +82,12 @@ bool checkAnalogModule(uint8_t module) {
 /**
  * Check that the analog channel number is value.
  * Verify that the analog channel number is one of the legal channel numbers. Channel numbers
- * are 1-based.
+ * are 0-based.
  * 
  * @return Analog channel is valid
  */
 bool checkAnalogChannel(uint32_t pin) {
-  if (pin > 0 && pin <= kAnalogPins)
+  if (pin >= 0 && pin < kAnalogPins)
     return true;
   return false;
 }
@@ -184,7 +184,7 @@ float getAnalogSampleRateWithModule(uint8_t module, int32_t *status) {
  */
 void setAnalogAverageBits(void* analog_port_pointer, uint32_t bits, int32_t *status) {
   AnalogPort* port = (AnalogPort*) analog_port_pointer;
-  analogSystem->writeAverageBits(port->port.pin - 1, bits, status);
+  analogSystem->writeAverageBits(port->port.pin, bits, status);
 }
 
 /**
@@ -198,7 +198,7 @@ void setAnalogAverageBits(void* analog_port_pointer, uint32_t bits, int32_t *sta
  */
 uint32_t getAnalogAverageBits(void* analog_port_pointer, int32_t *status) {
   AnalogPort* port = (AnalogPort*) analog_port_pointer;
-  uint32_t result = analogSystem->readAverageBits(port->port.pin - 1, status);
+  uint32_t result = analogSystem->readAverageBits(port->port.pin, status);
   return result;
 }
 
@@ -214,7 +214,7 @@ uint32_t getAnalogAverageBits(void* analog_port_pointer, int32_t *status) {
  */
 void setAnalogOversampleBits(void* analog_port_pointer, uint32_t bits, int32_t *status) {
   AnalogPort* port = (AnalogPort*) analog_port_pointer;
-  analogSystem->writeOversampleBits(port->port.pin - 1, bits, status);
+  analogSystem->writeOversampleBits(port->port.pin, bits, status);
 }
 
 
@@ -229,7 +229,7 @@ void setAnalogOversampleBits(void* analog_port_pointer, uint32_t bits, int32_t *
  */
 uint32_t getAnalogOversampleBits(void* analog_port_pointer, int32_t *status) {
   AnalogPort* port = (AnalogPort*) analog_port_pointer;
-  uint32_t result = analogSystem->readOversampleBits(port->port.pin - 1, status);
+  uint32_t result = analogSystem->readOversampleBits(port->port.pin, status);
   return result;
 }
 
@@ -248,7 +248,7 @@ int16_t getAnalogValue(void* analog_port_pointer, int32_t *status) {
   checkAnalogChannel(port->port.pin);
 
   tAI::tReadSelect readSelect;
-  readSelect.Channel = port->port.pin - 1;
+  readSelect.Channel = port->port.pin;
   readSelect.Averaged = false;
 
   {
@@ -279,7 +279,7 @@ int32_t getAnalogAverageValue(void* analog_port_pointer, int32_t *status) {
   checkAnalogChannel(port->port.pin);
 
   tAI::tReadSelect readSelect;
-  readSelect.Channel = port->port.pin - 1;
+  readSelect.Channel = port->port.pin;
   readSelect.Averaged = true;
 
   {
@@ -366,7 +366,7 @@ int32_t getAnalogVoltsToValue(void* analog_port_pointer, double voltage, int32_t
  */
 uint32_t getAnalogLSBWeight(void* analog_port_pointer, int32_t *status) {
   AnalogPort* port = (AnalogPort*) analog_port_pointer;
-  uint32_t lsbWeight = FRC_NetworkCommunication_nAICalibration_getLSBWeight(0, port->port.pin - 1, status); // XXX: aiSystemIndex == 0?
+  uint32_t lsbWeight = FRC_NetworkCommunication_nAICalibration_getLSBWeight(0, port->port.pin, status); // XXX: aiSystemIndex == 0?
   return lsbWeight;
 }
 
@@ -382,7 +382,7 @@ uint32_t getAnalogLSBWeight(void* analog_port_pointer, int32_t *status) {
  */
 int32_t getAnalogOffset(void* analog_port_pointer, int32_t *status) {
   AnalogPort* port = (AnalogPort*) analog_port_pointer;
-  int32_t offset = FRC_NetworkCommunication_nAICalibration_getOffset(0, port->port.pin - 1, status); // XXX: aiSystemIndex == 0?
+  int32_t offset = FRC_NetworkCommunication_nAICalibration_getOffset(0, port->port.pin, status); // XXX: aiSystemIndex == 0?
   return offset;
 }
 
@@ -574,7 +574,7 @@ void* initializeAnalogTrigger(void* port_pointer, uint32_t *index, int32_t *stat
   // TODO: if (index == ~0ul) { CloneError(triggers); return; }
 
   trigger->trigger = tAnalogTrigger::create(trigger->index, status);
-  trigger->trigger->writeSourceSelect_Channel(port->pin - 1, status);
+  trigger->trigger->writeSourceSelect_Channel(port->pin, status);
 
   return trigger;
 }
diff --git a/hal/lib/Athena/Digital.cpp b/hal/lib/Athena/Digital.cpp
index 5b27cd8cf1844a19d85b23013e9ae450210b079c..7f168a6cbc0b6b51cb98b9d65be85fa8c6eed804 100644
--- a/hal/lib/Athena/Digital.cpp
+++ b/hal/lib/Athena/Digital.cpp
@@ -107,7 +107,7 @@ void initializeDigital(int32_t *status) {
   pwmSystem->writeConfig_MinHigh(minHigh, status);
 //  printf("MinHigh: %d\n", minHigh);
   // Ensure that PWM output values are set to OFF
-  for (uint32_t pwm_index = 1; pwm_index <= kPwmPins; pwm_index++) {
+  for (uint32_t pwm_index = 0; pwm_index < kPwmPins; pwm_index++) {
 	// Initialize port structure
 	DigitalPort* digital_port = new DigitalPort();
 	digital_port->port.pin = pwm_index;
@@ -146,12 +146,12 @@ bool checkDigitalModule(uint8_t module) {
 
 bool checkPWMChannel(void* digital_port_pointer) {
   DigitalPort* port = (DigitalPort*) digital_port_pointer;
-  return (port->port.pin > 0 && port->port.pin <= kPwmPins);
+  return (port->port.pin >= 0 && port->port.pin < kPwmPins);
 }
 
 bool checkRelayChannel(void* digital_port_pointer) {
   DigitalPort* port = (DigitalPort*) digital_port_pointer;
-  return (port->port.pin > 0 && port->port.pin <= kRelayPins);
+  return (port->port.pin >= 0 && port->port.pin < kRelayPins);
 }
 
 uint8_t remapDigitalChannel(uint32_t pin, int32_t *status) {
@@ -173,7 +173,7 @@ void setPWM(void* digital_port_pointer, unsigned short value, int32_t *status) {
   DigitalPort* port = (DigitalPort*) digital_port_pointer;
   checkPWMChannel(port);
 //  printf("Value:%d\n", value);
-  pwmSystem->writeHdr(port->port.pin - 1, value, status); // XXX: Support MXP
+  pwmSystem->writeHdr(port->port.pin, value, status); // XXX: Support MXP
 }
 
 /**
@@ -185,7 +185,7 @@ void setPWM(void* digital_port_pointer, unsigned short value, int32_t *status) {
 unsigned short getPWM(void* digital_port_pointer, int32_t *status) {
   DigitalPort* port = (DigitalPort*) digital_port_pointer;
   checkPWMChannel(port);
-  return pwmSystem->readHdr(port->port.pin - 1, status); // XXX: Support MXP
+  return pwmSystem->readHdr(port->port.pin, status); // XXX: Support MXP
 }
 
 /**
@@ -197,7 +197,7 @@ unsigned short getPWM(void* digital_port_pointer, int32_t *status) {
 void setPWMPeriodScale(void* digital_port_pointer, uint32_t squelchMask, int32_t *status) {
   DigitalPort* port = (DigitalPort*) digital_port_pointer;
   checkPWMChannel(port);
-  pwmSystem->writePeriodScaleHdr(port->port.pin - 1, squelchMask, status); // XXX: Support MXP
+  pwmSystem->writePeriodScaleHdr(port->port.pin, squelchMask, status); // XXX: Support MXP
 }
 
 /**
@@ -325,22 +325,22 @@ void setPWMOutputChannelWithModule(uint8_t module, void* pwmGenerator, uint32_t
   if (id == ~0ul) return;
   switch(id) {
   case 0:
-    digitalSystem->writePWMOutputSelect(0, remapDigitalChannel(pin - 1, status), status);
+    digitalSystem->writePWMOutputSelect(0, remapDigitalChannel(pin, status), status);
     break;
   case 1:
-    digitalSystem->writePWMOutputSelect(1, remapDigitalChannel(pin - 1, status), status);
+    digitalSystem->writePWMOutputSelect(1, remapDigitalChannel(pin, status), status);
     break;
   case 2:
-    digitalSystem->writePWMOutputSelect(2, remapDigitalChannel(pin - 1, status), status);
+    digitalSystem->writePWMOutputSelect(2, remapDigitalChannel(pin, status), status);
     break;
   case 3:
-    digitalSystem->writePWMOutputSelect(3, remapDigitalChannel(pin - 1, status), status);
+    digitalSystem->writePWMOutputSelect(3, remapDigitalChannel(pin, status), status);
     break;
   case 4:
-    digitalSystem->writePWMOutputSelect(4, remapDigitalChannel(pin - 1, status), status);
+    digitalSystem->writePWMOutputSelect(4, remapDigitalChannel(pin, status), status);
     break;
   case 5:
-    digitalSystem->writePWMOutputSelect(5, remapDigitalChannel(pin - 1, status), status);
+    digitalSystem->writePWMOutputSelect(5, remapDigitalChannel(pin, status), status);
     break;
   }
 }
@@ -357,9 +357,9 @@ void setRelayForward(void* digital_port_pointer, bool on, int32_t *status) {
     Synchronized sync(digitalRelaySemaphore);
     uint8_t forwardRelays = relaySystem->readValue_Forward(status);
     if (on)
-      forwardRelays |= 1 << (port->port.pin - 1);
+      forwardRelays |= 1 << port->port.pin;
     else
-      forwardRelays &= ~(1 << (port->port.pin - 1));
+      forwardRelays &= ~(1 << port->port.pin);
     relaySystem->writeValue_Forward(forwardRelays, status);
   }
 }
@@ -376,9 +376,9 @@ void setRelayReverse(void* digital_port_pointer, bool on, int32_t *status) {
     Synchronized sync(digitalRelaySemaphore);
     uint8_t reverseRelays = relaySystem->readValue_Reverse(status);
     if (on)
-      reverseRelays |= 1 << (port->port.pin - 1);
+      reverseRelays |= 1 << port->port.pin;
     else
-      reverseRelays &= ~(1 << (port->port.pin - 1));
+      reverseRelays &= ~(1 << port->port.pin);
     relaySystem->writeValue_Reverse(reverseRelays, status);
   }
 }
@@ -389,7 +389,7 @@ void setRelayReverse(void* digital_port_pointer, bool on, int32_t *status) {
 bool getRelayForward(void* digital_port_pointer, int32_t *status) {
   DigitalPort* port = (DigitalPort*) digital_port_pointer;
   uint8_t forwardRelays = relaySystem->readValue_Forward(status);
-  return (forwardRelays & (1 << (port->port.pin - 1))) != 0;
+  return (forwardRelays & (1 << port->port.pin)) != 0;
 }
 
 /**
@@ -398,7 +398,7 @@ bool getRelayForward(void* digital_port_pointer, int32_t *status) {
 bool getRelayReverse(void* digital_port_pointer, int32_t *status) {
   DigitalPort* port = (DigitalPort*) digital_port_pointer;
   uint8_t reverseRelays = relaySystem->readValue_Reverse(status);
-  return (reverseRelays & (1 << (port->port.pin - 1))) != 0;
+  return (reverseRelays & (1 << port->port.pin)) != 0;
 }
 
 /**
@@ -414,10 +414,10 @@ bool allocateDIO(void* digital_port_pointer, bool input, int32_t *status) {
   DigitalPort* port = (DigitalPort*) digital_port_pointer;
   char buf[64];
   snprintf(buf, 64, "DIO %d (Module %d)", port->port.pin, port->port.module);
-  if (DIOChannels->Allocate(kDigitalPins * (port->port.module - 1) + port->port.pin - 1, buf) == ~0ul) return false;
+  if (DIOChannels->Allocate(kDigitalPins * (port->port.module - 1) + port->port.pin, buf) == ~0ul) return false;
   {
     Synchronized sync(digitalDIOSemaphore);
-    uint32_t bitToSet = 1 << (remapDigitalChannel(port->port.pin - 1, status));
+    uint32_t bitToSet = 1 << (remapDigitalChannel(port->port.pin, status));
     tDIO::tOutputEnable outputEnable = digitalSystem->readOutputEnable(status);
     if (input) {
       outputEnable.Headers = outputEnable.Headers & (~bitToSet); // clear the bit for read
@@ -436,7 +436,7 @@ bool allocateDIO(void* digital_port_pointer, bool input, int32_t *status) {
  */
 void freeDIO(void* digital_port_pointer, int32_t *status) {
   DigitalPort* port = (DigitalPort*) digital_port_pointer;
-  DIOChannels->Free(kDigitalPins * (port->port.module - 1) + port->port.pin - 1);
+  DIOChannels->Free(kDigitalPins * (port->port.module - 1) + port->port.pin);
 }
 
 /**
@@ -456,9 +456,9 @@ void setDIO(void* digital_port_pointer, short value, int32_t *status) {
     Synchronized sync(digitalDIOSemaphore);
     tDIO::tDO currentDIO = digitalSystem->readDO(status);
     if(value == 0) {
-      currentDIO.Headers = currentDIO.Headers & ~(1 << remapDigitalChannel(port->port.pin - 1, status));
+      currentDIO.Headers = currentDIO.Headers & ~(1 << remapDigitalChannel(port->port.pin, status));
     } else if (value == 1) {
-      currentDIO.Headers = currentDIO.Headers | (1 << remapDigitalChannel(port->port.pin - 1, status));
+      currentDIO.Headers = currentDIO.Headers | (1 << remapDigitalChannel(port->port.pin, status));
     } 
     digitalSystem->writeDO(currentDIO, status);
   }
@@ -479,7 +479,7 @@ bool getDIO(void* digital_port_pointer, int32_t *status) {
   //if it == 0, then return false
   //else return true
 
-  return ((currentDIO.Headers >> remapDigitalChannel(port->port.pin - 1, status)) & 1) != 0;
+  return ((currentDIO.Headers >> remapDigitalChannel(port->port.pin, status)) & 1) != 0;
 }
 
 /**
@@ -497,7 +497,7 @@ bool getDIODirection(void* digital_port_pointer, int32_t *status) {
   //AND it against the currentOutputEnable
   //if it == 0, then return false
   //else return true
-  return ((currentOutputEnable.Headers >> remapDigitalChannel(port->port.pin - 1, status)) & 1) != 0;
+  return ((currentOutputEnable.Headers >> remapDigitalChannel(port->port.pin, status)) & 1) != 0;
 }
 
 /**
@@ -510,7 +510,7 @@ bool getDIODirection(void* digital_port_pointer, int32_t *status) {
 void pulse(void* digital_port_pointer, double pulseLength, int32_t *status) {
   DigitalPort* port = (DigitalPort*) digital_port_pointer;
   tDIO::tPulse pulse;
-  pulse.Headers = 1 << remapDigitalChannel(port->port.pin - 1, status);
+  pulse.Headers = 1 << remapDigitalChannel(port->port.pin, status);
   digitalSystem->writePulseLength((uint8_t)(1.0e9 * pulseLength / (pwmSystem->readLoopTiming(status) * 25)), status);
   digitalSystem->writePulse(pulse, status);
 }
@@ -522,7 +522,7 @@ void pulse(void* digital_port_pointer, double pulseLength, int32_t *status) {
  */
 bool isPulsing(void* digital_port_pointer, int32_t *status) {
   DigitalPort* port = (DigitalPort*) digital_port_pointer;
-  uint16_t mask = 1 << remapDigitalChannel(port->port.pin - 1, status);
+  uint16_t mask = 1 << remapDigitalChannel(port->port.pin, status);
   tDIO::tPulse pulseRegister = digitalSystem->readPulse(status);
   return (pulseRegister.Headers & mask) != 0;
 }
diff --git a/wpilibc/wpilibC++/include/DriverStation.h b/wpilibc/wpilibC++/include/DriverStation.h
index 0a0fe836e2f1ff0e6b288463aa3381ed8bf6a744..9127a980deb1430411cfcf298c7d9799faf53ec9 100644
--- a/wpilibc/wpilibC++/include/DriverStation.h
+++ b/wpilibc/wpilibC++/include/DriverStation.h
@@ -30,7 +30,7 @@ public:
 	static DriverStation *GetInstance();
 
 	static const uint32_t kBatteryModuleNumber = 1;
-	static const uint32_t kBatteryChannel = 8;
+	static const uint32_t kBatteryChannel = 7;
 	static const uint32_t kJoystickPorts = 4;
 	static const uint32_t kJoystickAxes = 6;
 
diff --git a/wpilibc/wpilibC++/lib/AnalogChannel.cpp b/wpilibc/wpilibC++/lib/AnalogChannel.cpp
index bc9ea05f0b8d2d6774f70a1dca50b9a6389755b5..3e166561658acbec4dfa57423abd45e5988a0134 100644
--- a/wpilibc/wpilibC++/lib/AnalogChannel.cpp
+++ b/wpilibc/wpilibC++/lib/AnalogChannel.cpp
@@ -15,7 +15,7 @@ static Resource *channels = NULL;
 
 const uint8_t AnalogChannel::kAccumulatorModuleNumber;
 const uint32_t AnalogChannel::kAccumulatorNumChannels;
-const uint32_t AnalogChannel::kAccumulatorChannels[] = {1, 2};
+const uint32_t AnalogChannel::kAccumulatorChannels[] = {0, 1};
 
 /**
  * Common initialization.
@@ -39,7 +39,7 @@ void AnalogChannel::InitChannel(uint8_t moduleNumber, uint32_t channel)
 	}
 
 	snprintf(buf, 64, "Analog Input %d (Module: %d)", channel, moduleNumber);
-	if (channels->Allocate((moduleNumber - 1) * kAnalogChannels + channel - 1, buf) == ~0ul)
+	if (channels->Allocate((moduleNumber - 1) * kAnalogChannels + channel, buf) == ~0ul)
 	{
 		CloneError(channels);
 		return;
@@ -82,7 +82,7 @@ AnalogChannel::AnalogChannel(uint32_t channel)
  */
 AnalogChannel::~AnalogChannel()
 {
-	channels->Free((m_module - 1) * kAnalogChannels + m_channel - 1);
+	channels->Free((m_module - 1) * kAnalogChannels + m_channel);
 }
 
 /**
diff --git a/wpilibc/wpilibC++/lib/AnalogModule.cpp b/wpilibc/wpilibC++/lib/AnalogModule.cpp
index 4c85116f61b6beaddd26dfb10bed0308a3a9dea6..fba736738bfd68ab6195bf23e30d5e030e6f7b31 100644
--- a/wpilibc/wpilibC++/lib/AnalogModule.cpp
+++ b/wpilibc/wpilibC++/lib/AnalogModule.cpp
@@ -55,7 +55,7 @@ AnalogModule::AnalogModule(uint8_t moduleNumber)
 {
 	for (uint32_t i = 0; i < kAnalogChannels; i++)
 	{
-	  void* port = getPortWithModule(moduleNumber, i+1);
+	  void* port = getPortWithModule(moduleNumber, i);
 	  int32_t status = 0;
 	  m_ports[i] = initializeAnalogPort(port, &status);
 	  wpi_setErrorWithContext(status, getHALErrorMessage(status));
diff --git a/wpilibc/wpilibC++/lib/DigitalInput.cpp b/wpilibc/wpilibC++/lib/DigitalInput.cpp
index 4de69f70684c08471a9d7ebeb66319b41929e38a..bede57e9e7f8e48c79a09d3c7097ff9e5f0fd097 100644
--- a/wpilibc/wpilibC++/lib/DigitalInput.cpp
+++ b/wpilibc/wpilibC++/lib/DigitalInput.cpp
@@ -105,7 +105,7 @@ uint32_t DigitalInput::GetChannel()
  */
 uint32_t DigitalInput::GetChannelForRouting()
 {
-	return GetChannel() - 1;
+	return GetChannel();
 }
 
 /**
diff --git a/wpilibc/wpilibC++/lib/DigitalModule.cpp b/wpilibc/wpilibC++/lib/DigitalModule.cpp
index 8df0a53c451d56d644db0ae5d1a8a5da7af5da4b..8f91bcde26e1a2de0a9c50166612fc5871a7a8a5 100644
--- a/wpilibc/wpilibC++/lib/DigitalModule.cpp
+++ b/wpilibc/wpilibC++/lib/DigitalModule.cpp
@@ -50,21 +50,21 @@ DigitalModule::DigitalModule(uint8_t moduleNumber)
   	m_module = moduleNumber;
   	for (uint32_t i = 0; i < kDigitalChannels; i++)
 	{
-	  void* port = getPortWithModule(moduleNumber, i+1);
+	  void* port = getPortWithModule(moduleNumber, i);
 	  int32_t status = 0;
 	  m_digital_ports[i] = initializeDigitalPort(port, &status);
 	  wpi_setErrorWithContext(status, getHALErrorMessage(status));
 	}
   	for (uint32_t i = 0; i < kRelayChannels; i++)
 	{
-	  void* port = getPortWithModule(moduleNumber, i+1);
+	  void* port = getPortWithModule(moduleNumber, i);
 	  int32_t status = 0;
 	  m_relay_ports[i] = initializeDigitalPort(port, &status);
 	  wpi_setErrorWithContext(status, getHALErrorMessage(status));
 	}
   	for (uint32_t i = 0; i < kPwmChannels; i++)
 	{
-	  void* port = getPortWithModule(moduleNumber, i+1);
+	  void* port = getPortWithModule(moduleNumber, i);
 	  int32_t status = 0;
 	  m_pwm_ports[i] = initializeDigitalPort(port, &status);
 	  wpi_setErrorWithContext(status, getHALErrorMessage(status));
@@ -86,7 +86,7 @@ DigitalModule::~DigitalModule()
 void DigitalModule::SetPWM(uint32_t channel, unsigned short value)
 {
   	int32_t status = 0;
-	setPWM(m_pwm_ports[channel-1], value, &status);
+	setPWM(m_pwm_ports[channel], value, &status);
 	wpi_setErrorWithContext(status, getHALErrorMessage(status));
 }
 
@@ -99,7 +99,7 @@ void DigitalModule::SetPWM(uint32_t channel, unsigned short value)
 unsigned short DigitalModule::GetPWM(uint32_t channel)
 {
   	int32_t status = 0;
-	uint16_t value = getPWM(m_pwm_ports[channel-1], &status);
+	uint16_t value = getPWM(m_pwm_ports[channel], &status);
 	wpi_setErrorWithContext(status, getHALErrorMessage(status));
 	return value;
 }
@@ -113,7 +113,7 @@ unsigned short DigitalModule::GetPWM(uint32_t channel)
 void DigitalModule::SetPWMPeriodScale(uint32_t channel, uint32_t squelchMask)
 {
 	int32_t status = 0;
-	setPWMPeriodScale(m_pwm_ports[channel-1], squelchMask, &status);
+	setPWMPeriodScale(m_pwm_ports[channel], squelchMask, &status);
 	wpi_setErrorWithContext(status, getHALErrorMessage(status));
 }
 
@@ -125,7 +125,7 @@ void DigitalModule::SetPWMPeriodScale(uint32_t channel, uint32_t squelchMask)
 void DigitalModule::SetRelayForward(uint32_t channel, bool on)
 {
 	int32_t status = 0;
-	setRelayForward(m_relay_ports[channel-1], on, &status);
+	setRelayForward(m_relay_ports[channel], on, &status);
 	wpi_setErrorWithContext(status, getHALErrorMessage(status));
 }
 
@@ -137,7 +137,7 @@ void DigitalModule::SetRelayForward(uint32_t channel, bool on)
 void DigitalModule::SetRelayReverse(uint32_t channel, bool on)
 {
 	int32_t status = 0;
-	setRelayReverse(m_relay_ports[channel-1], on, &status);
+	setRelayReverse(m_relay_ports[channel], on, &status);
 	wpi_setErrorWithContext(status, getHALErrorMessage(status));
 }
 
@@ -147,7 +147,7 @@ void DigitalModule::SetRelayReverse(uint32_t channel, bool on)
 bool DigitalModule::GetRelayForward(uint32_t channel)
 {
 	int32_t status = 0;
-	bool on = getRelayForward(m_relay_ports[channel-1], &status);
+	bool on = getRelayForward(m_relay_ports[channel], &status);
 	wpi_setErrorWithContext(status, getHALErrorMessage(status));
 	return on;
 }
@@ -159,7 +159,7 @@ uint8_t DigitalModule::GetRelayForward()
 {
 	uint8_t value = 0;
 	for (unsigned int i = 0; i < kRelayChannels; i++) {
-		value |= GetRelayForward(i+1) << i;
+		value |= GetRelayForward(i) << i;
 	}
 	return value;
 }
@@ -170,7 +170,7 @@ uint8_t DigitalModule::GetRelayForward()
 bool DigitalModule::GetRelayReverse(uint32_t channel)
 {
 	int32_t status = 0;
-	bool on = getRelayReverse(m_relay_ports[channel-1], &status);
+	bool on = getRelayReverse(m_relay_ports[channel], &status);
 	wpi_setErrorWithContext(status, getHALErrorMessage(status));
 	return on;
 }
@@ -182,7 +182,7 @@ uint8_t DigitalModule::GetRelayReverse()
 {
 	uint8_t value = 0;
 	for (unsigned int i = 0; i < kRelayChannels; i++) {
-		value |= GetRelayReverse(i+1) << i;
+		value |= GetRelayReverse(i) << i;
 	}
 	return value;
 }
@@ -200,7 +200,7 @@ uint8_t DigitalModule::GetRelayReverse()
 bool DigitalModule::AllocateDIO(uint32_t channel, bool input)
 {
 	int32_t status = 0;
-	bool allocated = allocateDIO(m_digital_ports[channel-1], input, &status);
+	bool allocated = allocateDIO(m_digital_ports[channel], input, &status);
 	wpi_setErrorWithContext(status, getHALErrorMessage(status));
 	return allocated;
 }
@@ -213,7 +213,7 @@ bool DigitalModule::AllocateDIO(uint32_t channel, bool input)
 void DigitalModule::FreeDIO(uint32_t channel)
 {
 	int32_t status = 0;
-	freeDIO(m_digital_ports[channel-1], &status);
+	freeDIO(m_digital_ports[channel], &status);
 	wpi_setErrorWithContext(status, getHALErrorMessage(status));
 }
 
@@ -227,7 +227,7 @@ void DigitalModule::FreeDIO(uint32_t channel)
 void DigitalModule::SetDIO(uint32_t channel, short value)
 {
 	int32_t status = 0;
-	setDIO(m_digital_ports[channel-1], value, &status);
+	setDIO(m_digital_ports[channel], value, &status);
 	wpi_setErrorWithContext(status, getHALErrorMessage(status));
 }
 
@@ -241,7 +241,7 @@ void DigitalModule::SetDIO(uint32_t channel, short value)
 bool DigitalModule::GetDIO(uint32_t channel)
 {
 	int32_t status = 0;
-	bool value = getDIO(m_digital_ports[channel-1], &status);
+	bool value = getDIO(m_digital_ports[channel], &status);
 	wpi_setErrorWithContext(status, getHALErrorMessage(status));
 	return value;
 }
@@ -254,7 +254,7 @@ uint16_t DigitalModule::GetDIO()
 {
 	uint16_t value = 0;
 	for (unsigned int i = 0; i < kDigitalChannels; i++) {
-		value |= GetDIO(i+1) << i;
+		value |= GetDIO(i) << i;
 	}
 	return value;
 }
@@ -269,7 +269,7 @@ uint16_t DigitalModule::GetDIO()
 bool DigitalModule::GetDIODirection(uint32_t channel)
 {
 	int32_t status = 0;
-	bool value = getDIODirection(m_digital_ports[channel-1], &status);
+	bool value = getDIODirection(m_digital_ports[channel], &status);
 	wpi_setErrorWithContext(status, getHALErrorMessage(status));
 	return value;
 }
@@ -283,7 +283,7 @@ uint16_t DigitalModule::GetDIODirection()
 {
 	uint16_t value = 0;
 	for (unsigned int i = 0; i < kDigitalChannels; i++) {
-		value |= GetDIODirection(i+1) << i;
+		value |= GetDIODirection(i) << i;
 	}
 	return value;
 }
@@ -298,7 +298,7 @@ uint16_t DigitalModule::GetDIODirection()
 void DigitalModule::Pulse(uint32_t channel, float pulseLength)
 {
 	int32_t status = 0;
-	pulse(m_digital_ports[channel-1], pulseLength, &status);
+	pulse(m_digital_ports[channel], pulseLength, &status);
 	wpi_setErrorWithContext(status, getHALErrorMessage(status));
 }
 
@@ -310,7 +310,7 @@ void DigitalModule::Pulse(uint32_t channel, float pulseLength)
 bool DigitalModule::IsPulsing(uint32_t channel)
 {
 	int32_t status = 0;
-	bool value = isPulsing(m_digital_ports[channel-1], &status);
+	bool value = isPulsing(m_digital_ports[channel], &status);
 	wpi_setErrorWithContext(status, getHALErrorMessage(status));
 	return value;
 }
diff --git a/wpilibc/wpilibC++/lib/PWM.cpp b/wpilibc/wpilibC++/lib/PWM.cpp
index 615f43b82409bc0f8e5aad363e64bf7419ce41e8..9729857d5f0ea299fa8593f08d1b0f4e562549ab 100644
--- a/wpilibc/wpilibC++/lib/PWM.cpp
+++ b/wpilibc/wpilibC++/lib/PWM.cpp
@@ -44,7 +44,7 @@ void PWM::InitPWM(uint8_t moduleNumber, uint32_t channel)
 	}
 
 	snprintf(buf, 64, "PWM %d (Module: %d)", channel, moduleNumber);
-	if (allocated->Allocate((moduleNumber - 1) * kPwmChannels + channel - 1, buf) == ~0ul)
+	if (allocated->Allocate((moduleNumber - 1) * kPwmChannels + channel, buf) == ~0ul)
 	{
 		CloneError(allocated);
 		return;
@@ -94,7 +94,7 @@ PWM::~PWM()
 	if (m_module)
 	{
 		m_module->SetPWM(m_channel, kPwmDisabled);
-		allocated->Free((m_module->GetNumber() - 1) * kPwmChannels + m_channel - 1);
+		allocated->Free((m_module->GetNumber() - 1) * kPwmChannels + m_channel);
 	}
 }
 
diff --git a/wpilibc/wpilibC++/lib/Relay.cpp b/wpilibc/wpilibC++/lib/Relay.cpp
index 4ada65586f487a2d112ede43ac7b985ebdecf2eb..4ef9d1d5ed600b1cdf2497eee0b9372ca4cfc4da 100644
--- a/wpilibc/wpilibC++/lib/Relay.cpp
+++ b/wpilibc/wpilibC++/lib/Relay.cpp
@@ -44,7 +44,7 @@ void Relay::InitRelay (uint8_t moduleNumber)
 	if (m_direction == kBothDirections || m_direction == kForwardOnly)
 	{
 		snprintf(buf, 64, "Forward Relay %d (Module: %d)", m_channel, moduleNumber);
-		if (relayChannels->Allocate(((moduleNumber - 1) * kRelayChannels + m_channel - 1) * 2, buf) == ~0ul)
+		if (relayChannels->Allocate(((moduleNumber - 1) * kRelayChannels + m_channel) * 2, buf) == ~0ul)
 		{
 			CloneError(relayChannels);
 			return;
@@ -55,7 +55,7 @@ void Relay::InitRelay (uint8_t moduleNumber)
 	if (m_direction == kBothDirections || m_direction == kReverseOnly)
 	{
 		snprintf(buf, 64, "Reverse Relay %d (Module: %d)", m_channel, moduleNumber);
-		if (relayChannels->Allocate(((moduleNumber - 1) * kRelayChannels + m_channel - 1) * 2 + 1, buf) == ~0ul)
+		if (relayChannels->Allocate(((moduleNumber - 1) * kRelayChannels + m_channel) * 2 + 1, buf) == ~0ul)
 		{
 			CloneError(relayChannels);
 			return;
@@ -106,11 +106,11 @@ Relay::~Relay()
 
 	if (m_direction == kBothDirections || m_direction == kForwardOnly)
 	{
-		relayChannels->Free(((m_module->GetNumber() - 1) * kRelayChannels + m_channel - 1) * 2);
+		relayChannels->Free(((m_module->GetNumber() - 1) * kRelayChannels + m_channel) * 2);
 	}
 	if (m_direction == kBothDirections || m_direction == kReverseOnly)
 	{
-		relayChannels->Free(((m_module->GetNumber() - 1) * kRelayChannels + m_channel - 1) * 2 + 1);
+		relayChannels->Free(((m_module->GetNumber() - 1) * kRelayChannels + m_channel) * 2 + 1);
 	}
 }
 
diff --git a/wpilibc/wpilibC++/lib/SensorBase.cpp b/wpilibc/wpilibC++/lib/SensorBase.cpp
index 00c5a5dd8282f297b5424a762465cf25ab4508b8..ad22f1d87272c2bc9925625d48e93ff82a665551 100644
--- a/wpilibc/wpilibC++/lib/SensorBase.cpp
+++ b/wpilibc/wpilibC++/lib/SensorBase.cpp
@@ -131,7 +131,7 @@ bool SensorBase::CheckSolenoidModule(uint8_t moduleNumber)
  */
 bool SensorBase::CheckDigitalChannel(uint32_t channel)
 {
-	if (channel > 0 && channel <= kDigitalChannels)
+	if (channel >= 0 && channel < kDigitalChannels)
 		return true;
 	return false;
 }
@@ -145,7 +145,7 @@ bool SensorBase::CheckDigitalChannel(uint32_t channel)
  */
 bool SensorBase::CheckRelayChannel(uint32_t channel)
 {
-	if (channel > 0 && channel <= kRelayChannels)
+	if (channel >= 0 && channel < kRelayChannels)
 		return true;
 	return false;
 }
@@ -159,7 +159,7 @@ bool SensorBase::CheckRelayChannel(uint32_t channel)
  */
 bool SensorBase::CheckPWMChannel(uint32_t channel)
 {
-	if (channel > 0 && channel <= kPwmChannels)
+	if (channel >= 0 && channel < kPwmChannels)
 		return true;
 	return false;
 }
@@ -173,7 +173,7 @@ bool SensorBase::CheckPWMChannel(uint32_t channel)
  */
 bool SensorBase::CheckAnalogChannel(uint32_t channel)
 {
-	if (channel > 0 && channel <= kAnalogChannels)
+	if (channel >= 0 && channel < kAnalogChannels)
 		return true;
 	return false;
 }
diff --git a/wpilibc/wpilibC++IntegrationTests/include/TestBench.h b/wpilibc/wpilibC++IntegrationTests/include/TestBench.h
index 6a26977d74800bf339b20da64d9b1b16758b8679..b4aadbb5c01a3701a7feabefd3a20c64f6af7df2 100644
--- a/wpilibc/wpilibC++IntegrationTests/include/TestBench.h
+++ b/wpilibc/wpilibC++IntegrationTests/include/TestBench.h
@@ -12,25 +12,25 @@
 class TestBench {
 public:
 	/* Analog channels */
-	static const int kCameraGyroChannel = 1;
+	static const uint32_t kCameraGyroChannel = 0;
 	
 	/* DIO channels */
-	static const int kTalonEncoderChannelA = 1;
-	static const int kTalonEncoderChannelB = 2;
-	static const int kVictorEncoderChannelA = 3;
-	static const int kVictorEncoderChannelB = 4;
-	static const int kJaguarEncoderChannelA = 5;
-	static const int kJaguarEncoderChannelB = 6;
-	static const int kLoop1OutputChannel = 7;
-	static const int kLoop1InputChannel = 8;
-	static const int kLoop2OutputChannel = 9;
-	static const int kLoop2InputChannel = 10;
+	static const uint32_t kTalonEncoderChannelA = 0;
+	static const uint32_t kTalonEncoderChannelB = 1;
+	static const uint32_t kVictorEncoderChannelA = 2;
+	static const uint32_t kVictorEncoderChannelB = 3;
+	static const uint32_t kJaguarEncoderChannelA = 4;
+	static const uint32_t kJaguarEncoderChannelB = 5;
+	static const uint32_t kLoop1OutputChannel = 6;
+	static const uint32_t kLoop1InputChannel = 7;
+	static const uint32_t kLoop2OutputChannel = 8;
+	static const uint32_t kLoop2InputChannel = 9;
 	
 	/* PWM channels */
-	static const int kTalonChannel = 1;
-	static const int kVictorChannel = 2;
-	static const int kJaguarChannel = 3;
-	static const int kCameraPanChannel = 9;
-	static const int kCameraTiltChannel = 10;
+	static const uint32_t kTalonChannel = 0;
+	static const uint32_t kVictorChannel = 1;
+	static const uint32_t kJaguarChannel = 2;
+	static const uint32_t kCameraPanChannel = 8;
+	static const uint32_t kCameraTiltChannel = 9;
 };
 
diff --git a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/AnalogChannel.java b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/AnalogChannel.java
index 78c56e70000444ac10e59859e328e60d2a860422..6e19580f57469b61cdabe4912cd84df3c3d7602d 100644
--- a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/AnalogChannel.java
+++ b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/AnalogChannel.java
@@ -47,7 +47,7 @@ public class AnalogChannel extends SensorBase implements PIDSource,
 			* kAnalogChannels);
 	private ByteBuffer m_port;
 	private int m_moduleNumber, m_channel;
-	private static final int[] kAccumulatorChannels = { 1, 2 };
+	private static final int[] kAccumulatorChannels = { 0, 1 };
 	private long m_accumulatorOffset;
 
 	/**
@@ -82,8 +82,7 @@ public class AnalogChannel extends SensorBase implements PIDSource,
 					+ " cannot be allocated. Channel is not present.");
 		}
 		try {
-			channels.allocate((moduleNumber - 1) * kAnalogChannels + channel
-					- 1);
+			channels.allocate((moduleNumber - 1) * kAnalogChannels + channel);
 		} catch (CheckedAllocationException e) {
 			throw new AllocationException("Analog channel " + m_channel
 					+ " on module " + m_moduleNumber + " is already allocated");
@@ -107,7 +106,7 @@ public class AnalogChannel extends SensorBase implements PIDSource,
 	 * Channel destructor.
 	 */
 	public void free() {
-		channels.free(((m_moduleNumber - 1) * kAnalogChannels + m_channel - 1));
+		channels.free(((m_moduleNumber - 1) * kAnalogChannels + m_channel));
 		m_channel = 0;
 		m_moduleNumber = 0;
 		m_accumulatorOffset = 0;
diff --git a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/AnalogModule.java b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/AnalogModule.java
index 24c61fcb04a770887b4be3da808ce196aedc326e..7cbfebdc4dae6fbb111904a842663ae491e6a148 100644
--- a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/AnalogModule.java
+++ b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/AnalogModule.java
@@ -71,7 +71,7 @@ public class AnalogModule extends Module {
 
         m_ports = new ByteBuffer[8];
         for (int i = 0; i < SensorBase.kAnalogChannels; i++) {
-            ByteBuffer port_pointer = AnalogJNI.getPortWithModule((byte) moduleNumber, (byte) (i+1));
+            ByteBuffer port_pointer = AnalogJNI.getPortWithModule((byte) moduleNumber, (byte) i);
             ByteBuffer status = ByteBuffer.allocateDirect(4);
     		// set the byte order
     		status.order(ByteOrder.LITTLE_ENDIAN);
diff --git a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/DigitalModule.java b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/DigitalModule.java
index 5dc04d9ea2ee11735ab85859467122ac49a7f092..4dfd055cb965be086185021384f0e1c7be8563db 100644
--- a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/DigitalModule.java
+++ b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/DigitalModule.java
@@ -65,7 +65,7 @@ public class DigitalModule extends Module {
         m_digital_ports = new ByteBuffer[SensorBase.kDigitalChannels];
         for (int i = 0; i < SensorBase.kDigitalChannels; i++) {
             ByteBuffer port_pointer = DIOJNI.getPortWithModule(
-                                       (byte) moduleNumber, (byte) (i + 1));
+                                       (byte) moduleNumber, (byte) i);
             ByteBuffer status = ByteBuffer.allocateDirect(4);
     		// set the byte order
     		status.order(ByteOrder.LITTLE_ENDIAN);
@@ -77,7 +77,7 @@ public class DigitalModule extends Module {
         m_relay_ports = new ByteBuffer[SensorBase.kRelayChannels];
         for (int i = 0; i < SensorBase.kRelayChannels; i++) {
             ByteBuffer port_pointer = RelayJNI.getPortWithModule(
-                                       (byte) moduleNumber, (byte) (i + 1));
+                                       (byte) moduleNumber, (byte) i);
             ByteBuffer status = ByteBuffer.allocateDirect(4);
     		// set the byte order
     		status.order(ByteOrder.LITTLE_ENDIAN);
@@ -88,7 +88,7 @@ public class DigitalModule extends Module {
         m_pwm_ports = new ByteBuffer[SensorBase.kPwmChannels];
         for (int i = 0; i < SensorBase.kPwmChannels; i++) {
             ByteBuffer port_pointer = PWMJNI.getPortWithModule(
-                                       (byte) moduleNumber, (byte) (i + 1));
+                                       (byte) moduleNumber, (byte) i);
             ByteBuffer status = ByteBuffer.allocateDirect(4);
     		// set the byte order
     		status.order(ByteOrder.LITTLE_ENDIAN);
@@ -112,7 +112,7 @@ public class DigitalModule extends Module {
         ByteBuffer status = ByteBuffer.allocateDirect(4);
 		// set the byte order
 		status.order(ByteOrder.LITTLE_ENDIAN);
-        PWMJNI.setPWM(m_pwm_ports[channel - 1], (short) value, status.asIntBuffer());
+        PWMJNI.setPWM(m_pwm_ports[channel], (short) value, status.asIntBuffer());
         HALUtil.checkStatus(status.asIntBuffer());
     }
 
@@ -127,7 +127,7 @@ public class DigitalModule extends Module {
         ByteBuffer status = ByteBuffer.allocateDirect(4);
 		// set the byte order
 		status.order(ByteOrder.LITTLE_ENDIAN);
-        int value = (int) PWMJNI.getPWM(m_pwm_ports[channel - 1], status.asIntBuffer());
+        int value = (int) PWMJNI.getPWM(m_pwm_ports[channel], status.asIntBuffer());
         HALUtil.checkStatus(status.asIntBuffer());
         return value;
     }
@@ -144,7 +144,7 @@ public class DigitalModule extends Module {
         ByteBuffer status = ByteBuffer.allocateDirect(4);
 		// set the byte order
 		status.order(ByteOrder.LITTLE_ENDIAN);
-        PWMJNI.setPWMPeriodScale(m_pwm_ports[channel - 1], squelchMask,
+        PWMJNI.setPWMPeriodScale(m_pwm_ports[channel], squelchMask,
                                      status.asIntBuffer());
         HALUtil.checkStatus(status.asIntBuffer());
     }
@@ -162,7 +162,7 @@ public class DigitalModule extends Module {
         ByteBuffer status = ByteBuffer.allocateDirect(4);
 		// set the byte order
 		status.order(ByteOrder.LITTLE_ENDIAN);
-        RelayJNI.setRelayForward(m_relay_ports[channel - 1], (byte) (on ? 1
+        RelayJNI.setRelayForward(m_relay_ports[channel], (byte) (on ? 1
                                    : 0), status.asIntBuffer());
         HALUtil.checkStatus(status.asIntBuffer());
     }
@@ -180,7 +180,7 @@ public class DigitalModule extends Module {
         ByteBuffer status = ByteBuffer.allocateDirect(4);
 		// set the byte order
 		status.order(ByteOrder.LITTLE_ENDIAN);
-        RelayJNI.setRelayReverse(m_relay_ports[channel - 1], (byte) (on ? 1
+        RelayJNI.setRelayReverse(m_relay_ports[channel], (byte) (on ? 1
                                    : 0), status.asIntBuffer());
         HALUtil.checkStatus(status.asIntBuffer());
     }
@@ -196,7 +196,7 @@ public class DigitalModule extends Module {
         ByteBuffer status = ByteBuffer.allocateDirect(4);
 		// set the byte order
 		status.order(ByteOrder.LITTLE_ENDIAN);
-        boolean value = RelayJNI.getRelayForward(m_relay_ports[channel - 1],
+        boolean value = RelayJNI.getRelayForward(m_relay_ports[channel],
                         status.asIntBuffer()) != 0;
         HALUtil.checkStatus(status.asIntBuffer());
         return value;
@@ -231,7 +231,7 @@ public class DigitalModule extends Module {
         ByteBuffer status = ByteBuffer.allocateDirect(4);
 		// set the byte order
 		status.order(ByteOrder.LITTLE_ENDIAN);
-        boolean value = RelayJNI.getRelayReverse(m_relay_ports[channel - 1],
+        boolean value = RelayJNI.getRelayReverse(m_relay_ports[channel],
                         status.asIntBuffer()) != 0;
         HALUtil.checkStatus(status.asIntBuffer());
         return value;
@@ -272,7 +272,7 @@ public class DigitalModule extends Module {
 		// set the byte order
 		status.order(ByteOrder.LITTLE_ENDIAN);
         boolean allocated = DIOJNI.allocateDIO(
-                                m_digital_ports[channel - 1], (byte) (input ? 1 : 0), status.asIntBuffer()) != 0;
+                                m_digital_ports[channel], (byte) (input ? 1 : 0), status.asIntBuffer()) != 0;
         HALUtil.checkStatus(status.asIntBuffer());
         return allocated;
     }
@@ -287,7 +287,7 @@ public class DigitalModule extends Module {
         ByteBuffer status = ByteBuffer.allocateDirect(4);
 		// set the byte order
 		status.order(ByteOrder.LITTLE_ENDIAN);
-        DIOJNI.freeDIO(m_digital_ports[channel - 1], status.asIntBuffer());
+        DIOJNI.freeDIO(m_digital_ports[channel], status.asIntBuffer());
         HALUtil.checkStatus(status.asIntBuffer());
     }
 
@@ -304,7 +304,7 @@ public class DigitalModule extends Module {
         ByteBuffer status = ByteBuffer.allocateDirect(4);
 		// set the byte order
 		status.order(ByteOrder.LITTLE_ENDIAN);
-        DIOJNI.setDIO(m_digital_ports[channel - 1], (byte) (value ? 1 : 0),
+        DIOJNI.setDIO(m_digital_ports[channel], (byte) (value ? 1 : 0),
                           status.asIntBuffer());
         HALUtil.checkStatus(status.asIntBuffer());
     }
@@ -321,7 +321,7 @@ public class DigitalModule extends Module {
         ByteBuffer status = ByteBuffer.allocateDirect(4);
 		// set the byte order
 		status.order(ByteOrder.LITTLE_ENDIAN);
-        boolean value = DIOJNI.getDIO(m_digital_ports[channel - 1], status.asIntBuffer()) != 0;
+        boolean value = DIOJNI.getDIO(m_digital_ports[channel], status.asIntBuffer()) != 0;
         HALUtil.checkStatus(status.asIntBuffer());
         return value;
     }
@@ -357,7 +357,7 @@ public class DigitalModule extends Module {
 		// set the byte order
 		status.order(ByteOrder.LITTLE_ENDIAN);
         boolean value = DIOJNI.getDIODirection(
-                            m_digital_ports[channel - 1], status.asIntBuffer()) != 0;
+                            m_digital_ports[channel], status.asIntBuffer()) != 0;
         HALUtil.checkStatus(status.asIntBuffer());
         return value;
     }
@@ -394,7 +394,7 @@ public class DigitalModule extends Module {
         ByteBuffer status = ByteBuffer.allocateDirect(4);
 		// set the byte order
 		status.order(ByteOrder.LITTLE_ENDIAN);
-        DIOJNI.pulse(m_digital_ports[channel - 1], pulseLength, status.asIntBuffer());
+        DIOJNI.pulse(m_digital_ports[channel], pulseLength, status.asIntBuffer());
         HALUtil.checkStatus(status.asIntBuffer());
     }
 
@@ -415,7 +415,7 @@ public class DigitalModule extends Module {
         float convertedPulse = (float) (pulseLength / 1.0e9 * (DIOJNI.getLoopTiming(status.asIntBuffer()) * 25));
         System.err
         .println("You should use the float version of pulse for portability.  This is deprecated");
-        DIOJNI.pulse(m_digital_ports[channel - 1], convertedPulse, status.asIntBuffer());
+        DIOJNI.pulse(m_digital_ports[channel], convertedPulse, status.asIntBuffer());
         HALUtil.checkStatus(status.asIntBuffer());
     }
 
@@ -430,7 +430,7 @@ public class DigitalModule extends Module {
         ByteBuffer status = ByteBuffer.allocateDirect(4);
 		// set the byte order
 		status.order(ByteOrder.LITTLE_ENDIAN);
-        boolean value = DIOJNI.isPulsing(m_digital_ports[channel - 1],
+        boolean value = DIOJNI.isPulsing(m_digital_ports[channel],
                                              status.asIntBuffer()) != 0;
         HALUtil.checkStatus(status.asIntBuffer());
         return value;
diff --git a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/DigitalSource.java b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/DigitalSource.java
index be214ea6d4d7b1db2d04ab9a9475788b2496fdc5..515248b13d57387d338d741a2f22de492d683f39 100644
--- a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/DigitalSource.java
+++ b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/DigitalSource.java
@@ -45,7 +45,7 @@ public abstract class DigitalSource extends InterruptableSensorBase {
 
 		try {
 			channels.allocate((m_moduleNumber - 1) * kDigitalChannels
-					+ m_channel - 1);
+					+ m_channel);
 		} catch (CheckedAllocationException ex) {
 			throw new AllocationException("Digital input " + m_channel
 					+ " on module " + m_moduleNumber + " is already allocated");
@@ -63,7 +63,7 @@ public abstract class DigitalSource extends InterruptableSensorBase {
 	}
 
 	public void free() {
-		channels.free(((m_moduleNumber - 1) * kDigitalChannels + m_channel - 1));
+		channels.free(((m_moduleNumber - 1) * kDigitalChannels + m_channel));
 		ByteBuffer status = ByteBuffer.allocateDirect(4);
 		// set the byte order
 		status.order(ByteOrder.LITTLE_ENDIAN);
@@ -79,7 +79,7 @@ public abstract class DigitalSource extends InterruptableSensorBase {
 	 * @return channel routing number
 	 */
 	public int getChannelForRouting() {
-		return m_channel - 1;
+		return m_channel;
 	}
 
 	/**
diff --git a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/DriverStation.java b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/DriverStation.java
index 0b347975d891cc17d8d4b22d56b3b2ad58321e48..5fc76078ce1d8e5ee792df1c161b3fe3975f0e86 100644
--- a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/DriverStation.java
+++ b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/DriverStation.java
@@ -31,7 +31,7 @@ public class DriverStation implements IInputOutput {
     /**
      * Analog channel to read the battery
      */
-    public static final int kBatteryChannel = 8;
+    public static final int kBatteryChannel = 7;
     /**
      * Number of Joystick Ports
      */
diff --git a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/PWM.java b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/PWM.java
index 85585fbe5c6a7513421117a15a8f2d802325c55e..84e9fce0dcf3eb1a12b0a81a74a3906fadcb468e 100644
--- a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/PWM.java
+++ b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/PWM.java
@@ -116,7 +116,7 @@ public class PWM extends SensorBase implements LiveWindowSendable {
         checkPWMModule(moduleNumber);
         checkPWMChannel(channel);
         try {
-            allocated.allocate((moduleNumber - 1) * kPwmChannels + channel - 1);
+            allocated.allocate((moduleNumber - 1) * kPwmChannels + channel);
         } catch (CheckedAllocationException e) {
             throw new AllocationException(
                 "PWM channel " + channel + " on module " + moduleNumber + " is already allocated");
@@ -159,7 +159,7 @@ public class PWM extends SensorBase implements LiveWindowSendable {
     public void free() {
         m_module.setPWM(m_channel, kPwmDisabled);
         m_module.freeDIO(m_channel);
-        allocated.free((m_module.getModuleNumber() - 1) * kPwmChannels + m_channel - 1);
+        allocated.free((m_module.getModuleNumber() - 1) * kPwmChannels + m_channel);
     }
 
     /**
diff --git a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/Relay.java b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/Relay.java
index 68166def209cf5b8b5554a1bc2785c4cb5e20875..880bc05ce8f10641761e0d4ce3e4bdb070465e30 100644
--- a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/Relay.java
+++ b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/Relay.java
@@ -139,14 +139,14 @@ public class Relay extends SensorBase implements IDeviceController,
 			if (m_direction == Direction.kBoth
 					|| m_direction == Direction.kForward) {
 				relayChannels.allocate(((moduleNumber - 1) * kRelayChannels
-						+ m_channel - 1) * 2);
+						+ m_channel) * 2);
 				UsageReporting.report(tResourceType.kResourceType_Relay,
 						m_channel, moduleNumber - 1);
 			}
 			if (m_direction == Direction.kBoth
 					|| m_direction == Direction.kReverse) {
 				relayChannels.allocate(((moduleNumber - 1) * kRelayChannels
-						+ m_channel - 1) * 2 + 1);
+						+ m_channel) * 2 + 1);
 				UsageReporting.report(tResourceType.kResourceType_Relay,
 						m_channel + 128, moduleNumber - 1);
 			}
@@ -229,15 +229,15 @@ public class Relay extends SensorBase implements IDeviceController,
 
 		if (m_direction == Direction.kBoth || m_direction == Direction.kForward) {
 			relayChannels.free(((m_module.getModuleNumber() - 1)
-					* kRelayChannels + m_channel - 1) * 2);
+					* kRelayChannels + m_channel) * 2);
 			m_module.freeDIO(((m_module.getModuleNumber() - 1) * kRelayChannels
-					+ m_channel - 1) * 2);
+					+ m_channel) * 2);
 		}
 		if (m_direction == Direction.kBoth || m_direction == Direction.kReverse) {
 			relayChannels.free(((m_module.getModuleNumber() - 1)
-					* kRelayChannels + m_channel - 1) * 2 + 1);
+					* kRelayChannels + m_channel) * 2 + 1);
 			m_module.freeDIO(((m_module.getModuleNumber() - 1) * kRelayChannels
-					+ m_channel - 1) * 2 + 1);
+					+ m_channel) * 2 + 1);
 		}
 	}
 
diff --git a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/SensorBase.java b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/SensorBase.java
index 5a3028842401f45c0f302beeada8ac269091376b..0bfe8620ad8c9bb2ab3dc89a8c17ce27f0ecf61b 100644
--- a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/SensorBase.java
+++ b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/SensorBase.java
@@ -172,7 +172,7 @@ public abstract class SensorBase { // TODO: Refactor
      * @param channel The channel number to check.
      */
     protected static void checkDigitalChannel(final int channel) {
-        if (channel <= 0 || channel > kDigitalChannels) {
+        if (channel < 0 || channel >= kDigitalChannels) {
             System.err.println("Requested digital channel number is out of range.");
         }
     }
@@ -185,7 +185,7 @@ public abstract class SensorBase { // TODO: Refactor
      * @param channel The channel number to check.
      */
     protected static void checkRelayChannel(final int channel) {
-        if (channel <= 0 || channel > kRelayChannels) {
+        if (channel < 0 || channel >= kRelayChannels) {
             System.err.println("Requested relay channel number is out of range.");
             throw new IndexOutOfBoundsException("Requested relay channel number is out of range.");
         }
@@ -199,7 +199,7 @@ public abstract class SensorBase { // TODO: Refactor
      * @param channel The channel number to check.
      */
     protected static void checkPWMChannel(final int channel) {
-        if (channel <= 0 || channel > kPwmChannels) {
+        if (channel < 0 || channel >= kPwmChannels) {
             System.err.println("Requested PWM channel number is out of range.");
             throw new IndexOutOfBoundsException("Requested PWM channel number is out of range.");
         }
diff --git a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/test/TestBench.java b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/test/TestBench.java
index 25c1e8525e981749bf10f0ea4c3a74c68232e865..d4b02b55c366130dcbea182f5d2192ebddfb26fd 100644
--- a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/test/TestBench.java
+++ b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/test/TestBench.java
@@ -44,10 +44,10 @@ public final class TestBench {
 	
 	
 	//THESE MUST BE IN INCREMENTING ORDER
-	public static final int DIOCrossConnectA1 = 7;
-	public static final int DIOCrossConnectA2 = 8;
-	public static final int DIOCrossConnectB1 = 9;
-	public static final int DIOCrossConnectB2 = 10;
+	public static final int DIOCrossConnectA1 = 6;
+	public static final int DIOCrossConnectA2 = 7;
+	public static final int DIOCrossConnectB1 = 8;
+	public static final int DIOCrossConnectB2 = 9;
 	
 	/** The Singleton instance of the Test Bench */
 	private static TestBench instance = null;
@@ -69,9 +69,9 @@ public final class TestBench {
 	 * @return a freshly allocated Talon, Encoder pair
 	 */
 	public MotorEncoderFixture getTalonPair() {
-		Talon talon = new Talon(1);
-		DigitalInput encA1 = new DigitalInput(1);
-		DigitalInput encB1 = new DigitalInput(2);
+		Talon talon = new Talon(0);
+		DigitalInput encA1 = new DigitalInput(0);
+		DigitalInput encB1 = new DigitalInput(1);
 
 		MotorEncoderFixture talonPair = new MotorEncoderFixture(talon, encA1,
 				encB1);
@@ -85,9 +85,9 @@ public final class TestBench {
 	 * @return a freshly allocated Victor, Encoder pair
 	 */
 	public MotorEncoderFixture getVictorPair() {
-		Victor vic = new Victor(2);
-		DigitalInput encA2 = new DigitalInput(3);
-		DigitalInput encB2 = new DigitalInput(4);
+		Victor vic = new Victor(1);
+		DigitalInput encA2 = new DigitalInput(2);
+		DigitalInput encB2 = new DigitalInput(3);
 		MotorEncoderFixture vicPair = new MotorEncoderFixture(vic, encA2, encB2);
 		return vicPair;
 	}
@@ -99,9 +99,9 @@ public final class TestBench {
 	 * @return a freshly allocated Jaguar, Encoder pair
 	 */
 	public MotorEncoderFixture getJaguarPair() {
-		Jaguar jag = new Jaguar(3);
-		DigitalInput encA3 = new DigitalInput(5);
-		DigitalInput encB3 = new DigitalInput(6);
+		Jaguar jag = new Jaguar(2);
+		DigitalInput encA3 = new DigitalInput(4);
+		DigitalInput encB3 = new DigitalInput(5);
 		MotorEncoderFixture jagPair = new MotorEncoderFixture(jag, encA3, encB3);
 		return jagPair;
 	}
@@ -116,8 +116,8 @@ public final class TestBench {
 	 */
 	public MotorEncoderFixture getCanJaguarPair() {
 
-		DigitalInput encA4 = new DigitalInput(7);
-		DigitalInput encB4 = new DigitalInput(8);
+		DigitalInput encA4 = new DigitalInput(6);
+		DigitalInput encB4 = new DigitalInput(7);
 		MotorEncoderFixture canPair;
 		if (canJag == null) { // Again this is because the CanJaguar does not
 								// have a free method
@@ -138,12 +138,12 @@ public final class TestBench {
 	 * @return a freshly allocated Servo's and a freshly allocated Gyroscope
 	 */
 	public TiltPanCameraFixture getTiltPanCam() {
-		Gyro gyro = new Gyro(1);
+		Gyro gyro = new Gyro(0);
 		gyro.setSensitivity(.007); // If a different gyroscope is used this
 									// value will be different
 
-		Servo tilt = new Servo(10);
-		Servo pan = new Servo(9);
+		Servo tilt = new Servo(9);
+		Servo pan = new Servo(8);
 
 		TiltPanCameraFixture tpcam = new TiltPanCameraFixture(tilt, pan, gyro);
 
