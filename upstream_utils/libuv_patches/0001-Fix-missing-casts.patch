From bb42f9b81e12e52b5401c4afa879242b46615a4e Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Tue, 26 Apr 2022 15:01:25 -0400
Subject: [PATCH 1/6] Fix missing casts

---
 include/uv/unix.h           |  2 +-
 src/fs-poll.c               | 10 +++++-----
 src/inet.c                  | 11 +++++-----
 src/strscpy.c               |  2 +-
 src/threadpool.c            |  2 +-
 src/unix/android-ifaddrs.c  |  6 +++---
 src/unix/bsd-ifaddrs.c      |  2 +-
 src/unix/core.c             | 10 +++++-----
 src/unix/darwin-proctitle.c |  5 +++--
 src/unix/darwin.c           |  2 +-
 src/unix/freebsd.c          |  4 ++--
 src/unix/fs.c               | 18 ++++++++---------
 src/unix/fsevents.c         | 40 ++++++++++++++++++-------------------
 src/unix/getaddrinfo.c      |  8 ++++----
 src/unix/ibmi.c             |  2 +-
 src/unix/kqueue.c           |  6 +++---
 src/unix/linux-core.c       |  8 ++++----
 src/unix/linux-inotify.c    |  4 ++--
 src/unix/loop.c             |  2 +-
 src/unix/netbsd.c           |  4 ++--
 src/unix/openbsd.c          |  4 ++--
 src/unix/pipe.c             |  4 ++--
 src/unix/posix-poll.c       |  2 +-
 src/unix/process.c          |  2 +-
 src/unix/proctitle.c        |  2 +-
 src/unix/signal.c           |  1 +
 src/unix/stream.c           | 35 ++++++++++++++++----------------
 src/unix/thread.c           | 11 +++++-----
 src/unix/udp.c              |  4 ++--
 src/uv-common.c             | 16 +++++++--------
 src/win/core.c              |  8 +++++---
 src/win/fs-event.c          |  2 +-
 src/win/fs.c                | 20 +++++++++----------
 src/win/pipe.c              |  6 +++---
 src/win/process-stdio.c     |  2 +-
 src/win/process.c           | 15 +++++++-------
 src/win/thread.c            |  4 ++--
 src/win/tty.c               |  2 +-
 src/win/util.c              | 15 +++++++-------
 39 files changed, 155 insertions(+), 148 deletions(-)

diff --git a/include/uv/unix.h b/include/uv/unix.h
index 6c93ee97..a647593a 100644
--- a/include/uv/unix.h
+++ b/include/uv/unix.h
@@ -222,7 +222,7 @@ typedef struct {
   int backend_fd;                                                             \
   void* pending_queue[2];                                                     \
   void* watcher_queue[2];                                                     \
-  uv__io_t** watchers;                                                        \
+  void** watchers;                                                            \
   unsigned int nwatchers;                                                     \
   unsigned int nfds;                                                          \
   void* wq[2];                                                                \
diff --git a/src/fs-poll.c b/src/fs-poll.c
index 89864e23..f605bcea 100644
--- a/src/fs-poll.c
+++ b/src/fs-poll.c
@@ -77,7 +77,7 @@ int uv_fs_poll_start(uv_fs_poll_t* handle,
 
   loop = handle->loop;
   len = strlen(path);
-  ctx = uv__calloc(1, sizeof(*ctx) + len);
+  ctx = (struct poll_ctx*)uv__calloc(1, sizeof(*ctx) + len);
 
   if (ctx == NULL)
     return UV_ENOMEM;
@@ -101,7 +101,7 @@ int uv_fs_poll_start(uv_fs_poll_t* handle,
     goto error;
 
   if (handle->poll_ctx != NULL)
-    ctx->previous = handle->poll_ctx;
+    ctx->previous = (struct poll_ctx*)handle->poll_ctx;
   handle->poll_ctx = ctx;
   uv__handle_start(handle);
 
@@ -119,7 +119,7 @@ int uv_fs_poll_stop(uv_fs_poll_t* handle) {
   if (!uv_is_active((uv_handle_t*)handle))
     return 0;
 
-  ctx = handle->poll_ctx;
+  ctx = (struct poll_ctx*)handle->poll_ctx;
   assert(ctx != NULL);
   assert(ctx->parent_handle == handle);
 
@@ -144,7 +144,7 @@ int uv_fs_poll_getpath(uv_fs_poll_t* handle, char* buffer, size_t* size) {
     return UV_EINVAL;
   }
 
-  ctx = handle->poll_ctx;
+  ctx = (struct poll_ctx*)handle->poll_ctx;
   assert(ctx != NULL);
 
   required_len = strlen(ctx->path);
@@ -244,7 +244,7 @@ static void timer_close_cb(uv_handle_t* timer) {
     if (handle->poll_ctx == NULL && uv__is_closing(handle))
       uv__make_close_pending((uv_handle_t*)handle);
   } else {
-    for (last = handle->poll_ctx, it = last->previous;
+    for (last = (struct poll_ctx*)handle->poll_ctx, it = last->previous;
          it != ctx;
          last = it, it = it->previous) {
       assert(last->previous != NULL);
diff --git a/src/inet.c b/src/inet.c
index 698ab232..7e208b53 100644
--- a/src/inet.c
+++ b/src/inet.c
@@ -40,9 +40,9 @@ static int inet_pton6(const char *src, unsigned char *dst);
 int uv_inet_ntop(int af, const void* src, char* dst, size_t size) {
   switch (af) {
   case AF_INET:
-    return (inet_ntop4(src, dst, size));
+    return (inet_ntop4((const unsigned char*)src, dst, size));
   case AF_INET6:
-    return (inet_ntop6(src, dst, size));
+    return (inet_ntop6((const unsigned char*)src, dst, size));
   default:
     return UV_EAFNOSUPPORT;
   }
@@ -153,10 +153,11 @@ int uv_inet_pton(int af, const char* src, void* dst) {
 
   switch (af) {
   case AF_INET:
-    return (inet_pton4(src, dst));
+    return (inet_pton4(src, (unsigned char*)dst));
   case AF_INET6: {
     int len;
-    char tmp[UV__INET6_ADDRSTRLEN], *s, *p;
+    char tmp[UV__INET6_ADDRSTRLEN], *s;
+    const char *p;
     s = (char*) src;
     p = strchr(src, '%');
     if (p != NULL) {
@@ -167,7 +168,7 @@ int uv_inet_pton(int af, const char* src, void* dst) {
       memcpy(s, src, len);
       s[len] = '\0';
     }
-    return inet_pton6(s, dst);
+    return inet_pton6(s, (unsigned char*)dst);
   }
   default:
     return UV_EAFNOSUPPORT;
diff --git a/src/strscpy.c b/src/strscpy.c
index 2a2bdce7..4a9e8632 100644
--- a/src/strscpy.c
+++ b/src/strscpy.c
@@ -6,7 +6,7 @@ ssize_t uv__strscpy(char* d, const char* s, size_t n) {
 
   for (i = 0; i < n; i++)
     if ('\0' == (d[i] = s[i]))
-      return i > SSIZE_MAX ? UV_E2BIG : (ssize_t) i;
+      return i > SSIZE_MAX ? (ssize_t) UV_E2BIG : (ssize_t) i;
 
   if (i == 0)
     return 0;
diff --git a/src/threadpool.c b/src/threadpool.c
index 7aa57550..9cb863e7 100644
--- a/src/threadpool.c
+++ b/src/threadpool.c
@@ -201,7 +201,7 @@ static void init_threads(void) {
 
   threads = default_threads;
   if (nthreads > ARRAY_SIZE(default_threads)) {
-    threads = uv__malloc(nthreads * sizeof(threads[0]));
+    threads = (uv_thread_t*)uv__malloc(nthreads * sizeof(threads[0]));
     if (threads == NULL) {
       nthreads = ARRAY_SIZE(default_threads);
       threads = default_threads;
diff --git a/src/unix/android-ifaddrs.c b/src/unix/android-ifaddrs.c
index 99fb25a4..ab6b029d 100644
--- a/src/unix/android-ifaddrs.c
+++ b/src/unix/android-ifaddrs.c
@@ -191,7 +191,7 @@ static struct nlmsghdr *getNetlinkResponse(int p_socket, pid_t p_pid, int *p_siz
 
 static NetlinkList *newListItem(struct nlmsghdr *p_data, unsigned int p_size)
 {
-    NetlinkList *l_item = uv__malloc(sizeof(NetlinkList));
+    NetlinkList *l_item = (NetlinkList*)uv__malloc(sizeof(NetlinkList));
     if (l_item == NULL)
     {
         return NULL;
@@ -357,7 +357,7 @@ static int interpretLink(struct nlmsghdr *p_hdr, struct ifaddrs **p_resultList)
         }
     }
 
-    l_entry = uv__malloc(sizeof(struct ifaddrs) + sizeof(int) + l_nameSize + l_addrSize + l_dataSize);
+    l_entry = (struct ifaddrs*)uv__malloc(sizeof(struct ifaddrs) + sizeof(int) + l_nameSize + l_addrSize + l_dataSize);
     if (l_entry == NULL)
     {
         return -1;
@@ -486,7 +486,7 @@ static int interpretAddr(struct nlmsghdr *p_hdr, struct ifaddrs **p_resultList,
         }
     }
 
-    l_entry = uv__malloc(sizeof(struct ifaddrs) + l_nameSize + l_addrSize);
+    l_entry = (struct ifaddrs*)uv__malloc(sizeof(struct ifaddrs) + l_nameSize + l_addrSize);
     if (l_entry == NULL)
     {
         return -1;
diff --git a/src/unix/bsd-ifaddrs.c b/src/unix/bsd-ifaddrs.c
index 0d7bbe66..a01aa8d0 100644
--- a/src/unix/bsd-ifaddrs.c
+++ b/src/unix/bsd-ifaddrs.c
@@ -90,7 +90,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {
   }
 
   /* Make sure the memory is initiallized to zero using calloc() */
-  *addresses = uv__calloc(*count, sizeof(**addresses));
+  *addresses = (uv_interface_address_t*)uv__calloc(*count, sizeof(**addresses));
 
   if (*addresses == NULL) {
     freeifaddrs(addrs);
diff --git a/src/unix/core.c b/src/unix/core.c
index 202c75bb..ef98b6ce 100644
--- a/src/unix/core.c
+++ b/src/unix/core.c
@@ -823,7 +823,7 @@ static unsigned int next_power_of_two(unsigned int val) {
 }
 
 static void maybe_resize(uv_loop_t* loop, unsigned int len) {
-  uv__io_t** watchers;
+  void** watchers;
   void* fake_watcher_list;
   void* fake_watcher_count;
   unsigned int nwatchers;
@@ -842,8 +842,8 @@ static void maybe_resize(uv_loop_t* loop, unsigned int len) {
   }
 
   nwatchers = next_power_of_two(len + 2) - 2;
-  watchers = uv__realloc(loop->watchers,
-                         (nwatchers + 2) * sizeof(loop->watchers[0]));
+  watchers = (void**)
+      uv__realloc(loop->watchers, (nwatchers + 2) * sizeof(loop->watchers[0]));
 
   if (watchers == NULL)
     abort();
@@ -1202,7 +1202,7 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {
 
   for (;;) {
     uv__free(buf);
-    buf = uv__malloc(bufsize);
+    buf = (char*)uv__malloc(bufsize);
 
     if (buf == NULL)
       return UV_ENOMEM;
@@ -1229,7 +1229,7 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {
   name_size = strlen(pw.pw_name) + 1;
   homedir_size = strlen(pw.pw_dir) + 1;
   shell_size = strlen(pw.pw_shell) + 1;
-  pwd->username = uv__malloc(name_size + homedir_size + shell_size);
+  pwd->username = (char*)uv__malloc(name_size + homedir_size + shell_size);
 
   if (pwd->username == NULL) {
     uv__free(buf);
diff --git a/src/unix/darwin-proctitle.c b/src/unix/darwin-proctitle.c
index e505bdd2..f05d9f9f 100644
--- a/src/unix/darwin-proctitle.c
+++ b/src/unix/darwin-proctitle.c
@@ -131,8 +131,9 @@ void uv__set_process_title_platform_init(void) {
   if (pLSSetApplicationInformationItem == NULL)
     goto out;
 
-  display_name_key = pCFBundleGetDataPointerForName(launch_services_bundle,
-                                                    S("_kLSDisplayNameKey"));
+  display_name_key = (CFStringRef*)
+      pCFBundleGetDataPointerForName(launch_services_bundle,
+                                     S("_kLSDisplayNameKey"));
 
   if (display_name_key == NULL || *display_name_key == NULL)
     goto out;
diff --git a/src/unix/darwin.c b/src/unix/darwin.c
index e4cd8ff7..2282d916 100644
--- a/src/unix/darwin.c
+++ b/src/unix/darwin.c
@@ -199,7 +199,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
     return UV_EINVAL;  /* FIXME(bnoordhuis) Translate error. */
   }
 
-  *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));
+  *cpu_infos = (uv_cpu_info_t*)uv__malloc(numcpus * sizeof(**cpu_infos));
   if (!(*cpu_infos)) {
     vm_deallocate(mach_task_self(), (vm_address_t)info, msg_type);
     return UV_ENOMEM;
diff --git a/src/unix/freebsd.c b/src/unix/freebsd.c
index 7de88d6a..c401145c 100644
--- a/src/unix/freebsd.c
+++ b/src/unix/freebsd.c
@@ -241,7 +241,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
   if (sysctlbyname("hw.ncpu", &numcpus, &size, NULL, 0))
     return UV__ERR(errno);
 
-  *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));
+  *cpu_infos = (uv_cpu_info_t*)uv__malloc(numcpus * sizeof(**cpu_infos));
   if (!(*cpu_infos))
     return UV_ENOMEM;
 
@@ -258,7 +258,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
 
   size = maxcpus * CPUSTATES * sizeof(long);
 
-  cp_times = uv__malloc(size);
+  cp_times = (long*)uv__malloc(size);
   if (cp_times == NULL) {
     uv__free(*cpu_infos);
     return UV_ENOMEM;
diff --git a/src/unix/fs.c b/src/unix/fs.c
index 5138c619..36871eea 100644
--- a/src/unix/fs.c
+++ b/src/unix/fs.c
@@ -113,7 +113,7 @@ extern char *mkdtemp(char *template); /* See issue #740 on AIX < 7 */
       size_t new_path_len;                                                    \
       path_len = strlen(path) + 1;                                            \
       new_path_len = strlen(new_path) + 1;                                    \
-      req->path = uv__malloc(path_len + new_path_len);                        \
+      req->path = (char*)uv__malloc(path_len + new_path_len);                 \
       if (req->path == NULL)                                                  \
         return UV_ENOMEM;                                                     \
       req->new_path = req->path + path_len;                                   \
@@ -441,7 +441,7 @@ static ssize_t uv__fs_scandir(uv_fs_t* req) {
 static int uv__fs_opendir(uv_fs_t* req) {
   uv_dir_t* dir;
 
-  dir = uv__malloc(sizeof(*dir));
+  dir = (uv_dir_t*)uv__malloc(sizeof(*dir));
   if (dir == NULL)
     goto error;
 
@@ -465,7 +465,7 @@ static int uv__fs_readdir(uv_fs_t* req) {
   unsigned int dirent_idx;
   unsigned int i;
 
-  dir = req->ptr;
+  dir = (uv_dir_t*)req->ptr;
   dirent_idx = 0;
 
   while (dirent_idx < dir->nentries) {
@@ -507,7 +507,7 @@ error:
 static int uv__fs_closedir(uv_fs_t* req) {
   uv_dir_t* dir;
 
-  dir = req->ptr;
+  dir = (uv_dir_t*)req->ptr;
 
   if (dir->dir != NULL) {
     closedir(dir->dir);
@@ -558,7 +558,7 @@ static ssize_t uv__fs_readlink(uv_fs_t* req) {
     maxlen = uv__fs_pathmax_size(req->path);
 #endif
 
-  buf = uv__malloc(maxlen);
+  buf = (char*)uv__malloc(maxlen);
 
   if (buf == NULL) {
     errno = ENOMEM;
@@ -578,7 +578,7 @@ static ssize_t uv__fs_readlink(uv_fs_t* req) {
 
   /* Uncommon case: resize to make room for the trailing nul byte. */
   if (len == maxlen) {
-    newbuf = uv__realloc(buf, len + 1);
+    newbuf = (char*)uv__realloc(buf, len + 1);
 
     if (newbuf == NULL) {
       uv__free(buf);
@@ -605,7 +605,7 @@ static ssize_t uv__fs_realpath(uv_fs_t* req) {
   ssize_t len;
 
   len = uv__fs_pathmax_size(req->path);
-  buf = uv__malloc(len + 1);
+  buf = (char*)uv__malloc(len + 1);
 
   if (buf == NULL) {
     errno = ENOMEM;
@@ -1627,7 +1627,7 @@ int uv_fs_read(uv_loop_t* loop, uv_fs_t* req,
   req->nbufs = nbufs;
   req->bufs = req->bufsml;
   if (nbufs > ARRAY_SIZE(req->bufsml))
-    req->bufs = uv__malloc(nbufs * sizeof(*bufs));
+    req->bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(*bufs));
 
   if (req->bufs == NULL)
     return UV_ENOMEM;
@@ -1797,7 +1797,7 @@ int uv_fs_write(uv_loop_t* loop,
   req->nbufs = nbufs;
   req->bufs = req->bufsml;
   if (nbufs > ARRAY_SIZE(req->bufsml))
-    req->bufs = uv__malloc(nbufs * sizeof(*bufs));
+    req->bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(*bufs));
 
   if (req->bufs == NULL)
     return UV_ENOMEM;
diff --git a/src/unix/fsevents.c b/src/unix/fsevents.c
index ddacda31..32d280f4 100644
--- a/src/unix/fsevents.c
+++ b/src/unix/fsevents.c
@@ -186,7 +186,7 @@ static void (*pFSEventStreamStop)(FSEventStreamRef);
 static void uv__fsevents_cb(uv_async_t* cb) {
   uv_fs_event_t* handle;
 
-  handle = cb->data;
+  handle = (uv_fs_event_t*)cb->data;
 
   UV__FSEVENTS_PROCESS(handle, {
     handle->cb(handle, event->path[0] ? event->path : NULL, event->events, 0);
@@ -234,10 +234,10 @@ static void uv__fsevents_event_cb(ConstFSEventStreamRef streamRef,
   FSEventStreamEventFlags flags;
   QUEUE head;
 
-  loop = info;
-  state = loop->cf_state;
+  loop = (uv_loop_t*)info;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
   assert(state != NULL);
-  paths = eventPaths;
+  paths = (char**)eventPaths;
 
   /* For each handle */
   uv_mutex_lock(&state->fsevent_mutex);
@@ -305,7 +305,7 @@ static void uv__fsevents_event_cb(ConstFSEventStreamRef streamRef,
           continue;
       }
 
-      event = uv__malloc(sizeof(*event) + len);
+      event = (uv__fsevents_event_t*)uv__malloc(sizeof(*event) + len);
       if (event == NULL)
         break;
 
@@ -375,7 +375,7 @@ static int uv__fsevents_create_stream(uv_loop_t* loop, CFArrayRef paths) {
                              flags);
   assert(ref != NULL);
 
-  state = loop->cf_state;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
   pFSEventStreamScheduleWithRunLoop(ref,
                                     state->loop,
                                     *pkCFRunLoopDefaultMode);
@@ -394,7 +394,7 @@ static int uv__fsevents_create_stream(uv_loop_t* loop, CFArrayRef paths) {
 static void uv__fsevents_destroy_stream(uv_loop_t* loop) {
   uv__cf_loop_state_t* state;
 
-  state = loop->cf_state;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
 
   if (state->fsevent_stream == NULL)
     return;
@@ -421,7 +421,7 @@ static void uv__fsevents_reschedule(uv_fs_event_t* handle,
   int err;
   unsigned int path_count;
 
-  state = handle->loop->cf_state;
+  state = (uv__cf_loop_state_t*)handle->loop->cf_state;
   paths = NULL;
   cf_paths = NULL;
   err = 0;
@@ -449,7 +449,7 @@ static void uv__fsevents_reschedule(uv_fs_event_t* handle,
   uv_mutex_lock(&state->fsevent_mutex);
   path_count = state->fsevent_handle_count;
   if (path_count != 0) {
-    paths = uv__malloc(sizeof(*paths) * path_count);
+    paths = (CFStringRef*)uv__malloc(sizeof(*paths) * path_count);
     if (paths == NULL) {
       uv_mutex_unlock(&state->fsevent_mutex);
       goto final;
@@ -608,7 +608,7 @@ static int uv__fsevents_loop_init(uv_loop_t* loop) {
   if (err)
     return err;
 
-  state = uv__calloc(1, sizeof(*state));
+  state = (uv__cf_loop_state_t*)uv__calloc(1, sizeof(*state));
   if (state == NULL)
     return UV_ENOMEM;
 
@@ -716,7 +716,7 @@ void uv__fsevents_loop_delete(uv_loop_t* loop) {
   }
 
   /* Destroy state */
-  state = loop->cf_state;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
   uv_sem_destroy(&state->fsevent_sem);
   uv_mutex_destroy(&state->fsevent_mutex);
   pCFRelease(state->signal_source);
@@ -730,8 +730,8 @@ static void* uv__cf_loop_runner(void* arg) {
   uv_loop_t* loop;
   uv__cf_loop_state_t* state;
 
-  loop = arg;
-  state = loop->cf_state;
+  loop = (uv_loop_t*)arg;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
   state->loop = pCFRunLoopGetCurrent();
 
   pCFRunLoopAddSource(state->loop,
@@ -757,8 +757,8 @@ static void uv__cf_loop_cb(void* arg) {
   QUEUE split_head;
   uv__cf_loop_signal_t* s;
 
-  loop = arg;
-  state = loop->cf_state;
+  loop = (uv_loop_t*)arg;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
 
   uv_mutex_lock(&loop->cf_mutex);
   QUEUE_MOVE(&loop->cf_signals, &split_head);
@@ -788,7 +788,7 @@ int uv__cf_loop_signal(uv_loop_t* loop,
   uv__cf_loop_signal_t* item;
   uv__cf_loop_state_t* state;
 
-  item = uv__malloc(sizeof(*item));
+  item = (uv__cf_loop_signal_t*)uv__malloc(sizeof(*item));
   if (item == NULL)
     return UV_ENOMEM;
 
@@ -799,7 +799,7 @@ int uv__cf_loop_signal(uv_loop_t* loop,
   QUEUE_INSERT_TAIL(&loop->cf_signals, &item->member);
   uv_mutex_unlock(&loop->cf_mutex);
 
-  state = loop->cf_state;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
   assert(state != NULL);
   pCFRunLoopSourceSignal(state->signal_source);
   pCFRunLoopWakeUp(state->loop);
@@ -831,7 +831,7 @@ int uv__fsevents_init(uv_fs_event_t* handle) {
    * Events will occur in other thread.
    * Initialize callback for getting them back into event loop's thread
    */
-  handle->cf_cb = uv__malloc(sizeof(*handle->cf_cb));
+  handle->cf_cb = (uv_async_t*)uv__malloc(sizeof(*handle->cf_cb));
   if (handle->cf_cb == NULL) {
     err = UV_ENOMEM;
     goto fail_cf_cb_malloc;
@@ -847,7 +847,7 @@ int uv__fsevents_init(uv_fs_event_t* handle) {
     goto fail_cf_mutex_init;
 
   /* Insert handle into the list */
-  state = handle->loop->cf_state;
+  state = (uv__cf_loop_state_t*)handle->loop->cf_state;
   uv_mutex_lock(&state->fsevent_mutex);
   QUEUE_INSERT_TAIL(&state->fsevent_handles, &handle->cf_member);
   state->fsevent_handle_count++;
@@ -887,7 +887,7 @@ int uv__fsevents_close(uv_fs_event_t* handle) {
     return UV_EINVAL;
 
   /* Remove handle from  the list */
-  state = handle->loop->cf_state;
+  state = (uv__cf_loop_state_t*)handle->loop->cf_state;
   uv_mutex_lock(&state->fsevent_mutex);
   QUEUE_REMOVE(&handle->cf_member);
   state->fsevent_handle_count--;
diff --git a/src/unix/getaddrinfo.c b/src/unix/getaddrinfo.c
index d7ca7d1a..9a26b456 100644
--- a/src/unix/getaddrinfo.c
+++ b/src/unix/getaddrinfo.c
@@ -175,7 +175,7 @@ int uv_getaddrinfo(uv_loop_t* loop,
   hostname_len = hostname ? strlen(hostname) + 1 : 0;
   service_len = service ? strlen(service) + 1 : 0;
   hints_len = hints ? sizeof(*hints) : 0;
-  buf = uv__malloc(hostname_len + service_len + hints_len);
+  buf = (char*)uv__malloc(hostname_len + service_len + hints_len);
 
   if (buf == NULL)
     return UV_ENOMEM;
@@ -193,17 +193,17 @@ int uv_getaddrinfo(uv_loop_t* loop,
   len = 0;
 
   if (hints) {
-    req->hints = memcpy(buf + len, hints, sizeof(*hints));
+    req->hints = (struct addrinfo*)memcpy(buf + len, hints, sizeof(*hints));
     len += sizeof(*hints);
   }
 
   if (service) {
-    req->service = memcpy(buf + len, service, service_len);
+    req->service = (char*)memcpy(buf + len, service, service_len);
     len += service_len;
   }
 
   if (hostname)
-    req->hostname = memcpy(buf + len, hostname, hostname_len);
+    req->hostname = (char*)memcpy(buf + len, hostname, hostname_len);
 
   if (cb) {
     uv__work_submit(loop,
diff --git a/src/unix/ibmi.c b/src/unix/ibmi.c
index 8b355033..4b0be2df 100644
--- a/src/unix/ibmi.c
+++ b/src/unix/ibmi.c
@@ -227,7 +227,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
 
   numcpus = sysconf(_SC_NPROCESSORS_ONLN);
 
-  *cpu_infos = uv__malloc(numcpus * sizeof(uv_cpu_info_t));
+  *cpu_infos = (uv_cpu_info_t*)uv__malloc(numcpus * sizeof(uv_cpu_info_t));
   if (!*cpu_infos) {
     return UV_ENOMEM;
   }
diff --git a/src/unix/kqueue.c b/src/unix/kqueue.c
index c04e7a48..4c4268ba 100644
--- a/src/unix/kqueue.c
+++ b/src/unix/kqueue.c
@@ -250,15 +250,15 @@ void uv__io_poll(uv_loop_t* loop, int timeout) {
     nevents = 0;
 
     assert(loop->watchers != NULL);
-    loop->watchers[loop->nwatchers] = (void*) events;
-    loop->watchers[loop->nwatchers + 1] = (void*) (uintptr_t) nfds;
+    loop->watchers[loop->nwatchers] = (uv__io_t*) events;
+    loop->watchers[loop->nwatchers + 1] = (uv__io_t*) (uintptr_t) nfds;
     for (i = 0; i < nfds; i++) {
       ev = events + i;
       fd = ev->ident;
       /* Skip invalidated events, see uv__platform_invalidate_fd */
       if (fd == -1)
         continue;
-      w = loop->watchers[fd];
+      w = (uv__io_t*)loop->watchers[fd];
 
       if (w == NULL) {
         /* File descriptor that we've stopped watching, disarm it.
diff --git a/src/unix/linux-core.c b/src/unix/linux-core.c
index b539beb8..a66bb535 100644
--- a/src/unix/linux-core.c
+++ b/src/unix/linux-core.c
@@ -323,7 +323,7 @@ void uv__io_poll(uv_loop_t* loop, int timeout) {
     nevents = 0;
 
     assert(loop->watchers != NULL);
-    loop->watchers[loop->nwatchers] = (void*) events;
+    loop->watchers[loop->nwatchers] = events;
     loop->watchers[loop->nwatchers + 1] = (void*) (uintptr_t) nfds;
     for (i = 0; i < nfds; i++) {
       pe = events + i;
@@ -336,7 +336,7 @@ void uv__io_poll(uv_loop_t* loop, int timeout) {
       assert(fd >= 0);
       assert((unsigned) fd < loop->nwatchers);
 
-      w = loop->watchers[fd];
+      w = (uv__io_t*)loop->watchers[fd];
 
       if (w == NULL) {
         /* File descriptor that we've stopped watching, disarm it.
@@ -578,7 +578,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
     goto out;
 
   err = UV_ENOMEM;
-  ci = uv__calloc(numcpus, sizeof(*ci));
+  ci = (uv_cpu_info_t*)uv__calloc(numcpus, sizeof(*ci));
   if (ci == NULL)
     goto out;
 
@@ -867,7 +867,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {
   }
 
   /* Make sure the memory is initiallized to zero using calloc() */
-  *addresses = uv__calloc(*count, sizeof(**addresses));
+  *addresses = (uv_interface_address_t*)uv__calloc(*count, sizeof(**addresses));
   if (!(*addresses)) {
     freeifaddrs(addrs);
     return UV_ENOMEM;
diff --git a/src/unix/linux-inotify.c b/src/unix/linux-inotify.c
index 9b26202f..ed484ccb 100644
--- a/src/unix/linux-inotify.c
+++ b/src/unix/linux-inotify.c
@@ -308,12 +308,12 @@ int uv_fs_event_start(uv_fs_event_t* handle,
     goto no_insert;
 
   len = strlen(path) + 1;
-  w = uv__malloc(sizeof(*w) + len);
+  w = (watcher_list*)uv__malloc(sizeof(*w) + len);
   if (w == NULL)
     return UV_ENOMEM;
 
   w->wd = wd;
-  w->path = memcpy(w + 1, path, len);
+  w->path = (char*)memcpy(w + 1, path, len);
   QUEUE_INIT(&w->watchers);
   w->iterating = 0;
   RB_INSERT(watcher_root, CAST(&handle->loop->inotify_watchers), w);
diff --git a/src/unix/loop.c b/src/unix/loop.c
index c2a03d77..7a037d13 100644
--- a/src/unix/loop.c
+++ b/src/unix/loop.c
@@ -129,7 +129,7 @@ int uv_loop_fork(uv_loop_t* loop) {
 
   /* Rearm all the watchers that aren't re-queued by the above. */
   for (i = 0; i < loop->nwatchers; i++) {
-    w = loop->watchers[i];
+    w = (uv__io_t*)loop->watchers[i];
     if (w == NULL)
       continue;
 
diff --git a/src/unix/netbsd.c b/src/unix/netbsd.c
index c649bb37..fb89843a 100644
--- a/src/unix/netbsd.c
+++ b/src/unix/netbsd.c
@@ -206,14 +206,14 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
     cpuspeed = 0;
 
   size = numcpus * CPUSTATES * sizeof(*cp_times);
-  cp_times = uv__malloc(size);
+  cp_times = (u_int64_t*)uv__malloc(size);
   if (cp_times == NULL)
     return UV_ENOMEM;
 
   if (sysctlbyname("kern.cp_time", cp_times, &size, NULL, 0))
     return UV__ERR(errno);
 
-  *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));
+  *cpu_infos = (uv_cpu_info_t*)uv__malloc(numcpus * sizeof(**cpu_infos));
   if (!(*cpu_infos)) {
     uv__free(cp_times);
     uv__free(*cpu_infos);
diff --git a/src/unix/openbsd.c b/src/unix/openbsd.c
index ffae7683..f13ad8c8 100644
--- a/src/unix/openbsd.c
+++ b/src/unix/openbsd.c
@@ -73,7 +73,7 @@ int uv_exepath(char* buffer, size_t* size) {
   mypid = getpid();
   for (;;) {
     err = UV_ENOMEM;
-    argsbuf_tmp = uv__realloc(argsbuf, argsbuf_size);
+    argsbuf_tmp = (char**)uv__realloc(argsbuf, argsbuf_size);
     if (argsbuf_tmp == NULL)
       goto out;
     argsbuf = argsbuf_tmp;
@@ -198,7 +198,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
   if (sysctl(which, 2, &numcpus, &size, NULL, 0))
     return UV__ERR(errno);
 
-  *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));
+  *cpu_infos = (uv_cpu_info_t*)uv__malloc(numcpus * sizeof(**cpu_infos));
   if (!(*cpu_infos))
     return UV_ENOMEM;
 
diff --git a/src/unix/pipe.c b/src/unix/pipe.c
index 83476686..c21033a9 100644
--- a/src/unix/pipe.c
+++ b/src/unix/pipe.c
@@ -303,7 +303,7 @@ int uv_pipe_pending_count(uv_pipe_t* handle) {
   if (handle->queued_fds == NULL)
     return 1;
 
-  queued_fds = handle->queued_fds;
+  queued_fds = (uv__stream_queued_fds_t*)(handle->queued_fds);
   return queued_fds->offset + 1;
 }
 
@@ -340,7 +340,7 @@ int uv_pipe_chmod(uv_pipe_t* handle, int mode) {
   if (r != UV_ENOBUFS)
     return r;
 
-  name_buffer = uv__malloc(name_len);
+  name_buffer = (char*)uv__malloc(name_len);
   if (name_buffer == NULL)
     return UV_ENOMEM;
 
diff --git a/src/unix/posix-poll.c b/src/unix/posix-poll.c
index a3b9f219..b932f91f 100644
--- a/src/unix/posix-poll.c
+++ b/src/unix/posix-poll.c
@@ -61,7 +61,7 @@ static void uv__pollfds_maybe_resize(uv_loop_t* loop) {
     return;
 
   n = loop->poll_fds_size ? loop->poll_fds_size * 2 : 64;
-  p = uv__realloc(loop->poll_fds, n * sizeof(*loop->poll_fds));
+  p = (struct pollfd*)uv__realloc(loop->poll_fds, n * sizeof(*loop->poll_fds));
   if (p == NULL)
     abort();
 
diff --git a/src/unix/process.c b/src/unix/process.c
index bb6b76c9..87dac7fb 100644
--- a/src/unix/process.c
+++ b/src/unix/process.c
@@ -450,7 +450,7 @@ int uv_spawn(uv_loop_t* loop,
   err = UV_ENOMEM;
   pipes = pipes_storage;
   if (stdio_count > (int) ARRAY_SIZE(pipes_storage))
-    pipes = uv__malloc(stdio_count * sizeof(*pipes));
+    pipes = (int (*)[2])uv__malloc(stdio_count * sizeof(*pipes));
 
   if (pipes == NULL)
     goto error;
diff --git a/src/unix/proctitle.c b/src/unix/proctitle.c
index a5ce2030..b09808ff 100644
--- a/src/unix/proctitle.c
+++ b/src/unix/proctitle.c
@@ -72,7 +72,7 @@ char** uv_setup_args(int argc, char** argv) {
   /* Add space for the argv pointers. */
   size += (argc + 1) * sizeof(char*);
 
-  new_argv = uv__malloc(size);
+  new_argv = (char**)uv__malloc(size);
   if (new_argv == NULL)
     return argv;
   args_mem = new_argv;
diff --git a/src/unix/signal.c b/src/unix/signal.c
index 5e89ded2..ec2639a0 100644
--- a/src/unix/signal.c
+++ b/src/unix/signal.c
@@ -563,6 +563,7 @@ static void uv__signal_stop(uv_signal_t* handle) {
     if (first_oneshot && !rem_oneshot) {
       ret = uv__signal_register_handler(handle->signum, 1);
       assert(ret == 0);
+      (void) ret;
     }
   }
 
diff --git a/src/unix/stream.c b/src/unix/stream.c
index 17b06a39..f3a8e66d 100644
--- a/src/unix/stream.c
+++ b/src/unix/stream.c
@@ -126,7 +126,7 @@ static void uv__stream_osx_interrupt_select(uv_stream_t* stream) {
   uv__stream_select_t* s;
   int r;
 
-  s = stream->select;
+  s = (uv__stream_select_t*)stream->select;
   if (s == NULL)
     return;
 
@@ -155,8 +155,8 @@ static void uv__stream_osx_select(void* arg) {
   int r;
   int max_fd;
 
-  stream = arg;
-  s = stream->select;
+  stream = (uv_stream_t*)arg;
+  s = (uv__stream_select_t*)stream->select;
   fd = s->fd;
 
   if (fd > s->int_fd)
@@ -333,7 +333,7 @@ int uv__stream_try_select(uv_stream_t* stream, int* fd) {
   sread_sz = ROUND_UP(max_fd + 1, sizeof(uint32_t) * NBBY) / NBBY;
   swrite_sz = sread_sz;
 
-  s = uv__malloc(sizeof(*s) + sread_sz + swrite_sz);
+  s = (uv__stream_select_t*)uv__malloc(sizeof(*s) + sread_sz + swrite_sz);
   if (s == NULL) {
     err = UV_ENOMEM;
     goto failed_malloc;
@@ -628,7 +628,7 @@ done:
   if (server->queued_fds != NULL) {
     uv__stream_queued_fds_t* queued_fds;
 
-    queued_fds = server->queued_fds;
+    queued_fds = (uv__stream_queued_fds_t*)(server->queued_fds);
 
     /* Read first */
     server->accepted_fd = queued_fds->fds[0];
@@ -875,7 +875,7 @@ start:
     /* silence aliasing warning */
     {
       void* pv = CMSG_DATA(cmsg);
-      int* pi = pv;
+      int* pi = (int*)pv;
       *pi = fd_to_send;
     }
 
@@ -1013,11 +1013,12 @@ static int uv__stream_queue_fd(uv_stream_t* stream, int fd) {
   uv__stream_queued_fds_t* queued_fds;
   unsigned int queue_size;
 
-  queued_fds = stream->queued_fds;
+  queued_fds = (uv__stream_queued_fds_t*)stream->queued_fds;
   if (queued_fds == NULL) {
     queue_size = 8;
-    queued_fds = uv__malloc((queue_size - 1) * sizeof(*queued_fds->fds) +
-                            sizeof(*queued_fds));
+    queued_fds = (uv__stream_queued_fds_t*)
+        uv__malloc((queue_size - 1) * sizeof(*queued_fds->fds) +
+                   sizeof(*queued_fds));
     if (queued_fds == NULL)
       return UV_ENOMEM;
     queued_fds->size = queue_size;
@@ -1027,9 +1028,9 @@ static int uv__stream_queue_fd(uv_stream_t* stream, int fd) {
     /* Grow */
   } else if (queued_fds->size == queued_fds->offset) {
     queue_size = queued_fds->size + 8;
-    queued_fds = uv__realloc(queued_fds,
-                             (queue_size - 1) * sizeof(*queued_fds->fds) +
-                              sizeof(*queued_fds));
+    queued_fds = (uv__stream_queued_fds_t*)
+        uv__realloc(queued_fds, (queue_size - 1) * sizeof(*queued_fds->fds) +
+                    sizeof(*queued_fds));
 
     /*
      * Allocation failure, report back.
@@ -1072,7 +1073,7 @@ static int uv__stream_recv_cmsg(uv_stream_t* stream, struct msghdr* msg) {
 
     /* silence aliasing warning */
     pv = CMSG_DATA(cmsg);
-    pi = pv;
+    pi = (int*)pv;
 
     /* Count available fds */
     start = (char*) cmsg;
@@ -1443,7 +1444,7 @@ int uv_write2(uv_write_t* req,
 
   req->bufs = req->bufsml;
   if (nbufs > ARRAY_SIZE(req->bufsml))
-    req->bufs = uv__malloc(nbufs * sizeof(bufs[0]));
+    req->bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(bufs[0]));
 
   if (req->bufs == NULL)
     return UV_ENOMEM;
@@ -1616,7 +1617,7 @@ int uv___stream_fd(const uv_stream_t* handle) {
          handle->type == UV_TTY ||
          handle->type == UV_NAMED_PIPE);
 
-  s = handle->select;
+  s = (const uv__stream_select_t*)handle->select;
   if (s != NULL)
     return s->fd;
 
@@ -1634,7 +1635,7 @@ void uv__stream_close(uv_stream_t* handle) {
   if (handle->select != NULL) {
     uv__stream_select_t* s;
 
-    s = handle->select;
+    s = (uv__stream_select_t*)handle->select;
 
     uv_sem_post(&s->close_sem);
     uv_sem_post(&s->async_sem);
@@ -1669,7 +1670,7 @@ void uv__stream_close(uv_stream_t* handle) {
 
   /* Close all queued fds */
   if (handle->queued_fds != NULL) {
-    queued_fds = handle->queued_fds;
+    queued_fds = (uv__stream_queued_fds_t*)(handle->queued_fds);
     for (i = 0; i < queued_fds->offset; i++)
       uv__close(queued_fds->fds[i]);
     uv__free(handle->queued_fds);
diff --git a/src/unix/thread.c b/src/unix/thread.c
index f10c351e..c702d418 100644
--- a/src/unix/thread.c
+++ b/src/unix/thread.c
@@ -59,7 +59,7 @@ int uv_barrier_init(uv_barrier_t* barrier, unsigned int count) {
   if (barrier == NULL || count == 0)
     return UV_EINVAL;
 
-  b = uv__malloc(sizeof(*b));
+  b = (_uv_barrier*)uv__malloc(sizeof(*b));
   if (b == NULL)
     return UV_ENOMEM;
 
@@ -191,7 +191,7 @@ static size_t thread_stack_size(void) {
      * on the architecture.
      */
     if (lim.rlim_cur >= 8192)
-      if (lim.rlim_cur >= PTHREAD_STACK_MIN)
+      if (lim.rlim_cur >= (rlim_t) PTHREAD_STACK_MIN)
         return lim.rlim_cur;
   }
 #endif
@@ -239,7 +239,7 @@ int uv_thread_create_ex(uv_thread_t* tid,
     /* Round up to the nearest page boundary. */
     stack_size = (stack_size + pagesize - 1) &~ (pagesize - 1);
 #ifdef PTHREAD_STACK_MIN
-    if (stack_size < PTHREAD_STACK_MIN)
+    if (stack_size < (size_t) PTHREAD_STACK_MIN)
       stack_size = PTHREAD_STACK_MIN;
 #endif
   }
@@ -254,8 +254,7 @@ int uv_thread_create_ex(uv_thread_t* tid,
       abort();
   }
 
-  f.in = entry;
-  err = pthread_create(tid, attr, f.out, arg);
+  err = pthread_create(tid, attr, (void*(*)(void*)) (void(*)(void)) entry, arg);
 
   if (attr != NULL)
     pthread_attr_destroy(attr);
@@ -526,7 +525,7 @@ static int uv__custom_sem_init(uv_sem_t* sem_, unsigned int value) {
   int err;
   uv_semaphore_t* sem;
 
-  sem = uv__malloc(sizeof(*sem));
+  sem = (uv_semaphore_t*)uv__malloc(sizeof(*sem));
   if (sem == NULL)
     return UV_ENOMEM;
 
diff --git a/src/unix/udp.c b/src/unix/udp.c
index b578e7bc..5c03ae1b 100644
--- a/src/unix/udp.c
+++ b/src/unix/udp.c
@@ -178,7 +178,7 @@ static void uv__udp_recvmsg(uv_udp_t* handle) {
     assert(buf.base != NULL);
 
     h.msg_namelen = sizeof(peer);
-    h.msg_iov = (void*) &buf;
+    h.msg_iov = (iovec*) &buf;
     h.msg_iovlen = 1;
 
     do {
@@ -491,7 +491,7 @@ int uv__udp_send(uv_udp_send_t* req,
 
   req->bufs = req->bufsml;
   if (nbufs > ARRAY_SIZE(req->bufsml))
-    req->bufs = uv__malloc(nbufs * sizeof(bufs[0]));
+    req->bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(bufs[0]));
 
   if (req->bufs == NULL) {
     uv__req_unregister(handle->loop, req);
diff --git a/src/uv-common.c b/src/uv-common.c
index 066eb31d..47473346 100644
--- a/src/uv-common.c
+++ b/src/uv-common.c
@@ -54,10 +54,10 @@ static uv__allocator_t uv__allocator = {
 
 char* uv__strdup(const char* s) {
   size_t len = strlen(s) + 1;
-  char* m = uv__malloc(len);
+  char* m = (char*)uv__malloc(len);
   if (m == NULL)
     return NULL;
-  return memcpy(m, s, len);
+  return (char*)memcpy(m, s, len);
 }
 
 char* uv__strndup(const char* s, size_t n) {
@@ -65,11 +65,11 @@ char* uv__strndup(const char* s, size_t n) {
   size_t len = strlen(s);
   if (n < len)
     len = n;
-  m = uv__malloc(len + 1);
+  m = (char*)uv__malloc(len + 1);
   if (m == NULL)
     return NULL;
   m[len] = '\0';
-  return memcpy(m, s, len);
+  return (char*)memcpy(m, s, len);
 }
 
 void* uv__malloc(size_t size) {
@@ -593,7 +593,7 @@ void uv__fs_scandir_cleanup(uv_fs_t* req) {
 
   unsigned int* nbufs = uv__get_nbufs(req);
 
-  dents = req->ptr;
+  dents = (uv__dirent_t**)(req->ptr);
   if (*nbufs > 0 && *nbufs != (unsigned int) req->result)
     (*nbufs)--;
   for (; *nbufs < (unsigned int) req->result; (*nbufs)++)
@@ -620,7 +620,7 @@ int uv_fs_scandir_next(uv_fs_t* req, uv_dirent_t* ent) {
   nbufs = uv__get_nbufs(req);
   assert(nbufs);
 
-  dents = req->ptr;
+  dents = (uv__dirent_t**)(req->ptr);
 
   /* Free previous entity */
   if (*nbufs > 0)
@@ -685,7 +685,7 @@ void uv__fs_readdir_cleanup(uv_fs_t* req) {
   if (req->ptr == NULL)
     return;
 
-  dir = req->ptr;
+  dir = (uv_dir_t*)req->ptr;
   dirents = dir->dirents;
   req->ptr = NULL;
 
@@ -731,7 +731,7 @@ uv_loop_t* uv_default_loop(void) {
 uv_loop_t* uv_loop_new(void) {
   uv_loop_t* loop;
 
-  loop = uv__malloc(sizeof(*loop));
+  loop = (uv_loop_t*)uv__malloc(sizeof(*loop));
   if (loop == NULL)
     return NULL;
 
diff --git a/src/win/core.c b/src/win/core.c
index e9d0a581..1e162dd1 100644
--- a/src/win/core.c
+++ b/src/win/core.c
@@ -96,7 +96,8 @@ static int uv__loops_add(uv_loop_t* loop) {
 
   if (uv__loops_size == uv__loops_capacity) {
     new_capacity = uv__loops_capacity + UV__LOOPS_CHUNK_SIZE;
-    new_loops = uv__realloc(uv__loops, sizeof(uv_loop_t*) * new_capacity);
+    new_loops = (uv_loop_t**)
+        uv__realloc(uv__loops, sizeof(uv_loop_t*) * new_capacity);
     if (!new_loops)
       goto failed_loops_realloc;
     uv__loops = new_loops;
@@ -149,7 +150,8 @@ static void uv__loops_remove(uv_loop_t* loop) {
   smaller_capacity = uv__loops_capacity / 2;
   if (uv__loops_size >= smaller_capacity)
     goto loop_removed;
-  new_loops = uv__realloc(uv__loops, sizeof(uv_loop_t*) * smaller_capacity);
+  new_loops = (uv_loop_t**)
+      uv__realloc(uv__loops, sizeof(uv_loop_t*) * smaller_capacity);
   if (!new_loops)
     goto loop_removed;
   uv__loops = new_loops;
@@ -248,7 +250,7 @@ int uv_loop_init(uv_loop_t* loop) {
 
   loop->endgame_handles = NULL;
 
-  loop->timer_heap = timer_heap = uv__malloc(sizeof(*timer_heap));
+  loop->timer_heap = timer_heap = (heap*)uv__malloc(sizeof(*timer_heap));
   if (timer_heap == NULL) {
     err = UV_ENOMEM;
     goto fail_timers_alloc;
diff --git a/src/win/fs-event.c b/src/win/fs-event.c
index acf8e110..78741bfe 100644
--- a/src/win/fs-event.c
+++ b/src/win/fs-event.c
@@ -73,7 +73,7 @@ static void uv_relative_path(const WCHAR* filename,
   if (dirlen > 0 && dir[dirlen - 1] == '\\')
     dirlen--;
   relpathlen = filenamelen - dirlen - 1;
-  *relpath = uv__malloc((relpathlen + 1) * sizeof(WCHAR));
+  *relpath = (WCHAR*)uv__malloc((relpathlen + 1) * sizeof(WCHAR));
   if (!*relpath)
     uv_fatal_error(ERROR_OUTOFMEMORY, "uv__malloc");
   wcsncpy(*relpath, filename + dirlen + 1, relpathlen);
diff --git a/src/win/fs.c b/src/win/fs.c
index 7d78d466..dc0b8984 100644
--- a/src/win/fs.c
+++ b/src/win/fs.c
@@ -284,7 +284,7 @@ static int fs__wide_to_utf8(WCHAR* w_source_ptr,
     return 0;
   }
 
-  target = uv__malloc(target_len + 1);
+  target = (char*)uv__malloc(target_len + 1);
   if (target == NULL) {
     SetLastError(ERROR_OUTOFMEMORY);
     return -1;
@@ -1017,7 +1017,7 @@ void fs__scandir(uv_fs_t* req) {
       if (dirents_used >= dirents_size) {
         size_t new_dirents_size =
             dirents_size == 0 ? dirents_initial_size : dirents_size << 1;
-        uv__dirent_t** new_dirents =
+        uv__dirent_t** new_dirents = (uv__dirent_t**)
             uv__realloc(dirents, new_dirents_size * sizeof *dirents);
 
         if (new_dirents == NULL)
@@ -1031,7 +1031,7 @@ void fs__scandir(uv_fs_t* req) {
        * includes room for the first character of the filename, but `utf8_len`
        * doesn't count the NULL terminator at this point.
        */
-      dirent = uv__malloc(sizeof *dirent + utf8_len);
+      dirent = (uv__dirent_t*)uv__malloc(sizeof *dirent + utf8_len);
       if (dirent == NULL)
         goto out_of_memory_error;
 
@@ -1142,7 +1142,7 @@ void fs__opendir(uv_fs_t* req) {
     goto error;
   }
 
-  dir = uv__malloc(sizeof(*dir));
+  dir = (uv_dir_t*)uv__malloc(sizeof(*dir));
   if (dir == NULL) {
     SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
     goto error;
@@ -1157,7 +1157,7 @@ void fs__opendir(uv_fs_t* req) {
   else
     fmt = L"%s\\*";
 
-  find_path = uv__malloc(sizeof(WCHAR) * (len + 4));
+  find_path = (WCHAR*)uv__malloc(sizeof(WCHAR) * (len + 4));
   if (find_path == NULL) {
     SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
     goto error;
@@ -1194,7 +1194,7 @@ void fs__readdir(uv_fs_t* req) {
   int r;
 
   req->flags |= UV_FS_FREE_PTR;
-  dir = req->ptr;
+  dir = (uv_dir_t*)req->ptr;
   dirents = dir->dirents;
   memset(dirents, 0, dir->nentries * sizeof(*dir->dirents));
   find_data = &dir->find_data;
@@ -1251,7 +1251,7 @@ error:
 void fs__closedir(uv_fs_t* req) {
   uv_dir_t* dir;
 
-  dir = req->ptr;
+  dir = (uv_dir_t*)req->ptr;
   FindClose(dir->dir_handle);
   uv__free(req->ptr);
   SET_REQ_RESULT(req, 0);
@@ -2087,7 +2087,7 @@ static ssize_t fs__realpath_handle(HANDLE handle, char** realpath_ptr) {
     return -1;
   }
 
-  w_realpath_buf = uv__malloc((w_realpath_len + 1) * sizeof(WCHAR));
+  w_realpath_buf = (WCHAR*)uv__malloc((w_realpath_len + 1) * sizeof(WCHAR));
   if (w_realpath_buf == NULL) {
     SetLastError(ERROR_OUTOFMEMORY);
     return -1;
@@ -2299,7 +2299,7 @@ int uv_fs_read(uv_loop_t* loop,
   req->fs.info.nbufs = nbufs;
   req->fs.info.bufs = req->fs.info.bufsml;
   if (nbufs > ARRAY_SIZE(req->fs.info.bufsml))
-    req->fs.info.bufs = uv__malloc(nbufs * sizeof(*bufs));
+    req->fs.info.bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(*bufs));
 
   if (req->fs.info.bufs == NULL)
     return UV_ENOMEM;
@@ -2328,7 +2328,7 @@ int uv_fs_write(uv_loop_t* loop,
   req->fs.info.nbufs = nbufs;
   req->fs.info.bufs = req->fs.info.bufsml;
   if (nbufs > ARRAY_SIZE(req->fs.info.bufsml))
-    req->fs.info.bufs = uv__malloc(nbufs * sizeof(*bufs));
+    req->fs.info.bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(*bufs));
 
   if (req->fs.info.bufs == NULL)
     return UV_ENOMEM;
diff --git a/src/win/pipe.c b/src/win/pipe.c
index 277f6497..138f9ed6 100644
--- a/src/win/pipe.c
+++ b/src/win/pipe.c
@@ -1277,7 +1277,7 @@ static int uv__build_coalesced_write_req(uv_write_t* user_req,
                        data_length;                  /* (c) */
 
   /* Allocate buffer. */
-  heap_buffer = uv__malloc(heap_buffer_length);
+  heap_buffer = (char*)uv__malloc(heap_buffer_length);
   if (heap_buffer == NULL)
     return ERROR_NOT_ENOUGH_MEMORY; /* Maps to UV_ENOMEM. */
 
@@ -1519,7 +1519,7 @@ int uv__pipe_write_ipc(uv_loop_t* loop,
     bufs = stack_bufs;
   } else {
     /* Use heap-allocated buffer array. */
-    bufs = uv__calloc(buf_count, sizeof(uv_buf_t));
+    bufs = (uv_buf_t*)uv__calloc(buf_count, sizeof(uv_buf_t));
     if (bufs == NULL)
       return ERROR_NOT_ENOUGH_MEMORY; /* Maps to UV_ENOMEM. */
   }
@@ -2180,7 +2180,7 @@ static int uv__pipe_getname(const uv_pipe_t* handle, char* buffer, size_t* size)
                                       FileNameInformation);
   if (nt_status == STATUS_BUFFER_OVERFLOW) {
     name_size = sizeof(*name_info) + tmp_name_info.FileNameLength;
-    name_info = uv__malloc(name_size);
+    name_info = (FILE_NAME_INFORMATION*)uv__malloc(name_size);
     if (!name_info) {
       *size = 0;
       err = UV_ENOMEM;
diff --git a/src/win/process-stdio.c b/src/win/process-stdio.c
index 355d6188..47019388 100644
--- a/src/win/process-stdio.c
+++ b/src/win/process-stdio.c
@@ -103,7 +103,7 @@ static int uv__create_stdio_pipe_pair(uv_loop_t* loop,
   DWORD client_access = 0;
   HANDLE child_pipe = INVALID_HANDLE_VALUE;
   int err;
-  int overlap;
+  BOOL overlap;
 
   if (flags & UV_READABLE_PIPE) {
     /* The server needs inbound access too, otherwise CreateNamedPipe() won't
diff --git a/src/win/process.c b/src/win/process.c
index f9c53de0..f3c9a43e 100644
--- a/src/win/process.c
+++ b/src/win/process.c
@@ -615,8 +615,8 @@ error:
 
 
 int env_strncmp(const wchar_t* a, int na, const wchar_t* b) {
-  wchar_t* a_eq;
-  wchar_t* b_eq;
+  const wchar_t* a_eq;
+  const wchar_t* b_eq;
   wchar_t* A;
   wchar_t* B;
   int nb;
@@ -633,8 +633,8 @@ int env_strncmp(const wchar_t* a, int na, const wchar_t* b) {
   assert(b_eq);
   nb = b_eq - b;
 
-  A = alloca((na+1) * sizeof(wchar_t));
-  B = alloca((nb+1) * sizeof(wchar_t));
+  A = (wchar_t*)alloca((na+1) * sizeof(wchar_t));
+  B = (wchar_t*)alloca((nb+1) * sizeof(wchar_t));
 
   r = LCMapStringW(LOCALE_INVARIANT, LCMAP_UPPERCASE, a, na, A, na);
   assert(r==na);
@@ -692,7 +692,8 @@ int make_program_env(char* env_block[], WCHAR** dst_ptr) {
   WCHAR* dst_copy;
   WCHAR** ptr_copy;
   WCHAR** env_copy;
-  DWORD* required_vars_value_len = alloca(n_required_vars * sizeof(DWORD*));
+  DWORD* required_vars_value_len =
+      (DWORD*)alloca(n_required_vars * sizeof(DWORD*));
 
   /* first pass: determine size in UTF-16 */
   for (env = env_block; *env; env++) {
@@ -717,7 +718,7 @@ int make_program_env(char* env_block[], WCHAR** dst_ptr) {
   if (!dst_copy) {
     return ERROR_OUTOFMEMORY;
   }
-  env_copy = alloca(env_block_count * sizeof(WCHAR*));
+  env_copy = (WCHAR**)alloca(env_block_count * sizeof(WCHAR*));
 
   ptr = dst_copy;
   ptr_copy = env_copy;
@@ -771,7 +772,7 @@ int make_program_env(char* env_block[], WCHAR** dst_ptr) {
   }
 
   /* final pass: copy, in sort order, and inserting required variables */
-  dst = uv__malloc((1+env_len) * sizeof(WCHAR));
+  dst = (WCHAR*)uv__malloc((1+env_len) * sizeof(WCHAR));
   if (!dst) {
     uv__free(dst_copy);
     return ERROR_OUTOFMEMORY;
diff --git a/src/win/thread.c b/src/win/thread.c
index 89c53ada..72af03c6 100644
--- a/src/win/thread.c
+++ b/src/win/thread.c
@@ -98,7 +98,7 @@ static UINT __stdcall uv__thread_start(void* arg) {
   struct thread_ctx *ctx_p;
   struct thread_ctx ctx;
 
-  ctx_p = arg;
+  ctx_p = (struct thread_ctx*)arg;
   ctx = *ctx_p;
   uv__free(ctx_p);
 
@@ -141,7 +141,7 @@ int uv_thread_create_ex(uv_thread_t* tid,
       return UV_EINVAL;
   }
 
-  ctx = uv__malloc(sizeof(*ctx));
+  ctx = (struct thread_ctx*)uv__malloc(sizeof(*ctx));
   if (ctx == NULL)
     return UV_ENOMEM;
 
diff --git a/src/win/tty.c b/src/win/tty.c
index a98fe263..a5d58bf7 100644
--- a/src/win/tty.c
+++ b/src/win/tty.c
@@ -1675,7 +1675,7 @@ static int uv_tty_write_bufs(uv_tty_t* handle,
       max_len = (utf16_buf_used + 1) * sizeof(WCHAR);
       allocate = max_len > MAX_CONSOLE_CHAR;
       if (allocate)
-        utf16_buffer = uv__malloc(max_len);
+        utf16_buffer = (WCHAR*)uv__malloc(max_len);
       if (!MultiByteToWideChar(CP_UTF8,
                                0,
                                buf.base,
diff --git a/src/win/util.c b/src/win/util.c
index 7ca83213..d1cd19ba 100644
--- a/src/win/util.c
+++ b/src/win/util.c
@@ -616,14 +616,14 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos_ptr, int* cpu_count_ptr) {
   GetSystemInfo(&system_info);
   cpu_count = system_info.dwNumberOfProcessors;
 
-  cpu_infos = uv__calloc(cpu_count, sizeof *cpu_infos);
+  cpu_infos = (uv_cpu_info_t*)uv__calloc(cpu_count, sizeof *cpu_infos);
   if (cpu_infos == NULL) {
     err = ERROR_OUTOFMEMORY;
     goto error;
   }
 
   sppi_size = cpu_count * sizeof(*sppi);
-  sppi = uv__malloc(sppi_size);
+  sppi = (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION*)uv__malloc(sppi_size);
   if (sppi == NULL) {
     err = ERROR_OUTOFMEMORY;
     goto error;
@@ -856,7 +856,8 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,
       case ERROR_BUFFER_OVERFLOW:
         /* This happens when win_address_buf is NULL or too small to hold all
          * adapters. */
-        win_address_buf = uv__malloc(win_address_buf_size);
+        win_address_buf =
+            (IP_ADAPTER_ADDRESSES*)uv__malloc(win_address_buf_size);
         if (win_address_buf == NULL)
           return UV_ENOMEM;
 
@@ -864,7 +865,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,
 
       case ERROR_NO_DATA: {
         /* No adapters were found. */
-        uv_address_buf = uv__malloc(1);
+        uv_address_buf = (uv_interface_address_t*)uv__malloc(1);
         if (uv_address_buf == NULL)
           return UV_ENOMEM;
 
@@ -941,7 +942,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,
   }
 
   /* Allocate space to store interface data plus adapter names. */
-  uv_address_buf = uv__malloc(uv_address_buf_size);
+  uv_address_buf = (uv_interface_address_t*)uv__malloc(uv_address_buf_size);
   if (uv_address_buf == NULL) {
     uv__free(win_address_buf);
     return UV_ENOMEM;
@@ -1263,7 +1264,7 @@ int uv__convert_utf16_to_utf8(const WCHAR* utf16, int utf16len, char** utf8) {
   /* Allocate the destination buffer adding an extra byte for the terminating
    * NULL. If utf16len is not -1 WideCharToMultiByte will not add it, so
    * we do it ourselves always, just in case. */
-  *utf8 = uv__malloc(bufsize + 1);
+  *utf8 = (char*)uv__malloc(bufsize + 1);
 
   if (*utf8 == NULL)
     return UV_ENOMEM;
@@ -1311,7 +1312,7 @@ int uv__convert_utf8_to_utf16(const char* utf8, int utf8len, WCHAR** utf16) {
   /* Allocate the destination buffer adding an extra byte for the terminating
    * NULL. If utf8len is not -1 MultiByteToWideChar will not add it, so
    * we do it ourselves always, just in case. */
-  *utf16 = uv__malloc(sizeof(WCHAR) * (bufsize + 1));
+  *utf16 = (WCHAR*)uv__malloc(sizeof(WCHAR) * (bufsize + 1));
 
   if (*utf16 == NULL)
     return UV_ENOMEM;
-- 
2.20.1.windows.1

