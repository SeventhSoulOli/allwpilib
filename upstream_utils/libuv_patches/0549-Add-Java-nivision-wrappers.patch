From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Peter Johnson <johnson.peter@gmail.com>
Date: Tue, 9 Dec 2014 00:48:57 -0800
Subject: [PATCH 0549/6262] Add Java nivision wrappers.

Only very basic testing performed to date.

The wrappers are still a bit incomplete (some structures and functions),
but are much more complete than the old ones.

Fixes artf3796.

Changes from initial changeset:
- Use // for comments.
- Add auto-generate notices to the beginning of each generated file.
- Include error number with error text in exception.
- Add free() function to structures.
- Fix out-of-order / non-array enums.
- Avoid duplicate calls to DisposedStruct.write() as .getAddress() does it.
- Refactor OpaqueStruct.
- Default to no null allowed except when overridden.
- Implement unowned return values.
- Add gen_struct_sizer script.

Change-Id: Ie0d102c45817ea8812d98fe4938d1a2255c61664
---
 .gitignore                                    |     6 +
 .../src/main/java/com/ni/vision/NIVision.java | 24555 ++++++++++++++++
 .../java/com/ni/vision/VisionException.java   |    20 +
 wpilibj/wpilibJavaJNI/lib/NIVisionJNI.cpp     |  4717 +++
 wpilibj/wpilibJavaJNI/nivision/gen_java.py    |  1670 ++
 .../nivision/gen_struct_sizer.py              |   113 +
 wpilibj/wpilibJavaJNI/nivision/generateJNI.sh |    12 +
 .../wpilibJavaJNI/nivision/nivision_2011.ini  |   821 +
 .../wpilibJavaJNI/nivision/nivision_arm.ini   |  1863 ++
 .../wpilibJavaJNI/nivision/nivision_parse.py  |   220 +
 10 files changed, 33997 insertions(+)
 create mode 100644 wpilibj/wpilibJavaDevices/src/main/java/com/ni/vision/NIVision.java
 create mode 100644 wpilibj/wpilibJavaDevices/src/main/java/com/ni/vision/VisionException.java
 create mode 100644 wpilibj/wpilibJavaJNI/lib/NIVisionJNI.cpp
 create mode 100644 wpilibj/wpilibJavaJNI/nivision/gen_java.py
 create mode 100644 wpilibj/wpilibJavaJNI/nivision/gen_struct_sizer.py
 create mode 100755 wpilibj/wpilibJavaJNI/nivision/generateJNI.sh
 create mode 100644 wpilibj/wpilibJavaJNI/nivision/nivision_2011.ini
 create mode 100644 wpilibj/wpilibJavaJNI/nivision/nivision_arm.ini
 create mode 100644 wpilibj/wpilibJavaJNI/nivision/nivision_parse.py

diff --git a/.gitignore b/.gitignore
index b79f6c2f8cd092311bd99e8a9effc5d7d9ea4b54..4919c92565b701c1aafa748ded32b26792bc8446 100644
--- a/.gitignore
+++ b/.gitignore
@@ -10,6 +10,8 @@ bin/
 .project
 .classpath
 **/dependency-reduced-pom.xml
+wpilibj/wpilibJavaJNI/nivision/*.c
+wpilibj/wpilibJavaJNI/nivision/*.java
 
 # Created by the jenkins test script
 test-reports
@@ -155,6 +157,10 @@ local.properties
 .settings/
 .loadpath
 
+### Python ###
+*.pyc
+__pycache__
+
 # External tool builders
 .externalToolBuilders/
 
diff --git a/wpilibj/wpilibJavaDevices/src/main/java/com/ni/vision/NIVision.java b/wpilibj/wpilibJavaDevices/src/main/java/com/ni/vision/NIVision.java
new file mode 100644
index 0000000000000000000000000000000000000000..bc549d0d0a7ac111e8fadea4bed740f0421196fd
--- /dev/null
+++ b/wpilibj/wpilibJavaDevices/src/main/java/com/ni/vision/NIVision.java
@@ -0,0 +1,24555 @@
+//
+// This file is auto-generated by wpilibj/wpilibJavaJNI/nivision/gen_java.py
+// Please do not edit!
+//
+
+package com.ni.vision;
+
+import java.lang.reflect.*;
+import java.io.UnsupportedEncodingException;
+import java.nio.Buffer;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+
+public class NIVision {
+    private NIVision() {}
+
+    private static native void imaqDispose(long addr);
+
+    private static Constructor<?> constructDirectByteBuffer;
+    private static Field bufferAddressField;
+
+    static {
+        try {
+            Class<?>[] cArg = new Class[2];
+            cArg[0] = long.class;
+            cArg[1] = int.class;
+            constructDirectByteBuffer = Class.forName("java.nio.DirectByteBuffer").getDeclaredConstructor(cArg);
+            constructDirectByteBuffer.setAccessible(true);
+
+            bufferAddressField = Buffer.class.getDeclaredField("address");
+            bufferAddressField.setAccessible(true);
+        } catch (ReflectiveOperationException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
+    private static ByteBuffer newDirectByteBuffer(long addr, int cap) {
+        try {
+            return ((ByteBuffer)(constructDirectByteBuffer.newInstance(addr, cap))).order(ByteOrder.nativeOrder());
+        } catch (ReflectiveOperationException e) {
+            throw new ExceptionInInitializerError(e);
+        }
+    }
+
+    private static long getByteBufferAddress(ByteBuffer bb) {
+        try {
+            return bufferAddressField.getLong(bb);
+        } catch (IllegalAccessException e) {
+            return 0;
+        }
+    }
+
+    public static ByteBuffer sliceByteBuffer(ByteBuffer bb, int offset, int size) {
+        ByteBuffer new_bb = bb.duplicate();
+        new_bb.position(offset);
+        new_bb.limit(size);
+        return new_bb;
+    }
+
+    public static ByteBuffer getBytes(ByteBuffer bb, byte[] dst, int offset, int size) {
+        for (int i=offset; i<offset+size; i++)
+            dst[i] = bb.get(i);
+        return bb;
+    }
+
+    public static ByteBuffer putBytes(ByteBuffer bb, byte[] src, int offset, int size) {
+        for (int i=offset; i<offset+size; i++)
+            bb.put(i, src[i]);
+        return bb;
+    }
+
+    private static abstract class DisposedStruct {
+        protected ByteBuffer backing;
+        private boolean owned;
+        protected DisposedStruct(int size) {
+            backing = ByteBuffer.allocateDirect(size);
+            backing.order(ByteOrder.nativeOrder());
+            owned = false;
+        }
+        protected DisposedStruct(ByteBuffer backing, int offset, int size) {
+            this.backing = sliceByteBuffer(backing, offset, size);
+            owned = false;
+        }
+        private DisposedStruct(long nativeObj, boolean owned, int size) {
+            backing = newDirectByteBuffer(nativeObj, size);
+            this.owned = owned;
+        }
+        public void free() {
+            if (owned) {
+                imaqDispose(getByteBufferAddress(backing));
+                owned = false;
+                backing = null;
+            }
+        }
+        @Override
+        protected void finalize() throws Throwable {
+            if (owned)
+                imaqDispose(getByteBufferAddress(backing));
+            super.finalize();
+        }
+        public long getAddress() {
+            if (backing == null)
+                return 0;
+            write();
+            return getByteBufferAddress(backing);
+        }
+        protected void setBuffer(ByteBuffer backing, int offset, int size) {
+            this.backing = sliceByteBuffer(backing, offset, size);
+        }
+
+        abstract public void read();
+        abstract public void write();
+        abstract public int size();
+    }
+
+    private static abstract class OpaqueStruct {
+        private long nativeObj;
+        private boolean owned;
+        private OpaqueStruct() {
+            this.nativeObj = 0;
+            this.owned = false;
+        }
+        private OpaqueStruct(long nativeObj, boolean owned) {
+            this.nativeObj = nativeObj;
+            this.owned = owned;
+        }
+        public void free() {
+            if (owned && nativeObj != 0) {
+                imaqDispose(nativeObj);
+                owned = false;
+                nativeObj = 0;
+            }
+        }
+        @Override
+        protected void finalize() throws Throwable {
+            if (owned && nativeObj != 0)
+                imaqDispose(nativeObj);
+            super.finalize();
+        }
+        public long getAddress() {
+            return nativeObj;
+        }
+    }
+
+    private static long getPointer(ByteBuffer bb, int offset) {
+        return (long)bb.getInt(offset);
+    }
+    private static void putPointer(ByteBuffer bb, int offset, long address) {
+        bb.putInt(offset, (int)address);
+    }
+    private static void putPointer(ByteBuffer bb, int offset, ByteBuffer buf) {
+        if (buf == null)
+            bb.putInt(offset, 0);
+        else
+            bb.putInt(offset, (int)getByteBufferAddress(buf));
+    }
+    private static void putPointer(ByteBuffer bb, int offset, DisposedStruct struct) {
+        if (struct == null)
+            bb.putInt(offset, 0);
+        else
+            bb.putInt(offset, (int)struct.getAddress());
+    }
+    private static void putPointer(ByteBuffer bb, int offset, OpaqueStruct struct) {
+        if (struct == null)
+            bb.putInt(offset, 0);
+        else
+            bb.putInt(offset, (int)struct.getAddress());
+    }
+
+    /**
+     * Opaque Structures
+     */
+
+    public static class CharSet extends OpaqueStruct {
+        private CharSet() {}
+        private CharSet(long nativeObj, boolean owned) {
+            super(nativeObj, owned);
+        }
+    }
+
+    public static class ClassifierSession extends OpaqueStruct {
+        private ClassifierSession() {}
+        private ClassifierSession(long nativeObj, boolean owned) {
+            super(nativeObj, owned);
+        }
+    }
+
+    public static class Image extends OpaqueStruct {
+        private Image() {}
+        private Image(long nativeObj, boolean owned) {
+            super(nativeObj, owned);
+        }
+    }
+
+    public static class MultipleGeometricPattern extends OpaqueStruct {
+        private MultipleGeometricPattern() {}
+        private MultipleGeometricPattern(long nativeObj, boolean owned) {
+            super(nativeObj, owned);
+        }
+    }
+
+    public static class Overlay extends OpaqueStruct {
+        private Overlay() {}
+        private Overlay(long nativeObj, boolean owned) {
+            super(nativeObj, owned);
+        }
+    }
+
+    public static class ROI extends OpaqueStruct {
+        private ROI() {}
+        private ROI(long nativeObj, boolean owned) {
+            super(nativeObj, owned);
+        }
+    }
+
+    /**
+     * Manifest Constants
+     */
+    public static final boolean DEFAULT_SHOW_COORDINATES = true;
+    public static final int DEFAULT_MAX_ICONS_PER_LINE = 4;
+    public static final boolean DEFAULT_BMP_COMPRESS = false;
+    public static final int DEFAULT_PNG_QUALITY = 750;
+    public static final int DEFAULT_JPEG_QUALITY = 750;
+    public static final int ALL_CONTOURS = -1;
+    public static final int ALL_WINDOWS = -1;
+    public static final int SHIFT = 1;
+    public static final int ALT = 2;
+    public static final int CTRL = 4;
+    public static final int CAPS_LOCK = 8;
+    public static final int MODAL_DIALOG = -1;
+    public static final int USE_DEFAULT_QUALITY = -1;
+    public static final int ALL_SAMPLES = -1;
+    public static final int ALL_OBJECTS = -1;
+    public static final int ALL_CHARACTERS = -1;
+
+    /**
+     * Predefined Valid Characters
+     */
+    public static final byte[] ANY_CHARACTER = { 0 };
+    public static final byte[] ALPHABETIC = { 0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0 };
+    public static final byte[] ALPHANUMERIC = { 0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0 };
+    public static final byte[] UPPERCASE_LETTERS = { 0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0 };
+    public static final byte[] LOWERCASE_LETTERS = { 0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0 };
+    public static final byte[] DECIMAL_DIGITS = { 0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0 };
+    public static final byte[] HEXADECIMAL_DIGITS = { 0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x41,0x42,0x43,0x44,0x45,0x46,0x61,0x62,0x63,0x64,0x65,0x66,0 };
+    public static final byte[] PATTERN = { 0x5c,0x78,0x46,0x46,0 };
+    public static final byte[] FORCE_SPACE = { 0x20,0 };
+
+    /**
+     * Enumerated Types
+     */
+
+    public static enum PointSymbol {
+        POINT_AS_PIXEL(0), // A single pixel represents a point in the overlay.
+        POINT_AS_CROSS(1), // A cross represents a point in the overlay.
+        POINT_USER_DEFINED(2), // The pattern supplied by the user represents a point in the overlay.
+        ;
+        private final int value;
+        private PointSymbol(int value) {
+            this.value = value;
+        }
+        public static PointSymbol fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum MeasurementValue {
+        AREA(0), // Surface area of the particle in pixels.
+        AREA_CALIBRATED(1), // Surface area of the particle in calibrated units.
+        NUM_HOLES(2), // Number of holes in the particle.
+        AREA_OF_HOLES(3), // Surface area of the holes in calibrated units.
+        TOTAL_AREA(4), // Total surface area (holes and particle) in calibrated units.
+        IMAGE_AREA(5), // Surface area of the entire image in calibrated units.
+        PARTICLE_TO_IMAGE(6), // Ratio, expressed as a percentage, of the surface area of a particle in relation to the total area of the particle.
+        PARTICLE_TO_TOTAL(7), // Ratio, expressed as a percentage, of the surface area of a particle in relation to the total area of the particle.
+        CENTER_MASS_X(8), // X-coordinate of the center of mass.
+        CENTER_MASS_Y(9), // Y-coordinate of the center of mass.
+        LEFT_COLUMN(10), // Left edge of the bounding rectangle.
+        TOP_ROW(11), // Top edge of the bounding rectangle.
+        RIGHT_COLUMN(12), // Right edge of the bounding rectangle.
+        BOTTOM_ROW(13), // Bottom edge of bounding rectangle.
+        WIDTH(14), // Width of bounding rectangle in calibrated units.
+        HEIGHT(15), // Height of bounding rectangle in calibrated units.
+        MAX_SEGMENT_LENGTH(16), // Length of longest horizontal line segment.
+        MAX_SEGMENT_LEFT_COLUMN(17), // Leftmost x-coordinate of longest horizontal line segment.
+        MAX_SEGMENT_TOP_ROW(18), // Y-coordinate of longest horizontal line segment.
+        PERIMETER(19), // Outer perimeter of the particle.
+        PERIMETER_OF_HOLES(20), // Perimeter of all holes within the particle.
+        SIGMA_X(21), // Sum of the particle pixels on the x-axis.
+        SIGMA_Y(22), // Sum of the particle pixels on the y-axis.
+        SIGMA_XX(23), // Sum of the particle pixels on the x-axis squared.
+        SIGMA_YY(24), // Sum of the particle pixels on the y-axis squared.
+        SIGMA_XY(25), // Sum of the particle pixels on the x-axis and y-axis.
+        PROJ_X(26), // Projection corrected in X.
+        PROJ_Y(27), // Projection corrected in Y.
+        INERTIA_XX(28), // Inertia matrix coefficient in XX.
+        INERTIA_YY(29), // Inertia matrix coefficient in YY.
+        INERTIA_XY(30), // Inertia matrix coefficient in XY.
+        MEAN_H(31), // Mean length of horizontal segments.
+        MEAN_V(32), // Mean length of vertical segments.
+        MAX_INTERCEPT(33), // Length of longest segment of the convex hull.
+        MEAN_INTERCEPT(34), // Mean length of the chords in an object perpendicular to its max intercept.
+        ORIENTATION(35), // The orientation based on the inertia of the pixels in the particle.
+        EQUIV_ELLIPSE_MINOR(36), // Total length of the axis of the ellipse having the same area as the particle and a major axis equal to half the max intercept.
+        ELLIPSE_MAJOR(37), // Total length of major axis having the same area and perimeter as the particle in calibrated units.
+        ELLIPSE_MINOR(38), // Total length of minor axis having the same area and perimeter as the particle in calibrated units.
+        ELLIPSE_RATIO(39), // Fraction of major axis to minor axis.
+        RECT_LONG_SIDE(40), // Length of the long side of a rectangle having the same area and perimeter as the particle in calibrated units.
+        RECT_SHORT_SIDE(41), // Length of the short side of a rectangle having the same area and perimeter as the particle in calibrated units.
+        RECT_RATIO(42), // Ratio of rectangle long side to rectangle short side.
+        ELONGATION(43), // Max intercept/mean perpendicular intercept.
+        COMPACTNESS(44), // Particle area/(height x width).
+        HEYWOOD(45), // Particle perimeter/perimeter of the circle having the same area as the particle.
+        TYPE_FACTOR(46), // A complex factor relating the surface area to the moment of inertia.
+        HYDRAULIC(47), // Particle area/particle perimeter.
+        WADDLE_DISK(48), // Diameter of the disk having the same area as the particle in user units.
+        DIAGONAL(49), // Diagonal of an equivalent rectangle in user units.
+        ;
+        private final int value;
+        private MeasurementValue(int value) {
+            this.value = value;
+        }
+        public static MeasurementValue fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ScalingMode {
+        SCALE_LARGER(0), // The function duplicates pixels to make the image larger.
+        SCALE_SMALLER(1), // The function subsamples pixels to make the image smaller.
+        ;
+        private final int value;
+        private ScalingMode(int value) {
+            this.value = value;
+        }
+        public static ScalingMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ScalingMethod {
+        SCALE_TO_PRESERVE_AREA(0), // Correction functions scale the image such that the features in the corrected image have the same area as the features in the input image.
+        SCALE_TO_FIT(1), // Correction functions scale the image such that the corrected image is the same size as the input image.
+        ;
+        private final int value;
+        private ScalingMethod(int value) {
+            this.value = value;
+        }
+        public static ScalingMethod fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ReferenceMode {
+        COORD_X_Y(0), // This method requires three elements in the points array.
+        COORD_ORIGIN_X(1), // This method requires two elements in the points array.
+        ;
+        private final int value;
+        private ReferenceMode(int value) {
+            this.value = value;
+        }
+        public static ReferenceMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum RectOrientation {
+        BASE_INSIDE(0), // Specifies that the base of the rectangular image lies along the inside edge of the annulus.
+        BASE_OUTSIDE(1), // Specifies that the base of the rectangular image lies along the outside edge of the annulus.
+        ;
+        private final int value;
+        private RectOrientation(int value) {
+            this.value = value;
+        }
+        public static RectOrientation fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ShapeMode {
+        SHAPE_RECT(1), // The function draws a rectangle.
+        SHAPE_OVAL(2), // The function draws an oval.
+        ;
+        private final int value;
+        private ShapeMode(int value) {
+            this.value = value;
+        }
+        public static ShapeMode fromValue(int val) {
+            for (ShapeMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum PolarityType {
+        EDGE_RISING(1), // The edge is a rising edge.
+        EDGE_FALLING(-1), // The edge is a falling edge.
+        ;
+        private final int value;
+        private PolarityType(int value) {
+            this.value = value;
+        }
+        public static PolarityType fromValue(int val) {
+            for (PolarityType v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum SizeType {
+        KEEP_LARGE(0), // The function keeps large particles remaining after the erosion.
+        KEEP_SMALL(1), // The function keeps small particles eliminated by the erosion.
+        ;
+        private final int value;
+        private SizeType(int value) {
+            this.value = value;
+        }
+        public static SizeType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum Plane3D {
+        C3D_REAL(0), // The function shows the real part of complex images.
+        C3D_IMAGINARY(1), // The function shows the imaginary part of complex images.
+        C3D_MAGNITUDE(2), // The function shows the magnitude part of complex images.
+        C3D_PHASE(3), // The function shows the phase part of complex images.
+        ;
+        private final int value;
+        private Plane3D(int value) {
+            this.value = value;
+        }
+        public static Plane3D fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum PhotometricMode {
+        WHITE_IS_ZERO(0), // The function interprets zero-value pixels as white.
+        BLACK_IS_ZERO(1), // The function interprets zero-value pixels as black.
+        ;
+        private final int value;
+        private PhotometricMode(int value) {
+            this.value = value;
+        }
+        public static PhotometricMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ParticleInfoMode {
+        BASIC_INFO(0), // The function returns only the following elements of each report: area, calibratedArea, boundingRect.
+        ALL_INFO(1), // The function returns all the information about each particle.
+        ;
+        private final int value;
+        private ParticleInfoMode(int value) {
+            this.value = value;
+        }
+        public static ParticleInfoMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum OutlineMethod {
+        EDGE_DIFFERENCE(0), // The function uses a method that produces continuous contours by highlighting each pixel where an intensity variation occurs between itself and its three upper-left neighbors.
+        EDGE_GRADIENT(1), // The function uses a method that outlines contours where an intensity variation occurs along the vertical axis.
+        EDGE_PREWITT(2), // The function uses a method that extracts the outer contours of objects.
+        EDGE_ROBERTS(3), // The function uses a method that outlines the contours that highlight pixels where an intensity variation occurs along the diagonal axes.
+        EDGE_SIGMA(4), // The function uses a method that outlines contours and details by setting pixels to the mean value found in their neighborhood, if their deviation from this value is not significant.
+        EDGE_SOBEL(5), // The function uses a method that extracts the outer contours of objects.
+        ;
+        private final int value;
+        private OutlineMethod(int value) {
+            this.value = value;
+        }
+        public static OutlineMethod fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum MorphologyMethod {
+        AUTOM(0), // The function uses a transformation that generates simpler particles that contain fewer details.
+        CLOSE(1), // The function uses a transformation that fills tiny holes and smooths boundaries.
+        DILATE(2), // The function uses a transformation that eliminates tiny holes isolated in particles and expands the contour of the particles according to the template defined by the structuring element.
+        ERODE(3), // The function uses a transformation that eliminates pixels isolated in the background and erodes the contour of particles according to the template defined by the structuring element.
+        GRADIENT(4), // The function uses a transformation that leaves only the pixels that would be added by the dilation process or eliminated by the erosion process.
+        GRADIENTOUT(5), // The function uses a transformation that leaves only the pixels that would be added by the dilation process.
+        GRADIENTIN(6), // The function uses a transformation that leaves only the pixels that would be eliminated by the erosion process.
+        HITMISS(7), // The function uses a transformation that extracts each pixel located in a neighborhood exactly matching the template defined by the structuring element.
+        OPEN(8), // The function uses a transformation that removes small particles and smooths boundaries.
+        PCLOSE(9), // The function uses a transformation that fills tiny holes and smooths the inner contour of particles according to the template defined by the structuring element.
+        POPEN(10), // The function uses a transformation that removes small particles and smooths the contour of particles according to the template defined by the structuring element.
+        THICK(11), // The function uses a transformation that adds to an image those pixels located in a neighborhood that matches a template specified by the structuring element.
+        THIN(12), // The function uses a transformation that eliminates pixels that are located in a neighborhood matching a template specified by the structuring element.
+        ;
+        private final int value;
+        private MorphologyMethod(int value) {
+            this.value = value;
+        }
+        public static MorphologyMethod fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum MeterArcMode {
+        METER_ARC_ROI(0), // The function uses the roi parameter and ignores the base, start, and end parameters.
+        METER_ARC_POINTS(1), // The function uses the base,start, and end parameters and ignores the roi parameter.
+        ;
+        private final int value;
+        private MeterArcMode(int value) {
+            this.value = value;
+        }
+        public static MeterArcMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum RakeDirection {
+        LEFT_TO_RIGHT(0), // The function searches from the left side of the search area to the right side of the search area.
+        RIGHT_TO_LEFT(1), // The function searches from the right side of the search area to the left side of the search area.
+        TOP_TO_BOTTOM(2), // The function searches from the top side of the search area to the bottom side of the search area.
+        BOTTOM_TO_TOP(3), // The function searches from the bottom side of the search area to the top side of the search area.
+        ;
+        private final int value;
+        private RakeDirection(int value) {
+            this.value = value;
+        }
+        public static RakeDirection fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum TruncateMode {
+        TRUNCATE_LOW(0), // The function truncates low frequencies.
+        TRUNCATE_HIGH(1), // The function truncates high frequencies.
+        ;
+        private final int value;
+        private TruncateMode(int value) {
+            this.value = value;
+        }
+        public static TruncateMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum AttenuateMode {
+        ATTENUATE_LOW(0), // The function attenuates low frequencies.
+        ATTENUATE_HIGH(1), // The function attenuates high frequencies.
+        ;
+        private final int value;
+        private AttenuateMode(int value) {
+            this.value = value;
+        }
+        public static AttenuateMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum WindowThreadPolicy {
+        CALLING_THREAD(0), // Using this policy, NI Vision creates windows in the thread that makes the first display function call for a given window number.
+        SEPARATE_THREAD(1), // Using this policy, NI Vision creates windows in a separate thread and processes messages for the windows automatically.
+        ;
+        private final int value;
+        private WindowThreadPolicy(int value) {
+            this.value = value;
+        }
+        public static WindowThreadPolicy fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum WindowOptions {
+        WIND_RESIZABLE(1), // When present, the user may resize the window interactively.
+        WIND_TITLEBAR(2), // When present, the title bar on the window is visible.
+        WIND_CLOSEABLE(4), // When present, the close box is available.
+        WIND_TOPMOST(8), // When present, the window is always on top.
+        ;
+        private final int value;
+        private WindowOptions(int value) {
+            this.value = value;
+        }
+        public static WindowOptions fromValue(int val) {
+            for (WindowOptions v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum WindowEventType {
+        NO_EVENT(0), // No event occurred since the last call to imaqGetLastEvent().
+        CLICK_EVENT(1), // The user clicked on a window.
+        DRAW_EVENT(2), // The user drew an ROI in a window.
+        MOVE_EVENT(3), // The user moved a window.
+        SIZE_EVENT(4), // The user sized a window.
+        SCROLL_EVENT(5), // The user scrolled a window.
+        ACTIVATE_EVENT(6), // The user activated a window.
+        CLOSE_EVENT(7), // The user closed a window.
+        DOUBLE_CLICK_EVENT(8), // The user double-clicked in a window.
+        ;
+        private final int value;
+        private WindowEventType(int value) {
+            this.value = value;
+        }
+        public static WindowEventType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum VisionInfoType {
+        ANY_VISION_INFO(0), // The function checks if any extra vision information is associated with the image.
+        PATTERN_MATCHING_INFO(1), // The function checks if any pattern matching template information is associated with the image.
+        CALIBRATION_INFO(2), // The function checks if any calibration information is associated with the image.
+        OVERLAY_INFO(3), // The function checks if any overlay information is associated with the image.
+        ;
+        private final int value;
+        private VisionInfoType(int value) {
+            this.value = value;
+        }
+        public static VisionInfoType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum SearchStrategy {
+        CONSERVATIVE(1), // Instructs the pattern matching algorithm to use the largest possible amount of information from the image at the expense of slowing down the speed of the algorithm.
+        BALANCED(2), // Instructs the pattern matching algorithm to balance the amount of information from the image it uses with the speed of the algorithm.
+        AGGRESSIVE(3), // Instructs the pattern matching algorithm to use a lower amount of information from the image, which allows the algorithm to run quickly but at the expense of accuracy.
+        VERY_AGGRESSIVE(4), // Instructs the pattern matching algorithm to use the smallest possible amount of information from the image, which allows the algorithm to run at the highest speed possible but at the expense of accuracy.
+        ;
+        private final int value;
+        private SearchStrategy(int value) {
+            this.value = value;
+        }
+        public static SearchStrategy fromValue(int val) {
+            for (SearchStrategy v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum TwoEdgePolarityType {
+        NONE(0), // The function ignores the polarity of the edges.
+        RISING_FALLING(1), // The polarity of the first edge is rising (dark to light) and the polarity of the second edge is falling (light to dark).
+        FALLING_RISING(2), // The polarity of the first edge is falling (light to dark) and the polarity of the second edge is rising (dark to light).
+        RISING_RISING(3), // The polarity of the first edge is rising (dark to light) and the polarity of the second edge is rising (dark to light).
+        FALLING_FALLING(4), // The polarity of the first edge is falling (light to dark) and the polarity of the second edge is falling (light to dark).
+        ;
+        private final int value;
+        private TwoEdgePolarityType(int value) {
+            this.value = value;
+        }
+        public static TwoEdgePolarityType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ObjectType {
+        BRIGHT_OBJECTS(0), // The function detects bright objects.
+        DARK_OBJECTS(1), // The function detects dark objects.
+        ;
+        private final int value;
+        private ObjectType(int value) {
+            this.value = value;
+        }
+        public static ObjectType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum Tool {
+        NO_TOOL(-1), // No tool is in the selected state.
+        SELECTION_TOOL(0), // The selection tool selects an existing ROI in an image.
+        POINT_TOOL(1), // The point tool draws a point on the image.
+        LINE_TOOL(2), // The line tool draws a line on the image.
+        RECTANGLE_TOOL(3), // The rectangle tool draws a rectangle on the image.
+        OVAL_TOOL(4), // The oval tool draws an oval on the image.
+        POLYGON_TOOL(5), // The polygon tool draws a polygon on the image.
+        CLOSED_FREEHAND_TOOL(6), // The closed freehand tool draws closed freehand shapes on the image.
+        ANNULUS_TOOL(7), // The annulus tool draws annuluses on the image.
+        ZOOM_TOOL(8), // The zoom tool controls the zoom of an image.
+        PAN_TOOL(9), // The pan tool shifts the view of the image.
+        POLYLINE_TOOL(10), // The polyline tool draws a series of connected straight lines on the image.
+        FREEHAND_TOOL(11), // The freehand tool draws freehand lines on the image.
+        ROTATED_RECT_TOOL(12), // The rotated rectangle tool draws rotated rectangles on the image.
+        ZOOM_OUT_TOOL(13), // The zoom out tool controls the zoom of an image.
+        ;
+        private final int value;
+        private Tool(int value) {
+            this.value = value;
+        }
+        public static Tool fromValue(int val) {
+            for (Tool v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum TIFFCompressionType {
+        NO_COMPRESSION(0), // The function does not compress the TIFF file.
+        JPEG(1), // The function uses the JPEG compression algorithm to compress the TIFF file.
+        RUN_LENGTH(2), // The function uses a run length compression algorithm to compress the TIFF file.
+        ZIP(3), // The function uses the ZIP compression algorithm to compress the TIFF file.
+        ;
+        private final int value;
+        private TIFFCompressionType(int value) {
+            this.value = value;
+        }
+        public static TIFFCompressionType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ThresholdMethod {
+        THRESH_CLUSTERING(0), // The function uses a method that sorts the histogram of the image within a discrete number of classes corresponding to the number of phases perceived in an image.
+        THRESH_ENTROPY(1), // The function uses a method that is best for detecting particles that are present in minuscule proportions on the image.
+        THRESH_METRIC(2), // The function uses a method that is well-suited for images in which classes are not too disproportionate.
+        THRESH_MOMENTS(3), // The function uses a method that is suited for images that have poor contrast.
+        THRESH_INTERCLASS(4), // The function uses a method that is well-suited for images in which classes have well separated pixel value distributions.
+        ;
+        private final int value;
+        private ThresholdMethod(int value) {
+            this.value = value;
+        }
+        public static ThresholdMethod fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum TextAlignment {
+        LEFT(0), // Left aligns the text at the reference point.
+        CENTER(1), // Centers the text around the reference point.
+        RIGHT(2), // Right aligns the text at the reference point.
+        ;
+        private final int value;
+        private TextAlignment(int value) {
+            this.value = value;
+        }
+        public static TextAlignment fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum SpokeDirection {
+        OUTSIDE_TO_INSIDE(0), // The function searches from the outside of the search area to the inside of the search area.
+        INSIDE_TO_OUTSIDE(1), // The function searches from the inside of the search area to the outside of the search area.
+        ;
+        private final int value;
+        private SpokeDirection(int value) {
+            this.value = value;
+        }
+        public static SpokeDirection fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum SkeletonMethod {
+        SKELETON_L(0), // Uses an L-shaped structuring element in the skeleton function.
+        SKELETON_M(1), // Uses an M-shaped structuring element in the skeleton function.
+        SKELETON_INVERSE(2), // Uses an L-shaped structuring element on an inverse of the image in the skeleton function.
+        ;
+        private final int value;
+        private SkeletonMethod(int value) {
+            this.value = value;
+        }
+        public static SkeletonMethod fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum VerticalTextAlignment {
+        BOTTOM(0), // Aligns the bottom of the text at the reference point.
+        TOP(1), // Aligns the top of the text at the reference point.
+        BASELINE(2), // Aligns the baseline of the text at the reference point.
+        ;
+        private final int value;
+        private VerticalTextAlignment(int value) {
+            this.value = value;
+        }
+        public static VerticalTextAlignment fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum CalibrationROI {
+        FULL_IMAGE(0), // The correction function corrects the whole image, regardless of the user-defined or calibration-defined ROIs.
+        CALIBRATION_ROI(1), // The correction function corrects the area defined by the calibration ROI.
+        USER_ROI(2), // The correction function corrects the area defined by the user-defined ROI.
+        CALIBRATION_AND_USER_ROI(3), // The correction function corrects the area defined by the intersection of the user-defined ROI and the calibration ROI.
+        CALIBRATION_OR_USER_ROI(4), // The correction function corrects the area defined by the union of the user-defined ROI and the calibration ROI.
+        ;
+        private final int value;
+        private CalibrationROI(int value) {
+            this.value = value;
+        }
+        public static CalibrationROI fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ContourType {
+        EMPTY_CONTOUR(0), // The contour is empty.
+        POINT(1), // The contour represents a point.
+        LINE(2), // The contour represents a line.
+        RECT(3), // The contour represents a rectangle.
+        OVAL(4), // The contour represents an oval.
+        CLOSED_CONTOUR(5), // The contour represents a series of connected points where the last point connects to the first.
+        OPEN_CONTOUR(6), // The contour represents a series of connected points where the last point does not connect to the first.
+        ANNULUS(7), // The contour represents an annulus.
+        ROTATED_RECT(8), // The contour represents a rotated rectangle.
+        ;
+        private final int value;
+        private ContourType(int value) {
+            this.value = value;
+        }
+        public static ContourType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum MathTransformMethod {
+        TRANSFORM_LINEAR(0), // The function uses linear remapping.
+        TRANSFORM_LOG(1), // The function uses logarithmic remapping.
+        TRANSFORM_EXP(2), // The function uses exponential remapping.
+        TRANSFORM_SQR(3), // The function uses square remapping.
+        TRANSFORM_SQRT(4), // The function uses square root remapping.
+        TRANSFORM_POWX(5), // The function uses power X remapping.
+        TRANSFORM_POW1X(6), // The function uses power 1/X remapping.
+        ;
+        private final int value;
+        private MathTransformMethod(int value) {
+            this.value = value;
+        }
+        public static MathTransformMethod fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ComplexPlane {
+        REAL(0), // The function operates on the real plane of the complex image.
+        IMAGINARY(1), // The function operates on the imaginary plane of the complex image.
+        MAGNITUDE(2), // The function operates on the magnitude plane of the complex image.
+        PHASE(3), // The function operates on the phase plane of the complex image.
+        ;
+        private final int value;
+        private ComplexPlane(int value) {
+            this.value = value;
+        }
+        public static ComplexPlane fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum PaletteType {
+        PALETTE_GRAY(0), // The function uses a palette that has a gradual gray-level variation from black to white.
+        PALETTE_BINARY(1), // The function uses a palette of 16 cycles of 16 different colors that is useful with binary images.
+        PALETTE_GRADIENT(2), // The function uses a palette that has a gradation from red to white with a prominent range of light blue in the upper value range.
+        PALETTE_RAINBOW(3), // The function uses a palette that has a gradation from blue to red with a prominent range of greens in the middle value range.
+        PALETTE_TEMPERATURE(4), // The function uses a palette that has a gradation from light brown to dark brown.
+        PALETTE_USER(5), // The function uses a palette defined by the user.
+        ;
+        private final int value;
+        private PaletteType(int value) {
+            this.value = value;
+        }
+        public static PaletteType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ColorSensitivity {
+        SENSITIVITY_LOW(0), // Instructs the algorithm to divide the hue plane into a low number of sectors, allowing for simple color analysis.
+        SENSITIVITY_MED(1), // Instructs the algorithm to divide the hue plane into a medium number of sectors, allowing for color analysis that balances sensitivity and complexity.
+        SENSITIVITY_HIGH(2), // Instructs the algorithm to divide the hue plane into a high number of sectors, allowing for complex, sensitive color analysis.
+        ;
+        private final int value;
+        private ColorSensitivity(int value) {
+            this.value = value;
+        }
+        public static ColorSensitivity fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ColorMode {
+        RGB(0), // The function operates in the RGB (Red, Blue, Green) color space.
+        HSL(1), // The function operates in the HSL (Hue, Saturation, Luminance) color space.
+        HSV(2), // The function operates in the HSV (Hue, Saturation, Value) color space.
+        HSI(3), // The function operates in the HSI (Hue, Saturation, Intensity) color space.
+        CIE(4), // The function operates in the CIE L*a*b* color space.
+        CIEXYZ(5), // The function operates in the CIE XYZ color space.
+        ;
+        private final int value;
+        private ColorMode(int value) {
+            this.value = value;
+        }
+        public static ColorMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum DetectionMode {
+        DETECT_PEAKS(0), // The function detects peaks.
+        DETECT_VALLEYS(1), // The function detects valleys.
+        ;
+        private final int value;
+        private DetectionMode(int value) {
+            this.value = value;
+        }
+        public static DetectionMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum CalibrationUnit {
+        UNDEFINED(0), // The image does not have a defined unit of measurement.
+        ANGSTROM(1), // The unit of measure for the image is angstroms.
+        MICROMETER(2), // The unit of measure for the image is micrometers.
+        MILLIMETER(3), // The unit of measure for the image is millimeters.
+        CENTIMETER(4), // The unit of measure for the image is centimeters.
+        METER(5), // The unit of measure for the image is meters.
+        KILOMETER(6), // The unit of measure for the image is kilometers.
+        MICROINCH(7), // The unit of measure for the image is microinches.
+        INCH(8), // The unit of measure for the image is inches.
+        FOOT(9), // The unit of measure for the image is feet.
+        NAUTICMILE(10), // The unit of measure for the image is nautical miles.
+        GROUNDMILE(11), // The unit of measure for the image is ground miles.
+        STEP(12), // The unit of measure for the image is steps.
+        ;
+        private final int value;
+        private CalibrationUnit(int value) {
+            this.value = value;
+        }
+        public static CalibrationUnit fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ConcentricRakeDirection {
+        COUNTER_CLOCKWISE(0), // The function searches the search area in a counter-clockwise direction.
+        CLOCKWISE(1), // The function searches the search area in a clockwise direction.
+        ;
+        private final int value;
+        private ConcentricRakeDirection(int value) {
+            this.value = value;
+        }
+        public static ConcentricRakeDirection fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum CalibrationMode {
+        PERSPECTIVE(0), // Functions correct for distortion caused by the camera's perspective.
+        NONLINEAR(1), // Functions correct for distortion caused by the camera's lens.
+        SIMPLE_CALIBRATION(2), // Functions do not correct for distortion.
+        CORRECTED_IMAGE(3), // The image is already corrected.
+        ;
+        private final int value;
+        private CalibrationMode(int value) {
+            this.value = value;
+        }
+        public static CalibrationMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum BrowserLocation {
+        INSERT_FIRST_FREE(0), // Inserts the thumbnail in the first available cell.
+        INSERT_END(1), // Inserts the thumbnail after the last occupied cell.
+        ;
+        private final int value;
+        private BrowserLocation(int value) {
+            this.value = value;
+        }
+        public static BrowserLocation fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum BrowserFrameStyle {
+        RAISED_FRAME(0), // Each thumbnail has a raised frame.
+        BEVELLED_FRAME(1), // Each thumbnail has a beveled frame.
+        OUTLINE_FRAME(2), // Each thumbnail has an outlined frame.
+        HIDDEN_FRAME(3), // Each thumbnail has a hidden frame.
+        STEP_FRAME(4), // Each thumbnail has a stepped frame.
+        RAISED_OUTLINE_FRAME(5), // Each thumbnail has a raised, outlined frame.
+        ;
+        private final int value;
+        private BrowserFrameStyle(int value) {
+            this.value = value;
+        }
+        public static BrowserFrameStyle fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum BorderMethod {
+        BORDER_MIRROR(0), // Symmetrically copies pixel values from the image into the border.
+        BORDER_COPY(1), // Copies the value of the pixel closest to the edge of the image into the border.
+        BORDER_CLEAR(2), // Sets all pixels in the border to 0.
+        ;
+        private final int value;
+        private BorderMethod(int value) {
+            this.value = value;
+        }
+        public static BorderMethod fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum BarcodeType {
+        INVALID(-1), // The barcode is not of a type known by NI Vision.
+        CODABAR(1), // The barcode is of type Codabar.
+        CODE39(2), // The barcode is of type Code 39.
+        CODE93(4), // The barcode is of type Code 93.
+        CODE128(8), // The barcode is of type Code 128.
+        EAN8(16), // The barcode is of type EAN 8.
+        EAN13(32), // The barcode is of type EAN 13.
+        I2_OF_5(64), // The barcode is of type Code 25.
+        MSI(128), // The barcode is of type MSI code.
+        UPCA(256), // The barcode is of type UPC A.
+        PHARMACODE(512), // The barcode is of type Pharmacode.
+        RSS_LIMITED(1024), // The barcode is of type RSS Limited.
+        ;
+        private final int value;
+        private BarcodeType(int value) {
+            this.value = value;
+        }
+        public static BarcodeType fromValue(int val) {
+            for (BarcodeType v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum AxisOrientation {
+        DIRECT(0), // The y-axis direction corresponds to the y-axis direction of the Cartesian coordinate system.
+        INDIRECT(1), // The y-axis direction corresponds to the y-axis direction of an image.
+        ;
+        private final int value;
+        private AxisOrientation(int value) {
+            this.value = value;
+        }
+        public static AxisOrientation fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ColorIgnoreMode {
+        IGNORE_NONE(0), // Specifies that the function does not ignore any pixels.
+        IGNORE_BLACK(1), // Specifies that the function ignores black pixels.
+        IGNORE_WHITE(2), // Specifies that the function ignores white pixels.
+        IGNORE_BLACK_AND_WHITE(3), // Specifies that the function ignores black pixels and white pixels.
+        ;
+        private final int value;
+        private ColorIgnoreMode(int value) {
+            this.value = value;
+        }
+        public static ColorIgnoreMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum LevelType {
+        ABSOLUTE(0), // The function evaluates the threshold and hysteresis values as absolute values.
+        RELATIVE(1), // The function evaluates the threshold and hysteresis values relative to the dynamic range of the given path.
+        ;
+        private final int value;
+        private LevelType(int value) {
+            this.value = value;
+        }
+        public static LevelType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum MatchingMode {
+        MATCH_SHIFT_INVARIANT(1), // Searches for occurrences of the template image anywhere in the searchRect, assuming that the pattern is not rotated more than plus or minus 4 degrees.
+        MATCH_ROTATION_INVARIANT(2), // Searches for occurrences of the pattern in the image with no restriction on the rotation of the pattern.
+        ;
+        private final int value;
+        private MatchingMode(int value) {
+            this.value = value;
+        }
+        public static MatchingMode fromValue(int val) {
+            for (MatchingMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum MappingMethod {
+        FULL_DYNAMIC(0), // (Obsolete) When the image bit depth is 0, the function maps the full dynamic range of the 16-bit image to an 8-bit scale.
+        DOWNSHIFT(1), // (Obsolete) When the image bit depth is 0, the function shifts the 16-bit image pixels to the right the number of times specified by the shiftCount element of the DisplayMapping structure.
+        RANGE(2), // (Obsolete) When the image bit depth is 0, the function maps the pixel values in the range specified by the minimumValue and maximumValue elements of the DisplayMapping structure to an 8-bit scale.
+        C90_PCT_DYNAMIC(3), // (Obsolete) When the image bit depth to 0, the function maps the dynamic range containing the middle 90 percent of the cumulated histogram of the image to an 8-bit (256 grayscale values) scale.
+        PERCENT_RANGE(4), // (Obsolete) When the image bit depth is 0, the function maps the pixel values in the relative percentage range (0 to 100) of the cumulated histogram specified by minimumValue and maximumValue to an 8-bit scale.
+        DEFAULT_MAPPING(10), // If the bit depth is 0, the function maps the 16-bit image to 8 bits by following the IMAQ_FULL_DYNAMIC_ALWAYS behavior; otherwise, the function shifts the image data to the right according to the IMAQ_MOST_SIGNIFICANT behavior.
+        MOST_SIGNIFICANT(11), // The function shifts the 16-bit image pixels to the right until the 8 most significant bits of the image data are remaining.
+        FULL_DYNAMIC_ALWAYS(12), // The function maps the full dynamic range of the 16-bit image to an 8-bit scale.
+        DOWNSHIFT_ALWAYS(13), // The function shifts the 16-bit image pixels to the right the number of times specified by the shiftCount element of the DisplayMapping structure.
+        RANGE_ALWAYS(14), // The function maps the pixel values in the range specified by the minimumValue and maximumValue elements of the DisplayMapping structure to an 8-bit scale.
+        C90_PCT_DYNAMIC_ALWAYS(15), // The function maps the dynamic range containing the middle 90 percent of the cumulated histogram of the image to an 8-bit (256 grayscale values) scale.
+        PERCENT_RANGE_ALWAYS(16), // The function maps the pixel values in the relative percentage range (0 to 100) of the cumulated histogram specified by minimumValue and maximumValue to an 8-bit scale.
+        ;
+        private final int value;
+        private MappingMethod(int value) {
+            this.value = value;
+        }
+        public static MappingMethod fromValue(int val) {
+            for (MappingMethod v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ComparisonFunction {
+        CLEAR_LESS(0), // The comparison is true if the source pixel value is less than the comparison image pixel value.
+        CLEAR_LESS_OR_EQUAL(1), // The comparison is true if the source pixel value is less than or equal to the comparison image pixel value.
+        CLEAR_EQUAL(2), // The comparison is true if the source pixel value is equal to the comparison image pixel value.
+        CLEAR_GREATER_OR_EQUAL(3), // The comparison is true if the source pixel value is greater than or equal to the comparison image pixel value.
+        CLEAR_GREATER(4), // The comparison is true if the source pixel value is greater than the comparison image pixel value.
+        ;
+        private final int value;
+        private ComparisonFunction(int value) {
+            this.value = value;
+        }
+        public static ComparisonFunction fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum LineGaugeMethod {
+        EDGE_TO_EDGE(0), // Measures from the first edge on the line to the last edge on the line.
+        EDGE_TO_POINT(1), // Measures from the first edge on the line to the end point of the line.
+        POINT_TO_EDGE(2), // Measures from the start point of the line to the first edge on the line.
+        POINT_TO_POINT(3), // Measures from the start point of the line to the end point of the line.
+        ;
+        private final int value;
+        private LineGaugeMethod(int value) {
+            this.value = value;
+        }
+        public static LineGaugeMethod fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum Direction3D {
+        C3D_NW(0), // The viewing angle for the 3D image is from the northwest.
+        C3D_SW(1), // The viewing angle for the 3D image is from the southwest.
+        C3D_SE(2), // The viewing angle for the 3D image is from the southeast.
+        C3D_NE(3), // The viewing angle for the 3D image is from the northeast.
+        ;
+        private final int value;
+        private Direction3D(int value) {
+            this.value = value;
+        }
+        public static Direction3D fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum LearningMode {
+        LEARN_ALL(0), // The function extracts information for shift- and rotation-invariant matching.
+        LEARN_SHIFT_INFORMATION(1), // The function extracts information for shift-invariant matching.
+        LEARN_ROTATION_INFORMATION(2), // The function extracts information for rotation-invariant matching.
+        ;
+        private final int value;
+        private LearningMode(int value) {
+            this.value = value;
+        }
+        public static LearningMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum KernelFamily {
+        GRADIENT_FAMILY(0), // The kernel is in the gradient family.
+        LAPLACIAN_FAMILY(1), // The kernel is in the Laplacian family.
+        SMOOTHING_FAMILY(2), // The kernel is in the smoothing family.
+        GAUSSIAN_FAMILY(3), // The kernel is in the Gaussian family.
+        ;
+        private final int value;
+        private KernelFamily(int value) {
+            this.value = value;
+        }
+        public static KernelFamily fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum InterpolationMethod {
+        ZERO_ORDER(0), // The function uses an interpolation method that interpolates new pixel values using the nearest valid neighboring pixel.
+        BILINEAR(1), // The function uses an interpolation method that interpolates new pixel values using a bidirectional average of the neighboring pixels.
+        QUADRATIC(2), // The function uses an interpolation method that interpolates new pixel values using a quadratic approximating polynomial.
+        CUBIC_SPLINE(3), // The function uses an interpolation method that interpolates new pixel values by fitting them to a cubic spline curve, where the curve is based on known pixel values from the image.
+        BILINEAR_FIXED(4), // The function uses an interpolation method that interpolates new pixel values using a bidirectional average of the neighboring pixels.
+        ;
+        private final int value;
+        private InterpolationMethod(int value) {
+            this.value = value;
+        }
+        public static InterpolationMethod fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ImageType {
+        IMAGE_U8(0), // The image type is 8-bit unsigned integer grayscale.
+        IMAGE_U16(7), // The image type is 16-bit unsigned integer grayscale.
+        IMAGE_I16(1), // The image type is 16-bit signed integer grayscale.
+        IMAGE_SGL(2), // The image type is 32-bit floating-point grayscale.
+        IMAGE_COMPLEX(3), // The image type is complex.
+        IMAGE_RGB(4), // The image type is RGB color.
+        IMAGE_HSL(5), // The image type is HSL color.
+        IMAGE_RGB_U64(6), // The image type is 64-bit unsigned RGB color.
+        ;
+        private final int value;
+        private ImageType(int value) {
+            this.value = value;
+        }
+        public static ImageType fromValue(int val) {
+            for (ImageType v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ImageFeatureMode {
+        COLOR_AND_SHAPE_FEATURES(0), // Instructs the function to use the color and the shape features of the color pattern.
+        COLOR_FEATURES(1), // Instructs the function to use the color features of the color pattern.
+        SHAPE_FEATURES(2), // Instructs the function to use the shape features of the color pattern.
+        ;
+        private final int value;
+        private ImageFeatureMode(int value) {
+            this.value = value;
+        }
+        public static ImageFeatureMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum FontColor {
+        WHITE(0), // Draws text in white.
+        BLACK(1), // Draws text in black.
+        INVERT(2), // Inverts the text pixels.
+        BLACK_ON_WHITE(3), // Draws text in black with a white background.
+        WHITE_ON_BLACK(4), // Draws text in white with a black background.
+        ;
+        private final int value;
+        private FontColor(int value) {
+            this.value = value;
+        }
+        public static FontColor fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum FlipAxis {
+        HORIZONTAL_AXIS(0), // Flips the image over the central horizontal axis.
+        VERTICAL_AXIS(1), // Flips the image over the central vertical axis.
+        CENTER_AXIS(2), // Flips the image over both the central vertical and horizontal axes.
+        DIAG_L_TO_R_AXIS(3), // Flips the image over an axis from the upper left corner to lower right corner.
+        DIAG_R_TO_L_AXIS(4), // Flips the image over an axis from the upper right corner to lower left corner.
+        ;
+        private final int value;
+        private FlipAxis(int value) {
+            this.value = value;
+        }
+        public static FlipAxis fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum EdgeProcess {
+        FIRST(0), // The function looks for the first edge.
+        FIRST_AND_LAST(1), // The function looks for the first and last edge.
+        ALL(2), // The function looks for all edges.
+        BEST(3), // The function looks for the best edge.
+        ;
+        private final int value;
+        private EdgeProcess(int value) {
+            this.value = value;
+        }
+        public static EdgeProcess fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum DrawMode {
+        DRAW_VALUE(0), // Draws the boundary of the object with the specified pixel value.
+        DRAW_INVERT(2), // Inverts the pixel values of the boundary of the object.
+        PAINT_VALUE(1), // Fills the object with the given pixel value.
+        PAINT_INVERT(3), // Inverts the pixel values of the object.
+        HIGHLIGHT_VALUE(4), // The function fills the object by highlighting the enclosed pixels with the color of the object.
+        ;
+        private final int value;
+        private DrawMode(int value) {
+            this.value = value;
+        }
+        public static DrawMode fromValue(int val) {
+            for (DrawMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum NearestNeighborMetric {
+        METRIC_MAXIMUM(0), // The maximum metric.
+        METRIC_SUM(1), // The sum metric.
+        METRIC_EUCLIDEAN(2), // The Euclidean metric.
+        ;
+        private final int value;
+        private NearestNeighborMetric(int value) {
+            this.value = value;
+        }
+        public static NearestNeighborMetric fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ReadResolution {
+        LOW_RESOLUTION(0), // Configures NI Vision to use low resolution during the read process.
+        MEDIUM_RESOLUTION(1), // Configures NI Vision to use medium resolution during the read process.
+        HIGH_RESOLUTION(2), // Configures NI Vision to use high resolution during the read process.
+        ;
+        private final int value;
+        private ReadResolution(int value) {
+            this.value = value;
+        }
+        public static ReadResolution fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ThresholdMode {
+        FIXED_RANGE(0), // Performs thresholding using the values you provide in the lowThreshold and highThreshold elements of OCRProcessingOptions.
+        COMPUTED_UNIFORM(1), // Calculates a single threshold value for the entire ROI.
+        COMPUTED_LINEAR(2), // Calculates a value on the left side of the ROI, calculates a value on the right side of the ROI, and linearly fills the middle values from left to right.
+        COMPUTED_NONLINEAR(3), // Divides the ROI into the number of blocks specified by the blockCount element of OCRProcessingOptions and calculates a threshold value for each block.
+        ;
+        private final int value;
+        private ThresholdMode(int value) {
+            this.value = value;
+        }
+        public static ThresholdMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ReadStrategy {
+        READ_AGGRESSIVE(0), // Configures NI Vision to perform fewer checks when analyzing objects to determine if they match trained characters.
+        READ_CONSERVATIVE(1), // Configures NI Vision to perform more checks to determine if an object matches a trained character.
+        ;
+        private final int value;
+        private ReadStrategy(int value) {
+            this.value = value;
+        }
+        public static ReadStrategy fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum MeasurementType {
+        MT_CENTER_OF_MASS_X(0), // X-coordinate of the point representing the average position of the total particle mass, assuming every point in the particle has a constant density.
+        MT_CENTER_OF_MASS_Y(1), // Y-coordinate of the point representing the average position of the total particle mass, assuming every point in the particle has a constant density.
+        MT_FIRST_PIXEL_X(2), // X-coordinate of the highest, leftmost particle pixel.
+        MT_FIRST_PIXEL_Y(3), // Y-coordinate of the highest, leftmost particle pixel.
+        MT_BOUNDING_RECT_LEFT(4), // X-coordinate of the leftmost particle point.
+        MT_BOUNDING_RECT_TOP(5), // Y-coordinate of highest particle point.
+        MT_BOUNDING_RECT_RIGHT(6), // X-coordinate of the rightmost particle point.
+        MT_BOUNDING_RECT_BOTTOM(7), // Y-coordinate of the lowest particle point.
+        MT_MAX_FERET_DIAMETER_START_X(8), // X-coordinate of the start of the line segment connecting the two perimeter points that are the furthest apart.
+        MT_MAX_FERET_DIAMETER_START_Y(9), // Y-coordinate of the start of the line segment connecting the two perimeter points that are the furthest apart.
+        MT_MAX_FERET_DIAMETER_END_X(10), // X-coordinate of the end of the line segment connecting the two perimeter points that are the furthest apart.
+        MT_MAX_FERET_DIAMETER_END_Y(11), // Y-coordinate of the end of the line segment connecting the two perimeter points that are the furthest apart.
+        MT_MAX_HORIZ_SEGMENT_LENGTH_LEFT(12), // X-coordinate of the leftmost pixel in the longest row of contiguous pixels in the particle.
+        MT_MAX_HORIZ_SEGMENT_LENGTH_RIGHT(13), // X-coordinate of the rightmost pixel in the longest row of contiguous pixels in the particle.
+        MT_MAX_HORIZ_SEGMENT_LENGTH_ROW(14), // Y-coordinate of all of the pixels in the longest row of contiguous pixels in the particle.
+        MT_BOUNDING_RECT_WIDTH(16), // Distance between the x-coordinate of the leftmost particle point and the x-coordinate of the rightmost particle point.
+        MT_BOUNDING_RECT_HEIGHT(17), // Distance between the y-coordinate of highest particle point and the y-coordinate of the lowest particle point.
+        MT_BOUNDING_RECT_DIAGONAL(18), // Distance between opposite corners of the bounding rectangle.
+        MT_PERIMETER(19), // Length of the outer boundary of the particle.
+        MT_CONVEX_HULL_PERIMETER(20), // Perimeter of the smallest convex polygon containing all points in the particle.
+        MT_HOLES_PERIMETER(21), // Sum of the perimeters of each hole in the particle.
+        MT_MAX_FERET_DIAMETER(22), // Distance between the start and end of the line segment connecting the two perimeter points that are the furthest apart.
+        MT_EQUIVALENT_ELLIPSE_MAJOR_AXIS(23), // Length of the major axis of the ellipse with the same perimeter and area as the particle.
+        MT_EQUIVALENT_ELLIPSE_MINOR_AXIS(24), // Length of the minor axis of the ellipse with the same perimeter and area as the particle.
+        MT_EQUIVALENT_ELLIPSE_MINOR_AXIS_FERET(25), // Length of the minor axis of the ellipse with the same area as the particle, and Major Axis equal in length to the Max Feret Diameter.
+        MT_EQUIVALENT_RECT_LONG_SIDE(26), // Longest side of the rectangle with the same perimeter and area as the particle.
+        MT_EQUIVALENT_RECT_SHORT_SIDE(27), // Shortest side of the rectangle with the same perimeter and area as the particle.
+        MT_EQUIVALENT_RECT_DIAGONAL(28), // Distance between opposite corners of the rectangle with the same perimeter and area as the particle.
+        MT_EQUIVALENT_RECT_SHORT_SIDE_FERET(29), // Shortest side of the rectangle with the same area as the particle, and longest side equal in length to the Max Feret Diameter.
+        MT_AVERAGE_HORIZ_SEGMENT_LENGTH(30), // Average length of a horizontal segment in the particle.
+        MT_AVERAGE_VERT_SEGMENT_LENGTH(31), // Average length of a vertical segment in the particle.
+        MT_HYDRAULIC_RADIUS(32), // The particle area divided by the particle perimeter.
+        MT_WADDEL_DISK_DIAMETER(33), // Diameter of a disk with the same area as the particle.
+        MT_AREA(35), // Area of the particle.
+        MT_HOLES_AREA(36), // Sum of the areas of each hole in the particle.
+        MT_PARTICLE_AND_HOLES_AREA(37), // Area of a particle that completely covers the image.
+        MT_CONVEX_HULL_AREA(38), // Area of the smallest convex polygon containing all points in the particle.
+        MT_IMAGE_AREA(39), // Area of the image.
+        MT_NUMBER_OF_HOLES(41), // Number of holes in the particle.
+        MT_NUMBER_OF_HORIZ_SEGMENTS(42), // Number of horizontal segments in the particle.
+        MT_NUMBER_OF_VERT_SEGMENTS(43), // Number of vertical segments in the particle.
+        MT_ORIENTATION(45), // The angle of the line that passes through the particle Center of Mass about which the particle has the lowest moment of inertia.
+        MT_MAX_FERET_DIAMETER_ORIENTATION(46), // The angle of the line segment connecting the two perimeter points that are the furthest apart.
+        MT_AREA_BY_IMAGE_AREA(48), // Percentage of the particle Area covering the Image Area.
+        MT_AREA_BY_PARTICLE_AND_HOLES_AREA(49), // Percentage of the particle Area in relation to its Particle and Holes Area.
+        MT_RATIO_OF_EQUIVALENT_ELLIPSE_AXES(50), // Equivalent Ellipse Major Axis divided by Equivalent Ellipse Minor Axis.
+        MT_RATIO_OF_EQUIVALENT_RECT_SIDES(51), // Equivalent Rect Long Side divided by Equivalent Rect Short Side.
+        MT_ELONGATION_FACTOR(53), // Max Feret Diameter divided by Equivalent Rect Short Side (Feret).
+        MT_COMPACTNESS_FACTOR(54), // Area divided by the product of Bounding Rect Width and Bounding Rect Height.
+        MT_HEYWOOD_CIRCULARITY_FACTOR(55), // Perimeter divided by the circumference of a circle with the same area.
+        MT_TYPE_FACTOR(56), // Factor relating area to moment of inertia.
+        MT_SUM_X(58), // The sum of all x-coordinates in the particle.
+        MT_SUM_Y(59), // The sum of all y-coordinates in the particle.
+        MT_SUM_XX(60), // The sum of all x-coordinates squared in the particle.
+        MT_SUM_XY(61), // The sum of all x-coordinates times y-coordinates in the particle.
+        MT_SUM_YY(62), // The sum of all y-coordinates squared in the particle.
+        MT_SUM_XXX(63), // The sum of all x-coordinates cubed in the particle.
+        MT_SUM_XXY(64), // The sum of all x-coordinates squared times y-coordinates in the particle.
+        MT_SUM_XYY(65), // The sum of all x-coordinates times y-coordinates squared in the particle.
+        MT_SUM_YYY(66), // The sum of all y-coordinates cubed in the particle.
+        MT_MOMENT_OF_INERTIA_XX(68), // The moment of inertia in the x-direction twice.
+        MT_MOMENT_OF_INERTIA_XY(69), // The moment of inertia in the x and y directions.
+        MT_MOMENT_OF_INERTIA_YY(70), // The moment of inertia in the y-direction twice.
+        MT_MOMENT_OF_INERTIA_XXX(71), // The moment of inertia in the x-direction three times.
+        MT_MOMENT_OF_INERTIA_XXY(72), // The moment of inertia in the x-direction twice and the y-direction once.
+        MT_MOMENT_OF_INERTIA_XYY(73), // The moment of inertia in the x-direction once and the y-direction twice.
+        MT_MOMENT_OF_INERTIA_YYY(74), // The moment of inertia in the y-direction three times.
+        MT_NORM_MOMENT_OF_INERTIA_XX(75), // The normalized moment of inertia in the x-direction twice.
+        MT_NORM_MOMENT_OF_INERTIA_XY(76), // The normalized moment of inertia in the x- and y-directions.
+        MT_NORM_MOMENT_OF_INERTIA_YY(77), // The normalized moment of inertia in the y-direction twice.
+        MT_NORM_MOMENT_OF_INERTIA_XXX(78), // The normalized moment of inertia in the x-direction three times.
+        MT_NORM_MOMENT_OF_INERTIA_XXY(79), // The normalized moment of inertia in the x-direction twice and the y-direction once.
+        MT_NORM_MOMENT_OF_INERTIA_XYY(80), // The normalized moment of inertia in the x-direction once and the y-direction twice.
+        MT_NORM_MOMENT_OF_INERTIA_YYY(81), // The normalized moment of inertia in the y-direction three times.
+        MT_HU_MOMENT_1(82), // The first Hu moment.
+        MT_HU_MOMENT_2(83), // The second Hu moment.
+        MT_HU_MOMENT_3(84), // The third Hu moment.
+        MT_HU_MOMENT_4(85), // The fourth Hu moment.
+        MT_HU_MOMENT_5(86), // The fifth Hu moment.
+        MT_HU_MOMENT_6(87), // The sixth Hu moment.
+        MT_HU_MOMENT_7(88), // The seventh Hu moment.
+        ;
+        private final int value;
+        private MeasurementType(int value) {
+            this.value = value;
+        }
+        public static MeasurementType fromValue(int val) {
+            for (MeasurementType v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum GeometricMatchingMode {
+        GEOMETRIC_MATCH_SHIFT_INVARIANT(0), // Searches for occurrences of the pattern in the image, assuming that the pattern is not rotated more than plus or minus 5 degrees.
+        GEOMETRIC_MATCH_ROTATION_INVARIANT(1), // Searches for occurrences of the pattern in the image with reduced restriction on the rotation of the pattern.
+        GEOMETRIC_MATCH_SCALE_INVARIANT(2), // Searches for occurrences of the pattern in the image with reduced restriction on the size of the pattern.
+        GEOMETRIC_MATCH_OCCLUSION_INVARIANT(4), // Searches for occurrences of the pattern in the image, allowing for a specified percentage of the pattern to be occluded.
+        ;
+        private final int value;
+        private GeometricMatchingMode(int value) {
+            this.value = value;
+        }
+        public static GeometricMatchingMode fromValue(int val) {
+            for (GeometricMatchingMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ButtonLabel {
+        BUTTON_OK(0), // The label "OK".
+        BUTTON_SAVE(1), // The label "Save".
+        BUTTON_SELECT(2), // The label "Select".
+        BUTTON_LOAD(3), // The label "Load".
+        ;
+        private final int value;
+        private ButtonLabel(int value) {
+            this.value = value;
+        }
+        public static ButtonLabel fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum NearestNeighborMethod {
+        MINIMUM_MEAN_DISTANCE(0), // The minimum mean distance method.
+        K_NEAREST_NEIGHBOR(1), // The k-nearest neighbor method.
+        NEAREST_PROTOTYPE(2), // The nearest prototype method.
+        ;
+        private final int value;
+        private NearestNeighborMethod(int value) {
+            this.value = value;
+        }
+        public static NearestNeighborMethod fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum QRMirrorMode {
+        QR_MIRROR_MODE_AUTO_DETECT(-2), // The function should determine if the QR code is mirrored.
+        QR_MIRROR_MODE_MIRRORED(1), // The function should expect the QR code to appear mirrored.
+        QR_MIRROR_MODE_NORMAL(0), // The function should expect the QR code to appear normal.
+        ;
+        private final int value;
+        private QRMirrorMode(int value) {
+            this.value = value;
+        }
+        public static QRMirrorMode fromValue(int val) {
+            for (QRMirrorMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ColumnProcessingMode {
+        AVERAGE_COLUMNS(0), // Averages the data extracted for edge detection.
+        MEDIAN_COLUMNS(1), // Takes the median of the data extracted for edge detection.
+        ;
+        private final int value;
+        private ColumnProcessingMode(int value) {
+            this.value = value;
+        }
+        public static ColumnProcessingMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum FindReferenceDirection {
+        LEFT_TO_RIGHT_DIRECT(0), // Searches from the left side of the search area to the right side of the search area for a direct axis.
+        LEFT_TO_RIGHT_INDIRECT(1), // Searches from the left side of the search area to the right side of the search area for an indirect axis.
+        TOP_TO_BOTTOM_DIRECT(2), // Searches from the top of the search area to the bottom of the search area for a direct axis.
+        TOP_TO_BOTTOM_INDIRECT(3), // Searches from the top of the search area to the bottom of the search area for an indirect axis.
+        RIGHT_TO_LEFT_DIRECT(4), // Searches from the right side of the search area to the left side of the search area for a direct axis.
+        RIGHT_TO_LEFT_INDIRECT(5), // Searches from the right side of the search area to the left side of the search area for an indirect axis.
+        BOTTOM_TO_TOP_DIRECT(6), // Searches from the bottom of the search area to the top of the search area for a direct axis.
+        BOTTOM_TO_TOP_INDIRECT(7), // Searches from the bottom of the search area to the top of the search area for an indirect axis.
+        ;
+        private final int value;
+        private FindReferenceDirection(int value) {
+            this.value = value;
+        }
+        public static FindReferenceDirection fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum MulticoreOperation {
+        GET_CORES(0), // The number of processor cores NI Vision is currently using.
+        SET_CORES(1), // The number of processor cores for NI Vision to use.
+        USE_MAX_AVAILABLE(2), // Use the maximum number of available processor cores.
+        ;
+        private final int value;
+        private MulticoreOperation(int value) {
+            this.value = value;
+        }
+        public static MulticoreOperation fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum GroupBehavior {
+        GROUP_CLEAR(0), // Sets the behavior of the overlay group to clear the current settings when an image is transformed.
+        GROUP_KEEP(1), // Sets the behavior of the overlay group to keep the current settings when an image is transformed.
+        GROUP_TRANSFORM(2), // Sets the behavior of the overlay group to transform with the image.
+        ;
+        private final int value;
+        private GroupBehavior(int value) {
+            this.value = value;
+        }
+        public static GroupBehavior fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum QRDimensions {
+        QR_DIMENSIONS_AUTO_DETECT(0), // The function will automatically determine the dimensions of the QR code.
+        ;
+        private final int value;
+        private QRDimensions(int value) {
+            this.value = value;
+        }
+        public static QRDimensions fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum QRCellFilterMode {
+        QR_CELL_FILTER_MODE_AUTO_DETECT(-2), // The function will try all filter modes and uses the one that decodes the QR code within the fewest iterations and utilizing the least amount of error correction.
+        QR_CELL_FILTER_MODE_AVERAGE(0), // The function sets the pixel value for the cell to the average of the sampled pixels.
+        QR_CELL_FILTER_MODE_MEDIAN(1), // The function sets the pixel value for the cell to the median of the sampled pixels.
+        QR_CELL_FILTER_MODE_CENTRAL_AVERAGE(2), // The function sets the pixel value for the cell to the average of the pixels in the center of the cell sample.
+        QR_CELL_FILTER_MODE_HIGH_AVERAGE(3), // The function sets the pixel value for the cell to the average value of the half of the sampled pixels with the highest pixel values.
+        QR_CELL_FILTER_MODE_LOW_AVERAGE(4), // The function sets the pixel value for the cell to the average value of the half of the sampled pixels with the lowest pixel values.
+        QR_CELL_FILTER_MODE_VERY_HIGH_AVERAGE(5), // The function sets the pixel value for the cell to the average value of the ninth of the sampled pixels with the highest pixel values.
+        QR_CELL_FILTER_MODE_VERY_LOW_AVERAGE(6), // The function sets the pixel value for the cell to the average value of the ninth of the sampled pixels with the lowest pixel values.
+        QR_CELL_FILTER_MODE_ALL(8), // The function tries each filter mode, starting with IMAQ_QR_CELL_FILTER_MODE_AVERAGE and ending with IMAQ_QR_CELL_FILTER_MODE_VERY_LOW_AVERAGE, stopping once a filter mode decodes correctly.
+        ;
+        private final int value;
+        private QRCellFilterMode(int value) {
+            this.value = value;
+        }
+        public static QRCellFilterMode fromValue(int val) {
+            for (QRCellFilterMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum RoundingMode {
+        ROUNDING_MODE_OPTIMIZE(0), // Rounds the result of a division using the best available method.
+        ROUNDING_MODE_TRUNCATE(1), // Truncates the result of a division.
+        ;
+        private final int value;
+        private RoundingMode(int value) {
+            this.value = value;
+        }
+        public static RoundingMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum QRDemodulationMode {
+        QR_DEMODULATION_MODE_AUTO_DETECT(-2), // The function will try each demodulation mode and use the one which decodes the QR code within the fewest iterations and utilizing the least amount of error correction.
+        QR_DEMODULATION_MODE_HISTOGRAM(0), // The function uses a histogram of all of the QR cells to calculate a threshold.
+        QR_DEMODULATION_MODE_LOCAL_CONTRAST(1), // The function examines each of the cell's neighbors to determine if the cell is on or off.
+        QR_DEMODULATION_MODE_COMBINED(2), // The function uses the histogram of the QR code to calculate a threshold.
+        QR_DEMODULATION_MODE_ALL(3), // The function tries IMAQ_QR_DEMODULATION_MODE_HISTOGRAM, then IMAQ_QR_DEMODULATION_MODE_LOCAL_CONTRAST and then IMAQ_QR_DEMODULATION_MODE_COMBINED, stopping once one mode is successful.
+        ;
+        private final int value;
+        private QRDemodulationMode(int value) {
+            this.value = value;
+        }
+        public static QRDemodulationMode fromValue(int val) {
+            for (QRDemodulationMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ContrastMode {
+        ORIGINAL_CONTRAST(0), // Instructs the geometric matching algorithm to find matches with the same contrast as the template.
+        REVERSED_CONTRAST(1), // Instructs the geometric matching algorithm to find matches with the inverted contrast of the template.
+        BOTH_CONTRASTS(2), // Instructs the geometric matching algorithm to find matches with the same and inverted contrast of the template.
+        ;
+        private final int value;
+        private ContrastMode(int value) {
+            this.value = value;
+        }
+        public static ContrastMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum QRPolarities {
+        QR_POLARITY_AUTO_DETECT(-2), // The function should determine the polarity of the QR code.
+        QR_POLARITY_BLACK_ON_WHITE(0), // The function should search for a QR code with dark data on a bright background.
+        QR_POLARITY_WHITE_ON_BLACK(1), // The function should search for a QR code with bright data on a dark background.
+        ;
+        private final int value;
+        private QRPolarities(int value) {
+            this.value = value;
+        }
+        public static QRPolarities fromValue(int val) {
+            for (QRPolarities v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum QRRotationMode {
+        QR_ROTATION_MODE_UNLIMITED(0), // The function allows for unlimited rotation.
+        QR_ROTATION_MODE_0_DEGREES(1), // The function allows for ??? 5 degrees of rotation.
+        QR_ROTATION_MODE_90_DEGREES(2), // The function allows for between 85 and 95 degrees of rotation.
+        QR_ROTATION_MODE_180_DEGREES(3), // The function allows for between 175 and 185 degrees of rotation.
+        QR_ROTATION_MODE_270_DEGREES(4), // The function allows for between 265 and 275 degrees of rotation.
+        ;
+        private final int value;
+        private QRRotationMode(int value) {
+            this.value = value;
+        }
+        public static QRRotationMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum QRGradingMode {
+        QR_NO_GRADING(0), // The function does not make any preparatory calculations.
+        ;
+        private final int value;
+        private QRGradingMode(int value) {
+            this.value = value;
+        }
+        public static QRGradingMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum StraightEdgeSearchMode {
+        USE_FIRST_RAKE_EDGES(0), // Fits a straight edge on the first points detected using a rake.
+        USE_BEST_RAKE_EDGES(1), // Fits a straight edge on the best points detected using a rake.
+        USE_BEST_HOUGH_LINE(2), // Finds the strongest straight edge using all points detected on a rake.
+        USE_FIRST_PROJECTION_EDGE(3), // Uses the location of the first projected edge as the straight edge.
+        USE_BEST_PROJECTION_EDGE(4), // Finds the strongest projected edge location to determine the straight edge.
+        ;
+        private final int value;
+        private StraightEdgeSearchMode(int value) {
+            this.value = value;
+        }
+        public static StraightEdgeSearchMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum SearchDirection {
+        SEARCH_DIRECTION_LEFT_TO_RIGHT(0), // Searches from the left side of the search area to the right side of the search area.
+        SEARCH_DIRECTION_RIGHT_TO_LEFT(1), // Searches from the right side of the search area to the left side of the search area.
+        SEARCH_DIRECTION_TOP_TO_BOTTOM(2), // Searches from the top side of the search area to the bottom side of the search area.
+        SEARCH_DIRECTION_BOTTOM_TO_TOP(3), // Searches from the bottom side of the search area to the top side of the search area.
+        ;
+        private final int value;
+        private SearchDirection(int value) {
+            this.value = value;
+        }
+        public static SearchDirection fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum QRStreamMode {
+        QR_MODE_NUMERIC(0), // Specifies that the data was encoded using numeric mode.
+        QR_MODE_ALPHANUMERIC(1), // Specifies that the data was encoded using alpha-numeric mode.
+        QR_MODE_RAW_BYTE(2), // Specifies that the data was not encoded but is only raw binary bytes, or encoded in JIS-8.
+        QR_MODE_EAN128_TOKEN(3), // Specifies that the data has a special meaning represented by the application ID.
+        QR_MODE_EAN128_DATA(4), // Specifies that the data has a special meaning represented by the application ID.
+        QR_MODE_ECI(5), // Specifies that the data was meant to be read using the language represented in the language ID.
+        QR_MODE_KANJI(6), // Specifies that the data was encoded in Shift-JIS16 Japanese.
+        ;
+        private final int value;
+        private QRStreamMode(int value) {
+            this.value = value;
+        }
+        public static QRStreamMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ParticleClassifierType {
+        PARTICLE_LARGEST(0), // Use only the largest particle in the image.
+        PARTICLE_ALL(1), // Use all particles in the image.
+        ;
+        private final int value;
+        private ParticleClassifierType(int value) {
+            this.value = value;
+        }
+        public static ParticleClassifierType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum QRCellSampleSize {
+        QR_CELL_SAMPLE_SIZE_AUTO_DETECT(-2), // The function will try each sample size and use the one which decodes the QR code within the fewest iterations and utilizing the least amount of error correction.
+        QR_CELL_SAMPLE_SIZE1X1(1), // The function will use a 1x1 sized sample from each cell.
+        QR_CELL_SAMPLE_SIZE2X2(2), // The function will use a 2x2 sized sample from each cell.
+        QR_CELL_SAMPLE_SIZE3X3(3), // The function will use a 3x3 sized sample from each cell.
+        QR_CELL_SAMPLE_SIZE4X4(4), // The function will use a 4x4 sized sample from each cell.
+        QR_CELL_SAMPLE_SIZE5X5(5), // The function will use a 5x5 sized sample from each cell.
+        QR_CELL_SAMPLE_SIZE6X6(6), // The function will use a 6x6 sized sample from each cell.
+        QR_CELL_SAMPLE_SIZE7X7(7), // The function will use a 7x7 sized sample from each cell.
+        ;
+        private final int value;
+        private QRCellSampleSize(int value) {
+            this.value = value;
+        }
+        public static QRCellSampleSize fromValue(int val) {
+            for (QRCellSampleSize v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum RakeProcessType {
+        GET_FIRST_EDGES(0),
+        GET_FIRST_AND_LAST_EDGES(1),
+        GET_ALL_EDGES(2),
+        GET_BEST_EDGES(3),
+        ;
+        private final int value;
+        private RakeProcessType(int value) {
+            this.value = value;
+        }
+        public static RakeProcessType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum GeometricSetupDataItem {
+        CURVE_EXTRACTION_MODE(0), // Specifies how the function identifies curves in the image.
+        CURVE_EDGE_THRSHOLD(1), // Specifies the minimum contrast an edge pixel must have for it to be considered part of a curve.
+        CURVE_EDGE_FILTER(2), // Specifies the width of the edge filter that the function uses to identify curves in the image.
+        MINIMUM_CURVE_LENGTH(3), // Specifies the length, in pixels, of the smallest curve that you want the function to identify.
+        CURVE_ROW_SEARCH_STEP_SIZE(4), // Specifies the distance, in the y direction, between the image rows that the algorithm inspects for curve seed points.
+        CURVE_COL_SEARCH_STEP_SIZE(5), // Specifies the distance, in the x direction, between the image columns that the algorithm inspects for curve seed points.
+        CURVE_MAX_END_POINT_GAP(6), // Specifies the maximum gap, in pixels, between the endpoints of a curve that the function identifies as a closed curve.
+        EXTRACT_CLOSED_CURVES(7), // Specifies whether to identify only closed curves in the image.
+        ENABLE_SUBPIXEL_CURVE_EXTRACTION(8), // The function ignores this option.
+        ENABLE_CORRELATION_SCORE(9), // Specifies that the function should calculate the Correlation Score and return it for each match result.
+        ENABLE_SUBPIXEL_ACCURACY(10), // Determines whether to return the match results with subpixel accuracy.
+        SUBPIXEL_ITERATIONS(11), // Specifies the maximum number of incremental improvements used to refine matches using subpixel information.
+        SUBPIXEL_TOLERANCE(12), // Specifies the maximum amount of change, in pixels, between consecutive incremental improvements in the match position before the function stops refining the match position.
+        INITIAL_MATCH_LIST_LENGTH(13), // Specifies the maximum size of the match list.
+        ENABLE_TARGET_TEMPLATE_CURVESCORE(14), // Specifies whether the function should calculate the match curve to template curve score and return it for each match result.
+        MINIMUM_MATCH_SEPARATION_DISTANCE(15), // Specifies the minimum separation distance, in pixels, between the origins of two matches that have unique positions.
+        MINIMUM_MATCH_SEPARATION_ANGLE(16), // Specifies the minimum angular difference, in degrees, between two matches that have unique angles.
+        MINIMUM_MATCH_SEPARATION_SCALE(17), // Specifies the minimum difference in scale, expressed as a percentage, between two matches that have unique scales.
+        MAXIMUM_MATCH_OVERLAP(18), // Specifies whether you want the algorithm to spend less time accurately estimating the location of a match.
+        ENABLE_COARSE_RESULT(19), // Specifies whether you want the algorithm to spend less time accurately estimating the location of a match.
+        ENABLE_CALIBRATION_SUPPORT(20), // Specifies whether or not the algorithm treat the inspection image as a calibrated image.
+        ENABLE_CONTRAST_REVERSAL(21), // Specifies the contrast of the matches to search for.
+        SEARCH_STRATEGY(22), // Specifies the aggressiveness of the strategy used to find matches in the image.
+        REFINEMENT_MATCH_FACTOR(23), // Specifies the factor applied to the number of matches requested to determine how many matches are refined in the pyramid stage.
+        SUBPIXEL_MATCH_FACTOR(24), // Specifies the factor applied to the number for matches requested to determine how many matches are used for the final (subpixel) stage.
+        MAX_REFINEMENT_ITERATIONS(25), // Specifies maximum refinement iteration.
+        ;
+        private final int value;
+        private GeometricSetupDataItem(int value) {
+            this.value = value;
+        }
+        public static GeometricSetupDataItem fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum DistortionModel {
+        POLYNOMIAL_MODEL(0), // Polynomial model.
+        DIVISION_MODEL(1), // Division Model.
+        NO_DISTORTION_MODEL(-1), // Not a distortion model.
+        ;
+        private final int value;
+        private DistortionModel(int value) {
+            this.value = value;
+        }
+        public static DistortionModel fromValue(int val) {
+            for (DistortionModel v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum CalibrationThumbnailType {
+        CAMARA_MODEL_TYPE(0), // Camara model thumbnail type.
+        PERSPECTIVE_TYPE(1), // Perspective thumbnail type.
+        MICRO_PLANE_TYPE(2), // Micro Plane thumbnail type.
+        ;
+        private final int value;
+        private CalibrationThumbnailType(int value) {
+            this.value = value;
+        }
+        public static CalibrationThumbnailType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum SettingType {
+        ROTATION_ANGLE_RANGE(0), // Set a range for this option to specify the angles at which you expect the Function to find template matches in the inspection image.
+        SCALE_RANGE(1), // Set a range for this option to specify the sizes at which you expect the Function to find template matches in the inspection image.
+        OCCLUSION_RANGE(2), // Set a range for this option to specify the amount of occlusion you expect for a match in the inspection image.
+        ;
+        private final int value;
+        private SettingType(int value) {
+            this.value = value;
+        }
+        public static SettingType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum SegmentationDistanceLevel {
+        SEGMENTATION_LEVEL_CONSERVATIVE(0), // Uses extensive criteria to determine the Maximum Distance.
+        SEGMENTATION_LEVEL_AGGRESSIVE(1), // Uses few criteria to determine the Maximum Distance.
+        ;
+        private final int value;
+        private SegmentationDistanceLevel(int value) {
+            this.value = value;
+        }
+        public static SegmentationDistanceLevel fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ExtractContourSelection {
+        CLOSEST(0), // Selects the curve closest to the ROI.
+        LONGEST(1), // Selects the longest curve.
+        STRONGEST(2), // Selects the curve with the highest edge strength averaged from each point on the curve.
+        ;
+        private final int value;
+        private ExtractContourSelection(int value) {
+            this.value = value;
+        }
+        public static ExtractContourSelection fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum FindTransformMode {
+        FIND_REFERENCE(0), // Update both parts of the coordinate system.
+        UPDATE_TRANSFORM(1), // Update only the new reference system.
+        ;
+        private final int value;
+        private FindTransformMode(int value) {
+            this.value = value;
+        }
+        public static FindTransformMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ExtractContourDirection {
+        RECT_LEFT_RIGHT(0), // Searches the ROI from left to right.
+        RECT_RIGHT_LEFT(1), // Searches the ROI from right to left.
+        RECT_TOP_BOTTOM(2), // Searches the ROI from top to bottom.
+        RECT_BOTTOM_TOP(3), // Searches the ROI from bottom to top.
+        ANNULUS_INNER_OUTER(4), // Searches the ROI from the inner radius to the outer radius.
+        ANNULUS_OUTER_INNER(5), // Searches the ROI from the outer radius to the inner radius.
+        ANNULUS_START_STOP(6), // Searches the ROI from start angle to end angle.
+        ANNULUS_STOP_START(7), // Searches the ROI from end angle to start angle.
+        ;
+        private final int value;
+        private ExtractContourDirection(int value) {
+            this.value = value;
+        }
+        public static ExtractContourDirection fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum EdgePolaritySearchMode {
+        SEARCH_FOR_ALL_EDGES(0), // Searches for all edges.
+        SEARCH_FOR_RISING_EDGES(1), // Searches for rising edges only.
+        SEARCH_FOR_FALLING_EDGES(2), // Searches for falling edges only.
+        ;
+        private final int value;
+        private EdgePolaritySearchMode(int value) {
+            this.value = value;
+        }
+        public static EdgePolaritySearchMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum Connectivity {
+        FOUR_CONNECTED(0), // Morphological reconstruction is performed in connectivity mode 4.
+        EIGHT_CONNECTED(1), // Morphological reconstruction is performed in connectivity mode 8.
+        ;
+        private final int value;
+        private Connectivity(int value) {
+            this.value = value;
+        }
+        public static Connectivity fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum MorphologyReconstructOperation {
+        DILATE_RECONSTRUCT(0), // Performs Reconstruction by dilation.
+        ERODE_RECONSTRUCT(1), // Performs Reconstruction by erosion.
+        ;
+        private final int value;
+        private MorphologyReconstructOperation(int value) {
+            this.value = value;
+        }
+        public static MorphologyReconstructOperation fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum WaveletType {
+        DB02(0),
+        DB03(1),
+        DB04(2), // Specifies the Wavelet Type as DB02.
+        DB05(3),
+        DB06(4),
+        DB07(5),
+        DB08(6),
+        DB09(7),
+        DB10(8),
+        DB11(9),
+        DB12(10),
+        DB13(11),
+        DB14(12),
+        HAAR(13),
+        BIOR1_3(14),
+        BIOR1_5(15),
+        BIOR2_2(16),
+        BIOR2_4(17),
+        BIOR2_6(18),
+        BIOR2_8(19),
+        BIOR3_1(20),
+        BIOR3_3(21),
+        BIOR3_5(22),
+        BIOR3_7(23),
+        BIOR3_9(24),
+        BIOR4_4(25),
+        COIF1(26),
+        COIF2(27),
+        COIF3(28),
+        COIF4(29),
+        COIF5(30),
+        SYM2(31),
+        SYM3(32),
+        SYM4(33),
+        SYM5(34),
+        SYM6(35),
+        SYM7(36),
+        SYM8(37),
+        BIOR5_5(38),
+        BIOR6_8(39),
+        ;
+        private final int value;
+        private WaveletType(int value) {
+            this.value = value;
+        }
+        public static WaveletType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ParticleClassifierThresholdType {
+        THRESHOLD_MANUAL(0), // The classifier performs a manual threshold on the image during preprocessing.
+        THRESHOLD_AUTO(1), // The classifier performs an auto threshold on the image during preprocessing.
+        THRESHOLD_LOCAL(2), // The classifier performs a local threshold on the image during preprocessing.
+        ;
+        private final int value;
+        private ParticleClassifierThresholdType(int value) {
+            this.value = value;
+        }
+        public static ParticleClassifierThresholdType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum MeasureParticlesCalibrationMode {
+        CALIBRATION_MODE_PIXEL(0), // The function takes only pixel measurements on the particles in the image.
+        CALIBRATION_MODE_CALIBRATED(1), // The function takes only calibrated measurements on the particles in the image.
+        CALIBRATION_MODE_BOTH(2), // The function takes both pixel and calibrated measurements on the particles in the image.
+        ;
+        private final int value;
+        private MeasureParticlesCalibrationMode(int value) {
+            this.value = value;
+        }
+        public static MeasureParticlesCalibrationMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum GeometricMatchingSearchStrategy {
+        GEOMETRIC_MATCHING_CONSERVATIVE(0), // Instructs the pattern matching algorithm to use the largest possible amount of information from the image at the expense of slowing down the speed of the algorithm.
+        GEOMETRIC_MATCHING_BALANCED(1), // Instructs the pattern matching algorithm to balance the amount of information from the image it uses with the speed of the algorithm.
+        GEOMETRIC_MATCHING_AGGRESSIVE(2), // Instructs the pattern matching algorithm to use a lower amount of information from the image, which allows the algorithm to run quickly but at the expense of accuracy.
+        ;
+        private final int value;
+        private GeometricMatchingSearchStrategy(int value) {
+            this.value = value;
+        }
+        public static GeometricMatchingSearchStrategy fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ColorClassificationResolution {
+        CLASSIFIER_LOW_RESOLUTION(0), // Low resolution version of the color classifier.
+        CLASSIFIER_MEDIUM_RESOLUTION(1), // Medium resolution version of the color classifier.
+        CLASSIFIER_HIGH_RESOLUTION(2), // High resolution version of the color classifier.
+        ;
+        private final int value;
+        private ColorClassificationResolution(int value) {
+            this.value = value;
+        }
+        public static ColorClassificationResolution fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ConnectionConstraintType {
+        DISTANCE_CONSTRAINT(0), // Specifies the distance, in pixels, within which the end points of two curves must lie in order to be considered part of a contour.
+        ANGLE_CONSTRAINT(1), // Specifies the range, in degrees, within which the difference between the angle of two curves, measured at the end points, must lie in order for the two curves to be considered part of a contour.
+        CONNECTIVITY_CONSTRAINT(2), // Specifies the distance, in pixels, within which a line extended from the end point of a curve must pass the end point of another curve in order for the two curves to be considered part of a contour.
+        GRADIENT_CONSTRAINT(3), // Specifies the range, in degrees, within which the gradient angles of two curves, measured at the end points, must lie in order for the two curves to be considered part of a contour.
+        NUM_CONNECTION_CONSTRAINT_TYPES(4), // .
+        ;
+        private final int value;
+        private ConnectionConstraintType(int value) {
+            this.value = value;
+        }
+        public static ConnectionConstraintType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum Barcode2DContrast {
+        ALL_BARCODE_2D_CONTRASTS(0), // The function searches for barcodes of each contrast type.
+        BLACK_ON_WHITE_BARCODE_2D(1), // The function searches for 2D barcodes containing black data on a white background.
+        WHITE_ON_BLACK_BARCODE_2D(2), // The function searches for 2D barcodes containing white data on a black background.
+        ;
+        private final int value;
+        private Barcode2DContrast(int value) {
+            this.value = value;
+        }
+        public static Barcode2DContrast fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum QRModelType {
+        QR_MODELTYPE_AUTO_DETECT(0), // Specifies that the function will auto-detect the type of QR code.
+        QR_MODELTYPE_MICRO(1), // Specifies the QR code is of a micro type.
+        QR_MODELTYPE_MODEL1(2), // Specifies the QR code is of a model1 type.
+        QR_MODELTYPE_MODEL2(3), // Specifies the QR code is of a model2 type.
+        ;
+        private final int value;
+        private QRModelType(int value) {
+            this.value = value;
+        }
+        public static QRModelType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum WindowBackgroundFillStyle {
+        FILL_STYLE_SOLID(0), // Fill the display window with a solid color.
+        FILL_STYLE_HATCH(2), // Fill the display window with a pattern defined by WindowBackgroundHatchStyle.
+        FILL_STYLE_DEFAULT(3), // Fill the display window with the NI Vision default pattern.
+        ;
+        private final int value;
+        private WindowBackgroundFillStyle(int value) {
+            this.value = value;
+        }
+        public static WindowBackgroundFillStyle fromValue(int val) {
+            for (WindowBackgroundFillStyle v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ExtractionMode {
+        NORMAL_IMAGE(0), // Specifies that the function makes no assumptions about the uniformity of objects in the image or the image background.
+        UNIFORM_REGIONS(1), // Specifies that the function assumes that either the objects in the image or the image background consists of uniform pixel values.
+        ;
+        private final int value;
+        private ExtractionMode(int value) {
+            this.value = value;
+        }
+        public static ExtractionMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum EdgeFilterSize {
+        FINE(0), // Specifies that the function uses a fine (narrow) edge filter.
+        NORMAL(1), // Specifies that the function uses a normal edge filter.
+        CONTOUR_TRACING(2), // Sets the Edge Filter Size to contour tracing, which provides the best results for contour extraction but increases the time required to process the image.
+        ;
+        private final int value;
+        private EdgeFilterSize(int value) {
+            this.value = value;
+        }
+        public static EdgeFilterSize fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum Barcode2DSearchMode {
+        SEARCH_MULTIPLE(0), // The function searches for multiple 2D barcodes.
+        SEARCH_SINGLE_CONSERVATIVE(1), // The function searches for 2D barcodes using the same searching algorithm as IMAQ_SEARCH_MULTIPLE but stops searching after locating one valid barcode.
+        SEARCH_SINGLE_AGGRESSIVE(2), // The function searches for a single 2D barcode using a method that assumes the barcode occupies a majority of the search region.
+        ;
+        private final int value;
+        private Barcode2DSearchMode(int value) {
+            this.value = value;
+        }
+        public static Barcode2DSearchMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum DataMatrixSubtype {
+        ALL_DATA_MATRIX_SUBTYPES(0), // The function searches for Data Matrix barcodes of all subtypes.
+        DATA_MATRIX_SUBTYPES_ECC_000_ECC_140(1), // The function searches for Data Matrix barcodes of subtypes ECC 000, ECC 050, ECC 080, ECC 100 and ECC 140.
+        DATA_MATRIX_SUBTYPE_ECC_200(2), // The function searches for Data Matrix ECC 200 barcodes.
+        ;
+        private final int value;
+        private DataMatrixSubtype(int value) {
+            this.value = value;
+        }
+        public static DataMatrixSubtype fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum FeatureType {
+        NOT_FOUND_FEATURE(0), // Specifies the feature is not found.
+        CIRCLE_FEATURE(1), // Specifies the feature is a circle.
+        ELLIPSE_FEATURE(2), // Specifies the feature is an ellipse.
+        CONST_CURVE_FEATURE(3), // Specifies the features is a constant curve.
+        RECTANGLE_FEATURE(4), // Specifies the feature is a rectangle.
+        LEG_FEATURE(5), // Specifies the feature is a leg.
+        CORNER_FEATURE(6), // Specifies the feature is a corner.
+        PARALLEL_LINE_PAIR_FEATURE(7), // Specifies the feature is a parallel line pair.
+        PAIR_OF_PARALLEL_LINE_PAIRS_FEATURE(8), // Specifies the feature is a pair of parallel line pairs.
+        LINE_FEATURE(9), // Specifies the feature is a line.
+        CLOSED_CURVE_FEATURE(10), // Specifies the feature is a closed curve.
+        ;
+        private final int value;
+        private FeatureType(int value) {
+            this.value = value;
+        }
+        public static FeatureType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum Barcode2DCellShape {
+        SQUARE_CELLS(0), // The function uses an algorithm for decoding the 2D barcode that works with square data cells.
+        ROUND_CELLS(1), // The function uses an algorithm for decoding the 2D barcode that works with round data cells.
+        ;
+        private final int value;
+        private Barcode2DCellShape(int value) {
+            this.value = value;
+        }
+        public static Barcode2DCellShape fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum LocalThresholdMethod {
+        NIBLACK(0), // The function computes thresholds for each pixel based on its local statistics using the Niblack local thresholding algorithm.
+        BACKGROUND_CORRECTION(1), // The function performs background correction first to eliminate non-uniform lighting effects, then performs thresholding using the Otsu thresholding algorithm.
+        ;
+        private final int value;
+        private LocalThresholdMethod(int value) {
+            this.value = value;
+        }
+        public static LocalThresholdMethod fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum Barcode2DType {
+        PDF417(0), // The 2D barcode is of type PDF417.
+        DATA_MATRIX_ECC_000(1), // The 2D barcode is of type Data Matrix ECC 000.
+        DATA_MATRIX_ECC_050(2), // The 2D barcode is of type Data Matrix ECC 050.
+        DATA_MATRIX_ECC_080(3), // The 2D barcode is of type Data Matrix ECC 080.
+        DATA_MATRIX_ECC_100(4), // The 2D barcode is of type Data Matrix ECC 100.
+        DATA_MATRIX_ECC_140(5), // The 2D barcode is of type Data Matrix ECC 140.
+        DATA_MATRIX_ECC_200(6), // The 2D barcode is of type Data Matrix ECC 200.
+        ;
+        private final int value;
+        private Barcode2DType(int value) {
+            this.value = value;
+        }
+        public static Barcode2DType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ClassifierEngineType {
+        ENGINE_NONE(0), // No engine has been set on this classifier session.
+        ENGINE_NEAREST_NEIGHBOR(1), // Nearest neighbor engine.
+        ENGINE_SUPPORT_VECTOR_MACHINE(2),
+        ;
+        private final int value;
+        private ClassifierEngineType(int value) {
+            this.value = value;
+        }
+        public static ClassifierEngineType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ClassifierType {
+        CLASSIFIER_CUSTOM(0), // The classifier session classifies vectors of doubles.
+        CLASSIFIER_PARTICLE(1), // The classifier session classifies particles in binary images.
+        CLASSIFIER_COLOR(2), // The classifier session classifies an image based on its color.
+        CLASSIFIER_TEXTURE(3), // The classifier session classifies an image based on its texture.
+        ;
+        private final int value;
+        private ClassifierType(int value) {
+            this.value = value;
+        }
+        public static ClassifierType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ParticleType {
+        PARTICLE_BRIGHT(0), // Bright particles.
+        PARTICLE_DARK(1), // Dark particles.
+        ;
+        private final int value;
+        private ParticleType(int value) {
+            this.value = value;
+        }
+        public static ParticleType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum VisionInfoType2 {
+        VISIONINFO_CALIBRATION(0x01), // Used to indicate interaction with the Calibration information in an image.
+        VISIONINFO_OVERLAY(0x02), // Used to indicate interaction with the Overlay information in an image.
+        VISIONINFO_GRAYTEMPLATE(0x04), // Used to indicate interaction with the grayscale template information in an image.
+        VISIONINFO_COLORTEMPLATE(0x08), // Used to indicate interaction with the color template information in an image.
+        VISIONINFO_GEOMETRICTEMPLATE(0x10), // Used to indicate interaction with the geometric template information in an image.
+        VISIONINFO_CUSTOMDATA(0x20), // Used to indicate interaction with the binary or text Custom Data in an image.
+        VISIONINFO_GOLDENTEMPLATE(0x40), // Used to indicate interaction with the golden template information in an image.
+        VISIONINFO_GEOMETRICTEMPLATE2(0x80), // Used to indicate interaction with the geometric template 2 information in an image.
+        VISIONINFO_ALL(0xFFFFFFFF), // Removes, checks for, or indicates the presence of all types of extra information in an image.
+        ;
+        private final int value;
+        private VisionInfoType2(int value) {
+            this.value = value;
+        }
+        public static VisionInfoType2 fromValue(int val) {
+            for (VisionInfoType2 v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum ReadClassifierFileMode {
+        CLASSIFIER_READ_ALL(0), // Read all information from the classifier file.
+        CLASSIFIER_READ_SAMPLES(1), // Read only the samples from the classifier file.
+        CLASSIFIER_READ_PROPERTIES(2), // Read only the properties from the classifier file.
+        ;
+        private final int value;
+        private ReadClassifierFileMode(int value) {
+            this.value = value;
+        }
+        public static ReadClassifierFileMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum WriteClassifierFileMode {
+        CLASSIFIER_WRITE_ALL(0), // Writes all information to the classifier file.
+        CLASSIFIER_WRITE_CLASSIFY_ONLY(1), // Write only the information needed to classify to the classifier file.
+        ;
+        private final int value;
+        private WriteClassifierFileMode(int value) {
+            this.value = value;
+        }
+        public static WriteClassifierFileMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum Barcode2DShape {
+        SQUARE_BARCODE_2D(0), // The function searches for square 2D barcodes.
+        RECTANGULAR_BARCODE_2D(1), // The function searches for rectangular 2D barcodes.
+        ;
+        private final int value;
+        private Barcode2DShape(int value) {
+            this.value = value;
+        }
+        public static Barcode2DShape fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum DataMatrixRotationMode {
+        UNLIMITED_ROTATION(0), // The function allows for unlimited rotation.
+        C0_DEGREES(1), // The function allows for between -5 and 5 degrees of rotation.
+        C90_DEGREES(2), // The function allows for between 85 and 95 degrees of rotation.
+        C180_DEGREES(3), // The function allows for between 175 and 185 degrees of rotation.
+        C270_DEGREES(4), // The function allows for between 265 and 275 degrees of rotation.
+        ;
+        private final int value;
+        private DataMatrixRotationMode(int value) {
+            this.value = value;
+        }
+        public static DataMatrixRotationMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum AIMGrade {
+        AIM_GRADE_F(0), // The Data Matrix barcode received a grade of F.
+        AIM_GRADE_D(1), // The Data Matrix barcode received a grade of D.
+        AIM_GRADE_C(2), // The Data Matrix barcode received a grade of C.
+        AIM_GRADE_B(3), // The Data Matrix barcode received a grade of B.
+        AIM_GRADE_A(4), // The Data Matrix barcode received a grade of A.
+        ;
+        private final int value;
+        private AIMGrade(int value) {
+            this.value = value;
+        }
+        public static AIMGrade fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum DataMatrixCellFillMode {
+        AUTO_DETECT_CELL_FILL_MODE(-2), // Sets the function to determine the Data Matrix barcode cell fill percentage automatically.
+        LOW_FILL(0), // Sets the function to read Data Matrix barcodes with a cell fill percentage of less than 30 percent.
+        NORMAL_FILL(1), // Sets the function to read Data Matrix barcodes with a cell fill percentage greater than or equal to 30 percent.
+        ;
+        private final int value;
+        private DataMatrixCellFillMode(int value) {
+            this.value = value;
+        }
+        public static DataMatrixCellFillMode fromValue(int val) {
+            for (DataMatrixCellFillMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum DataMatrixDemodulationMode {
+        AUTO_DETECT_DEMODULATION_MODE(-2), // The function will try each demodulation mode and use the one which decodes the Data Matrix barcode within the fewest iterations and utilizing the least amount of error correction.
+        HISTOGRAM(0), // The function uses a histogram of all of the Data Matrix cells to calculate a threshold.
+        LOCAL_CONTRAST(1), // The function examines each of the cell's neighbors to determine if the cell is on or off.
+        COMBINED(2), // The function uses the histogram of the Data Matrix barcode to calculate a threshold.
+        ALL_DEMODULATION_MODES(3), // The function tries IMAQ_HISTOGRAM, then IMAQ_LOCAL_CONTRAST and then IMAQ_COMBINATION, stopping once one mode is successful.
+        ;
+        private final int value;
+        private DataMatrixDemodulationMode(int value) {
+            this.value = value;
+        }
+        public static DataMatrixDemodulationMode fromValue(int val) {
+            for (DataMatrixDemodulationMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum DataMatrixECC {
+        AUTO_DETECT_ECC(-2), // Sets the function to determine the Data Matrix barcode ECC automatically.
+        ECC_000(0), // Sets the function to read Data Matrix barcodes of ECC 000 only.
+        ECC_050(50), // Sets the function to read Data Matrix barcodes of ECC 050 only.
+        ECC_080(80), // Sets the function to read Data Matrix barcodes of ECC 080 only.
+        ECC_100(100), // Sets the function to read Data Matrix barcodes of ECC 100 only.
+        ECC_140(140), // Sets the function to read Data Matrix barcodes of ECC 140 only.
+        ECC_000_140(190), // Sets the function to read Data Matrix barcodes of ECC 000, ECC 050, ECC 080, ECC 100, and ECC 140 only.
+        ECC_200(200), // Sets the function to read Data Matrix barcodes of ECC 200 only.
+        ;
+        private final int value;
+        private DataMatrixECC(int value) {
+            this.value = value;
+        }
+        public static DataMatrixECC fromValue(int val) {
+            for (DataMatrixECC v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum DataMatrixPolarity {
+        AUTO_DETECT_POLARITY(-2), // Sets the function to determine the Data Matrix barcode polarity automatically.
+        BLACK_DATA_ON_WHITE_BACKGROUND(0), // Sets the function to read Data Matrix barcodes with dark data on a bright background.
+        WHITE_DATA_ON_BLACK_BACKGROUND(1), // Sets the function to read Data Matrix barcodes with bright data on a dark background.
+        ;
+        private final int value;
+        private DataMatrixPolarity(int value) {
+            this.value = value;
+        }
+        public static DataMatrixPolarity fromValue(int val) {
+            for (DataMatrixPolarity v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum DataMatrixCellFilterMode {
+        AUTO_DETECT_CELL_FILTER_MODE(-2), // The function will try all filter modes and uses the one that decodes the Data Matrix barcode within the fewest iterations and utilizing the least amount of error correction.
+        AVERAGE_FILTER(0), // The function sets the pixel value for the cell to the average of the sampled pixels.
+        MEDIAN_FILTER(1), // The function sets the pixel value for the cell to the median of the sampled pixels.
+        CENTRAL_AVERAGE_FILTER(2), // The function sets the pixel value for the cell to the average of the pixels in the center of the cell sample.
+        HIGH_AVERAGE_FILTER(3), // The function sets the pixel value for the cell to the average value of the half of the sampled pixels with the highest pixel values.
+        LOW_AVERAGE_FILTER(4), // The function sets the pixel value for the cell to the average value of the half of the sampled pixels with the lowest pixel values.
+        VERY_HIGH_AVERAGE_FILTER(5), // The function sets the pixel value for the cell to the average value of the ninth of the sampled pixels with the highest pixel values.
+        VERY_LOW_AVERAGE_FILTER(6), // The function sets the pixel value for the cell to the average value of the ninth of the sampled pixels with the lowest pixel values.
+        ALL_CELL_FILTERS(8), // The function tries each filter mode, starting with IMAQ_AVERAGE_FILTER and ending with IMAQ_VERY_LOW_AVERAGE_FILTER, stopping once a filter mode decodes correctly.
+        ;
+        private final int value;
+        private DataMatrixCellFilterMode(int value) {
+            this.value = value;
+        }
+        public static DataMatrixCellFilterMode fromValue(int val) {
+            for (DataMatrixCellFilterMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum WindowBackgroundHatchStyle {
+        HATCH_STYLE_HORIZONTAL(0), // The background of the display window will be horizontal bars.
+        HATCH_STYLE_VERTICAL(1), // The background of the display window will be vertical bars.
+        HATCH_STYLE_FORWARD_DIAGONAL(2), // The background of the display window will be diagonal bars.
+        HATCH_STYLE_BACKWARD_DIAGONAL(3), // The background of the display window will be diagonal bars.
+        HATCH_STYLE_CROSS(4), // The background of the display window will be intersecting horizontal and vertical bars.
+        HATCH_STYLE_CROSS_HATCH(5), // The background of the display window will be intersecting forward and backward diagonal bars.
+        ;
+        private final int value;
+        private WindowBackgroundHatchStyle(int value) {
+            this.value = value;
+        }
+        public static WindowBackgroundHatchStyle fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum DataMatrixMirrorMode {
+        AUTO_DETECT_MIRROR(-2), // Specifies that the function should determine if the Data Matrix barcode is mirrored.
+        APPEARS_NORMAL(0), // Specifies that the function should expect the Data Matrix barcode to appear normal.
+        APPEARS_MIRRORED(1), // Specifies that the function should expect the Data Matrix barcode to appear mirrored.
+        ;
+        private final int value;
+        private DataMatrixMirrorMode(int value) {
+            this.value = value;
+        }
+        public static DataMatrixMirrorMode fromValue(int val) {
+            for (DataMatrixMirrorMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum CalibrationMode2 {
+        PERSPECTIVE_MODE(0), // Functions correct for distortion caused by the camera's perspective.
+        MICROPLANE_MODE(1), // Functions correct for distortion caused by the camera's lens.
+        SIMPLE_CALIBRATION_MODE(2), // Functions do not correct for distortion.
+        CORRECTED_IMAGE_MODE(3), // The image is already corrected.
+        NO_CALIBRATION_MODE(4), // Image with No calibration.
+        ;
+        private final int value;
+        private CalibrationMode2(int value) {
+            this.value = value;
+        }
+        public static CalibrationMode2 fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum DataMatrixGradingMode {
+        NO_GRADING(0), // The function does not make any preparatory calculations.
+        PREPARE_FOR_AIM(1), // The function prepares the image for grading using the AIM Print Quality metrics.
+        ;
+        private final int value;
+        private DataMatrixGradingMode(int value) {
+            this.value = value;
+        }
+        public static DataMatrixGradingMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum WaveletTransformMode {
+        WAVELET_TRANSFORM_INTEGER(0), // Uses a 5-3 reversible integer transform.
+        WAVELET_TRANSFORM_FLOATING_POINT(1), // Performs a 9-7 irreversible floating-point transform.
+        ;
+        private final int value;
+        private WaveletTransformMode(int value) {
+            this.value = value;
+        }
+        public static WaveletTransformMode fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum NormalizationMethod {
+        NORMALIZATION_NONE(0), // No normalization.
+        NORMALIZATION_HISTOGRAM_MATCHING(1), // Adjust image so its histogram is similar to the golden template's histogram.
+        NORMALIZATION_AVERAGE_MATCHING(2), // Adjust image so its mean pixel value equals the golden template's mean pixel value.
+        ;
+        private final int value;
+        private NormalizationMethod(int value) {
+            this.value = value;
+        }
+        public static NormalizationMethod fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum RegistrationMethod {
+        REGISTRATION_NONE(0), // No registration.
+        REGISTRATION_PERSPECTIVE(1), // Adjust image to correct for minor variations in alignment or perspective.
+        ;
+        private final int value;
+        private RegistrationMethod(int value) {
+            this.value = value;
+        }
+        public static RegistrationMethod fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum LinearAveragesMode {
+        COLUMN_AVERAGES(1), // Specifies that the function calculates the mean pixel value of each column.
+        ROW_AVERAGES(2), // Specifies that the function calculates the mean pixel value of each row.
+        RISING_DIAGONAL_AVERAGES(4), // Specifies that the function calculates the mean pixel value of each diagonal running from the lower left to the upper right of the inspected area of the image.
+        FALLING_DIAGONAL_AVERAGES(8), // Specifies that the function calculates the mean pixel value of each diagonal running from the upper left to the lower right of the inspected area of the image.
+        ALL_LINEAR_AVERAGES(15), // Specifies that the function calculates all four linear mean pixel values.
+        ;
+        private final int value;
+        private LinearAveragesMode(int value) {
+            this.value = value;
+        }
+        public static LinearAveragesMode fromValue(int val) {
+            for (LinearAveragesMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum CompressionType {
+        COMPRESSION_NONE(0), // Specifies that the function should not compress the image.
+        COMPRESSION_JPEG(1), // Specifies that the function should use lossy JPEG compression on the image.
+        COMPRESSION_PACKED_BINARY(2), // Specifies that the function should use lossless binary packing on the image.
+        ;
+        private final int value;
+        private CompressionType(int value) {
+            this.value = value;
+        }
+        public static CompressionType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum FlattenType {
+        FLATTEN_IMAGE(0), // Flattens just the image data.
+        FLATTEN_IMAGE_AND_VISION_INFO(1), // Flattens the image data and any Vision information associated with the image.
+        ;
+        private final int value;
+        private FlattenType(int value) {
+            this.value = value;
+        }
+        public static FlattenType fromValue(int val) {
+            try {
+                return values()[val];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return null;
+            }
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    public static enum DataMatrixCellSampleSize {
+        AUTO_DETECT_CELL_SAMPLE_SIZE(-2), // The function will try each sample size and use the one which decodes the Data Matrix barcode within the fewest iterations and utilizing the least amount of error correction.
+        ;
+        private final int value;
+        private DataMatrixCellSampleSize(int value) {
+            this.value = value;
+        }
+        public static DataMatrixCellSampleSize fromValue(int val) {
+            for (DataMatrixCellSampleSize v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Forward Declare Data Structures
+     */
+
+    /**
+     * Data Structures
+     */
+
+    public static class DivisionModel extends DisposedStruct {
+        public float kappa; // The learned kappa coefficient of division model.
+
+        private void init() {
+            
+        }
+        public DivisionModel() {
+            super(4);
+            init();
+        }
+        public DivisionModel(double kappa) {
+            super(4);
+            this.kappa = (float)kappa;
+        }
+        protected DivisionModel(ByteBuffer backing, int offset) {
+            super(backing, offset, 4);
+            init();
+        }
+        protected DivisionModel(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 4);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 4);
+        }
+        public void read() {
+            kappa = backing.getFloat(0);
+        }
+        public void write() {
+            backing.putFloat(0, kappa);
+        }
+        public int size() {
+            return 4;
+        }
+    }
+
+    public static class FocalLength extends DisposedStruct {
+        public float fx; // Focal length in X direction.
+        public float fy; // Focal length in Y direction.
+
+        private void init() {
+            
+        }
+        public FocalLength() {
+            super(8);
+            init();
+        }
+        public FocalLength(double fx, double fy) {
+            super(8);
+            this.fx = (float)fx;
+            this.fy = (float)fy;
+        }
+        protected FocalLength(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected FocalLength(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            fx = backing.getFloat(0);
+            fy = backing.getFloat(4);
+        }
+        public void write() {
+            backing.putFloat(0, fx);
+            backing.putFloat(4, fy);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class PolyModel extends DisposedStruct {
+        public float[] kCoeffs; // The learned radial coefficients of polynomial model.
+        public float p1; // The P1(learned tangential coefficients of polynomial model).
+        public float p2; // The P2(learned tangential coefficients of polynomial model).
+        private ByteBuffer kCoeffs_buf;
+
+        private void init() {
+            kCoeffs = new float[0];
+        }
+        public PolyModel() {
+            super(16);
+            init();
+        }
+        public PolyModel(float[] kCoeffs, double p1, double p2) {
+            super(16);
+            this.kCoeffs = kCoeffs;
+            this.p1 = (float)p1;
+            this.p2 = (float)p2;
+        }
+        protected PolyModel(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected PolyModel(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            int kCoeffs_numKCoeffs = backing.getInt(4);
+            long kCoeffs_addr = getPointer(backing, 0);
+            kCoeffs = new float[kCoeffs_numKCoeffs];
+            if (kCoeffs_numKCoeffs > 0 && kCoeffs_addr != 0) {
+                newDirectByteBuffer(kCoeffs_addr, kCoeffs_numKCoeffs*4).asFloatBuffer().get(kCoeffs);
+            }
+            p1 = backing.getFloat(8);
+            p2 = backing.getFloat(12);
+        }
+        public void write() {
+            kCoeffs_buf = ByteBuffer.allocateDirect(kCoeffs.length*4);
+            kCoeffs_buf.asFloatBuffer().put(kCoeffs).rewind();
+            backing.putInt(4, kCoeffs.length);
+            putPointer(backing, 0, kCoeffs_buf);
+            backing.putFloat(8, p1);
+            backing.putFloat(12, p2);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class DistortionModelParams extends DisposedStruct {
+        public DistortionModel distortionModel; // Type of learned distortion model.
+        public PolyModel polyModel; // The learned coefficients of polynomial model.
+        public DivisionModel divisionModel; // The learned coefficient of division model.
+
+        private void init() {
+            polyModel = new PolyModel(backing, 4);
+            divisionModel = new DivisionModel(backing, 20);
+        }
+        public DistortionModelParams() {
+            super(24);
+            init();
+        }
+        public DistortionModelParams(DistortionModel distortionModel, PolyModel polyModel, DivisionModel divisionModel) {
+            super(24);
+            this.distortionModel = distortionModel;
+            this.polyModel = polyModel;
+            this.divisionModel = divisionModel;
+        }
+        protected DistortionModelParams(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected DistortionModelParams(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            distortionModel = DistortionModel.fromValue(backing.getInt(0));
+            polyModel.read();
+            divisionModel.read();
+        }
+        public void write() {
+            if (distortionModel != null)
+                backing.putInt(0, distortionModel.getValue());
+            polyModel.write();
+            divisionModel.write();
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class PointFloat extends DisposedStruct {
+        public float x; // The x-coordinate of the point.
+        public float y; // The y-coordinate of the point.
+
+        private void init() {
+            
+        }
+        public PointFloat() {
+            super(8);
+            init();
+        }
+        public PointFloat(double x, double y) {
+            super(8);
+            this.x = (float)x;
+            this.y = (float)y;
+        }
+        protected PointFloat(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected PointFloat(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            x = backing.getFloat(0);
+            y = backing.getFloat(4);
+        }
+        public void write() {
+            backing.putFloat(0, x);
+            backing.putFloat(4, y);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class InternalParameters extends DisposedStruct {
+        public byte isInsufficientData;
+        public FocalLength focalLength;
+        public PointFloat opticalCenter;
+
+        private void init() {
+            focalLength = new FocalLength(backing, 4);
+            opticalCenter = new PointFloat(backing, 12);
+        }
+        public InternalParameters() {
+            super(20);
+            init();
+        }
+        public InternalParameters(byte isInsufficientData, FocalLength focalLength, PointFloat opticalCenter) {
+            super(20);
+            this.isInsufficientData = isInsufficientData;
+            this.focalLength = focalLength;
+            this.opticalCenter = opticalCenter;
+        }
+        protected InternalParameters(ByteBuffer backing, int offset) {
+            super(backing, offset, 20);
+            init();
+        }
+        protected InternalParameters(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 20);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 20);
+        }
+        public void read() {
+            isInsufficientData = backing.get(0);
+            focalLength.read();
+            opticalCenter.read();
+        }
+        public void write() {
+            backing.put(0, isInsufficientData);
+            focalLength.write();
+            opticalCenter.write();
+        }
+        public int size() {
+            return 20;
+        }
+    }
+
+    public static class MaxGridSize extends DisposedStruct {
+        public int xMax; // Maximum x limit for the grid size.
+        public int yMax; // Maximum y limit for the grid size.
+
+        private void init() {
+            
+        }
+        public MaxGridSize() {
+            super(8);
+            init();
+        }
+        public MaxGridSize(int xMax, int yMax) {
+            super(8);
+            this.xMax = xMax;
+            this.yMax = yMax;
+        }
+        protected MaxGridSize(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected MaxGridSize(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            xMax = backing.getInt(0);
+            yMax = backing.getInt(4);
+        }
+        public void write() {
+            backing.putInt(0, xMax);
+            backing.putInt(4, yMax);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class ImageSize extends DisposedStruct {
+        public int xRes; // X resolution of the image.
+        public int yRes; // Y resolution of the image.
+
+        private void init() {
+            
+        }
+        public ImageSize() {
+            super(8);
+            init();
+        }
+        public ImageSize(int xRes, int yRes) {
+            super(8);
+            this.xRes = xRes;
+            this.yRes = yRes;
+        }
+        protected ImageSize(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected ImageSize(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            xRes = backing.getInt(0);
+            yRes = backing.getInt(4);
+        }
+        public void write() {
+            backing.putInt(0, xRes);
+            backing.putInt(4, yRes);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class CalibrationReferencePoints extends DisposedStruct {
+        public PointDouble[] pixelCoords; // Specifies the coordinates of the pixel reference points.
+        public PointDouble[] realCoords; // Specifies the measuring unit associated with the image.
+        public CalibrationUnit units; // Specifies the units of X Step and Y Step.
+        public ImageSize imageSize; // Specifies the size of calibration template image.
+        private ByteBuffer pixelCoords_buf;
+        private ByteBuffer realCoords_buf;
+
+        private void init() {
+            pixelCoords = new PointDouble[0];
+            realCoords = new PointDouble[0];
+            imageSize = new ImageSize(backing, 20);
+        }
+        public CalibrationReferencePoints() {
+            super(28);
+            init();
+        }
+        public CalibrationReferencePoints(PointDouble[] pixelCoords, PointDouble[] realCoords, CalibrationUnit units, ImageSize imageSize) {
+            super(28);
+            this.pixelCoords = pixelCoords;
+            this.realCoords = realCoords;
+            this.units = units;
+            this.imageSize = imageSize;
+        }
+        protected CalibrationReferencePoints(ByteBuffer backing, int offset) {
+            super(backing, offset, 28);
+            init();
+        }
+        protected CalibrationReferencePoints(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 28);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 28);
+        }
+        public void read() {
+            int pixelCoords_numPixelCoords = backing.getInt(4);
+            long pixelCoords_addr = getPointer(backing, 0);
+            pixelCoords = new PointDouble[pixelCoords_numPixelCoords];
+            if (pixelCoords_numPixelCoords > 0 && pixelCoords_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(pixelCoords_addr, pixelCoords_numPixelCoords*16);
+                for (int i=0, off=0; i<pixelCoords_numPixelCoords; i++, off += 16) {
+                    pixelCoords[i] = new PointDouble(bb, off);
+                    pixelCoords[i].read();
+                }
+            }
+            int realCoords_numRealCoords = backing.getInt(12);
+            long realCoords_addr = getPointer(backing, 8);
+            realCoords = new PointDouble[realCoords_numRealCoords];
+            if (realCoords_numRealCoords > 0 && realCoords_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(realCoords_addr, realCoords_numRealCoords*16);
+                for (int i=0, off=0; i<realCoords_numRealCoords; i++, off += 16) {
+                    realCoords[i] = new PointDouble(bb, off);
+                    realCoords[i].read();
+                }
+            }
+            units = CalibrationUnit.fromValue(backing.getInt(16));
+            imageSize.read();
+        }
+        public void write() {
+            pixelCoords_buf = ByteBuffer.allocateDirect(pixelCoords.length*16);
+            for (int i=0, off=0; i<pixelCoords.length; i++, off += 16) {
+                pixelCoords[i].setBuffer(pixelCoords_buf, off);
+                pixelCoords[i].write();
+            }
+            backing.putInt(4, pixelCoords.length);
+            putPointer(backing, 0, pixelCoords_buf);
+            realCoords_buf = ByteBuffer.allocateDirect(realCoords.length*16);
+            for (int i=0, off=0; i<realCoords.length; i++, off += 16) {
+                realCoords[i].setBuffer(realCoords_buf, off);
+                realCoords[i].write();
+            }
+            backing.putInt(12, realCoords.length);
+            putPointer(backing, 8, realCoords_buf);
+            if (units != null)
+                backing.putInt(16, units.getValue());
+            imageSize.write();
+        }
+        public int size() {
+            return 28;
+        }
+    }
+
+    public static class GetCameraParametersReport extends DisposedStruct {
+        public int projectionMatrixRows; // Number of rows in projection matrix.
+        public int projectionMatrixCols; // Number of columns in projection matrix.
+        public DistortionModelParams distortion; // Distortion model Coefficients.
+        public InternalParameters internalParams; // The learned internal paramters of camera model such as focal length and optical center.
+
+        private void init() {
+            distortion = new DistortionModelParams(backing, 12);
+            internalParams = new InternalParameters(backing, 36);
+        }
+        public GetCameraParametersReport() {
+            super(56);
+            init();
+        }
+        public GetCameraParametersReport(int projectionMatrixRows, int projectionMatrixCols, DistortionModelParams distortion, InternalParameters internalParams) {
+            super(56);
+            this.projectionMatrixRows = projectionMatrixRows;
+            this.projectionMatrixCols = projectionMatrixCols;
+            this.distortion = distortion;
+            this.internalParams = internalParams;
+        }
+        protected GetCameraParametersReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 56);
+            init();
+        }
+        protected GetCameraParametersReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 56);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 56);
+        }
+        public void read() {
+            projectionMatrixRows = backing.getInt(4);
+            projectionMatrixCols = backing.getInt(8);
+            distortion.read();
+            internalParams.read();
+        }
+        public void write() {
+            backing.putInt(4, projectionMatrixRows);
+            backing.putInt(8, projectionMatrixCols);
+            distortion.write();
+            internalParams.write();
+        }
+        public int size() {
+            return 56;
+        }
+    }
+
+    public static class CalibrationAxisInfo extends DisposedStruct {
+        public PointFloat center; // The origin of the reference coordinate system, expressed in pixel units.
+        public float rotationAngle; // The angle of the x-axis of the real-world coordinate system, in relation to the horizontal.
+        public AxisOrientation axisDirection; // Specifies the direction of the calibraiton axis which is either Direct or Indirect.
+
+        private void init() {
+            center = new PointFloat(backing, 0);
+        }
+        public CalibrationAxisInfo() {
+            super(16);
+            init();
+        }
+        public CalibrationAxisInfo(PointFloat center, double rotationAngle, AxisOrientation axisDirection) {
+            super(16);
+            this.center = center;
+            this.rotationAngle = (float)rotationAngle;
+            this.axisDirection = axisDirection;
+        }
+        protected CalibrationAxisInfo(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected CalibrationAxisInfo(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            center.read();
+            rotationAngle = backing.getFloat(8);
+            axisDirection = AxisOrientation.fromValue(backing.getInt(12));
+        }
+        public void write() {
+            center.write();
+            backing.putFloat(8, rotationAngle);
+            if (axisDirection != null)
+                backing.putInt(12, axisDirection.getValue());
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class CalibrationLearnSetupInfo extends DisposedStruct {
+        public CalibrationMode2 calibrationMethod; // Type of calibration method used.
+        public DistortionModel distortionModel; // Type of learned distortion model.
+        public ScalingMethod scaleMode; // The aspect scaling to use when correcting an image.
+        public CalibrationROI roiMode; // The ROI to use when correcting an image.
+        public byte learnCorrectionTable; // Set this input to true value if you want the correction table to be determined and stored.
+
+        private void init() {
+            
+        }
+        public CalibrationLearnSetupInfo() {
+            super(20);
+            init();
+        }
+        public CalibrationLearnSetupInfo(CalibrationMode2 calibrationMethod, DistortionModel distortionModel, ScalingMethod scaleMode, CalibrationROI roiMode, byte learnCorrectionTable) {
+            super(20);
+            this.calibrationMethod = calibrationMethod;
+            this.distortionModel = distortionModel;
+            this.scaleMode = scaleMode;
+            this.roiMode = roiMode;
+            this.learnCorrectionTable = learnCorrectionTable;
+        }
+        protected CalibrationLearnSetupInfo(ByteBuffer backing, int offset) {
+            super(backing, offset, 20);
+            init();
+        }
+        protected CalibrationLearnSetupInfo(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 20);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 20);
+        }
+        public void read() {
+            calibrationMethod = CalibrationMode2.fromValue(backing.getInt(0));
+            distortionModel = DistortionModel.fromValue(backing.getInt(4));
+            scaleMode = ScalingMethod.fromValue(backing.getInt(8));
+            roiMode = CalibrationROI.fromValue(backing.getInt(12));
+            learnCorrectionTable = backing.get(16);
+        }
+        public void write() {
+            if (calibrationMethod != null)
+                backing.putInt(0, calibrationMethod.getValue());
+            if (distortionModel != null)
+                backing.putInt(4, distortionModel.getValue());
+            if (scaleMode != null)
+                backing.putInt(8, scaleMode.getValue());
+            if (roiMode != null)
+                backing.putInt(12, roiMode.getValue());
+            backing.put(16, learnCorrectionTable);
+        }
+        public int size() {
+            return 20;
+        }
+    }
+
+    public static class GridDescriptor extends DisposedStruct {
+        public float xStep; // The distance in the x direction between two adjacent pixels in units specified by unit.
+        public float yStep; // The distance in the y direction between two adjacent pixels in units specified by unit.
+        public CalibrationUnit unit; // The unit of measure for the image.
+
+        private void init() {
+            
+        }
+        public GridDescriptor() {
+            super(12);
+            init();
+        }
+        public GridDescriptor(double xStep, double yStep, CalibrationUnit unit) {
+            super(12);
+            this.xStep = (float)xStep;
+            this.yStep = (float)yStep;
+            this.unit = unit;
+        }
+        protected GridDescriptor(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected GridDescriptor(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            xStep = backing.getFloat(0);
+            yStep = backing.getFloat(4);
+            unit = CalibrationUnit.fromValue(backing.getInt(8));
+        }
+        public void write() {
+            backing.putFloat(0, xStep);
+            backing.putFloat(4, yStep);
+            if (unit != null)
+                backing.putInt(8, unit.getValue());
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class ErrorStatistics extends DisposedStruct {
+        public double mean; // Mean error statistics value.
+        public double maximum; // Maximum value of error.
+        public double standardDeviation; // The standard deviation error statistiscs value.
+        public double distortion; // The distortion error statistics value.
+
+        private void init() {
+            
+        }
+        public ErrorStatistics() {
+            super(32);
+            init();
+        }
+        public ErrorStatistics(double mean, double maximum, double standardDeviation, double distortion) {
+            super(32);
+            this.mean = mean;
+            this.maximum = maximum;
+            this.standardDeviation = standardDeviation;
+            this.distortion = distortion;
+        }
+        protected ErrorStatistics(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected ErrorStatistics(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            mean = backing.getDouble(0);
+            maximum = backing.getDouble(8);
+            standardDeviation = backing.getDouble(16);
+            distortion = backing.getDouble(24);
+        }
+        public void write() {
+            backing.putDouble(0, mean);
+            backing.putDouble(8, maximum);
+            backing.putDouble(16, standardDeviation);
+            backing.putDouble(24, distortion);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class GetCalibrationInfoReport extends DisposedStruct {
+        public ROI userRoi; // Specifies the ROI the user provided when learning the calibration.
+        public ROI calibrationRoi; // Specifies the ROI that corresponds to the region of the image where the calibration information is accurate.
+        public CalibrationAxisInfo axisInfo; // Reference Coordinate System for the real-world coordinates.
+        public CalibrationLearnSetupInfo learnSetupInfo; // Calibration learn setup information.
+        public GridDescriptor gridDescriptor; // Specifies scaling constants used to calibrate the image.
+        public int errorMapRows; // Number of rows in error map.
+        public int errorMapCols; // Number of Columns in error map.
+        public ErrorStatistics errorStatistics; // Error statistics of the calibration.
+
+        private void init() {
+            axisInfo = new CalibrationAxisInfo(backing, 8);
+            learnSetupInfo = new CalibrationLearnSetupInfo(backing, 24);
+            gridDescriptor = new GridDescriptor(backing, 44);
+            errorStatistics = new ErrorStatistics(backing, 72);
+        }
+        public GetCalibrationInfoReport() {
+            super(104);
+            init();
+        }
+        public GetCalibrationInfoReport(ROI userRoi, ROI calibrationRoi, CalibrationAxisInfo axisInfo, CalibrationLearnSetupInfo learnSetupInfo, GridDescriptor gridDescriptor, int errorMapRows, int errorMapCols, ErrorStatistics errorStatistics) {
+            super(104);
+            this.userRoi = userRoi;
+            this.calibrationRoi = calibrationRoi;
+            this.axisInfo = axisInfo;
+            this.learnSetupInfo = learnSetupInfo;
+            this.gridDescriptor = gridDescriptor;
+            this.errorMapRows = errorMapRows;
+            this.errorMapCols = errorMapCols;
+            this.errorStatistics = errorStatistics;
+        }
+        protected GetCalibrationInfoReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 104);
+            init();
+        }
+        protected GetCalibrationInfoReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 104);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 104);
+        }
+        public void read() {
+            long userRoi_addr = getPointer(backing, 0);
+            if (userRoi_addr == 0)
+                userRoi = null;
+            else
+                userRoi = new ROI(userRoi_addr, false);
+            long calibrationRoi_addr = getPointer(backing, 4);
+            if (calibrationRoi_addr == 0)
+                calibrationRoi = null;
+            else
+                calibrationRoi = new ROI(calibrationRoi_addr, false);
+            axisInfo.read();
+            learnSetupInfo.read();
+            gridDescriptor.read();
+            errorMapRows = backing.getInt(60);
+            errorMapCols = backing.getInt(64);
+            errorStatistics.read();
+        }
+        public void write() {
+            putPointer(backing, 0, userRoi);
+            putPointer(backing, 4, calibrationRoi);
+            axisInfo.write();
+            learnSetupInfo.write();
+            gridDescriptor.write();
+            backing.putInt(60, errorMapRows);
+            backing.putInt(64, errorMapCols);
+            errorStatistics.write();
+        }
+        public int size() {
+            return 104;
+        }
+    }
+
+    public static class EdgePolarity extends DisposedStruct {
+        public EdgePolaritySearchMode start;
+        public EdgePolaritySearchMode end;
+
+        private void init() {
+            
+        }
+        public EdgePolarity() {
+            super(8);
+            init();
+        }
+        public EdgePolarity(EdgePolaritySearchMode start, EdgePolaritySearchMode end) {
+            super(8);
+            this.start = start;
+            this.end = end;
+        }
+        protected EdgePolarity(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected EdgePolarity(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            start = EdgePolaritySearchMode.fromValue(backing.getInt(0));
+            end = EdgePolaritySearchMode.fromValue(backing.getInt(4));
+        }
+        public void write() {
+            if (start != null)
+                backing.putInt(0, start.getValue());
+            if (end != null)
+                backing.putInt(4, end.getValue());
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class ClampSettings extends DisposedStruct {
+        public double angleRange; // Specifies the angle range.
+        public EdgePolarity edgePolarity; // Specifies the edge polarity.
+
+        private void init() {
+            edgePolarity = new EdgePolarity(backing, 8);
+        }
+        public ClampSettings() {
+            super(16);
+            init();
+        }
+        public ClampSettings(double angleRange, EdgePolarity edgePolarity) {
+            super(16);
+            this.angleRange = angleRange;
+            this.edgePolarity = edgePolarity;
+        }
+        protected ClampSettings(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected ClampSettings(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            angleRange = backing.getDouble(0);
+            edgePolarity.read();
+        }
+        public void write() {
+            backing.putDouble(0, angleRange);
+            edgePolarity.write();
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class PointDouble extends DisposedStruct {
+        public double x; // The x-coordinate of the point.
+        public double y; // The y-coordinate of the point.
+
+        private void init() {
+            
+        }
+        public PointDouble() {
+            super(16);
+            init();
+        }
+        public PointDouble(double x, double y) {
+            super(16);
+            this.x = x;
+            this.y = y;
+        }
+        protected PointDouble(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected PointDouble(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            x = backing.getDouble(0);
+            y = backing.getDouble(8);
+        }
+        public void write() {
+            backing.putDouble(0, x);
+            backing.putDouble(8, y);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class PointDoublePair extends DisposedStruct {
+        public PointDouble start; // The Start co-ordinate of the pair.
+        public PointDouble end; // The End co-ordinate of the pair.
+
+        private void init() {
+            start = new PointDouble(backing, 0);
+            end = new PointDouble(backing, 16);
+        }
+        public PointDoublePair() {
+            super(32);
+            init();
+        }
+        public PointDoublePair(PointDouble start, PointDouble end) {
+            super(32);
+            this.start = start;
+            this.end = end;
+        }
+        protected PointDoublePair(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected PointDoublePair(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            start.read();
+            end.read();
+        }
+        public void write() {
+            start.write();
+            end.write();
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class ClampResults extends DisposedStruct {
+        public double distancePix; // Defines the Pixel world distance.
+        public double distanceRealWorld; // Defines the real world distance.
+        public double angleAbs; // Defines the absolute angle.
+        public double angleRelative; // Defines the relative angle.
+
+        private void init() {
+            
+        }
+        public ClampResults() {
+            super(32);
+            init();
+        }
+        public ClampResults(double distancePix, double distanceRealWorld, double angleAbs, double angleRelative) {
+            super(32);
+            this.distancePix = distancePix;
+            this.distanceRealWorld = distanceRealWorld;
+            this.angleAbs = angleAbs;
+            this.angleRelative = angleRelative;
+        }
+        protected ClampResults(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected ClampResults(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            distancePix = backing.getDouble(0);
+            distanceRealWorld = backing.getDouble(8);
+            angleAbs = backing.getDouble(16);
+            angleRelative = backing.getDouble(24);
+        }
+        public void write() {
+            backing.putDouble(0, distancePix);
+            backing.putDouble(8, distanceRealWorld);
+            backing.putDouble(16, angleAbs);
+            backing.putDouble(24, angleRelative);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class ClampPoints extends DisposedStruct {
+        public PointDoublePair pixel; // Specifies the pixel world point pair for clamp.
+        public PointDoublePair realWorld; // Specifies the real world point pair for clamp.
+
+        private void init() {
+            pixel = new PointDoublePair(backing, 0);
+            realWorld = new PointDoublePair(backing, 32);
+        }
+        public ClampPoints() {
+            super(64);
+            init();
+        }
+        public ClampPoints(PointDoublePair pixel, PointDoublePair realWorld) {
+            super(64);
+            this.pixel = pixel;
+            this.realWorld = realWorld;
+        }
+        protected ClampPoints(ByteBuffer backing, int offset) {
+            super(backing, offset, 64);
+            init();
+        }
+        protected ClampPoints(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 64);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 64);
+        }
+        public void read() {
+            pixel.read();
+            realWorld.read();
+        }
+        public void write() {
+            pixel.write();
+            realWorld.write();
+        }
+        public int size() {
+            return 64;
+        }
+    }
+
+    public static class RGBValue extends DisposedStruct {
+        public short B; // The blue value of the color.
+        public short G; // The green value of the color.
+        public short R; // The red value of the color.
+        public short alpha; // The alpha value of the color, which represents extra information about a color image, such as gamma correction.
+
+        private void init() {
+            
+        }
+        public RGBValue() {
+            super(4);
+            init();
+        }
+        public RGBValue(int B, int G, int R, int alpha) {
+            super(4);
+            this.B = (short)B;
+            this.G = (short)G;
+            this.R = (short)R;
+            this.alpha = (short)alpha;
+        }
+        protected RGBValue(ByteBuffer backing, int offset) {
+            super(backing, offset, 4);
+            init();
+        }
+        protected RGBValue(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 4);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 4);
+        }
+        public void read() {
+            B = backing.getShort(0);
+            G = backing.getShort(1);
+            R = backing.getShort(2);
+            alpha = backing.getShort(3);
+        }
+        public void write() {
+            backing.putShort(0, B);
+            backing.putShort(1, G);
+            backing.putShort(2, R);
+            backing.putShort(3, alpha);
+        }
+        public int size() {
+            return 4;
+        }
+    }
+
+    public static class ClampOverlaySettings extends DisposedStruct {
+        public int showSearchArea; // If TRUE, the function overlays the search area on the image.
+        public int showCurves; // If TRUE, the function overlays the curves on the image.
+        public int showClampLocation; // If TRUE, the function overlays the clamp location on the image.
+        public int showResult; // If TRUE, the function overlays the hit lines to the object and the edge used to generate the hit line on the result image.
+        public RGBValue searchAreaColor; // Specifies the RGB color value to use to overlay the search area.
+        public RGBValue curvesColor; // Specifies the RGB color value to use to overlay the curves.
+        public RGBValue clampLocationsColor; // Specifies the RGB color value to use to overlay the clamp locations.
+        public RGBValue resultColor; // Specifies the RGB color value to use to overlay the results.
+        public String overlayGroupName; // Specifies the group overlay name for the step overlays.
+        private ByteBuffer overlayGroupName_buf;
+
+        private void init() {
+            searchAreaColor = new RGBValue(backing, 16);
+            curvesColor = new RGBValue(backing, 20);
+            clampLocationsColor = new RGBValue(backing, 24);
+            resultColor = new RGBValue(backing, 28);
+        }
+        public ClampOverlaySettings() {
+            super(36);
+            init();
+        }
+        public ClampOverlaySettings(int showSearchArea, int showCurves, int showClampLocation, int showResult, RGBValue searchAreaColor, RGBValue curvesColor, RGBValue clampLocationsColor, RGBValue resultColor, String overlayGroupName) {
+            super(36);
+            this.showSearchArea = showSearchArea;
+            this.showCurves = showCurves;
+            this.showClampLocation = showClampLocation;
+            this.showResult = showResult;
+            this.searchAreaColor = searchAreaColor;
+            this.curvesColor = curvesColor;
+            this.clampLocationsColor = clampLocationsColor;
+            this.resultColor = resultColor;
+            this.overlayGroupName = overlayGroupName;
+        }
+        protected ClampOverlaySettings(ByteBuffer backing, int offset) {
+            super(backing, offset, 36);
+            init();
+        }
+        protected ClampOverlaySettings(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 36);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 36);
+        }
+        public void read() {
+            showSearchArea = backing.getInt(0);
+            showCurves = backing.getInt(4);
+            showClampLocation = backing.getInt(8);
+            showResult = backing.getInt(12);
+            searchAreaColor.read();
+            curvesColor.read();
+            clampLocationsColor.read();
+            resultColor.read();
+            long overlayGroupName_addr = getPointer(backing, 32);
+            if (overlayGroupName_addr == 0)
+                overlayGroupName = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(overlayGroupName_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    overlayGroupName = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    overlayGroupName = "";
+                }
+            }
+            
+        }
+        public void write() {
+            backing.putInt(0, showSearchArea);
+            backing.putInt(4, showCurves);
+            backing.putInt(8, showClampLocation);
+            backing.putInt(12, showResult);
+            searchAreaColor.write();
+            curvesColor.write();
+            clampLocationsColor.write();
+            resultColor.write();
+            if (overlayGroupName != null) {
+                byte[] overlayGroupName_bytes;
+                try {
+                    overlayGroupName_bytes = overlayGroupName.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    overlayGroupName_bytes = new byte[0];
+                }
+                overlayGroupName_buf = ByteBuffer.allocateDirect(overlayGroupName_bytes.length+1);
+                putBytes(overlayGroupName_buf, overlayGroupName_bytes, 0, overlayGroupName_bytes.length).put(overlayGroupName_bytes.length, (byte)0);
+            }
+            putPointer(backing, 32, overlayGroupName == null ? 0 : getByteBufferAddress(overlayGroupName_buf));
+        }
+        public int size() {
+            return 36;
+        }
+    }
+
+    public static class ClampMax2Report extends DisposedStruct {
+        public ClampResults clampResults; // Specifies the Clamp results information returned by the function.
+        public ClampPoints clampPoints; // Specifies the clamp points information returned by the function.
+        public int calibrationValid; // Specifies if the calibration information is valid or not.
+
+        private void init() {
+            clampResults = new ClampResults(backing, 0);
+            clampPoints = new ClampPoints(backing, 32);
+        }
+        public ClampMax2Report() {
+            super(104);
+            init();
+        }
+        public ClampMax2Report(ClampResults clampResults, ClampPoints clampPoints, int calibrationValid) {
+            super(104);
+            this.clampResults = clampResults;
+            this.clampPoints = clampPoints;
+            this.calibrationValid = calibrationValid;
+        }
+        protected ClampMax2Report(ByteBuffer backing, int offset) {
+            super(backing, offset, 104);
+            init();
+        }
+        protected ClampMax2Report(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 104);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 104);
+        }
+        public void read() {
+            clampResults.read();
+            clampPoints.read();
+            calibrationValid = backing.getInt(96);
+        }
+        public void write() {
+            clampResults.write();
+            clampPoints.write();
+            backing.putInt(96, calibrationValid);
+        }
+        public int size() {
+            return 104;
+        }
+    }
+
+    public static class ContourFitSplineReport extends DisposedStruct {
+        public PointDouble[] points; // It returns the points of the best-fit B-spline curve.
+        private ByteBuffer points_buf;
+
+        private void init() {
+            points = new PointDouble[0];
+        }
+        public ContourFitSplineReport() {
+            super(8);
+            init();
+        }
+        public ContourFitSplineReport(PointDouble[] points) {
+            super(8);
+            this.points = points;
+        }
+        protected ContourFitSplineReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected ContourFitSplineReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            int points_numberOfPoints = backing.getInt(4);
+            long points_addr = getPointer(backing, 0);
+            points = new PointDouble[points_numberOfPoints];
+            if (points_numberOfPoints > 0 && points_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(points_addr, points_numberOfPoints*16);
+                for (int i=0, off=0; i<points_numberOfPoints; i++, off += 16) {
+                    points[i] = new PointDouble(bb, off);
+                    points[i].read();
+                }
+            }
+        }
+        public void write() {
+            points_buf = ByteBuffer.allocateDirect(points.length*16);
+            for (int i=0, off=0; i<points.length; i++, off += 16) {
+                points[i].setBuffer(points_buf, off);
+                points[i].write();
+            }
+            backing.putInt(4, points.length);
+            putPointer(backing, 0, points_buf);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class LineFloat extends DisposedStruct {
+        public PointFloat start; // The coordinate location of the start of the line.
+        public PointFloat end; // The coordinate location of the end of the line.
+
+        private void init() {
+            start = new PointFloat(backing, 0);
+            end = new PointFloat(backing, 8);
+        }
+        public LineFloat() {
+            super(16);
+            init();
+        }
+        public LineFloat(PointFloat start, PointFloat end) {
+            super(16);
+            this.start = start;
+            this.end = end;
+        }
+        protected LineFloat(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected LineFloat(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            start.read();
+            end.read();
+        }
+        public void write() {
+            start.write();
+            end.write();
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class LineEquation extends DisposedStruct {
+        public double a; // The a coefficient of the line equation.
+        public double b; // The b coefficient of the line equation.
+        public double c; // The c coefficient of the line equation.
+
+        private void init() {
+            
+        }
+        public LineEquation() {
+            super(24);
+            init();
+        }
+        public LineEquation(double a, double b, double c) {
+            super(24);
+            this.a = a;
+            this.b = b;
+            this.c = c;
+        }
+        protected LineEquation(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected LineEquation(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            a = backing.getDouble(0);
+            b = backing.getDouble(8);
+            c = backing.getDouble(16);
+        }
+        public void write() {
+            backing.putDouble(0, a);
+            backing.putDouble(8, b);
+            backing.putDouble(16, c);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class ContourFitLineReport extends DisposedStruct {
+        public LineFloat lineSegment; // Line Segment represents the intersection of the line equation and the contour.
+        public LineEquation lineEquation; // Line Equation is a structure of three coefficients A, B, and C of the equation in the normal form (Ax + By + C=0) of the best fit line.
+
+        private void init() {
+            lineSegment = new LineFloat(backing, 0);
+            lineEquation = new LineEquation(backing, 16);
+        }
+        public ContourFitLineReport() {
+            super(40);
+            init();
+        }
+        public ContourFitLineReport(LineFloat lineSegment, LineEquation lineEquation) {
+            super(40);
+            this.lineSegment = lineSegment;
+            this.lineEquation = lineEquation;
+        }
+        protected ContourFitLineReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 40);
+            init();
+        }
+        protected ContourFitLineReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 40);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 40);
+        }
+        public void read() {
+            lineSegment.read();
+            lineEquation.read();
+        }
+        public void write() {
+            lineSegment.write();
+            lineEquation.write();
+        }
+        public int size() {
+            return 40;
+        }
+    }
+
+    public static class ContourFitPolynomialReport extends DisposedStruct {
+        public PointDouble[] bestFit; // It returns the points of the best-fit polynomial.
+        public double[] polynomialCoefficients; // Polynomial Coefficients returns the coefficients of the polynomial equation.
+        private ByteBuffer bestFit_buf;
+        private ByteBuffer polynomialCoefficients_buf;
+
+        private void init() {
+            bestFit = new PointDouble[0];
+            polynomialCoefficients = new double[0];
+        }
+        public ContourFitPolynomialReport() {
+            super(16);
+            init();
+        }
+        public ContourFitPolynomialReport(PointDouble[] bestFit, double[] polynomialCoefficients) {
+            super(16);
+            this.bestFit = bestFit;
+            this.polynomialCoefficients = polynomialCoefficients;
+        }
+        protected ContourFitPolynomialReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected ContourFitPolynomialReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            int bestFit_numberOfPoints = backing.getInt(4);
+            long bestFit_addr = getPointer(backing, 0);
+            bestFit = new PointDouble[bestFit_numberOfPoints];
+            if (bestFit_numberOfPoints > 0 && bestFit_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(bestFit_addr, bestFit_numberOfPoints*16);
+                for (int i=0, off=0; i<bestFit_numberOfPoints; i++, off += 16) {
+                    bestFit[i] = new PointDouble(bb, off);
+                    bestFit[i].read();
+                }
+            }
+            int polynomialCoefficients_numberOfCoefficients = backing.getInt(12);
+            long polynomialCoefficients_addr = getPointer(backing, 8);
+            polynomialCoefficients = new double[polynomialCoefficients_numberOfCoefficients];
+            if (polynomialCoefficients_numberOfCoefficients > 0 && polynomialCoefficients_addr != 0) {
+                newDirectByteBuffer(polynomialCoefficients_addr, polynomialCoefficients_numberOfCoefficients*8).asDoubleBuffer().get(polynomialCoefficients);
+            }
+        }
+        public void write() {
+            bestFit_buf = ByteBuffer.allocateDirect(bestFit.length*16);
+            for (int i=0, off=0; i<bestFit.length; i++, off += 16) {
+                bestFit[i].setBuffer(bestFit_buf, off);
+                bestFit[i].write();
+            }
+            backing.putInt(4, bestFit.length);
+            putPointer(backing, 0, bestFit_buf);
+            polynomialCoefficients_buf = ByteBuffer.allocateDirect(polynomialCoefficients.length*8);
+            polynomialCoefficients_buf.asDoubleBuffer().put(polynomialCoefficients).rewind();
+            backing.putInt(12, polynomialCoefficients.length);
+            putPointer(backing, 8, polynomialCoefficients_buf);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class PartialCircle extends DisposedStruct {
+        public PointFloat center; // Center of the circle.
+        public double radius; // Radius of the circle.
+        public double startAngle; // Start angle of the fitted structure.
+        public double endAngle; // End angle of the fitted structure.
+
+        private void init() {
+            center = new PointFloat(backing, 0);
+        }
+        public PartialCircle() {
+            super(32);
+            init();
+        }
+        public PartialCircle(PointFloat center, double radius, double startAngle, double endAngle) {
+            super(32);
+            this.center = center;
+            this.radius = radius;
+            this.startAngle = startAngle;
+            this.endAngle = endAngle;
+        }
+        protected PartialCircle(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected PartialCircle(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            center.read();
+            radius = backing.getDouble(8);
+            startAngle = backing.getDouble(16);
+            endAngle = backing.getDouble(24);
+        }
+        public void write() {
+            center.write();
+            backing.putDouble(8, radius);
+            backing.putDouble(16, startAngle);
+            backing.putDouble(24, endAngle);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class PartialEllipse extends DisposedStruct {
+        public PointFloat center; // Center of the Ellipse.
+        public double angle; // Angle of the ellipse.
+        public double majorRadius; // The length of the semi-major axis of the ellipse.
+        public double minorRadius; // The length of the semi-minor axis of the ellipse.
+        public double startAngle; // Start angle of the fitted structure.
+        public double endAngle; // End angle of the fitted structure.
+
+        private void init() {
+            center = new PointFloat(backing, 0);
+        }
+        public PartialEllipse() {
+            super(48);
+            init();
+        }
+        public PartialEllipse(PointFloat center, double angle, double majorRadius, double minorRadius, double startAngle, double endAngle) {
+            super(48);
+            this.center = center;
+            this.angle = angle;
+            this.majorRadius = majorRadius;
+            this.minorRadius = minorRadius;
+            this.startAngle = startAngle;
+            this.endAngle = endAngle;
+        }
+        protected PartialEllipse(ByteBuffer backing, int offset) {
+            super(backing, offset, 48);
+            init();
+        }
+        protected PartialEllipse(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 48);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 48);
+        }
+        public void read() {
+            center.read();
+            angle = backing.getDouble(8);
+            majorRadius = backing.getDouble(16);
+            minorRadius = backing.getDouble(24);
+            startAngle = backing.getDouble(32);
+            endAngle = backing.getDouble(40);
+        }
+        public void write() {
+            center.write();
+            backing.putDouble(8, angle);
+            backing.putDouble(16, majorRadius);
+            backing.putDouble(24, minorRadius);
+            backing.putDouble(32, startAngle);
+            backing.putDouble(40, endAngle);
+        }
+        public int size() {
+            return 48;
+        }
+    }
+
+    public static class SetupMatchPatternData extends DisposedStruct {
+        public byte[] matchSetupData; // String containing the match setup data.
+        private ByteBuffer matchSetupData_buf;
+
+        private void init() {
+            matchSetupData = new byte[0];
+        }
+        public SetupMatchPatternData() {
+            super(8);
+            init();
+        }
+        public SetupMatchPatternData(byte[] matchSetupData) {
+            super(8);
+            this.matchSetupData = matchSetupData;
+        }
+        protected SetupMatchPatternData(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected SetupMatchPatternData(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            int matchSetupData_numMatchSetupData = backing.getInt(4);
+            long matchSetupData_addr = getPointer(backing, 0);
+            matchSetupData = new byte[matchSetupData_numMatchSetupData];
+            if (matchSetupData_numMatchSetupData > 0 && matchSetupData_addr != 0) {
+                getBytes(newDirectByteBuffer(matchSetupData_addr, matchSetupData_numMatchSetupData), matchSetupData, 0, matchSetupData_numMatchSetupData);
+            }
+        }
+        public void write() {
+            matchSetupData_buf = ByteBuffer.allocateDirect(matchSetupData.length);
+            putBytes(matchSetupData_buf, matchSetupData, 0, matchSetupData.length);
+            backing.putInt(4, matchSetupData.length);
+            putPointer(backing, 0, matchSetupData_buf);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class RangeSettingDouble extends DisposedStruct {
+        public SettingType settingType; // Match Constraints specifies the match option whose values you want to constrain by the given range.
+        public double min; // Min is the minimum value of the range for a given Match Constraint.
+        public double max; // Max is the maximum value of the range for a given Match Constraint.
+
+        private void init() {
+            
+        }
+        public RangeSettingDouble() {
+            super(24);
+            init();
+        }
+        public RangeSettingDouble(SettingType settingType, double min, double max) {
+            super(24);
+            this.settingType = settingType;
+            this.min = min;
+            this.max = max;
+        }
+        protected RangeSettingDouble(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected RangeSettingDouble(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            settingType = SettingType.fromValue(backing.getInt(0));
+            min = backing.getDouble(8);
+            max = backing.getDouble(16);
+        }
+        public void write() {
+            if (settingType != null)
+                backing.putInt(0, settingType.getValue());
+            backing.putDouble(8, min);
+            backing.putDouble(16, max);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class GeometricAdvancedSetupDataOption extends DisposedStruct {
+        public GeometricSetupDataItem type; // It determines the option you want to use during the matching phase.
+        public double value; // Value is the value for the option you want to use during the matching phase.
+
+        private void init() {
+            
+        }
+        public GeometricAdvancedSetupDataOption() {
+            super(16);
+            init();
+        }
+        public GeometricAdvancedSetupDataOption(GeometricSetupDataItem type, double value) {
+            super(16);
+            this.type = type;
+            this.value = value;
+        }
+        protected GeometricAdvancedSetupDataOption(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected GeometricAdvancedSetupDataOption(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            type = GeometricSetupDataItem.fromValue(backing.getInt(0));
+            value = backing.getDouble(8);
+        }
+        public void write() {
+            if (type != null)
+                backing.putInt(0, type.getValue());
+            backing.putDouble(8, value);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class ContourInfoReport extends DisposedStruct {
+        public PointDouble[] pointsPixel; // Points (pixel) specifies the location of every point detected on the curve, in pixels.
+        public PointDouble[] pointsReal; // Points (real) specifies the location of every point detected on the curve, in calibrated units.
+        public double[] curvaturePixel; // Curvature Pixel displays the curvature profile for the selected contour, in pixels.
+        public double[] curvatureReal; // Curvature Real displays the curvature profile for the selected contour, in calibrated units.
+        public double length; // Length (pixel) specifies the length, in pixels, of the curves in the image.
+        public double lengthReal; // Length (real) specifies the length, in calibrated units, of the curves within the curvature range.
+        public int hasEquation; // Has Equation specifies whether the contour has a fitted equation.
+        private ByteBuffer pointsPixel_buf;
+        private ByteBuffer pointsReal_buf;
+        private ByteBuffer curvaturePixel_buf;
+        private ByteBuffer curvatureReal_buf;
+
+        private void init() {
+            pointsPixel = new PointDouble[0];
+            pointsReal = new PointDouble[0];
+            curvaturePixel = new double[0];
+            curvatureReal = new double[0];
+        }
+        public ContourInfoReport() {
+            super(56);
+            init();
+        }
+        public ContourInfoReport(PointDouble[] pointsPixel, PointDouble[] pointsReal, double[] curvaturePixel, double[] curvatureReal, double length, double lengthReal, int hasEquation) {
+            super(56);
+            this.pointsPixel = pointsPixel;
+            this.pointsReal = pointsReal;
+            this.curvaturePixel = curvaturePixel;
+            this.curvatureReal = curvatureReal;
+            this.length = length;
+            this.lengthReal = lengthReal;
+            this.hasEquation = hasEquation;
+        }
+        protected ContourInfoReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 56);
+            init();
+        }
+        protected ContourInfoReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 56);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 56);
+        }
+        public void read() {
+            int pointsPixel_numPointsPixel = backing.getInt(4);
+            long pointsPixel_addr = getPointer(backing, 0);
+            pointsPixel = new PointDouble[pointsPixel_numPointsPixel];
+            if (pointsPixel_numPointsPixel > 0 && pointsPixel_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(pointsPixel_addr, pointsPixel_numPointsPixel*16);
+                for (int i=0, off=0; i<pointsPixel_numPointsPixel; i++, off += 16) {
+                    pointsPixel[i] = new PointDouble(bb, off);
+                    pointsPixel[i].read();
+                }
+            }
+            int pointsReal_numPointsReal = backing.getInt(12);
+            long pointsReal_addr = getPointer(backing, 8);
+            pointsReal = new PointDouble[pointsReal_numPointsReal];
+            if (pointsReal_numPointsReal > 0 && pointsReal_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(pointsReal_addr, pointsReal_numPointsReal*16);
+                for (int i=0, off=0; i<pointsReal_numPointsReal; i++, off += 16) {
+                    pointsReal[i] = new PointDouble(bb, off);
+                    pointsReal[i].read();
+                }
+            }
+            int curvaturePixel_numCurvaturePixel = backing.getInt(20);
+            long curvaturePixel_addr = getPointer(backing, 16);
+            curvaturePixel = new double[curvaturePixel_numCurvaturePixel];
+            if (curvaturePixel_numCurvaturePixel > 0 && curvaturePixel_addr != 0) {
+                newDirectByteBuffer(curvaturePixel_addr, curvaturePixel_numCurvaturePixel*8).asDoubleBuffer().get(curvaturePixel);
+            }
+            int curvatureReal_numCurvatureReal = backing.getInt(28);
+            long curvatureReal_addr = getPointer(backing, 24);
+            curvatureReal = new double[curvatureReal_numCurvatureReal];
+            if (curvatureReal_numCurvatureReal > 0 && curvatureReal_addr != 0) {
+                newDirectByteBuffer(curvatureReal_addr, curvatureReal_numCurvatureReal*8).asDoubleBuffer().get(curvatureReal);
+            }
+            length = backing.getDouble(32);
+            lengthReal = backing.getDouble(40);
+            hasEquation = backing.getInt(48);
+        }
+        public void write() {
+            pointsPixel_buf = ByteBuffer.allocateDirect(pointsPixel.length*16);
+            for (int i=0, off=0; i<pointsPixel.length; i++, off += 16) {
+                pointsPixel[i].setBuffer(pointsPixel_buf, off);
+                pointsPixel[i].write();
+            }
+            backing.putInt(4, pointsPixel.length);
+            putPointer(backing, 0, pointsPixel_buf);
+            pointsReal_buf = ByteBuffer.allocateDirect(pointsReal.length*16);
+            for (int i=0, off=0; i<pointsReal.length; i++, off += 16) {
+                pointsReal[i].setBuffer(pointsReal_buf, off);
+                pointsReal[i].write();
+            }
+            backing.putInt(12, pointsReal.length);
+            putPointer(backing, 8, pointsReal_buf);
+            curvaturePixel_buf = ByteBuffer.allocateDirect(curvaturePixel.length*8);
+            curvaturePixel_buf.asDoubleBuffer().put(curvaturePixel).rewind();
+            backing.putInt(20, curvaturePixel.length);
+            putPointer(backing, 16, curvaturePixel_buf);
+            curvatureReal_buf = ByteBuffer.allocateDirect(curvatureReal.length*8);
+            curvatureReal_buf.asDoubleBuffer().put(curvatureReal).rewind();
+            backing.putInt(28, curvatureReal.length);
+            putPointer(backing, 24, curvatureReal_buf);
+            backing.putDouble(32, length);
+            backing.putDouble(40, lengthReal);
+            backing.putInt(48, hasEquation);
+        }
+        public int size() {
+            return 56;
+        }
+    }
+
+    public static class ROILabel extends DisposedStruct {
+        public String className; // Specifies the classname you want to segment.
+        public int label; // Label is the label number associated with the Class Name.
+        private ByteBuffer className_buf;
+
+        private void init() {
+            
+        }
+        public ROILabel() {
+            super(8);
+            init();
+        }
+        public ROILabel(String className, int label) {
+            super(8);
+            this.className = className;
+            this.label = label;
+        }
+        protected ROILabel(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected ROILabel(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            long className_addr = getPointer(backing, 0);
+            if (className_addr == 0)
+                className = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(className_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    className = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    className = "";
+                }
+            }
+            
+            label = backing.getInt(4);
+        }
+        public void write() {
+            if (className != null) {
+                byte[] className_bytes;
+                try {
+                    className_bytes = className.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    className_bytes = new byte[0];
+                }
+                className_buf = ByteBuffer.allocateDirect(className_bytes.length+1);
+                putBytes(className_buf, className_bytes, 0, className_bytes.length).put(className_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, className == null ? 0 : getByteBufferAddress(className_buf));
+            backing.putInt(4, label);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class SupervisedColorSegmentationReport extends DisposedStruct {
+        public ROILabel[] labelOut; // The Roi labels array.
+        private ByteBuffer labelOut_buf;
+
+        private void init() {
+            labelOut = new ROILabel[0];
+        }
+        public SupervisedColorSegmentationReport() {
+            super(8);
+            init();
+        }
+        public SupervisedColorSegmentationReport(ROILabel[] labelOut) {
+            super(8);
+            this.labelOut = labelOut;
+        }
+        protected SupervisedColorSegmentationReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected SupervisedColorSegmentationReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            int labelOut_numLabelOut = backing.getInt(4);
+            long labelOut_addr = getPointer(backing, 0);
+            labelOut = new ROILabel[labelOut_numLabelOut];
+            if (labelOut_numLabelOut > 0 && labelOut_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(labelOut_addr, labelOut_numLabelOut*8);
+                for (int i=0, off=0; i<labelOut_numLabelOut; i++, off += 8) {
+                    labelOut[i] = new ROILabel(bb, off);
+                    labelOut[i].read();
+                }
+            }
+        }
+        public void write() {
+            labelOut_buf = ByteBuffer.allocateDirect(labelOut.length*8);
+            for (int i=0, off=0; i<labelOut.length; i++, off += 8) {
+                labelOut[i].setBuffer(labelOut_buf, off);
+                labelOut[i].write();
+            }
+            backing.putInt(4, labelOut.length);
+            putPointer(backing, 0, labelOut_buf);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class LabelToROIReport extends DisposedStruct {
+        public ROI[] roiArray; // Array of ROIs.
+        public int[] labelsOutArray; // Array of labels.
+        public int[] isTooManyVectorsArray; // isTooManyVectorsArray array.
+        private ByteBuffer roiArray_buf;
+        private ByteBuffer labelsOutArray_buf;
+        private ByteBuffer isTooManyVectorsArray_buf;
+
+        private void init() {
+            roiArray = new ROI[0];
+            labelsOutArray = new int[0];
+            isTooManyVectorsArray = new int[0];
+        }
+        public LabelToROIReport() {
+            super(24);
+            init();
+        }
+        public LabelToROIReport(ROI[] roiArray, int[] labelsOutArray, int[] isTooManyVectorsArray) {
+            super(24);
+            this.roiArray = roiArray;
+            this.labelsOutArray = labelsOutArray;
+            this.isTooManyVectorsArray = isTooManyVectorsArray;
+        }
+        protected LabelToROIReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected LabelToROIReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            int roiArray_numOfROIs = backing.getInt(4);
+            long roiArray_addr = getPointer(backing, 0);
+            roiArray = new ROI[roiArray_numOfROIs];
+            if (roiArray_numOfROIs > 0 && roiArray_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(roiArray_addr, roiArray_numOfROIs*4);
+                for (int i=0, off=0; i<roiArray_numOfROIs; i++, off += 4) {
+                    roiArray[i] = new ROI(getPointer(bb, off), false);
+                }
+            }
+            int labelsOutArray_numOfLabels = backing.getInt(12);
+            long labelsOutArray_addr = getPointer(backing, 8);
+            labelsOutArray = new int[labelsOutArray_numOfLabels];
+            if (labelsOutArray_numOfLabels > 0 && labelsOutArray_addr != 0) {
+                newDirectByteBuffer(labelsOutArray_addr, labelsOutArray_numOfLabels*4).asIntBuffer().get(labelsOutArray);
+            }
+            int isTooManyVectorsArray_isTooManyVectorsArraySize = backing.getInt(20);
+            long isTooManyVectorsArray_addr = getPointer(backing, 16);
+            isTooManyVectorsArray = new int[isTooManyVectorsArray_isTooManyVectorsArraySize];
+            if (isTooManyVectorsArray_isTooManyVectorsArraySize > 0 && isTooManyVectorsArray_addr != 0) {
+                newDirectByteBuffer(isTooManyVectorsArray_addr, isTooManyVectorsArray_isTooManyVectorsArraySize*4).asIntBuffer().get(isTooManyVectorsArray);
+            }
+        }
+        public void write() {
+            roiArray_buf = ByteBuffer.allocateDirect(roiArray.length*4);
+            for (int i=0, off=0; i<roiArray.length; i++, off += 4) {
+                putPointer(roiArray_buf, off, roiArray[i]);
+            }
+            backing.putInt(4, roiArray.length);
+            putPointer(backing, 0, roiArray_buf);
+            labelsOutArray_buf = ByteBuffer.allocateDirect(labelsOutArray.length*4);
+            labelsOutArray_buf.asIntBuffer().put(labelsOutArray).rewind();
+            backing.putInt(12, labelsOutArray.length);
+            putPointer(backing, 8, labelsOutArray_buf);
+            isTooManyVectorsArray_buf = ByteBuffer.allocateDirect(isTooManyVectorsArray.length*4);
+            isTooManyVectorsArray_buf.asIntBuffer().put(isTooManyVectorsArray).rewind();
+            backing.putInt(20, isTooManyVectorsArray.length);
+            putPointer(backing, 16, isTooManyVectorsArray_buf);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class ColorSegmenationOptions extends DisposedStruct {
+        public int windowX; // X is the window size in x direction.
+        public int windowY; // Y is the window size in y direction.
+        public int stepSize; // Step Size is the distance between two windows.
+        public int minParticleArea; // Min Particle Area is the minimum number of allowed pixels.
+        public int maxParticleArea; // Max Particle Area is the maximum number of allowed pixels.
+        public short isFineSegment; // When enabled, the step processes the boundary pixels of each segmentation cluster using a step size of 1.
+
+        private void init() {
+            
+        }
+        public ColorSegmenationOptions() {
+            super(24);
+            init();
+        }
+        public ColorSegmenationOptions(int windowX, int windowY, int stepSize, int minParticleArea, int maxParticleArea, int isFineSegment) {
+            super(24);
+            this.windowX = windowX;
+            this.windowY = windowY;
+            this.stepSize = stepSize;
+            this.minParticleArea = minParticleArea;
+            this.maxParticleArea = maxParticleArea;
+            this.isFineSegment = (short)isFineSegment;
+        }
+        protected ColorSegmenationOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected ColorSegmenationOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            windowX = backing.getInt(0);
+            windowY = backing.getInt(4);
+            stepSize = backing.getInt(8);
+            minParticleArea = backing.getInt(12);
+            maxParticleArea = backing.getInt(16);
+            isFineSegment = backing.getShort(20);
+        }
+        public void write() {
+            backing.putInt(0, windowX);
+            backing.putInt(4, windowY);
+            backing.putInt(8, stepSize);
+            backing.putInt(12, minParticleArea);
+            backing.putInt(16, maxParticleArea);
+            backing.putShort(20, isFineSegment);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class ClassifiedCurve extends DisposedStruct {
+        public double length; // Specifies the length, in pixels, of the curves within the curvature range.
+        public double lengthReal; // specifies the length, in calibrated units, of the curves within the curvature range.
+        public double maxCurvature; // specifies the maximum curvature, in pixels, for the selected curvature range.
+        public double maxCurvatureReal; // specifies the maximum curvature, in calibrated units, for the selected curvature range.
+        public int label; // specifies the class to which the the sample belongs.
+        public PointDouble[] curvePoints; // Curve Points is a point-coordinate cluster that defines the points of the curve.
+        private ByteBuffer curvePoints_buf;
+
+        private void init() {
+            curvePoints = new PointDouble[0];
+        }
+        public ClassifiedCurve() {
+            super(48);
+            init();
+        }
+        public ClassifiedCurve(double length, double lengthReal, double maxCurvature, double maxCurvatureReal, int label, PointDouble[] curvePoints) {
+            super(48);
+            this.length = length;
+            this.lengthReal = lengthReal;
+            this.maxCurvature = maxCurvature;
+            this.maxCurvatureReal = maxCurvatureReal;
+            this.label = label;
+            this.curvePoints = curvePoints;
+        }
+        protected ClassifiedCurve(ByteBuffer backing, int offset) {
+            super(backing, offset, 48);
+            init();
+        }
+        protected ClassifiedCurve(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 48);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 48);
+        }
+        public void read() {
+            length = backing.getDouble(0);
+            lengthReal = backing.getDouble(8);
+            maxCurvature = backing.getDouble(16);
+            maxCurvatureReal = backing.getDouble(24);
+            label = backing.getInt(32);
+            int curvePoints_numCurvePoints = backing.getInt(40);
+            long curvePoints_addr = getPointer(backing, 36);
+            curvePoints = new PointDouble[curvePoints_numCurvePoints];
+            if (curvePoints_numCurvePoints > 0 && curvePoints_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(curvePoints_addr, curvePoints_numCurvePoints*16);
+                for (int i=0, off=0; i<curvePoints_numCurvePoints; i++, off += 16) {
+                    curvePoints[i] = new PointDouble(bb, off);
+                    curvePoints[i].read();
+                }
+            }
+        }
+        public void write() {
+            backing.putDouble(0, length);
+            backing.putDouble(8, lengthReal);
+            backing.putDouble(16, maxCurvature);
+            backing.putDouble(24, maxCurvatureReal);
+            backing.putInt(32, label);
+            curvePoints_buf = ByteBuffer.allocateDirect(curvePoints.length*16);
+            for (int i=0, off=0; i<curvePoints.length; i++, off += 16) {
+                curvePoints[i].setBuffer(curvePoints_buf, off);
+                curvePoints[i].write();
+            }
+            backing.putInt(40, curvePoints.length);
+            putPointer(backing, 36, curvePoints_buf);
+        }
+        public int size() {
+            return 48;
+        }
+    }
+
+    public static class RangeDouble extends DisposedStruct {
+        public double minValue; // The minimum value of the range.
+        public double maxValue; // The maximum value of the range.
+
+        private void init() {
+            
+        }
+        public RangeDouble() {
+            super(16);
+            init();
+        }
+        public RangeDouble(double minValue, double maxValue) {
+            super(16);
+            this.minValue = minValue;
+            this.maxValue = maxValue;
+        }
+        protected RangeDouble(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected RangeDouble(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            minValue = backing.getDouble(0);
+            maxValue = backing.getDouble(8);
+        }
+        public void write() {
+            backing.putDouble(0, minValue);
+            backing.putDouble(8, maxValue);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class RangeLabel extends DisposedStruct {
+        public RangeDouble range; // Specifies the range of curvature values.
+        public int label; // Class Label specifies the class to which the the sample belongs.
+
+        private void init() {
+            range = new RangeDouble(backing, 0);
+        }
+        public RangeLabel() {
+            super(24);
+            init();
+        }
+        public RangeLabel(RangeDouble range, int label) {
+            super(24);
+            this.range = range;
+            this.label = label;
+        }
+        protected RangeLabel(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected RangeLabel(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            range.read();
+            label = backing.getInt(16);
+        }
+        public void write() {
+            range.write();
+            backing.putInt(16, label);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class CurvatureAnalysisReport extends DisposedStruct {
+        public ClassifiedCurve[] curves;
+        private ByteBuffer curves_buf;
+
+        private void init() {
+            curves = new ClassifiedCurve[0];
+        }
+        public CurvatureAnalysisReport() {
+            super(8);
+            init();
+        }
+        public CurvatureAnalysisReport(ClassifiedCurve[] curves) {
+            super(8);
+            this.curves = curves;
+        }
+        protected CurvatureAnalysisReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected CurvatureAnalysisReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            int curves_numCurves = backing.getInt(4);
+            long curves_addr = getPointer(backing, 0);
+            curves = new ClassifiedCurve[curves_numCurves];
+            if (curves_numCurves > 0 && curves_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(curves_addr, curves_numCurves*48);
+                for (int i=0, off=0; i<curves_numCurves; i++, off += 48) {
+                    curves[i] = new ClassifiedCurve(bb, off);
+                    curves[i].read();
+                }
+            }
+        }
+        public void write() {
+            curves_buf = ByteBuffer.allocateDirect(curves.length*48);
+            for (int i=0, off=0; i<curves.length; i++, off += 48) {
+                curves[i].setBuffer(curves_buf, off);
+                curves[i].write();
+            }
+            backing.putInt(4, curves.length);
+            putPointer(backing, 0, curves_buf);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class Disparity extends DisposedStruct {
+        public PointDouble current; // Current is a array of points that defines the target contour.
+        public PointDouble reference; // reference is a array of points that defines the template contour.
+        public double distance; // Specifies the distance, in pixels, between the template contour point and the target contour point.
+
+        private void init() {
+            current = new PointDouble(backing, 0);
+            reference = new PointDouble(backing, 16);
+        }
+        public Disparity() {
+            super(40);
+            init();
+        }
+        public Disparity(PointDouble current, PointDouble reference, double distance) {
+            super(40);
+            this.current = current;
+            this.reference = reference;
+            this.distance = distance;
+        }
+        protected Disparity(ByteBuffer backing, int offset) {
+            super(backing, offset, 40);
+            init();
+        }
+        protected Disparity(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 40);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 40);
+        }
+        public void read() {
+            current.read();
+            reference.read();
+            distance = backing.getDouble(32);
+        }
+        public void write() {
+            current.write();
+            reference.write();
+            backing.putDouble(32, distance);
+        }
+        public int size() {
+            return 40;
+        }
+    }
+
+    public static class ComputeDistancesReport extends DisposedStruct {
+        public Disparity[] distances; // Distances is an array containing the computed distances.
+        public Disparity[] distancesReal; // Distances Real is an array containing the computed distances in calibrated units.
+        private ByteBuffer distances_buf;
+        private ByteBuffer distancesReal_buf;
+
+        private void init() {
+            distances = new Disparity[0];
+            distancesReal = new Disparity[0];
+        }
+        public ComputeDistancesReport() {
+            super(16);
+            init();
+        }
+        public ComputeDistancesReport(Disparity[] distances, Disparity[] distancesReal) {
+            super(16);
+            this.distances = distances;
+            this.distancesReal = distancesReal;
+        }
+        protected ComputeDistancesReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected ComputeDistancesReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            int distances_numDistances = backing.getInt(4);
+            long distances_addr = getPointer(backing, 0);
+            distances = new Disparity[distances_numDistances];
+            if (distances_numDistances > 0 && distances_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(distances_addr, distances_numDistances*40);
+                for (int i=0, off=0; i<distances_numDistances; i++, off += 40) {
+                    distances[i] = new Disparity(bb, off);
+                    distances[i].read();
+                }
+            }
+            int distancesReal_numDistancesReal = backing.getInt(12);
+            long distancesReal_addr = getPointer(backing, 8);
+            distancesReal = new Disparity[distancesReal_numDistancesReal];
+            if (distancesReal_numDistancesReal > 0 && distancesReal_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(distancesReal_addr, distancesReal_numDistancesReal*40);
+                for (int i=0, off=0; i<distancesReal_numDistancesReal; i++, off += 40) {
+                    distancesReal[i] = new Disparity(bb, off);
+                    distancesReal[i].read();
+                }
+            }
+        }
+        public void write() {
+            distances_buf = ByteBuffer.allocateDirect(distances.length*40);
+            for (int i=0, off=0; i<distances.length; i++, off += 40) {
+                distances[i].setBuffer(distances_buf, off);
+                distances[i].write();
+            }
+            backing.putInt(4, distances.length);
+            putPointer(backing, 0, distances_buf);
+            distancesReal_buf = ByteBuffer.allocateDirect(distancesReal.length*40);
+            for (int i=0, off=0; i<distancesReal.length; i++, off += 40) {
+                distancesReal[i].setBuffer(distancesReal_buf, off);
+                distancesReal[i].write();
+            }
+            backing.putInt(12, distancesReal.length);
+            putPointer(backing, 8, distancesReal_buf);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class MatchMode extends DisposedStruct {
+        public int rotation; // Rotation When enabled, the Function searches for occurrences of the template in the inspection image, allowing for template matches to be rotated.
+        public int scale; // Rotation When enabled, the Function searches for occurrences of the template in the inspection image, allowing for template matches to be rotated.
+        public int occlusion; // Occlusion specifies whether or not to search for occluded versions of the shape.
+
+        private void init() {
+            
+        }
+        public MatchMode() {
+            super(12);
+            init();
+        }
+        public MatchMode(int rotation, int scale, int occlusion) {
+            super(12);
+            this.rotation = rotation;
+            this.scale = scale;
+            this.occlusion = occlusion;
+        }
+        protected MatchMode(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected MatchMode(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            rotation = backing.getInt(0);
+            scale = backing.getInt(4);
+            occlusion = backing.getInt(8);
+        }
+        public void write() {
+            backing.putInt(0, rotation);
+            backing.putInt(4, scale);
+            backing.putInt(8, occlusion);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class ClassifiedDisparity extends DisposedStruct {
+        public double length; // Length (pixel) specifies the length, in pixels, of the curves within the curvature range.
+        public double lengthReal; // Length (real) specifies the length, in calibrated units, of the curves within the curvature range.
+        public double maxDistance; // Maximum Distance (pixel) specifies the maximum distance, in pixels, between points along the selected contour and the template contour.
+        public double maxDistanceReal; // Maximum Distance (real) specifies the maximum distance, in calibrated units, between points along the selected contour and the template contour.
+        public int label; // Class Label specifies the class to which the the sample belongs.
+        public PointDouble[] templateSubsection; // Template subsection points is an array of points that defines the boundary of the template.
+        public PointDouble[] targetSubsection; // Current Points(Target subsection points) is an array of points that defines the boundary of the target.
+        private ByteBuffer templateSubsection_buf;
+        private ByteBuffer targetSubsection_buf;
+
+        private void init() {
+            templateSubsection = new PointDouble[0];
+            targetSubsection = new PointDouble[0];
+        }
+        public ClassifiedDisparity() {
+            super(56);
+            init();
+        }
+        public ClassifiedDisparity(double length, double lengthReal, double maxDistance, double maxDistanceReal, int label, PointDouble[] templateSubsection, PointDouble[] targetSubsection) {
+            super(56);
+            this.length = length;
+            this.lengthReal = lengthReal;
+            this.maxDistance = maxDistance;
+            this.maxDistanceReal = maxDistanceReal;
+            this.label = label;
+            this.templateSubsection = templateSubsection;
+            this.targetSubsection = targetSubsection;
+        }
+        protected ClassifiedDisparity(ByteBuffer backing, int offset) {
+            super(backing, offset, 56);
+            init();
+        }
+        protected ClassifiedDisparity(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 56);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 56);
+        }
+        public void read() {
+            length = backing.getDouble(0);
+            lengthReal = backing.getDouble(8);
+            maxDistance = backing.getDouble(16);
+            maxDistanceReal = backing.getDouble(24);
+            label = backing.getInt(32);
+            int templateSubsection_numTemplateSubsection = backing.getInt(40);
+            long templateSubsection_addr = getPointer(backing, 36);
+            templateSubsection = new PointDouble[templateSubsection_numTemplateSubsection];
+            if (templateSubsection_numTemplateSubsection > 0 && templateSubsection_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(templateSubsection_addr, templateSubsection_numTemplateSubsection*16);
+                for (int i=0, off=0; i<templateSubsection_numTemplateSubsection; i++, off += 16) {
+                    templateSubsection[i] = new PointDouble(bb, off);
+                    templateSubsection[i].read();
+                }
+            }
+            int targetSubsection_numTargetSubsection = backing.getInt(48);
+            long targetSubsection_addr = getPointer(backing, 44);
+            targetSubsection = new PointDouble[targetSubsection_numTargetSubsection];
+            if (targetSubsection_numTargetSubsection > 0 && targetSubsection_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(targetSubsection_addr, targetSubsection_numTargetSubsection*16);
+                for (int i=0, off=0; i<targetSubsection_numTargetSubsection; i++, off += 16) {
+                    targetSubsection[i] = new PointDouble(bb, off);
+                    targetSubsection[i].read();
+                }
+            }
+        }
+        public void write() {
+            backing.putDouble(0, length);
+            backing.putDouble(8, lengthReal);
+            backing.putDouble(16, maxDistance);
+            backing.putDouble(24, maxDistanceReal);
+            backing.putInt(32, label);
+            templateSubsection_buf = ByteBuffer.allocateDirect(templateSubsection.length*16);
+            for (int i=0, off=0; i<templateSubsection.length; i++, off += 16) {
+                templateSubsection[i].setBuffer(templateSubsection_buf, off);
+                templateSubsection[i].write();
+            }
+            backing.putInt(40, templateSubsection.length);
+            putPointer(backing, 36, templateSubsection_buf);
+            targetSubsection_buf = ByteBuffer.allocateDirect(targetSubsection.length*16);
+            for (int i=0, off=0; i<targetSubsection.length; i++, off += 16) {
+                targetSubsection[i].setBuffer(targetSubsection_buf, off);
+                targetSubsection[i].write();
+            }
+            backing.putInt(48, targetSubsection.length);
+            putPointer(backing, 44, targetSubsection_buf);
+        }
+        public int size() {
+            return 56;
+        }
+    }
+
+    public static class ClassifyDistancesReport extends DisposedStruct {
+        public ClassifiedDisparity[] classifiedDistances; // Disparity array containing the classified distances.
+        private ByteBuffer classifiedDistances_buf;
+
+        private void init() {
+            classifiedDistances = new ClassifiedDisparity[0];
+        }
+        public ClassifyDistancesReport() {
+            super(8);
+            init();
+        }
+        public ClassifyDistancesReport(ClassifiedDisparity[] classifiedDistances) {
+            super(8);
+            this.classifiedDistances = classifiedDistances;
+        }
+        protected ClassifyDistancesReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected ClassifyDistancesReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            int classifiedDistances_numClassifiedDistances = backing.getInt(4);
+            long classifiedDistances_addr = getPointer(backing, 0);
+            classifiedDistances = new ClassifiedDisparity[classifiedDistances_numClassifiedDistances];
+            if (classifiedDistances_numClassifiedDistances > 0 && classifiedDistances_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(classifiedDistances_addr, classifiedDistances_numClassifiedDistances*56);
+                for (int i=0, off=0; i<classifiedDistances_numClassifiedDistances; i++, off += 56) {
+                    classifiedDistances[i] = new ClassifiedDisparity(bb, off);
+                    classifiedDistances[i].read();
+                }
+            }
+        }
+        public void write() {
+            classifiedDistances_buf = ByteBuffer.allocateDirect(classifiedDistances.length*56);
+            for (int i=0, off=0; i<classifiedDistances.length; i++, off += 56) {
+                classifiedDistances[i].setBuffer(classifiedDistances_buf, off);
+                classifiedDistances[i].write();
+            }
+            backing.putInt(4, classifiedDistances.length);
+            putPointer(backing, 0, classifiedDistances_buf);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class ContourComputeCurvatureReport extends DisposedStruct {
+        public double[] curvaturePixel; // Curvature Pixel displays the curvature profile for the selected contour, in pixels.
+        public double[] curvatureReal; // Curvature Real displays the curvature profile for the selected contour, in calibrated units.
+        private ByteBuffer curvaturePixel_buf;
+        private ByteBuffer curvatureReal_buf;
+
+        private void init() {
+            curvaturePixel = new double[0];
+            curvatureReal = new double[0];
+        }
+        public ContourComputeCurvatureReport() {
+            super(16);
+            init();
+        }
+        public ContourComputeCurvatureReport(double[] curvaturePixel, double[] curvatureReal) {
+            super(16);
+            this.curvaturePixel = curvaturePixel;
+            this.curvatureReal = curvatureReal;
+        }
+        protected ContourComputeCurvatureReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected ContourComputeCurvatureReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            int curvaturePixel_numCurvaturePixel = backing.getInt(4);
+            long curvaturePixel_addr = getPointer(backing, 0);
+            curvaturePixel = new double[curvaturePixel_numCurvaturePixel];
+            if (curvaturePixel_numCurvaturePixel > 0 && curvaturePixel_addr != 0) {
+                newDirectByteBuffer(curvaturePixel_addr, curvaturePixel_numCurvaturePixel*8).asDoubleBuffer().get(curvaturePixel);
+            }
+            int curvatureReal_numCurvatureReal = backing.getInt(12);
+            long curvatureReal_addr = getPointer(backing, 8);
+            curvatureReal = new double[curvatureReal_numCurvatureReal];
+            if (curvatureReal_numCurvatureReal > 0 && curvatureReal_addr != 0) {
+                newDirectByteBuffer(curvatureReal_addr, curvatureReal_numCurvatureReal*8).asDoubleBuffer().get(curvatureReal);
+            }
+        }
+        public void write() {
+            curvaturePixel_buf = ByteBuffer.allocateDirect(curvaturePixel.length*8);
+            curvaturePixel_buf.asDoubleBuffer().put(curvaturePixel).rewind();
+            backing.putInt(4, curvaturePixel.length);
+            putPointer(backing, 0, curvaturePixel_buf);
+            curvatureReal_buf = ByteBuffer.allocateDirect(curvatureReal.length*8);
+            curvatureReal_buf.asDoubleBuffer().put(curvatureReal).rewind();
+            backing.putInt(12, curvatureReal.length);
+            putPointer(backing, 8, curvatureReal_buf);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class ContourOverlaySettings extends DisposedStruct {
+        public int overlay; // Overlay specifies whether to display the overlay on the image.
+        public RGBValue color; // Color is the color of the overlay.
+        public int width; // Width specifies the width of the overlay in pixels.
+        public int maintainWidth; // Maintain Width? specifies whether you want the overlay measured in screen pixels or image pixels.
+
+        private void init() {
+            color = new RGBValue(backing, 4);
+        }
+        public ContourOverlaySettings() {
+            super(16);
+            init();
+        }
+        public ContourOverlaySettings(int overlay, RGBValue color, int width, int maintainWidth) {
+            super(16);
+            this.overlay = overlay;
+            this.color = color;
+            this.width = width;
+            this.maintainWidth = maintainWidth;
+        }
+        protected ContourOverlaySettings(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected ContourOverlaySettings(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            overlay = backing.getInt(0);
+            color.read();
+            width = backing.getInt(8);
+            maintainWidth = backing.getInt(12);
+        }
+        public void write() {
+            backing.putInt(0, overlay);
+            color.write();
+            backing.putInt(8, width);
+            backing.putInt(12, maintainWidth);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class CurveParameters extends DisposedStruct {
+        public ExtractionMode extractionMode; // Specifies the method the function uses to identify curves in the image.
+        public int threshold; // Specifies the minimum contrast a seed point must have in order to begin a curve.
+        public EdgeFilterSize filterSize; // Specifies the width of the edge filter the function uses to identify curves in the image.
+        public int minLength; // Specifies the length, in pixels, of the smallest curve the function will extract.
+        public int searchStep; // Search Step Size specifies the distance, in the y direction, between the image rows that the algorithm inspects for curve seed points.
+        public int maxEndPointGap; // Specifies the maximum gap, in pixels, between the endpoints of a curve that the function identifies as a closed curve.
+        public int subpixel; // Subpixel specifies whether to detect curve points with subpixel accuracy.
+
+        private void init() {
+            
+        }
+        public CurveParameters() {
+            super(28);
+            init();
+        }
+        public CurveParameters(ExtractionMode extractionMode, int threshold, EdgeFilterSize filterSize, int minLength, int searchStep, int maxEndPointGap, int subpixel) {
+            super(28);
+            this.extractionMode = extractionMode;
+            this.threshold = threshold;
+            this.filterSize = filterSize;
+            this.minLength = minLength;
+            this.searchStep = searchStep;
+            this.maxEndPointGap = maxEndPointGap;
+            this.subpixel = subpixel;
+        }
+        protected CurveParameters(ByteBuffer backing, int offset) {
+            super(backing, offset, 28);
+            init();
+        }
+        protected CurveParameters(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 28);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 28);
+        }
+        public void read() {
+            extractionMode = ExtractionMode.fromValue(backing.getInt(0));
+            threshold = backing.getInt(4);
+            filterSize = EdgeFilterSize.fromValue(backing.getInt(8));
+            minLength = backing.getInt(12);
+            searchStep = backing.getInt(16);
+            maxEndPointGap = backing.getInt(20);
+            subpixel = backing.getInt(24);
+        }
+        public void write() {
+            if (extractionMode != null)
+                backing.putInt(0, extractionMode.getValue());
+            backing.putInt(4, threshold);
+            if (filterSize != null)
+                backing.putInt(8, filterSize.getValue());
+            backing.putInt(12, minLength);
+            backing.putInt(16, searchStep);
+            backing.putInt(20, maxEndPointGap);
+            backing.putInt(24, subpixel);
+        }
+        public int size() {
+            return 28;
+        }
+    }
+
+    public static class ExtractContourReport extends DisposedStruct {
+        public PointDouble[] contourPoints; // Contour Points specifies every point found on the contour.
+        public PointDouble[] sourcePoints; // Source Image Points specifies every point found on the contour in the source image.
+        private ByteBuffer contourPoints_buf;
+        private ByteBuffer sourcePoints_buf;
+
+        private void init() {
+            contourPoints = new PointDouble[0];
+            sourcePoints = new PointDouble[0];
+        }
+        public ExtractContourReport() {
+            super(16);
+            init();
+        }
+        public ExtractContourReport(PointDouble[] contourPoints, PointDouble[] sourcePoints) {
+            super(16);
+            this.contourPoints = contourPoints;
+            this.sourcePoints = sourcePoints;
+        }
+        protected ExtractContourReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected ExtractContourReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            int contourPoints_numContourPoints = backing.getInt(4);
+            long contourPoints_addr = getPointer(backing, 0);
+            contourPoints = new PointDouble[contourPoints_numContourPoints];
+            if (contourPoints_numContourPoints > 0 && contourPoints_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(contourPoints_addr, contourPoints_numContourPoints*16);
+                for (int i=0, off=0; i<contourPoints_numContourPoints; i++, off += 16) {
+                    contourPoints[i] = new PointDouble(bb, off);
+                    contourPoints[i].read();
+                }
+            }
+            int sourcePoints_numSourcePoints = backing.getInt(12);
+            long sourcePoints_addr = getPointer(backing, 8);
+            sourcePoints = new PointDouble[sourcePoints_numSourcePoints];
+            if (sourcePoints_numSourcePoints > 0 && sourcePoints_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(sourcePoints_addr, sourcePoints_numSourcePoints*16);
+                for (int i=0, off=0; i<sourcePoints_numSourcePoints; i++, off += 16) {
+                    sourcePoints[i] = new PointDouble(bb, off);
+                    sourcePoints[i].read();
+                }
+            }
+        }
+        public void write() {
+            contourPoints_buf = ByteBuffer.allocateDirect(contourPoints.length*16);
+            for (int i=0, off=0; i<contourPoints.length; i++, off += 16) {
+                contourPoints[i].setBuffer(contourPoints_buf, off);
+                contourPoints[i].write();
+            }
+            backing.putInt(4, contourPoints.length);
+            putPointer(backing, 0, contourPoints_buf);
+            sourcePoints_buf = ByteBuffer.allocateDirect(sourcePoints.length*16);
+            for (int i=0, off=0; i<sourcePoints.length; i++, off += 16) {
+                sourcePoints[i].setBuffer(sourcePoints_buf, off);
+                sourcePoints[i].write();
+            }
+            backing.putInt(12, sourcePoints.length);
+            putPointer(backing, 8, sourcePoints_buf);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class ConnectionConstraint extends DisposedStruct {
+        public ConnectionConstraintType constraintType; // Constraint Type specifies what criteria to use to consider two curves part of a contour.
+        public RangeDouble range; // Specifies range for a given Match Constraint.
+
+        private void init() {
+            range = new RangeDouble(backing, 8);
+        }
+        public ConnectionConstraint() {
+            super(24);
+            init();
+        }
+        public ConnectionConstraint(ConnectionConstraintType constraintType, RangeDouble range) {
+            super(24);
+            this.constraintType = constraintType;
+            this.range = range;
+        }
+        protected ConnectionConstraint(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected ConnectionConstraint(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            constraintType = ConnectionConstraintType.fromValue(backing.getInt(0));
+            range.read();
+        }
+        public void write() {
+            if (constraintType != null)
+                backing.putInt(0, constraintType.getValue());
+            range.write();
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class ExtractTextureFeaturesReport extends DisposedStruct {
+        public int[] waveletBands; // The array having all the Wavelet Banks used for extraction.
+        public int textureFeaturesRows; // Number of Rows in the Texture Features array.
+        public int textureFeaturesCols; // Number of Cols in Texture Features array.
+        private ByteBuffer waveletBands_buf;
+
+        private void init() {
+            waveletBands = new int[0];
+        }
+        public ExtractTextureFeaturesReport() {
+            super(20);
+            init();
+        }
+        public ExtractTextureFeaturesReport(int[] waveletBands, int textureFeaturesRows, int textureFeaturesCols) {
+            super(20);
+            this.waveletBands = waveletBands;
+            this.textureFeaturesRows = textureFeaturesRows;
+            this.textureFeaturesCols = textureFeaturesCols;
+        }
+        protected ExtractTextureFeaturesReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 20);
+            init();
+        }
+        protected ExtractTextureFeaturesReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 20);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 20);
+        }
+        public void read() {
+            int waveletBands_numWaveletBands = backing.getInt(4);
+            long waveletBands_addr = getPointer(backing, 0);
+            waveletBands = new int[waveletBands_numWaveletBands];
+            if (waveletBands_numWaveletBands > 0 && waveletBands_addr != 0) {
+                newDirectByteBuffer(waveletBands_addr, waveletBands_numWaveletBands*4).asIntBuffer().get(waveletBands);
+            }
+            textureFeaturesRows = backing.getInt(12);
+            textureFeaturesCols = backing.getInt(16);
+        }
+        public void write() {
+            waveletBands_buf = ByteBuffer.allocateDirect(waveletBands.length*4);
+            waveletBands_buf.asIntBuffer().put(waveletBands).rewind();
+            backing.putInt(4, waveletBands.length);
+            putPointer(backing, 0, waveletBands_buf);
+            backing.putInt(12, textureFeaturesRows);
+            backing.putInt(16, textureFeaturesCols);
+        }
+        public int size() {
+            return 20;
+        }
+    }
+
+    public static class WaveletBandsReport extends DisposedStruct {
+        public float LHLBand; // 2-D array for LHL Band.
+        public int rows; // Number of Rows for each of the 2-D arrays.
+        public int cols; // Number of Columns for each of the 2-D arrays.
+
+        private void init() {
+            
+        }
+        public WaveletBandsReport() {
+            super(40);
+            init();
+        }
+        public WaveletBandsReport(double LHLBand, int rows, int cols) {
+            super(40);
+            this.LHLBand = (float)LHLBand;
+            this.rows = rows;
+            this.cols = cols;
+        }
+        protected WaveletBandsReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 40);
+            init();
+        }
+        protected WaveletBandsReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 40);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 40);
+        }
+        public void read() {
+            LHLBand = backing.getFloat(24);
+            rows = backing.getInt(32);
+            cols = backing.getInt(36);
+        }
+        public void write() {
+            backing.putFloat(24, LHLBand);
+            backing.putInt(32, rows);
+            backing.putInt(36, cols);
+        }
+        public int size() {
+            return 40;
+        }
+    }
+
+    public static class CircleFitOptions extends DisposedStruct {
+        public int maxRadius; // Specifies the acceptable distance, in pixels, that a point determined to belong to the circle can be from the perimeter of the circle.
+        public double stepSize; // Step Size is the angle, in degrees, between each radial line in the annular region.
+        public RakeProcessType processType; // Method used to process the data extracted for edge detection.
+
+        private void init() {
+            
+        }
+        public CircleFitOptions() {
+            super(24);
+            init();
+        }
+        public CircleFitOptions(int maxRadius, double stepSize, RakeProcessType processType) {
+            super(24);
+            this.maxRadius = maxRadius;
+            this.stepSize = stepSize;
+            this.processType = processType;
+        }
+        protected CircleFitOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected CircleFitOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            maxRadius = backing.getInt(0);
+            stepSize = backing.getDouble(8);
+            processType = RakeProcessType.fromValue(backing.getInt(16));
+        }
+        public void write() {
+            backing.putInt(0, maxRadius);
+            backing.putDouble(8, stepSize);
+            if (processType != null)
+                backing.putInt(16, processType.getValue());
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class EdgeOptions2 extends DisposedStruct {
+        public EdgePolaritySearchMode polarity; // Specifies the polarity of the edges to be found.
+        public int kernelSize; // Specifies the size of the edge detection kernel.
+        public int width; // Specifies the number of pixels averaged perpendicular to the search direction to compute the edge profile strength at each point along the search ROI.
+        public float minThreshold; // Specifies the minimum edge strength (gradient magnitude) required for a detected edge.
+        public InterpolationMethod interpolationType; // Specifies the interpolation method used to locate the edge position.
+        public ColumnProcessingMode columnProcessingMode; // Specifies the method used to find the straight edge.
+
+        private void init() {
+            
+        }
+        public EdgeOptions2() {
+            super(24);
+            init();
+        }
+        public EdgeOptions2(EdgePolaritySearchMode polarity, int kernelSize, int width, double minThreshold, InterpolationMethod interpolationType, ColumnProcessingMode columnProcessingMode) {
+            super(24);
+            this.polarity = polarity;
+            this.kernelSize = kernelSize;
+            this.width = width;
+            this.minThreshold = (float)minThreshold;
+            this.interpolationType = interpolationType;
+            this.columnProcessingMode = columnProcessingMode;
+        }
+        protected EdgeOptions2(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected EdgeOptions2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            polarity = EdgePolaritySearchMode.fromValue(backing.getInt(0));
+            kernelSize = backing.getInt(4);
+            width = backing.getInt(8);
+            minThreshold = backing.getFloat(12);
+            interpolationType = InterpolationMethod.fromValue(backing.getInt(16));
+            columnProcessingMode = ColumnProcessingMode.fromValue(backing.getInt(20));
+        }
+        public void write() {
+            if (polarity != null)
+                backing.putInt(0, polarity.getValue());
+            backing.putInt(4, kernelSize);
+            backing.putInt(8, width);
+            backing.putFloat(12, minThreshold);
+            if (interpolationType != null)
+                backing.putInt(16, interpolationType.getValue());
+            if (columnProcessingMode != null)
+                backing.putInt(20, columnProcessingMode.getValue());
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class FindCircularEdgeOptions extends DisposedStruct {
+        public SpokeDirection direction; // Specifies the Spoke direction to search in the ROI.
+        public int showSearchArea; // If TRUE, the function overlays the search area on the image.
+        public int showSearchLines; // If TRUE, the function overlays the search lines used to locate the edges on the image.
+        public int showEdgesFound; // If TRUE, the function overlays the locations of the edges found on the image.
+        public int showResult; // If TRUE, the function overlays the hit lines to the object and the edge used to generate the hit line on the result image.
+        public RGBValue searchAreaColor; // Specifies the RGB color value to use to overlay the search area.
+        public RGBValue searchLinesColor; // Specifies the RGB color value to use to overlay the search lines.
+        public RGBValue searchEdgesColor; // Specifies the RGB color value to use to overlay the search edges.
+        public RGBValue resultColor; // Specifies the RGB color value to use to overlay the results.
+        public String overlayGroupName; // Specifies the overlay group name to assign to the overlays.
+        public EdgeOptions2 edgeOptions; // Specifies the edge detection options along a single search line.
+        private ByteBuffer overlayGroupName_buf;
+
+        private void init() {
+            searchAreaColor = new RGBValue(backing, 20);
+            searchLinesColor = new RGBValue(backing, 24);
+            searchEdgesColor = new RGBValue(backing, 28);
+            resultColor = new RGBValue(backing, 32);
+            edgeOptions = new EdgeOptions2(backing, 40);
+        }
+        public FindCircularEdgeOptions() {
+            super(64);
+            init();
+        }
+        public FindCircularEdgeOptions(SpokeDirection direction, int showSearchArea, int showSearchLines, int showEdgesFound, int showResult, RGBValue searchAreaColor, RGBValue searchLinesColor, RGBValue searchEdgesColor, RGBValue resultColor, String overlayGroupName, EdgeOptions2 edgeOptions) {
+            super(64);
+            this.direction = direction;
+            this.showSearchArea = showSearchArea;
+            this.showSearchLines = showSearchLines;
+            this.showEdgesFound = showEdgesFound;
+            this.showResult = showResult;
+            this.searchAreaColor = searchAreaColor;
+            this.searchLinesColor = searchLinesColor;
+            this.searchEdgesColor = searchEdgesColor;
+            this.resultColor = resultColor;
+            this.overlayGroupName = overlayGroupName;
+            this.edgeOptions = edgeOptions;
+        }
+        protected FindCircularEdgeOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 64);
+            init();
+        }
+        protected FindCircularEdgeOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 64);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 64);
+        }
+        public void read() {
+            direction = SpokeDirection.fromValue(backing.getInt(0));
+            showSearchArea = backing.getInt(4);
+            showSearchLines = backing.getInt(8);
+            showEdgesFound = backing.getInt(12);
+            showResult = backing.getInt(16);
+            searchAreaColor.read();
+            searchLinesColor.read();
+            searchEdgesColor.read();
+            resultColor.read();
+            long overlayGroupName_addr = getPointer(backing, 36);
+            if (overlayGroupName_addr == 0)
+                overlayGroupName = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(overlayGroupName_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    overlayGroupName = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    overlayGroupName = "";
+                }
+            }
+            
+            edgeOptions.read();
+        }
+        public void write() {
+            if (direction != null)
+                backing.putInt(0, direction.getValue());
+            backing.putInt(4, showSearchArea);
+            backing.putInt(8, showSearchLines);
+            backing.putInt(12, showEdgesFound);
+            backing.putInt(16, showResult);
+            searchAreaColor.write();
+            searchLinesColor.write();
+            searchEdgesColor.write();
+            resultColor.write();
+            if (overlayGroupName != null) {
+                byte[] overlayGroupName_bytes;
+                try {
+                    overlayGroupName_bytes = overlayGroupName.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    overlayGroupName_bytes = new byte[0];
+                }
+                overlayGroupName_buf = ByteBuffer.allocateDirect(overlayGroupName_bytes.length+1);
+                putBytes(overlayGroupName_buf, overlayGroupName_bytes, 0, overlayGroupName_bytes.length).put(overlayGroupName_bytes.length, (byte)0);
+            }
+            putPointer(backing, 36, overlayGroupName == null ? 0 : getByteBufferAddress(overlayGroupName_buf));
+            edgeOptions.write();
+        }
+        public int size() {
+            return 64;
+        }
+    }
+
+    public static class FindConcentricEdgeOptions extends DisposedStruct {
+        public ConcentricRakeDirection direction; // Specifies the Concentric Rake direction.
+        public int showSearchArea; // If TRUE, the function overlays the search area on the image.
+        public int showSearchLines; // If TRUE, the function overlays the search lines used to locate the edges on the image.
+        public int showEdgesFound; // If TRUE, the function overlays the locations of the edges found on the image.
+        public int showResult; // If TRUE, the function overlays the hit lines to the object and the edge used to generate the hit line on the result image.
+        public RGBValue searchAreaColor; // Specifies the RGB color value to use to overlay the search area.
+        public RGBValue searchLinesColor; // Specifies the RGB color value to use to overlay the search lines.
+        public RGBValue searchEdgesColor; // Specifies the RGB color value to use to overlay the search edges.
+        public RGBValue resultColor; // Specifies the RGB color value to use to overlay the results.
+        public String overlayGroupName; // Specifies the overlay group name to assign to the overlays.
+        public EdgeOptions2 edgeOptions; // Specifies the edge detection options along a single search line.
+        private ByteBuffer overlayGroupName_buf;
+
+        private void init() {
+            searchAreaColor = new RGBValue(backing, 20);
+            searchLinesColor = new RGBValue(backing, 24);
+            searchEdgesColor = new RGBValue(backing, 28);
+            resultColor = new RGBValue(backing, 32);
+            edgeOptions = new EdgeOptions2(backing, 40);
+        }
+        public FindConcentricEdgeOptions() {
+            super(64);
+            init();
+        }
+        public FindConcentricEdgeOptions(ConcentricRakeDirection direction, int showSearchArea, int showSearchLines, int showEdgesFound, int showResult, RGBValue searchAreaColor, RGBValue searchLinesColor, RGBValue searchEdgesColor, RGBValue resultColor, String overlayGroupName, EdgeOptions2 edgeOptions) {
+            super(64);
+            this.direction = direction;
+            this.showSearchArea = showSearchArea;
+            this.showSearchLines = showSearchLines;
+            this.showEdgesFound = showEdgesFound;
+            this.showResult = showResult;
+            this.searchAreaColor = searchAreaColor;
+            this.searchLinesColor = searchLinesColor;
+            this.searchEdgesColor = searchEdgesColor;
+            this.resultColor = resultColor;
+            this.overlayGroupName = overlayGroupName;
+            this.edgeOptions = edgeOptions;
+        }
+        protected FindConcentricEdgeOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 64);
+            init();
+        }
+        protected FindConcentricEdgeOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 64);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 64);
+        }
+        public void read() {
+            direction = ConcentricRakeDirection.fromValue(backing.getInt(0));
+            showSearchArea = backing.getInt(4);
+            showSearchLines = backing.getInt(8);
+            showEdgesFound = backing.getInt(12);
+            showResult = backing.getInt(16);
+            searchAreaColor.read();
+            searchLinesColor.read();
+            searchEdgesColor.read();
+            resultColor.read();
+            long overlayGroupName_addr = getPointer(backing, 36);
+            if (overlayGroupName_addr == 0)
+                overlayGroupName = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(overlayGroupName_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    overlayGroupName = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    overlayGroupName = "";
+                }
+            }
+            
+            edgeOptions.read();
+        }
+        public void write() {
+            if (direction != null)
+                backing.putInt(0, direction.getValue());
+            backing.putInt(4, showSearchArea);
+            backing.putInt(8, showSearchLines);
+            backing.putInt(12, showEdgesFound);
+            backing.putInt(16, showResult);
+            searchAreaColor.write();
+            searchLinesColor.write();
+            searchEdgesColor.write();
+            resultColor.write();
+            if (overlayGroupName != null) {
+                byte[] overlayGroupName_bytes;
+                try {
+                    overlayGroupName_bytes = overlayGroupName.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    overlayGroupName_bytes = new byte[0];
+                }
+                overlayGroupName_buf = ByteBuffer.allocateDirect(overlayGroupName_bytes.length+1);
+                putBytes(overlayGroupName_buf, overlayGroupName_bytes, 0, overlayGroupName_bytes.length).put(overlayGroupName_bytes.length, (byte)0);
+            }
+            putPointer(backing, 36, overlayGroupName == null ? 0 : getByteBufferAddress(overlayGroupName_buf));
+            edgeOptions.write();
+        }
+        public int size() {
+            return 64;
+        }
+    }
+
+    public static class ConcentricEdgeFitOptions extends DisposedStruct {
+        public int maxRadius; // Specifies the acceptable distance, in pixels, that a point determined to belong to the circle can be from the perimeter of the circle.
+        public double stepSize; // The sampling factor that determines the gap between the rake lines.
+        public RakeProcessType processType; // Method used to process the data extracted for edge detection.
+
+        private void init() {
+            
+        }
+        public ConcentricEdgeFitOptions() {
+            super(24);
+            init();
+        }
+        public ConcentricEdgeFitOptions(int maxRadius, double stepSize, RakeProcessType processType) {
+            super(24);
+            this.maxRadius = maxRadius;
+            this.stepSize = stepSize;
+            this.processType = processType;
+        }
+        protected ConcentricEdgeFitOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected ConcentricEdgeFitOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            maxRadius = backing.getInt(0);
+            stepSize = backing.getDouble(8);
+            processType = RakeProcessType.fromValue(backing.getInt(16));
+        }
+        public void write() {
+            backing.putInt(0, maxRadius);
+            backing.putDouble(8, stepSize);
+            if (processType != null)
+                backing.putInt(16, processType.getValue());
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class FindConcentricEdgeReport extends DisposedStruct {
+        public PointFloat startPt; // Pixel Coordinates for starting point of the edge.
+        public PointFloat endPt; // Pixel Coordinates for end point of the edge.
+        public PointFloat startPtCalibrated; // Real world Coordinates for starting point of the edge.
+        public PointFloat endPtCalibrated; // Real world Coordinates for end point of the edge.
+        public double angle; // Angle of the edge found.
+        public double angleCalibrated; // Calibrated angle of the edge found.
+        public double straightness; // The straightness value of the detected straight edge.
+        public double avgStrength; // Average strength of the egde found.
+        public double avgSNR; // Average SNR(Signal to Noise Ratio) for the edge found.
+        public int lineFound; // If the edge is found or not.
+
+        private void init() {
+            startPt = new PointFloat(backing, 0);
+            endPt = new PointFloat(backing, 8);
+            startPtCalibrated = new PointFloat(backing, 16);
+            endPtCalibrated = new PointFloat(backing, 24);
+        }
+        public FindConcentricEdgeReport() {
+            super(80);
+            init();
+        }
+        public FindConcentricEdgeReport(PointFloat startPt, PointFloat endPt, PointFloat startPtCalibrated, PointFloat endPtCalibrated, double angle, double angleCalibrated, double straightness, double avgStrength, double avgSNR, int lineFound) {
+            super(80);
+            this.startPt = startPt;
+            this.endPt = endPt;
+            this.startPtCalibrated = startPtCalibrated;
+            this.endPtCalibrated = endPtCalibrated;
+            this.angle = angle;
+            this.angleCalibrated = angleCalibrated;
+            this.straightness = straightness;
+            this.avgStrength = avgStrength;
+            this.avgSNR = avgSNR;
+            this.lineFound = lineFound;
+        }
+        protected FindConcentricEdgeReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 80);
+            init();
+        }
+        protected FindConcentricEdgeReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 80);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 80);
+        }
+        public void read() {
+            startPt.read();
+            endPt.read();
+            startPtCalibrated.read();
+            endPtCalibrated.read();
+            angle = backing.getDouble(32);
+            angleCalibrated = backing.getDouble(40);
+            straightness = backing.getDouble(48);
+            avgStrength = backing.getDouble(56);
+            avgSNR = backing.getDouble(64);
+            lineFound = backing.getInt(72);
+        }
+        public void write() {
+            startPt.write();
+            endPt.write();
+            startPtCalibrated.write();
+            endPtCalibrated.write();
+            backing.putDouble(32, angle);
+            backing.putDouble(40, angleCalibrated);
+            backing.putDouble(48, straightness);
+            backing.putDouble(56, avgStrength);
+            backing.putDouble(64, avgSNR);
+            backing.putInt(72, lineFound);
+        }
+        public int size() {
+            return 80;
+        }
+    }
+
+    public static class FindCircularEdgeReport extends DisposedStruct {
+        public PointFloat centerCalibrated; // Real world Coordinates of the Center.
+        public double radiusCalibrated; // Real world radius of the Circular Edge found.
+        public PointFloat center; // Pixel Coordinates of the Center.
+        public double radius; // Radius in pixels of the Circular Edge found.
+        public double roundness; // The roundness of the calculated circular edge.
+        public double avgStrength; // Average strength of the egde found.
+        public double avgSNR; // Average SNR(Signal to Noise Ratio) for the edge found.
+        public int circleFound; // If the circlular edge is found or not.
+
+        private void init() {
+            centerCalibrated = new PointFloat(backing, 0);
+            center = new PointFloat(backing, 16);
+        }
+        public FindCircularEdgeReport() {
+            super(64);
+            init();
+        }
+        public FindCircularEdgeReport(PointFloat centerCalibrated, double radiusCalibrated, PointFloat center, double radius, double roundness, double avgStrength, double avgSNR, int circleFound) {
+            super(64);
+            this.centerCalibrated = centerCalibrated;
+            this.radiusCalibrated = radiusCalibrated;
+            this.center = center;
+            this.radius = radius;
+            this.roundness = roundness;
+            this.avgStrength = avgStrength;
+            this.avgSNR = avgSNR;
+            this.circleFound = circleFound;
+        }
+        protected FindCircularEdgeReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 64);
+            init();
+        }
+        protected FindCircularEdgeReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 64);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 64);
+        }
+        public void read() {
+            centerCalibrated.read();
+            radiusCalibrated = backing.getDouble(8);
+            center.read();
+            radius = backing.getDouble(24);
+            roundness = backing.getDouble(32);
+            avgStrength = backing.getDouble(40);
+            avgSNR = backing.getDouble(48);
+            circleFound = backing.getInt(56);
+        }
+        public void write() {
+            centerCalibrated.write();
+            backing.putDouble(8, radiusCalibrated);
+            center.write();
+            backing.putDouble(24, radius);
+            backing.putDouble(32, roundness);
+            backing.putDouble(40, avgStrength);
+            backing.putDouble(48, avgSNR);
+            backing.putInt(56, circleFound);
+        }
+        public int size() {
+            return 64;
+        }
+    }
+
+    public static class WindowSize extends DisposedStruct {
+        public int x; // Window lenght on X direction.
+        public int y; // Window lenght on Y direction.
+        public int stepSize; // Distance between windows.
+
+        private void init() {
+            
+        }
+        public WindowSize() {
+            super(12);
+            init();
+        }
+        public WindowSize(int x, int y, int stepSize) {
+            super(12);
+            this.x = x;
+            this.y = y;
+            this.stepSize = stepSize;
+        }
+        protected WindowSize(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected WindowSize(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            x = backing.getInt(0);
+            y = backing.getInt(4);
+            stepSize = backing.getInt(8);
+        }
+        public void write() {
+            backing.putInt(0, x);
+            backing.putInt(4, y);
+            backing.putInt(8, stepSize);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class DisplacementVector extends DisposedStruct {
+        public int x; // length on X direction.
+        public int y; // length on Y direction.
+
+        private void init() {
+            
+        }
+        public DisplacementVector() {
+            super(8);
+            init();
+        }
+        public DisplacementVector(int x, int y) {
+            super(8);
+            this.x = x;
+            this.y = y;
+        }
+        protected DisplacementVector(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected DisplacementVector(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            x = backing.getInt(0);
+            y = backing.getInt(4);
+        }
+        public void write() {
+            backing.putInt(0, x);
+            backing.putInt(4, y);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class WaveletOptions extends DisposedStruct {
+        public WaveletType typeOfWavelet; // Type of wavelet(db, bior.
+        public float minEnergy; // Minimum Energy in the bands to consider for texture defect detection.
+
+        private void init() {
+            
+        }
+        public WaveletOptions() {
+            super(8);
+            init();
+        }
+        public WaveletOptions(WaveletType typeOfWavelet, double minEnergy) {
+            super(8);
+            this.typeOfWavelet = typeOfWavelet;
+            this.minEnergy = (float)minEnergy;
+        }
+        protected WaveletOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected WaveletOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            typeOfWavelet = WaveletType.fromValue(backing.getInt(0));
+            minEnergy = backing.getFloat(4);
+        }
+        public void write() {
+            if (typeOfWavelet != null)
+                backing.putInt(0, typeOfWavelet.getValue());
+            backing.putFloat(4, minEnergy);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class CooccurrenceOptions extends DisposedStruct {
+        public int level; // Level/size of matrix.
+        public DisplacementVector displacement; // Displacemnet between pixels to accumulate the matrix.
+
+        private void init() {
+            displacement = new DisplacementVector(backing, 4);
+        }
+        public CooccurrenceOptions() {
+            super(12);
+            init();
+        }
+        public CooccurrenceOptions(int level, DisplacementVector displacement) {
+            super(12);
+            this.level = level;
+            this.displacement = displacement;
+        }
+        protected CooccurrenceOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected CooccurrenceOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            level = backing.getInt(0);
+            displacement.read();
+        }
+        public void write() {
+            backing.putInt(0, level);
+            displacement.write();
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class ParticleClassifierLocalThresholdOptions extends DisposedStruct {
+        public LocalThresholdMethod method; // Specifies the local thresholding method the function uses.
+        public ParticleType particleType; // Specifies what kind of particles to look for.
+        public int windowWidth; // The width of the rectangular window around the pixel on which the function performs the local threshold.
+        public int windowHeight; // The height of the rectangular window around the pixel on which the function performs the local threshold.
+        public double deviationWeight; // Specifies the k constant used in the Niblack local thresholding algorithm, which determines the weight applied to the variance calculation.
+
+        private void init() {
+            
+        }
+        public ParticleClassifierLocalThresholdOptions() {
+            super(24);
+            init();
+        }
+        public ParticleClassifierLocalThresholdOptions(LocalThresholdMethod method, ParticleType particleType, int windowWidth, int windowHeight, double deviationWeight) {
+            super(24);
+            this.method = method;
+            this.particleType = particleType;
+            this.windowWidth = windowWidth;
+            this.windowHeight = windowHeight;
+            this.deviationWeight = deviationWeight;
+        }
+        protected ParticleClassifierLocalThresholdOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected ParticleClassifierLocalThresholdOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            method = LocalThresholdMethod.fromValue(backing.getInt(0));
+            particleType = ParticleType.fromValue(backing.getInt(4));
+            windowWidth = backing.getInt(8);
+            windowHeight = backing.getInt(12);
+            deviationWeight = backing.getDouble(16);
+        }
+        public void write() {
+            if (method != null)
+                backing.putInt(0, method.getValue());
+            if (particleType != null)
+                backing.putInt(4, particleType.getValue());
+            backing.putInt(8, windowWidth);
+            backing.putInt(12, windowHeight);
+            backing.putDouble(16, deviationWeight);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class RangeFloat extends DisposedStruct {
+        public float minValue; // The minimum value of the range.
+        public float maxValue; // The maximum value of the range.
+
+        private void init() {
+            
+        }
+        public RangeFloat() {
+            super(8);
+            init();
+        }
+        public RangeFloat(double minValue, double maxValue) {
+            super(8);
+            this.minValue = (float)minValue;
+            this.maxValue = (float)maxValue;
+        }
+        protected RangeFloat(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected RangeFloat(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            minValue = backing.getFloat(0);
+            maxValue = backing.getFloat(4);
+        }
+        public void write() {
+            backing.putFloat(0, minValue);
+            backing.putFloat(4, maxValue);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class ParticleClassifierAutoThresholdOptions extends DisposedStruct {
+        public ThresholdMethod method; // The method for binary thresholding, which specifies how to calculate the classes.
+        public ParticleType particleType; // Specifies what kind of particles to look for.
+        public RangeFloat limits; // The limits on the automatic threshold range.
+
+        private void init() {
+            limits = new RangeFloat(backing, 8);
+        }
+        public ParticleClassifierAutoThresholdOptions() {
+            super(16);
+            init();
+        }
+        public ParticleClassifierAutoThresholdOptions(ThresholdMethod method, ParticleType particleType, RangeFloat limits) {
+            super(16);
+            this.method = method;
+            this.particleType = particleType;
+            this.limits = limits;
+        }
+        protected ParticleClassifierAutoThresholdOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected ParticleClassifierAutoThresholdOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            method = ThresholdMethod.fromValue(backing.getInt(0));
+            particleType = ParticleType.fromValue(backing.getInt(4));
+            limits.read();
+        }
+        public void write() {
+            if (method != null)
+                backing.putInt(0, method.getValue());
+            if (particleType != null)
+                backing.putInt(4, particleType.getValue());
+            limits.write();
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class ParticleClassifierPreprocessingOptions2 extends DisposedStruct {
+        public ParticleClassifierThresholdType thresholdType; // The type of threshold to perform on the image.
+        public RangeFloat manualThresholdRange; // The range of pixels to keep if manually thresholding the image.
+        public ParticleClassifierAutoThresholdOptions autoThresholdOptions; // The options used to auto threshold the image.
+        public ParticleClassifierLocalThresholdOptions localThresholdOptions; // The options used to local threshold the image.
+        public int rejectBorder; // Set this element to TRUE to reject border particles.
+        public int numErosions; // The number of erosions to perform.
+
+        private void init() {
+            manualThresholdRange = new RangeFloat(backing, 4);
+            autoThresholdOptions = new ParticleClassifierAutoThresholdOptions(backing, 12);
+            localThresholdOptions = new ParticleClassifierLocalThresholdOptions(backing, 32);
+        }
+        public ParticleClassifierPreprocessingOptions2() {
+            super(64);
+            init();
+        }
+        public ParticleClassifierPreprocessingOptions2(ParticleClassifierThresholdType thresholdType, RangeFloat manualThresholdRange, ParticleClassifierAutoThresholdOptions autoThresholdOptions, ParticleClassifierLocalThresholdOptions localThresholdOptions, int rejectBorder, int numErosions) {
+            super(64);
+            this.thresholdType = thresholdType;
+            this.manualThresholdRange = manualThresholdRange;
+            this.autoThresholdOptions = autoThresholdOptions;
+            this.localThresholdOptions = localThresholdOptions;
+            this.rejectBorder = rejectBorder;
+            this.numErosions = numErosions;
+        }
+        protected ParticleClassifierPreprocessingOptions2(ByteBuffer backing, int offset) {
+            super(backing, offset, 64);
+            init();
+        }
+        protected ParticleClassifierPreprocessingOptions2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 64);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 64);
+        }
+        public void read() {
+            thresholdType = ParticleClassifierThresholdType.fromValue(backing.getInt(0));
+            manualThresholdRange.read();
+            autoThresholdOptions.read();
+            localThresholdOptions.read();
+            rejectBorder = backing.getInt(56);
+            numErosions = backing.getInt(60);
+        }
+        public void write() {
+            if (thresholdType != null)
+                backing.putInt(0, thresholdType.getValue());
+            manualThresholdRange.write();
+            autoThresholdOptions.write();
+            localThresholdOptions.write();
+            backing.putInt(56, rejectBorder);
+            backing.putInt(60, numErosions);
+        }
+        public int size() {
+            return 64;
+        }
+    }
+
+    public static class MeasureParticlesReport extends DisposedStruct {
+        public int numParticles; // The number of particles on which measurements were taken.
+        public int numMeasurements; // The number of measurements taken.
+
+        private void init() {
+            
+        }
+        public MeasureParticlesReport() {
+            super(16);
+            init();
+        }
+        public MeasureParticlesReport(int numParticles, int numMeasurements) {
+            super(16);
+            this.numParticles = numParticles;
+            this.numMeasurements = numMeasurements;
+        }
+        protected MeasureParticlesReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected MeasureParticlesReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            numParticles = backing.getInt(8);
+            numMeasurements = backing.getInt(12);
+        }
+        public void write() {
+            backing.putInt(8, numParticles);
+            backing.putInt(12, numMeasurements);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class GeometricPatternMatch3 extends DisposedStruct {
+        public PointFloat position; // The location of the origin of the template in the match.
+        public float rotation; // The rotation of the match relative to the template image, in degrees.
+        public float scale; // The size of the match relative to the size of the template image, expressed as a percentage.
+        public float score; // The accuracy of the match.
+        public PointFloat[] corner; // An array of four points describing the rectangle surrounding the template image.
+        public int inverse; // This element is TRUE if the match is an inverse of the template image.
+        public float occlusion; // The percentage of the match that is occluded.
+        public float templateMatchCurveScore; // The accuracy of the match obtained by comparing the template curves to the curves in the match region.
+        public float matchTemplateCurveScore; // The accuracy of the match obtained by comparing the curves in the match region to the template curves.
+        public float correlationScore; // The accuracy of the match obtained by comparing the template image to the match region using a correlation metric that compares the two regions as a function of their pixel values.
+        public PointFloat calibratedPosition; // The location of the origin of the template in the match.
+        public float calibratedRotation; // The rotation of the match relative to the template image, in degrees.
+        public PointFloat[] calibratedCorner; // An array of four points describing the rectangle surrounding the template image.
+
+        private void init() {
+            position = new PointFloat(backing, 0);
+            corner = new PointFloat[4];
+            
+            for (int i=0, off=20; i<4; i++, off += 8)
+                corner[i] = new PointFloat(backing, off);
+            calibratedPosition = new PointFloat(backing, 72);
+            calibratedCorner = new PointFloat[4];
+            
+            for (int i=0, off=84; i<4; i++, off += 8)
+                calibratedCorner[i] = new PointFloat(backing, off);
+        }
+        public GeometricPatternMatch3() {
+            super(116);
+            init();
+        }
+        public GeometricPatternMatch3(PointFloat position, double rotation, double scale, double score, PointFloat[] corner, int inverse, double occlusion, double templateMatchCurveScore, double matchTemplateCurveScore, double correlationScore, PointFloat calibratedPosition, double calibratedRotation, PointFloat[] calibratedCorner) {
+            super(116);
+            this.position = position;
+            this.rotation = (float)rotation;
+            this.scale = (float)scale;
+            this.score = (float)score;
+            this.corner = corner;
+            this.inverse = inverse;
+            this.occlusion = (float)occlusion;
+            this.templateMatchCurveScore = (float)templateMatchCurveScore;
+            this.matchTemplateCurveScore = (float)matchTemplateCurveScore;
+            this.correlationScore = (float)correlationScore;
+            this.calibratedPosition = calibratedPosition;
+            this.calibratedRotation = (float)calibratedRotation;
+            this.calibratedCorner = calibratedCorner;
+        }
+        protected GeometricPatternMatch3(ByteBuffer backing, int offset) {
+            super(backing, offset, 116);
+            init();
+        }
+        protected GeometricPatternMatch3(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 116);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 116);
+        }
+        public void read() {
+            position.read();
+            rotation = backing.getFloat(8);
+            scale = backing.getFloat(12);
+            score = backing.getFloat(16);
+            for (PointFloat it : corner) {
+                it.read();
+            }
+            inverse = backing.getInt(52);
+            occlusion = backing.getFloat(56);
+            templateMatchCurveScore = backing.getFloat(60);
+            matchTemplateCurveScore = backing.getFloat(64);
+            correlationScore = backing.getFloat(68);
+            calibratedPosition.read();
+            calibratedRotation = backing.getFloat(80);
+            for (PointFloat it : calibratedCorner) {
+                it.read();
+            }
+        }
+        public void write() {
+            position.write();
+            backing.putFloat(8, rotation);
+            backing.putFloat(12, scale);
+            backing.putFloat(16, score);
+            for (PointFloat it : corner) {
+                it.write();
+            }
+            backing.putInt(52, inverse);
+            backing.putFloat(56, occlusion);
+            backing.putFloat(60, templateMatchCurveScore);
+            backing.putFloat(64, matchTemplateCurveScore);
+            backing.putFloat(68, correlationScore);
+            calibratedPosition.write();
+            backing.putFloat(80, calibratedRotation);
+            for (PointFloat it : calibratedCorner) {
+                it.write();
+            }
+        }
+        public int size() {
+            return 116;
+        }
+    }
+
+    public static class MatchGeometricPatternAdvancedOptions3 extends DisposedStruct {
+        public int subpixelIterations; // Specifies the maximum number of incremental improvements used to refine matches with subpixel information.
+        public double subpixelTolerance; // Specifies the maximum amount of change, in pixels, between consecutive incremental improvements in the match position before the function stops refining the match position.
+        public int initialMatchListLength; // Specifies the maximum size of the match list.
+        public int targetTemplateCurveScore; // Set this element to TRUE to specify that the function should calculate the match curve to template curve score and return it for each match result.
+        public int correlationScore; // Set this element to TRUE to specify that the function should calculate the correlation score and return it for each match result.
+        public double minMatchSeparationDistance; // Specifies the minimum separation distance, in pixels, between the origins of two matches that have unique positions.
+        public double minMatchSeparationAngle; // Specifies the minimum angular difference, in degrees, between two matches that have unique angles.
+        public double minMatchSeparationScale; // Specifies the minimum difference in scale, expressed as a percentage, between two matches that have unique scales.
+        public double maxMatchOverlap; // Specifies the maximum amount of overlap, expressed as a percentage, allowed between the bounding rectangles of two unique matches.
+        public int coarseResult; // Specifies whether you want the function to spend less time accurately estimating the location of a match.
+        public int enableCalibrationSupport; // Set this element to TRUE to specify the algorithm treat the inspection image as a calibrated image.
+        public ContrastMode enableContrastReversal; // Use this element to specify the contrast of the matches to search for in the image.
+        public GeometricMatchingSearchStrategy matchStrategy; // Specifies the aggressiveness of the search strategy.
+        public int refineMatchFactor; // Specifies the factor that is applied to the number of matches requested by the user to determine the number of matches that are refined at the initial matching stage.
+        public int subpixelMatchFactor; // Specifies the factor that is applied to the number of matches requested by the user to determine the number of matches that are evaluated at the final subpixel matching stage.
+
+        private void init() {
+            
+        }
+        public MatchGeometricPatternAdvancedOptions3() {
+            super(88);
+            init();
+        }
+        public MatchGeometricPatternAdvancedOptions3(int subpixelIterations, double subpixelTolerance, int initialMatchListLength, int targetTemplateCurveScore, int correlationScore, double minMatchSeparationDistance, double minMatchSeparationAngle, double minMatchSeparationScale, double maxMatchOverlap, int coarseResult, int enableCalibrationSupport, ContrastMode enableContrastReversal, GeometricMatchingSearchStrategy matchStrategy, int refineMatchFactor, int subpixelMatchFactor) {
+            super(88);
+            this.subpixelIterations = subpixelIterations;
+            this.subpixelTolerance = subpixelTolerance;
+            this.initialMatchListLength = initialMatchListLength;
+            this.targetTemplateCurveScore = targetTemplateCurveScore;
+            this.correlationScore = correlationScore;
+            this.minMatchSeparationDistance = minMatchSeparationDistance;
+            this.minMatchSeparationAngle = minMatchSeparationAngle;
+            this.minMatchSeparationScale = minMatchSeparationScale;
+            this.maxMatchOverlap = maxMatchOverlap;
+            this.coarseResult = coarseResult;
+            this.enableCalibrationSupport = enableCalibrationSupport;
+            this.enableContrastReversal = enableContrastReversal;
+            this.matchStrategy = matchStrategy;
+            this.refineMatchFactor = refineMatchFactor;
+            this.subpixelMatchFactor = subpixelMatchFactor;
+        }
+        protected MatchGeometricPatternAdvancedOptions3(ByteBuffer backing, int offset) {
+            super(backing, offset, 88);
+            init();
+        }
+        protected MatchGeometricPatternAdvancedOptions3(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 88);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 88);
+        }
+        public void read() {
+            subpixelIterations = backing.getInt(0);
+            subpixelTolerance = backing.getDouble(8);
+            initialMatchListLength = backing.getInt(16);
+            targetTemplateCurveScore = backing.getInt(20);
+            correlationScore = backing.getInt(24);
+            minMatchSeparationDistance = backing.getDouble(32);
+            minMatchSeparationAngle = backing.getDouble(40);
+            minMatchSeparationScale = backing.getDouble(48);
+            maxMatchOverlap = backing.getDouble(56);
+            coarseResult = backing.getInt(64);
+            enableCalibrationSupport = backing.getInt(68);
+            enableContrastReversal = ContrastMode.fromValue(backing.getInt(72));
+            matchStrategy = GeometricMatchingSearchStrategy.fromValue(backing.getInt(76));
+            refineMatchFactor = backing.getInt(80);
+            subpixelMatchFactor = backing.getInt(84);
+        }
+        public void write() {
+            backing.putInt(0, subpixelIterations);
+            backing.putDouble(8, subpixelTolerance);
+            backing.putInt(16, initialMatchListLength);
+            backing.putInt(20, targetTemplateCurveScore);
+            backing.putInt(24, correlationScore);
+            backing.putDouble(32, minMatchSeparationDistance);
+            backing.putDouble(40, minMatchSeparationAngle);
+            backing.putDouble(48, minMatchSeparationScale);
+            backing.putDouble(56, maxMatchOverlap);
+            backing.putInt(64, coarseResult);
+            backing.putInt(68, enableCalibrationSupport);
+            if (enableContrastReversal != null)
+                backing.putInt(72, enableContrastReversal.getValue());
+            if (matchStrategy != null)
+                backing.putInt(76, matchStrategy.getValue());
+            backing.putInt(80, refineMatchFactor);
+            backing.putInt(84, subpixelMatchFactor);
+        }
+        public int size() {
+            return 88;
+        }
+    }
+
+    public static class ColorOptions extends DisposedStruct {
+        public ColorClassificationResolution colorClassificationResolution; // Specifies the color resolution of the classifier.
+        public int useLuminance; // Specifies if the luminance band is going to be used in the feature vector.
+        public ColorMode colorMode; // Specifies the color mode of the classifier.
+
+        private void init() {
+            
+        }
+        public ColorOptions() {
+            super(12);
+            init();
+        }
+        public ColorOptions(ColorClassificationResolution colorClassificationResolution, int useLuminance, ColorMode colorMode) {
+            super(12);
+            this.colorClassificationResolution = colorClassificationResolution;
+            this.useLuminance = useLuminance;
+            this.colorMode = colorMode;
+        }
+        protected ColorOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected ColorOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            colorClassificationResolution = ColorClassificationResolution.fromValue(backing.getInt(0));
+            useLuminance = backing.getInt(4);
+            colorMode = ColorMode.fromValue(backing.getInt(8));
+        }
+        public void write() {
+            if (colorClassificationResolution != null)
+                backing.putInt(0, colorClassificationResolution.getValue());
+            backing.putInt(4, useLuminance);
+            if (colorMode != null)
+                backing.putInt(8, colorMode.getValue());
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class SampleScore extends DisposedStruct {
+        public String className; // The name of the class.
+        public float distance; // The distance from the item to this class.
+        public int index; // index of this sample.
+        private ByteBuffer className_buf;
+
+        private void init() {
+            
+        }
+        public SampleScore() {
+            super(12);
+            init();
+        }
+        public SampleScore(String className, double distance, int index) {
+            super(12);
+            this.className = className;
+            this.distance = (float)distance;
+            this.index = index;
+        }
+        protected SampleScore(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected SampleScore(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            long className_addr = getPointer(backing, 0);
+            if (className_addr == 0)
+                className = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(className_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    className = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    className = "";
+                }
+            }
+            
+            distance = backing.getFloat(4);
+            index = backing.getInt(8);
+        }
+        public void write() {
+            if (className != null) {
+                byte[] className_bytes;
+                try {
+                    className_bytes = className.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    className_bytes = new byte[0];
+                }
+                className_buf = ByteBuffer.allocateDirect(className_bytes.length+1);
+                putBytes(className_buf, className_bytes, 0, className_bytes.length).put(className_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, className == null ? 0 : getByteBufferAddress(className_buf));
+            backing.putFloat(4, distance);
+            backing.putInt(8, index);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class ClassifierReportAdvanced extends DisposedStruct {
+        public String bestClassName; // The name of the best class for the sample.
+        public float classificationScore; // The similarity of the sample and the two closest classes in the classifier.
+        public float identificationScore; // The similarity of the sample and the assigned class.
+        public ClassScore[] allScores; // All classes and their scores.
+        public SampleScore[] sampleScores; // All samples and their scores.
+        private ByteBuffer bestClassName_buf;
+        private ByteBuffer allScores_buf;
+        private ByteBuffer sampleScores_buf;
+
+        private void init() {
+            allScores = new ClassScore[0];
+            sampleScores = new SampleScore[0];
+        }
+        public ClassifierReportAdvanced() {
+            super(28);
+            init();
+        }
+        public ClassifierReportAdvanced(String bestClassName, double classificationScore, double identificationScore, ClassScore[] allScores, SampleScore[] sampleScores) {
+            super(28);
+            this.bestClassName = bestClassName;
+            this.classificationScore = (float)classificationScore;
+            this.identificationScore = (float)identificationScore;
+            this.allScores = allScores;
+            this.sampleScores = sampleScores;
+        }
+        protected ClassifierReportAdvanced(ByteBuffer backing, int offset) {
+            super(backing, offset, 28);
+            init();
+        }
+        protected ClassifierReportAdvanced(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 28);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 28);
+        }
+        public void read() {
+            long bestClassName_addr = getPointer(backing, 0);
+            if (bestClassName_addr == 0)
+                bestClassName = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(bestClassName_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    bestClassName = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    bestClassName = "";
+                }
+            }
+            
+            classificationScore = backing.getFloat(4);
+            identificationScore = backing.getFloat(8);
+            int allScores_allScoresSize = backing.getInt(16);
+            long allScores_addr = getPointer(backing, 12);
+            allScores = new ClassScore[allScores_allScoresSize];
+            if (allScores_allScoresSize > 0 && allScores_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(allScores_addr, allScores_allScoresSize*8);
+                for (int i=0, off=0; i<allScores_allScoresSize; i++, off += 8) {
+                    allScores[i] = new ClassScore(bb, off);
+                    allScores[i].read();
+                }
+            }
+            int sampleScores_sampleScoresSize = backing.getInt(24);
+            long sampleScores_addr = getPointer(backing, 20);
+            sampleScores = new SampleScore[sampleScores_sampleScoresSize];
+            if (sampleScores_sampleScoresSize > 0 && sampleScores_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(sampleScores_addr, sampleScores_sampleScoresSize*12);
+                for (int i=0, off=0; i<sampleScores_sampleScoresSize; i++, off += 12) {
+                    sampleScores[i] = new SampleScore(bb, off);
+                    sampleScores[i].read();
+                }
+            }
+        }
+        public void write() {
+            if (bestClassName != null) {
+                byte[] bestClassName_bytes;
+                try {
+                    bestClassName_bytes = bestClassName.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    bestClassName_bytes = new byte[0];
+                }
+                bestClassName_buf = ByteBuffer.allocateDirect(bestClassName_bytes.length+1);
+                putBytes(bestClassName_buf, bestClassName_bytes, 0, bestClassName_bytes.length).put(bestClassName_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, bestClassName == null ? 0 : getByteBufferAddress(bestClassName_buf));
+            backing.putFloat(4, classificationScore);
+            backing.putFloat(8, identificationScore);
+            allScores_buf = ByteBuffer.allocateDirect(allScores.length*8);
+            for (int i=0, off=0; i<allScores.length; i++, off += 8) {
+                allScores[i].setBuffer(allScores_buf, off);
+                allScores[i].write();
+            }
+            backing.putInt(16, allScores.length);
+            putPointer(backing, 12, allScores_buf);
+            sampleScores_buf = ByteBuffer.allocateDirect(sampleScores.length*12);
+            for (int i=0, off=0; i<sampleScores.length; i++, off += 12) {
+                sampleScores[i].setBuffer(sampleScores_buf, off);
+                sampleScores[i].write();
+            }
+            backing.putInt(24, sampleScores.length);
+            putPointer(backing, 20, sampleScores_buf);
+        }
+        public int size() {
+            return 28;
+        }
+    }
+
+    public static class LearnGeometricPatternAdvancedOptions2 extends DisposedStruct {
+        public double minScaleFactor; // Specifies the minimum scale factor that the template is learned for.
+        public double maxScaleFactor; // Specifies the maximum scale factor the template is learned for.
+        public double minRotationAngleValue; // Specifies the minimum rotation angle the template is learned for.
+        public double maxRotationAngleValue; // Specifies the maximum rotation angle the template is learned for.
+        public int imageSamplingFactor; // Specifies the factor that is used to subsample the template and the image for the initial matching phase.
+
+        private void init() {
+            
+        }
+        public LearnGeometricPatternAdvancedOptions2() {
+            super(40);
+            init();
+        }
+        public LearnGeometricPatternAdvancedOptions2(double minScaleFactor, double maxScaleFactor, double minRotationAngleValue, double maxRotationAngleValue, int imageSamplingFactor) {
+            super(40);
+            this.minScaleFactor = minScaleFactor;
+            this.maxScaleFactor = maxScaleFactor;
+            this.minRotationAngleValue = minRotationAngleValue;
+            this.maxRotationAngleValue = maxRotationAngleValue;
+            this.imageSamplingFactor = imageSamplingFactor;
+        }
+        protected LearnGeometricPatternAdvancedOptions2(ByteBuffer backing, int offset) {
+            super(backing, offset, 40);
+            init();
+        }
+        protected LearnGeometricPatternAdvancedOptions2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 40);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 40);
+        }
+        public void read() {
+            minScaleFactor = backing.getDouble(0);
+            maxScaleFactor = backing.getDouble(8);
+            minRotationAngleValue = backing.getDouble(16);
+            maxRotationAngleValue = backing.getDouble(24);
+            imageSamplingFactor = backing.getInt(32);
+        }
+        public void write() {
+            backing.putDouble(0, minScaleFactor);
+            backing.putDouble(8, maxScaleFactor);
+            backing.putDouble(16, minRotationAngleValue);
+            backing.putDouble(24, maxRotationAngleValue);
+            backing.putInt(32, imageSamplingFactor);
+        }
+        public int size() {
+            return 40;
+        }
+    }
+
+    public static class ParticleFilterOptions2 extends DisposedStruct {
+        public int rejectMatches; // Set this parameter to TRUE to transfer only those particles that do not meet all the criteria.
+        public int rejectBorder; // Set this element to TRUE to reject border particles.
+        public int fillHoles; // Set this element to TRUE to fill holes in particles.
+        public int connectivity8; // Set this parameter to TRUE to use connectivity-8 to determine whether particles are touching.
+
+        private void init() {
+            
+        }
+        public ParticleFilterOptions2() {
+            super(16);
+            init();
+        }
+        public ParticleFilterOptions2(int rejectMatches, int rejectBorder, int fillHoles, int connectivity8) {
+            super(16);
+            this.rejectMatches = rejectMatches;
+            this.rejectBorder = rejectBorder;
+            this.fillHoles = fillHoles;
+            this.connectivity8 = connectivity8;
+        }
+        protected ParticleFilterOptions2(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected ParticleFilterOptions2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            rejectMatches = backing.getInt(0);
+            rejectBorder = backing.getInt(4);
+            fillHoles = backing.getInt(8);
+            connectivity8 = backing.getInt(12);
+        }
+        public void write() {
+            backing.putInt(0, rejectMatches);
+            backing.putInt(4, rejectBorder);
+            backing.putInt(8, fillHoles);
+            backing.putInt(12, connectivity8);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class FindEdgeOptions2 extends DisposedStruct {
+        public RakeDirection direction; // The direction to search in the ROI.
+        public int showSearchArea; // If TRUE, the function overlays the search area on the image.
+        public int showSearchLines; // If TRUE, the function overlays the search lines used to locate the edges on the image.
+        public int showEdgesFound; // If TRUE, the function overlays the locations of the edges found on the image.
+        public int showResult; // If TRUE, the function overlays the hit lines to the object and the edge used to generate the hit line on the result image.
+        public RGBValue searchAreaColor; // Specifies the RGB color value to use to overlay the search area.
+        public RGBValue searchLinesColor; // Specifies the RGB color value to use to overlay the search lines.
+        public RGBValue searchEdgesColor; // Specifies the RGB color value to use to overlay the search edges.
+        public RGBValue resultColor; // Specifies the RGB color value to use to overlay the results.
+        public String overlayGroupName; // Specifies the overlay group name to assign to the overlays.
+        public EdgeOptions2 edgeOptions; // Specifies the edge detection options along a single search line.
+        private ByteBuffer overlayGroupName_buf;
+
+        private void init() {
+            searchAreaColor = new RGBValue(backing, 20);
+            searchLinesColor = new RGBValue(backing, 24);
+            searchEdgesColor = new RGBValue(backing, 28);
+            resultColor = new RGBValue(backing, 32);
+            edgeOptions = new EdgeOptions2(backing, 40);
+        }
+        public FindEdgeOptions2() {
+            super(64);
+            init();
+        }
+        public FindEdgeOptions2(RakeDirection direction, int showSearchArea, int showSearchLines, int showEdgesFound, int showResult, RGBValue searchAreaColor, RGBValue searchLinesColor, RGBValue searchEdgesColor, RGBValue resultColor, String overlayGroupName, EdgeOptions2 edgeOptions) {
+            super(64);
+            this.direction = direction;
+            this.showSearchArea = showSearchArea;
+            this.showSearchLines = showSearchLines;
+            this.showEdgesFound = showEdgesFound;
+            this.showResult = showResult;
+            this.searchAreaColor = searchAreaColor;
+            this.searchLinesColor = searchLinesColor;
+            this.searchEdgesColor = searchEdgesColor;
+            this.resultColor = resultColor;
+            this.overlayGroupName = overlayGroupName;
+            this.edgeOptions = edgeOptions;
+        }
+        protected FindEdgeOptions2(ByteBuffer backing, int offset) {
+            super(backing, offset, 64);
+            init();
+        }
+        protected FindEdgeOptions2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 64);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 64);
+        }
+        public void read() {
+            direction = RakeDirection.fromValue(backing.getInt(0));
+            showSearchArea = backing.getInt(4);
+            showSearchLines = backing.getInt(8);
+            showEdgesFound = backing.getInt(12);
+            showResult = backing.getInt(16);
+            searchAreaColor.read();
+            searchLinesColor.read();
+            searchEdgesColor.read();
+            resultColor.read();
+            long overlayGroupName_addr = getPointer(backing, 36);
+            if (overlayGroupName_addr == 0)
+                overlayGroupName = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(overlayGroupName_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    overlayGroupName = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    overlayGroupName = "";
+                }
+            }
+            
+            edgeOptions.read();
+        }
+        public void write() {
+            if (direction != null)
+                backing.putInt(0, direction.getValue());
+            backing.putInt(4, showSearchArea);
+            backing.putInt(8, showSearchLines);
+            backing.putInt(12, showEdgesFound);
+            backing.putInt(16, showResult);
+            searchAreaColor.write();
+            searchLinesColor.write();
+            searchEdgesColor.write();
+            resultColor.write();
+            if (overlayGroupName != null) {
+                byte[] overlayGroupName_bytes;
+                try {
+                    overlayGroupName_bytes = overlayGroupName.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    overlayGroupName_bytes = new byte[0];
+                }
+                overlayGroupName_buf = ByteBuffer.allocateDirect(overlayGroupName_bytes.length+1);
+                putBytes(overlayGroupName_buf, overlayGroupName_bytes, 0, overlayGroupName_bytes.length).put(overlayGroupName_bytes.length, (byte)0);
+            }
+            putPointer(backing, 36, overlayGroupName == null ? 0 : getByteBufferAddress(overlayGroupName_buf));
+            edgeOptions.write();
+        }
+        public int size() {
+            return 64;
+        }
+    }
+
+    public static class FindEdgeReport extends DisposedStruct {
+        public StraightEdge[] straightEdges; // An array of straight edges detected.
+        private ByteBuffer straightEdges_buf;
+
+        private void init() {
+            straightEdges = new StraightEdge[0];
+        }
+        public FindEdgeReport() {
+            super(8);
+            init();
+        }
+        public FindEdgeReport(StraightEdge[] straightEdges) {
+            super(8);
+            this.straightEdges = straightEdges;
+        }
+        protected FindEdgeReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected FindEdgeReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            int straightEdges_numStraightEdges = backing.getInt(4);
+            long straightEdges_addr = getPointer(backing, 0);
+            straightEdges = new StraightEdge[straightEdges_numStraightEdges];
+            if (straightEdges_numStraightEdges > 0 && straightEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(straightEdges_addr, straightEdges_numStraightEdges*88);
+                for (int i=0, off=0; i<straightEdges_numStraightEdges; i++, off += 88) {
+                    straightEdges[i] = new StraightEdge(bb, off);
+                    straightEdges[i].read();
+                }
+            }
+        }
+        public void write() {
+            straightEdges_buf = ByteBuffer.allocateDirect(straightEdges.length*88);
+            for (int i=0, off=0; i<straightEdges.length; i++, off += 88) {
+                straightEdges[i].setBuffer(straightEdges_buf, off);
+                straightEdges[i].write();
+            }
+            backing.putInt(4, straightEdges.length);
+            putPointer(backing, 0, straightEdges_buf);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class FindTransformRectOptions2 extends DisposedStruct {
+        public FindReferenceDirection direction; // Specifies the direction and orientation in which the function searches for the primary axis.
+        public int showSearchArea; // If TRUE, the function overlays the search area on the image.
+        public int showSearchLines; // If TRUE, the function overlays the search lines used to locate the edges on the image.
+        public int showEdgesFound; // If TRUE, the function overlays the locations of the edges found on the image.
+        public int showResult; // If TRUE, the function overlays the hit lines to the object and the edge used to generate the hit line on the result image.
+        public RGBValue searchAreaColor; // Specifies the RGB color value to use to overlay the search area.
+        public RGBValue searchLinesColor; // Specifies the RGB color value to use to overlay the search lines.
+        public RGBValue searchEdgesColor; // Specifies the RGB color value to use to overlay the search edges.
+        public RGBValue resultColor; // Specifies the RGB color value to use to overlay the results.
+        public String overlayGroupName; // Specifies the overlay group name to assign to the overlays.
+        public EdgeOptions2 edgeOptions; // Specifies the edge detection options along a single search line.
+        private ByteBuffer overlayGroupName_buf;
+
+        private void init() {
+            searchAreaColor = new RGBValue(backing, 20);
+            searchLinesColor = new RGBValue(backing, 24);
+            searchEdgesColor = new RGBValue(backing, 28);
+            resultColor = new RGBValue(backing, 32);
+            edgeOptions = new EdgeOptions2(backing, 40);
+        }
+        public FindTransformRectOptions2() {
+            super(64);
+            init();
+        }
+        public FindTransformRectOptions2(FindReferenceDirection direction, int showSearchArea, int showSearchLines, int showEdgesFound, int showResult, RGBValue searchAreaColor, RGBValue searchLinesColor, RGBValue searchEdgesColor, RGBValue resultColor, String overlayGroupName, EdgeOptions2 edgeOptions) {
+            super(64);
+            this.direction = direction;
+            this.showSearchArea = showSearchArea;
+            this.showSearchLines = showSearchLines;
+            this.showEdgesFound = showEdgesFound;
+            this.showResult = showResult;
+            this.searchAreaColor = searchAreaColor;
+            this.searchLinesColor = searchLinesColor;
+            this.searchEdgesColor = searchEdgesColor;
+            this.resultColor = resultColor;
+            this.overlayGroupName = overlayGroupName;
+            this.edgeOptions = edgeOptions;
+        }
+        protected FindTransformRectOptions2(ByteBuffer backing, int offset) {
+            super(backing, offset, 64);
+            init();
+        }
+        protected FindTransformRectOptions2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 64);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 64);
+        }
+        public void read() {
+            direction = FindReferenceDirection.fromValue(backing.getInt(0));
+            showSearchArea = backing.getInt(4);
+            showSearchLines = backing.getInt(8);
+            showEdgesFound = backing.getInt(12);
+            showResult = backing.getInt(16);
+            searchAreaColor.read();
+            searchLinesColor.read();
+            searchEdgesColor.read();
+            resultColor.read();
+            long overlayGroupName_addr = getPointer(backing, 36);
+            if (overlayGroupName_addr == 0)
+                overlayGroupName = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(overlayGroupName_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    overlayGroupName = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    overlayGroupName = "";
+                }
+            }
+            
+            edgeOptions.read();
+        }
+        public void write() {
+            if (direction != null)
+                backing.putInt(0, direction.getValue());
+            backing.putInt(4, showSearchArea);
+            backing.putInt(8, showSearchLines);
+            backing.putInt(12, showEdgesFound);
+            backing.putInt(16, showResult);
+            searchAreaColor.write();
+            searchLinesColor.write();
+            searchEdgesColor.write();
+            resultColor.write();
+            if (overlayGroupName != null) {
+                byte[] overlayGroupName_bytes;
+                try {
+                    overlayGroupName_bytes = overlayGroupName.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    overlayGroupName_bytes = new byte[0];
+                }
+                overlayGroupName_buf = ByteBuffer.allocateDirect(overlayGroupName_bytes.length+1);
+                putBytes(overlayGroupName_buf, overlayGroupName_bytes, 0, overlayGroupName_bytes.length).put(overlayGroupName_bytes.length, (byte)0);
+            }
+            putPointer(backing, 36, overlayGroupName == null ? 0 : getByteBufferAddress(overlayGroupName_buf));
+            edgeOptions.write();
+        }
+        public int size() {
+            return 64;
+        }
+    }
+
+    public static class FindTransformRectsOptions2 extends DisposedStruct {
+        public FindReferenceDirection direction; // Specifies the direction and orientation in which the function searches for the primary axis.
+        public int showSearchArea; // If TRUE, the function overlays the search area on the image.
+        public int showSearchLines; // If TRUE, the function overlays the search lines used to locate the edges on the image.
+        public int showEdgesFound; // If TRUE, the function overlays the locations of the edges found on the image.
+        public int showResult; // If TRUE, the function overlays the hit lines to the object and the edge used to generate the hit line on the result image.
+        public RGBValue searchAreaColor; // Specifies the RGB color value to use to overlay the search area.
+        public RGBValue searchLinesColor; // Specifies the RGB color value to use to overlay the search lines.
+        public RGBValue searchEdgesColor; // Specifies the RGB color value to use to overlay the search edges.
+        public RGBValue resultColor; // Specifies the RGB color value to use to overlay the results.
+        public String overlayGroupName; // Specifies the overlay group name to assign to the overlays.
+        public EdgeOptions2 primaryEdgeOptions; // Specifies the parameters used to compute the edge gradient information and detect the edges for the primary ROI.
+        public EdgeOptions2 secondaryEdgeOptions; // Specifies the parameters used to compute the edge gradient information and detect the edges for the secondary ROI.
+        private ByteBuffer overlayGroupName_buf;
+
+        private void init() {
+            searchAreaColor = new RGBValue(backing, 20);
+            searchLinesColor = new RGBValue(backing, 24);
+            searchEdgesColor = new RGBValue(backing, 28);
+            resultColor = new RGBValue(backing, 32);
+            primaryEdgeOptions = new EdgeOptions2(backing, 40);
+            secondaryEdgeOptions = new EdgeOptions2(backing, 64);
+        }
+        public FindTransformRectsOptions2() {
+            super(88);
+            init();
+        }
+        public FindTransformRectsOptions2(FindReferenceDirection direction, int showSearchArea, int showSearchLines, int showEdgesFound, int showResult, RGBValue searchAreaColor, RGBValue searchLinesColor, RGBValue searchEdgesColor, RGBValue resultColor, String overlayGroupName, EdgeOptions2 primaryEdgeOptions, EdgeOptions2 secondaryEdgeOptions) {
+            super(88);
+            this.direction = direction;
+            this.showSearchArea = showSearchArea;
+            this.showSearchLines = showSearchLines;
+            this.showEdgesFound = showEdgesFound;
+            this.showResult = showResult;
+            this.searchAreaColor = searchAreaColor;
+            this.searchLinesColor = searchLinesColor;
+            this.searchEdgesColor = searchEdgesColor;
+            this.resultColor = resultColor;
+            this.overlayGroupName = overlayGroupName;
+            this.primaryEdgeOptions = primaryEdgeOptions;
+            this.secondaryEdgeOptions = secondaryEdgeOptions;
+        }
+        protected FindTransformRectsOptions2(ByteBuffer backing, int offset) {
+            super(backing, offset, 88);
+            init();
+        }
+        protected FindTransformRectsOptions2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 88);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 88);
+        }
+        public void read() {
+            direction = FindReferenceDirection.fromValue(backing.getInt(0));
+            showSearchArea = backing.getInt(4);
+            showSearchLines = backing.getInt(8);
+            showEdgesFound = backing.getInt(12);
+            showResult = backing.getInt(16);
+            searchAreaColor.read();
+            searchLinesColor.read();
+            searchEdgesColor.read();
+            resultColor.read();
+            long overlayGroupName_addr = getPointer(backing, 36);
+            if (overlayGroupName_addr == 0)
+                overlayGroupName = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(overlayGroupName_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    overlayGroupName = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    overlayGroupName = "";
+                }
+            }
+            
+            primaryEdgeOptions.read();
+            secondaryEdgeOptions.read();
+        }
+        public void write() {
+            if (direction != null)
+                backing.putInt(0, direction.getValue());
+            backing.putInt(4, showSearchArea);
+            backing.putInt(8, showSearchLines);
+            backing.putInt(12, showEdgesFound);
+            backing.putInt(16, showResult);
+            searchAreaColor.write();
+            searchLinesColor.write();
+            searchEdgesColor.write();
+            resultColor.write();
+            if (overlayGroupName != null) {
+                byte[] overlayGroupName_bytes;
+                try {
+                    overlayGroupName_bytes = overlayGroupName.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    overlayGroupName_bytes = new byte[0];
+                }
+                overlayGroupName_buf = ByteBuffer.allocateDirect(overlayGroupName_bytes.length+1);
+                putBytes(overlayGroupName_buf, overlayGroupName_bytes, 0, overlayGroupName_bytes.length).put(overlayGroupName_bytes.length, (byte)0);
+            }
+            putPointer(backing, 36, overlayGroupName == null ? 0 : getByteBufferAddress(overlayGroupName_buf));
+            primaryEdgeOptions.write();
+            secondaryEdgeOptions.write();
+        }
+        public int size() {
+            return 88;
+        }
+    }
+
+    public static class ReadTextReport3 extends DisposedStruct {
+        public String readString; // The read string.
+        public CharReport3[] characterReport; // An array of reports describing the properties of each identified character.
+        public ROI roiBoundingCharacters; // An array specifying the coordinates of the character bounding ROI.
+        private ByteBuffer readString_buf;
+        private ByteBuffer characterReport_buf;
+
+        private void init() {
+            characterReport = new CharReport3[0];
+        }
+        public ReadTextReport3() {
+            super(16);
+            init();
+        }
+        public ReadTextReport3(String readString, CharReport3[] characterReport, ROI roiBoundingCharacters) {
+            super(16);
+            this.readString = readString;
+            this.characterReport = characterReport;
+            this.roiBoundingCharacters = roiBoundingCharacters;
+        }
+        protected ReadTextReport3(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected ReadTextReport3(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            long readString_addr = getPointer(backing, 0);
+            if (readString_addr == 0)
+                readString = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(readString_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    readString = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    readString = "";
+                }
+            }
+            
+            int characterReport_numCharacterReports = backing.getInt(8);
+            long characterReport_addr = getPointer(backing, 4);
+            characterReport = new CharReport3[characterReport_numCharacterReports];
+            if (characterReport_numCharacterReports > 0 && characterReport_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(characterReport_addr, characterReport_numCharacterReports*44);
+                for (int i=0, off=0; i<characterReport_numCharacterReports; i++, off += 44) {
+                    characterReport[i] = new CharReport3(bb, off);
+                    characterReport[i].read();
+                }
+            }
+            long roiBoundingCharacters_addr = getPointer(backing, 12);
+            if (roiBoundingCharacters_addr == 0)
+                roiBoundingCharacters = null;
+            else
+                roiBoundingCharacters = new ROI(roiBoundingCharacters_addr, false);
+        }
+        public void write() {
+            if (readString != null) {
+                byte[] readString_bytes;
+                try {
+                    readString_bytes = readString.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    readString_bytes = new byte[0];
+                }
+                readString_buf = ByteBuffer.allocateDirect(readString_bytes.length+1);
+                putBytes(readString_buf, readString_bytes, 0, readString_bytes.length).put(readString_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, readString == null ? 0 : getByteBufferAddress(readString_buf));
+            characterReport_buf = ByteBuffer.allocateDirect(characterReport.length*44);
+            for (int i=0, off=0; i<characterReport.length; i++, off += 44) {
+                characterReport[i].setBuffer(characterReport_buf, off);
+                characterReport[i].write();
+            }
+            backing.putInt(8, characterReport.length);
+            putPointer(backing, 4, characterReport_buf);
+            putPointer(backing, 12, roiBoundingCharacters);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class CharacterStatistics extends DisposedStruct {
+        public int left; // The left offset of the character bounding rectangles in the current ROI.
+        public int top; // The top offset of the character bounding rectangles in the current ROI.
+        public int width; // The width of each of the characters you trained in the current ROI.
+        public int height; // The height of each trained character in the current ROI.
+        public int characterSize; // The size of the character in pixels.
+
+        private void init() {
+            
+        }
+        public CharacterStatistics() {
+            super(20);
+            init();
+        }
+        public CharacterStatistics(int left, int top, int width, int height, int characterSize) {
+            super(20);
+            this.left = left;
+            this.top = top;
+            this.width = width;
+            this.height = height;
+            this.characterSize = characterSize;
+        }
+        protected CharacterStatistics(ByteBuffer backing, int offset) {
+            super(backing, offset, 20);
+            init();
+        }
+        protected CharacterStatistics(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 20);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 20);
+        }
+        public void read() {
+            left = backing.getInt(0);
+            top = backing.getInt(4);
+            width = backing.getInt(8);
+            height = backing.getInt(12);
+            characterSize = backing.getInt(16);
+        }
+        public void write() {
+            backing.putInt(0, left);
+            backing.putInt(4, top);
+            backing.putInt(8, width);
+            backing.putInt(12, height);
+            backing.putInt(16, characterSize);
+        }
+        public int size() {
+            return 20;
+        }
+    }
+
+    public static class CharReport3 extends DisposedStruct {
+        public String character; // The character value.
+        public int classificationScore; // The degree to which the assigned character class represents the object better than the other character classes in the character set.
+        public int verificationScore; // The similarity of the character and the reference character for the character class.
+        public int verified; // This element is TRUE if a reference character was found for the character class and FALSE if a reference character was not found.
+        public int lowThreshold; // The minimum value of the threshold range used for this character.
+        public int highThreshold; // The maximum value of the threshold range used for this character.
+        public CharacterStatistics characterStats; // Describes the characters segmented in the ROI.
+        private ByteBuffer character_buf;
+
+        private void init() {
+            characterStats = new CharacterStatistics(backing, 24);
+        }
+        public CharReport3() {
+            super(44);
+            init();
+        }
+        public CharReport3(String character, int classificationScore, int verificationScore, int verified, int lowThreshold, int highThreshold, CharacterStatistics characterStats) {
+            super(44);
+            this.character = character;
+            this.classificationScore = classificationScore;
+            this.verificationScore = verificationScore;
+            this.verified = verified;
+            this.lowThreshold = lowThreshold;
+            this.highThreshold = highThreshold;
+            this.characterStats = characterStats;
+        }
+        protected CharReport3(ByteBuffer backing, int offset) {
+            super(backing, offset, 44);
+            init();
+        }
+        protected CharReport3(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 44);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 44);
+        }
+        public void read() {
+            long character_addr = getPointer(backing, 0);
+            if (character_addr == 0)
+                character = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(character_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    character = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    character = "";
+                }
+            }
+            
+            classificationScore = backing.getInt(4);
+            verificationScore = backing.getInt(8);
+            verified = backing.getInt(12);
+            lowThreshold = backing.getInt(16);
+            highThreshold = backing.getInt(20);
+            characterStats.read();
+        }
+        public void write() {
+            if (character != null) {
+                byte[] character_bytes;
+                try {
+                    character_bytes = character.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    character_bytes = new byte[0];
+                }
+                character_buf = ByteBuffer.allocateDirect(character_bytes.length+1);
+                putBytes(character_buf, character_bytes, 0, character_bytes.length).put(character_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, character == null ? 0 : getByteBufferAddress(character_buf));
+            backing.putInt(4, classificationScore);
+            backing.putInt(8, verificationScore);
+            backing.putInt(12, verified);
+            backing.putInt(16, lowThreshold);
+            backing.putInt(20, highThreshold);
+            characterStats.write();
+        }
+        public int size() {
+            return 44;
+        }
+    }
+
+    public static class ArcInfo2 extends DisposedStruct {
+        public PointFloat center; // The center point of the arc.
+        public double radius; // The radius of the arc.
+        public double startAngle; // The starting angle of the arc, specified counter-clockwise from the x-axis.
+        public double endAngle; // The ending angle of the arc, specified counter-clockwise from the x-axis.
+
+        private void init() {
+            center = new PointFloat(backing, 0);
+        }
+        public ArcInfo2() {
+            super(32);
+            init();
+        }
+        public ArcInfo2(PointFloat center, double radius, double startAngle, double endAngle) {
+            super(32);
+            this.center = center;
+            this.radius = radius;
+            this.startAngle = startAngle;
+            this.endAngle = endAngle;
+        }
+        protected ArcInfo2(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected ArcInfo2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            center.read();
+            radius = backing.getDouble(8);
+            startAngle = backing.getDouble(16);
+            endAngle = backing.getDouble(24);
+        }
+        public void write() {
+            center.write();
+            backing.putDouble(8, radius);
+            backing.putDouble(16, startAngle);
+            backing.putDouble(24, endAngle);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class EdgeReport2 extends DisposedStruct {
+        public EdgeInfo[] edges; // An array of edges detected.
+        public double[] gradientInfo; // An array that contains the calculated edge strengths along the user-defined search area.
+        public int calibrationValid; // Indicates if the calibration data corresponding to the location of the edges is correct.
+        private ByteBuffer edges_buf;
+        private ByteBuffer gradientInfo_buf;
+
+        private void init() {
+            edges = new EdgeInfo[0];
+            gradientInfo = new double[0];
+        }
+        public EdgeReport2() {
+            super(20);
+            init();
+        }
+        public EdgeReport2(EdgeInfo[] edges, double[] gradientInfo, int calibrationValid) {
+            super(20);
+            this.edges = edges;
+            this.gradientInfo = gradientInfo;
+            this.calibrationValid = calibrationValid;
+        }
+        protected EdgeReport2(ByteBuffer backing, int offset) {
+            super(backing, offset, 20);
+            init();
+        }
+        protected EdgeReport2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 20);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 20);
+        }
+        public void read() {
+            int edges_numEdges = backing.getInt(4);
+            long edges_addr = getPointer(backing, 0);
+            edges = new EdgeInfo[edges_numEdges];
+            if (edges_numEdges > 0 && edges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(edges_addr, edges_numEdges*56);
+                for (int i=0, off=0; i<edges_numEdges; i++, off += 56) {
+                    edges[i] = new EdgeInfo(bb, off);
+                    edges[i].read();
+                }
+            }
+            int gradientInfo_numGradientInfo = backing.getInt(12);
+            long gradientInfo_addr = getPointer(backing, 8);
+            gradientInfo = new double[gradientInfo_numGradientInfo];
+            if (gradientInfo_numGradientInfo > 0 && gradientInfo_addr != 0) {
+                newDirectByteBuffer(gradientInfo_addr, gradientInfo_numGradientInfo*8).asDoubleBuffer().get(gradientInfo);
+            }
+            calibrationValid = backing.getInt(16);
+        }
+        public void write() {
+            edges_buf = ByteBuffer.allocateDirect(edges.length*56);
+            for (int i=0, off=0; i<edges.length; i++, off += 56) {
+                edges[i].setBuffer(edges_buf, off);
+                edges[i].write();
+            }
+            backing.putInt(4, edges.length);
+            putPointer(backing, 0, edges_buf);
+            gradientInfo_buf = ByteBuffer.allocateDirect(gradientInfo.length*8);
+            gradientInfo_buf.asDoubleBuffer().put(gradientInfo).rewind();
+            backing.putInt(12, gradientInfo.length);
+            putPointer(backing, 8, gradientInfo_buf);
+            backing.putInt(16, calibrationValid);
+        }
+        public int size() {
+            return 20;
+        }
+    }
+
+    public static class SearchArcInfo extends DisposedStruct {
+        public ArcInfo2 arcCoordinates; // Describes the arc used for edge detection.
+        public EdgeReport2 edgeReport; // Describes the edges found in this search line.
+
+        private void init() {
+            arcCoordinates = new ArcInfo2(backing, 0);
+            edgeReport = new EdgeReport2(backing, 32);
+        }
+        public SearchArcInfo() {
+            super(56);
+            init();
+        }
+        public SearchArcInfo(ArcInfo2 arcCoordinates, EdgeReport2 edgeReport) {
+            super(56);
+            this.arcCoordinates = arcCoordinates;
+            this.edgeReport = edgeReport;
+        }
+        protected SearchArcInfo(ByteBuffer backing, int offset) {
+            super(backing, offset, 56);
+            init();
+        }
+        protected SearchArcInfo(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 56);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 56);
+        }
+        public void read() {
+            arcCoordinates.read();
+            edgeReport.read();
+        }
+        public void write() {
+            arcCoordinates.write();
+            edgeReport.write();
+        }
+        public int size() {
+            return 56;
+        }
+    }
+
+    public static class ConcentricRakeReport2 extends DisposedStruct {
+        public EdgeInfo[] firstEdges; // The first edge point detected along each search line in the ROI.
+        public EdgeInfo[] lastEdges; // The last edge point detected along each search line in the ROI.
+        public SearchArcInfo[] searchArcs; // Contains the arcs used for edge detection and the edge information for each arc.
+        private ByteBuffer firstEdges_buf;
+        private ByteBuffer lastEdges_buf;
+        private ByteBuffer searchArcs_buf;
+
+        private void init() {
+            firstEdges = new EdgeInfo[0];
+            lastEdges = new EdgeInfo[0];
+            searchArcs = new SearchArcInfo[0];
+        }
+        public ConcentricRakeReport2() {
+            super(24);
+            init();
+        }
+        public ConcentricRakeReport2(EdgeInfo[] firstEdges, EdgeInfo[] lastEdges, SearchArcInfo[] searchArcs) {
+            super(24);
+            this.firstEdges = firstEdges;
+            this.lastEdges = lastEdges;
+            this.searchArcs = searchArcs;
+        }
+        protected ConcentricRakeReport2(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected ConcentricRakeReport2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            int firstEdges_numFirstEdges = backing.getInt(4);
+            long firstEdges_addr = getPointer(backing, 0);
+            firstEdges = new EdgeInfo[firstEdges_numFirstEdges];
+            if (firstEdges_numFirstEdges > 0 && firstEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(firstEdges_addr, firstEdges_numFirstEdges*56);
+                for (int i=0, off=0; i<firstEdges_numFirstEdges; i++, off += 56) {
+                    firstEdges[i] = new EdgeInfo(bb, off);
+                    firstEdges[i].read();
+                }
+            }
+            int lastEdges_numLastEdges = backing.getInt(12);
+            long lastEdges_addr = getPointer(backing, 8);
+            lastEdges = new EdgeInfo[lastEdges_numLastEdges];
+            if (lastEdges_numLastEdges > 0 && lastEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(lastEdges_addr, lastEdges_numLastEdges*56);
+                for (int i=0, off=0; i<lastEdges_numLastEdges; i++, off += 56) {
+                    lastEdges[i] = new EdgeInfo(bb, off);
+                    lastEdges[i].read();
+                }
+            }
+            int searchArcs_numSearchArcs = backing.getInt(20);
+            long searchArcs_addr = getPointer(backing, 16);
+            searchArcs = new SearchArcInfo[searchArcs_numSearchArcs];
+            if (searchArcs_numSearchArcs > 0 && searchArcs_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(searchArcs_addr, searchArcs_numSearchArcs*56);
+                for (int i=0, off=0; i<searchArcs_numSearchArcs; i++, off += 56) {
+                    searchArcs[i] = new SearchArcInfo(bb, off);
+                    searchArcs[i].read();
+                }
+            }
+        }
+        public void write() {
+            firstEdges_buf = ByteBuffer.allocateDirect(firstEdges.length*56);
+            for (int i=0, off=0; i<firstEdges.length; i++, off += 56) {
+                firstEdges[i].setBuffer(firstEdges_buf, off);
+                firstEdges[i].write();
+            }
+            backing.putInt(4, firstEdges.length);
+            putPointer(backing, 0, firstEdges_buf);
+            lastEdges_buf = ByteBuffer.allocateDirect(lastEdges.length*56);
+            for (int i=0, off=0; i<lastEdges.length; i++, off += 56) {
+                lastEdges[i].setBuffer(lastEdges_buf, off);
+                lastEdges[i].write();
+            }
+            backing.putInt(12, lastEdges.length);
+            putPointer(backing, 8, lastEdges_buf);
+            searchArcs_buf = ByteBuffer.allocateDirect(searchArcs.length*56);
+            for (int i=0, off=0; i<searchArcs.length; i++, off += 56) {
+                searchArcs[i].setBuffer(searchArcs_buf, off);
+                searchArcs[i].write();
+            }
+            backing.putInt(20, searchArcs.length);
+            putPointer(backing, 16, searchArcs_buf);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class SpokeReport2 extends DisposedStruct {
+        public EdgeInfo[] firstEdges; // The first edge point detected along each search line in the ROI.
+        public EdgeInfo[] lastEdges; // The last edge point detected along each search line in the ROI.
+        public SearchLineInfo[] searchLines; // The search lines used for edge detection.
+        private ByteBuffer firstEdges_buf;
+        private ByteBuffer lastEdges_buf;
+        private ByteBuffer searchLines_buf;
+
+        private void init() {
+            firstEdges = new EdgeInfo[0];
+            lastEdges = new EdgeInfo[0];
+            searchLines = new SearchLineInfo[0];
+        }
+        public SpokeReport2() {
+            super(24);
+            init();
+        }
+        public SpokeReport2(EdgeInfo[] firstEdges, EdgeInfo[] lastEdges, SearchLineInfo[] searchLines) {
+            super(24);
+            this.firstEdges = firstEdges;
+            this.lastEdges = lastEdges;
+            this.searchLines = searchLines;
+        }
+        protected SpokeReport2(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected SpokeReport2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            int firstEdges_numFirstEdges = backing.getInt(4);
+            long firstEdges_addr = getPointer(backing, 0);
+            firstEdges = new EdgeInfo[firstEdges_numFirstEdges];
+            if (firstEdges_numFirstEdges > 0 && firstEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(firstEdges_addr, firstEdges_numFirstEdges*56);
+                for (int i=0, off=0; i<firstEdges_numFirstEdges; i++, off += 56) {
+                    firstEdges[i] = new EdgeInfo(bb, off);
+                    firstEdges[i].read();
+                }
+            }
+            int lastEdges_numLastEdges = backing.getInt(12);
+            long lastEdges_addr = getPointer(backing, 8);
+            lastEdges = new EdgeInfo[lastEdges_numLastEdges];
+            if (lastEdges_numLastEdges > 0 && lastEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(lastEdges_addr, lastEdges_numLastEdges*56);
+                for (int i=0, off=0; i<lastEdges_numLastEdges; i++, off += 56) {
+                    lastEdges[i] = new EdgeInfo(bb, off);
+                    lastEdges[i].read();
+                }
+            }
+            int searchLines_numSearchLines = backing.getInt(20);
+            long searchLines_addr = getPointer(backing, 16);
+            searchLines = new SearchLineInfo[searchLines_numSearchLines];
+            if (searchLines_numSearchLines > 0 && searchLines_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(searchLines_addr, searchLines_numSearchLines*36);
+                for (int i=0, off=0; i<searchLines_numSearchLines; i++, off += 36) {
+                    searchLines[i] = new SearchLineInfo(bb, off);
+                    searchLines[i].read();
+                }
+            }
+        }
+        public void write() {
+            firstEdges_buf = ByteBuffer.allocateDirect(firstEdges.length*56);
+            for (int i=0, off=0; i<firstEdges.length; i++, off += 56) {
+                firstEdges[i].setBuffer(firstEdges_buf, off);
+                firstEdges[i].write();
+            }
+            backing.putInt(4, firstEdges.length);
+            putPointer(backing, 0, firstEdges_buf);
+            lastEdges_buf = ByteBuffer.allocateDirect(lastEdges.length*56);
+            for (int i=0, off=0; i<lastEdges.length; i++, off += 56) {
+                lastEdges[i].setBuffer(lastEdges_buf, off);
+                lastEdges[i].write();
+            }
+            backing.putInt(12, lastEdges.length);
+            putPointer(backing, 8, lastEdges_buf);
+            searchLines_buf = ByteBuffer.allocateDirect(searchLines.length*36);
+            for (int i=0, off=0; i<searchLines.length; i++, off += 36) {
+                searchLines[i].setBuffer(searchLines_buf, off);
+                searchLines[i].write();
+            }
+            backing.putInt(20, searchLines.length);
+            putPointer(backing, 16, searchLines_buf);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class EdgeInfo extends DisposedStruct {
+        public PointFloat position; // The location of the edge in the image.
+        public PointFloat calibratedPosition; // The position of the edge in the image in real-world coordinates.
+        public double distance; // The location of the edge from the first point along the boundary of the input ROI.
+        public double calibratedDistance; // The location of the edge from the first point along the boundary of the input ROI in real-world coordinates.
+        public double magnitude; // The intensity contrast at the edge.
+        public double noisePeak; // The strength of the noise associated with the current edge.
+        public int rising; // Indicates the polarity of the edge.
+
+        private void init() {
+            position = new PointFloat(backing, 0);
+            calibratedPosition = new PointFloat(backing, 8);
+        }
+        public EdgeInfo() {
+            super(56);
+            init();
+        }
+        public EdgeInfo(PointFloat position, PointFloat calibratedPosition, double distance, double calibratedDistance, double magnitude, double noisePeak, int rising) {
+            super(56);
+            this.position = position;
+            this.calibratedPosition = calibratedPosition;
+            this.distance = distance;
+            this.calibratedDistance = calibratedDistance;
+            this.magnitude = magnitude;
+            this.noisePeak = noisePeak;
+            this.rising = rising;
+        }
+        protected EdgeInfo(ByteBuffer backing, int offset) {
+            super(backing, offset, 56);
+            init();
+        }
+        protected EdgeInfo(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 56);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 56);
+        }
+        public void read() {
+            position.read();
+            calibratedPosition.read();
+            distance = backing.getDouble(16);
+            calibratedDistance = backing.getDouble(24);
+            magnitude = backing.getDouble(32);
+            noisePeak = backing.getDouble(40);
+            rising = backing.getInt(48);
+        }
+        public void write() {
+            position.write();
+            calibratedPosition.write();
+            backing.putDouble(16, distance);
+            backing.putDouble(24, calibratedDistance);
+            backing.putDouble(32, magnitude);
+            backing.putDouble(40, noisePeak);
+            backing.putInt(48, rising);
+        }
+        public int size() {
+            return 56;
+        }
+    }
+
+    public static class SearchLineInfo extends DisposedStruct {
+        public LineFloat lineCoordinates; // The endpoints of the search line.
+        public EdgeReport2 edgeReport; // Describes the edges found in this search line.
+
+        private void init() {
+            lineCoordinates = new LineFloat(backing, 0);
+            edgeReport = new EdgeReport2(backing, 16);
+        }
+        public SearchLineInfo() {
+            super(36);
+            init();
+        }
+        public SearchLineInfo(LineFloat lineCoordinates, EdgeReport2 edgeReport) {
+            super(36);
+            this.lineCoordinates = lineCoordinates;
+            this.edgeReport = edgeReport;
+        }
+        protected SearchLineInfo(ByteBuffer backing, int offset) {
+            super(backing, offset, 36);
+            init();
+        }
+        protected SearchLineInfo(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 36);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 36);
+        }
+        public void read() {
+            lineCoordinates.read();
+            edgeReport.read();
+        }
+        public void write() {
+            lineCoordinates.write();
+            edgeReport.write();
+        }
+        public int size() {
+            return 36;
+        }
+    }
+
+    public static class RakeReport2 extends DisposedStruct {
+        public EdgeInfo[] firstEdges; // The first edge point detected along each search line in the ROI.
+        public EdgeInfo[] lastEdges; // The last edge point detected along each search line in the ROI.
+        public SearchLineInfo[] searchLines; // The search lines used for edge detection.
+        private ByteBuffer firstEdges_buf;
+        private ByteBuffer lastEdges_buf;
+        private ByteBuffer searchLines_buf;
+
+        private void init() {
+            firstEdges = new EdgeInfo[0];
+            lastEdges = new EdgeInfo[0];
+            searchLines = new SearchLineInfo[0];
+        }
+        public RakeReport2() {
+            super(24);
+            init();
+        }
+        public RakeReport2(EdgeInfo[] firstEdges, EdgeInfo[] lastEdges, SearchLineInfo[] searchLines) {
+            super(24);
+            this.firstEdges = firstEdges;
+            this.lastEdges = lastEdges;
+            this.searchLines = searchLines;
+        }
+        protected RakeReport2(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected RakeReport2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            int firstEdges_numFirstEdges = backing.getInt(4);
+            long firstEdges_addr = getPointer(backing, 0);
+            firstEdges = new EdgeInfo[firstEdges_numFirstEdges];
+            if (firstEdges_numFirstEdges > 0 && firstEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(firstEdges_addr, firstEdges_numFirstEdges*56);
+                for (int i=0, off=0; i<firstEdges_numFirstEdges; i++, off += 56) {
+                    firstEdges[i] = new EdgeInfo(bb, off);
+                    firstEdges[i].read();
+                }
+            }
+            int lastEdges_numLastEdges = backing.getInt(12);
+            long lastEdges_addr = getPointer(backing, 8);
+            lastEdges = new EdgeInfo[lastEdges_numLastEdges];
+            if (lastEdges_numLastEdges > 0 && lastEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(lastEdges_addr, lastEdges_numLastEdges*56);
+                for (int i=0, off=0; i<lastEdges_numLastEdges; i++, off += 56) {
+                    lastEdges[i] = new EdgeInfo(bb, off);
+                    lastEdges[i].read();
+                }
+            }
+            int searchLines_numSearchLines = backing.getInt(20);
+            long searchLines_addr = getPointer(backing, 16);
+            searchLines = new SearchLineInfo[searchLines_numSearchLines];
+            if (searchLines_numSearchLines > 0 && searchLines_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(searchLines_addr, searchLines_numSearchLines*36);
+                for (int i=0, off=0; i<searchLines_numSearchLines; i++, off += 36) {
+                    searchLines[i] = new SearchLineInfo(bb, off);
+                    searchLines[i].read();
+                }
+            }
+        }
+        public void write() {
+            firstEdges_buf = ByteBuffer.allocateDirect(firstEdges.length*56);
+            for (int i=0, off=0; i<firstEdges.length; i++, off += 56) {
+                firstEdges[i].setBuffer(firstEdges_buf, off);
+                firstEdges[i].write();
+            }
+            backing.putInt(4, firstEdges.length);
+            putPointer(backing, 0, firstEdges_buf);
+            lastEdges_buf = ByteBuffer.allocateDirect(lastEdges.length*56);
+            for (int i=0, off=0; i<lastEdges.length; i++, off += 56) {
+                lastEdges[i].setBuffer(lastEdges_buf, off);
+                lastEdges[i].write();
+            }
+            backing.putInt(12, lastEdges.length);
+            putPointer(backing, 8, lastEdges_buf);
+            searchLines_buf = ByteBuffer.allocateDirect(searchLines.length*36);
+            for (int i=0, off=0; i<searchLines.length; i++, off += 36) {
+                searchLines[i].setBuffer(searchLines_buf, off);
+                searchLines[i].write();
+            }
+            backing.putInt(20, searchLines.length);
+            putPointer(backing, 16, searchLines_buf);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class TransformBehaviors extends DisposedStruct {
+        public GroupBehavior ShiftBehavior; // Specifies the behavior of an overlay group when a shift operation is applied to an image.
+        public GroupBehavior ScaleBehavior; // Specifies the behavior of an overlay group when a scale operation is applied to an image.
+        public GroupBehavior RotateBehavior; // Specifies the behavior of an overlay group when a rotate operation is applied to an image.
+        public GroupBehavior SymmetryBehavior; // Specifies the behavior of an overlay group when a symmetry operation is applied to an image.
+
+        private void init() {
+            
+        }
+        public TransformBehaviors() {
+            super(16);
+            init();
+        }
+        public TransformBehaviors(GroupBehavior ShiftBehavior, GroupBehavior ScaleBehavior, GroupBehavior RotateBehavior, GroupBehavior SymmetryBehavior) {
+            super(16);
+            this.ShiftBehavior = ShiftBehavior;
+            this.ScaleBehavior = ScaleBehavior;
+            this.RotateBehavior = RotateBehavior;
+            this.SymmetryBehavior = SymmetryBehavior;
+        }
+        protected TransformBehaviors(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected TransformBehaviors(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            ShiftBehavior = GroupBehavior.fromValue(backing.getInt(0));
+            ScaleBehavior = GroupBehavior.fromValue(backing.getInt(4));
+            RotateBehavior = GroupBehavior.fromValue(backing.getInt(8));
+            SymmetryBehavior = GroupBehavior.fromValue(backing.getInt(12));
+        }
+        public void write() {
+            if (ShiftBehavior != null)
+                backing.putInt(0, ShiftBehavior.getValue());
+            if (ScaleBehavior != null)
+                backing.putInt(4, ScaleBehavior.getValue());
+            if (RotateBehavior != null)
+                backing.putInt(8, RotateBehavior.getValue());
+            if (SymmetryBehavior != null)
+                backing.putInt(12, SymmetryBehavior.getValue());
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class QRCodeDataToken extends DisposedStruct {
+        public QRStreamMode mode; // Specifies the stream mode or the format of the data that is encoded in the QR code.
+        public int modeData; // Indicates specifiers used by the user to postprocess the data if it requires it.
+        public byte[] data; // Shows the encoded data in the QR code.
+        private ByteBuffer data_buf;
+
+        private void init() {
+            data = new byte[0];
+        }
+        public QRCodeDataToken() {
+            super(16);
+            init();
+        }
+        public QRCodeDataToken(QRStreamMode mode, int modeData, byte[] data) {
+            super(16);
+            this.mode = mode;
+            this.modeData = modeData;
+            this.data = data;
+        }
+        protected QRCodeDataToken(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected QRCodeDataToken(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            mode = QRStreamMode.fromValue(backing.getInt(0));
+            modeData = backing.getInt(4);
+            int data_dataLength = backing.getInt(12);
+            long data_addr = getPointer(backing, 8);
+            data = new byte[data_dataLength];
+            if (data_dataLength > 0 && data_addr != 0) {
+                getBytes(newDirectByteBuffer(data_addr, data_dataLength), data, 0, data_dataLength);
+            }
+        }
+        public void write() {
+            if (mode != null)
+                backing.putInt(0, mode.getValue());
+            backing.putInt(4, modeData);
+            data_buf = ByteBuffer.allocateDirect(data.length);
+            putBytes(data_buf, data, 0, data.length);
+            backing.putInt(12, data.length);
+            putPointer(backing, 8, data_buf);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class ParticleFilterOptions extends DisposedStruct {
+        public int rejectMatches; // Set this parameter to TRUE to transfer only those particles that do not meet all the criteria.
+        public int rejectBorder; // Set this element to TRUE to reject border particles.
+        public int connectivity8; // Set this parameter to TRUE to use connectivity-8 to determine whether particles are touching.
+
+        private void init() {
+            
+        }
+        public ParticleFilterOptions() {
+            super(12);
+            init();
+        }
+        public ParticleFilterOptions(int rejectMatches, int rejectBorder, int connectivity8) {
+            super(12);
+            this.rejectMatches = rejectMatches;
+            this.rejectBorder = rejectBorder;
+            this.connectivity8 = connectivity8;
+        }
+        protected ParticleFilterOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected ParticleFilterOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            rejectMatches = backing.getInt(0);
+            rejectBorder = backing.getInt(4);
+            connectivity8 = backing.getInt(8);
+        }
+        public void write() {
+            backing.putInt(0, rejectMatches);
+            backing.putInt(4, rejectBorder);
+            backing.putInt(8, connectivity8);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class StraightEdgeReport2 extends DisposedStruct {
+        public StraightEdge[] straightEdges; // Contains an array of found straight edges.
+        public SearchLineInfo[] searchLines; // Contains an array of all search lines used in the detection.
+        private ByteBuffer straightEdges_buf;
+        private ByteBuffer searchLines_buf;
+
+        private void init() {
+            straightEdges = new StraightEdge[0];
+            searchLines = new SearchLineInfo[0];
+        }
+        public StraightEdgeReport2() {
+            super(16);
+            init();
+        }
+        public StraightEdgeReport2(StraightEdge[] straightEdges, SearchLineInfo[] searchLines) {
+            super(16);
+            this.straightEdges = straightEdges;
+            this.searchLines = searchLines;
+        }
+        protected StraightEdgeReport2(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected StraightEdgeReport2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            int straightEdges_numStraightEdges = backing.getInt(4);
+            long straightEdges_addr = getPointer(backing, 0);
+            straightEdges = new StraightEdge[straightEdges_numStraightEdges];
+            if (straightEdges_numStraightEdges > 0 && straightEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(straightEdges_addr, straightEdges_numStraightEdges*88);
+                for (int i=0, off=0; i<straightEdges_numStraightEdges; i++, off += 88) {
+                    straightEdges[i] = new StraightEdge(bb, off);
+                    straightEdges[i].read();
+                }
+            }
+            int searchLines_numSearchLines = backing.getInt(12);
+            long searchLines_addr = getPointer(backing, 8);
+            searchLines = new SearchLineInfo[searchLines_numSearchLines];
+            if (searchLines_numSearchLines > 0 && searchLines_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(searchLines_addr, searchLines_numSearchLines*36);
+                for (int i=0, off=0; i<searchLines_numSearchLines; i++, off += 36) {
+                    searchLines[i] = new SearchLineInfo(bb, off);
+                    searchLines[i].read();
+                }
+            }
+        }
+        public void write() {
+            straightEdges_buf = ByteBuffer.allocateDirect(straightEdges.length*88);
+            for (int i=0, off=0; i<straightEdges.length; i++, off += 88) {
+                straightEdges[i].setBuffer(straightEdges_buf, off);
+                straightEdges[i].write();
+            }
+            backing.putInt(4, straightEdges.length);
+            putPointer(backing, 0, straightEdges_buf);
+            searchLines_buf = ByteBuffer.allocateDirect(searchLines.length*36);
+            for (int i=0, off=0; i<searchLines.length; i++, off += 36) {
+                searchLines[i].setBuffer(searchLines_buf, off);
+                searchLines[i].write();
+            }
+            backing.putInt(12, searchLines.length);
+            putPointer(backing, 8, searchLines_buf);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class StraightEdgeOptions extends DisposedStruct {
+        public int numLines; // Specifies the number of straight edges to find.
+        public StraightEdgeSearchMode searchMode; // Specifies the method used to find the straight edge.
+        public double minScore; // Specifies the minimum score of a detected straight edge.
+        public double maxScore; // Specifies the maximum score of a detected edge.
+        public double orientation; // Specifies the angle at which the straight edge is expected to be found.
+        public double angleRange; // Specifies the +/- range around the orientation within which the straight edge is expected to be found.
+        public double angleTolerance; // Specifies the expected angular accuracy of the straight edge.
+        public int stepSize; // Specifies the gap in pixels between the search lines used with the rake-based methods.
+        public double minSignalToNoiseRatio; // Specifies the minimum signal to noise ratio (SNR) of the edge points used to fit the straight edge.
+        public double minCoverage; // Specifies the minimum number of points as a percentage of the number of search lines that need to be included in the detected straight edge.
+        public int houghIterations; // Specifies the number of iterations used in the Hough-based method.
+
+        private void init() {
+            
+        }
+        public StraightEdgeOptions() {
+            super(80);
+            init();
+        }
+        public StraightEdgeOptions(int numLines, StraightEdgeSearchMode searchMode, double minScore, double maxScore, double orientation, double angleRange, double angleTolerance, int stepSize, double minSignalToNoiseRatio, double minCoverage, int houghIterations) {
+            super(80);
+            this.numLines = numLines;
+            this.searchMode = searchMode;
+            this.minScore = minScore;
+            this.maxScore = maxScore;
+            this.orientation = orientation;
+            this.angleRange = angleRange;
+            this.angleTolerance = angleTolerance;
+            this.stepSize = stepSize;
+            this.minSignalToNoiseRatio = minSignalToNoiseRatio;
+            this.minCoverage = minCoverage;
+            this.houghIterations = houghIterations;
+        }
+        protected StraightEdgeOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 80);
+            init();
+        }
+        protected StraightEdgeOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 80);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 80);
+        }
+        public void read() {
+            numLines = backing.getInt(0);
+            searchMode = StraightEdgeSearchMode.fromValue(backing.getInt(4));
+            minScore = backing.getDouble(8);
+            maxScore = backing.getDouble(16);
+            orientation = backing.getDouble(24);
+            angleRange = backing.getDouble(32);
+            angleTolerance = backing.getDouble(40);
+            stepSize = backing.getInt(48);
+            minSignalToNoiseRatio = backing.getDouble(56);
+            minCoverage = backing.getDouble(64);
+            houghIterations = backing.getInt(72);
+        }
+        public void write() {
+            backing.putInt(0, numLines);
+            if (searchMode != null)
+                backing.putInt(4, searchMode.getValue());
+            backing.putDouble(8, minScore);
+            backing.putDouble(16, maxScore);
+            backing.putDouble(24, orientation);
+            backing.putDouble(32, angleRange);
+            backing.putDouble(40, angleTolerance);
+            backing.putInt(48, stepSize);
+            backing.putDouble(56, minSignalToNoiseRatio);
+            backing.putDouble(64, minCoverage);
+            backing.putInt(72, houghIterations);
+        }
+        public int size() {
+            return 80;
+        }
+    }
+
+    public static class StraightEdge extends DisposedStruct {
+        public LineFloat straightEdgeCoordinates; // End points of the detected straight edge in pixel coordinates.
+        public LineFloat calibratedStraightEdgeCoordinates; // End points of the detected straight edge in real-world coordinates.
+        public double angle; // Angle of the found edge using the pixel coordinates.
+        public double calibratedAngle; // Angle of the found edge using the real-world coordinates.
+        public double score; // Describes the score of the detected edge.
+        public double straightness; // The straightness value of the detected straight edge.
+        public double averageSignalToNoiseRatio; // Describes the average signal to noise ratio (SNR) of the detected edge.
+        public int calibrationValid; // Indicates if the calibration data for the straight edge is valid.
+        public EdgeInfo[] usedEdges; // An array of edges that were used to determine this straight line.
+        private ByteBuffer usedEdges_buf;
+
+        private void init() {
+            straightEdgeCoordinates = new LineFloat(backing, 0);
+            calibratedStraightEdgeCoordinates = new LineFloat(backing, 16);
+            usedEdges = new EdgeInfo[0];
+        }
+        public StraightEdge() {
+            super(88);
+            init();
+        }
+        public StraightEdge(LineFloat straightEdgeCoordinates, LineFloat calibratedStraightEdgeCoordinates, double angle, double calibratedAngle, double score, double straightness, double averageSignalToNoiseRatio, int calibrationValid, EdgeInfo[] usedEdges) {
+            super(88);
+            this.straightEdgeCoordinates = straightEdgeCoordinates;
+            this.calibratedStraightEdgeCoordinates = calibratedStraightEdgeCoordinates;
+            this.angle = angle;
+            this.calibratedAngle = calibratedAngle;
+            this.score = score;
+            this.straightness = straightness;
+            this.averageSignalToNoiseRatio = averageSignalToNoiseRatio;
+            this.calibrationValid = calibrationValid;
+            this.usedEdges = usedEdges;
+        }
+        protected StraightEdge(ByteBuffer backing, int offset) {
+            super(backing, offset, 88);
+            init();
+        }
+        protected StraightEdge(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 88);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 88);
+        }
+        public void read() {
+            straightEdgeCoordinates.read();
+            calibratedStraightEdgeCoordinates.read();
+            angle = backing.getDouble(32);
+            calibratedAngle = backing.getDouble(40);
+            score = backing.getDouble(48);
+            straightness = backing.getDouble(56);
+            averageSignalToNoiseRatio = backing.getDouble(64);
+            calibrationValid = backing.getInt(72);
+            int usedEdges_numUsedEdges = backing.getInt(80);
+            long usedEdges_addr = getPointer(backing, 76);
+            usedEdges = new EdgeInfo[usedEdges_numUsedEdges];
+            if (usedEdges_numUsedEdges > 0 && usedEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(usedEdges_addr, usedEdges_numUsedEdges*56);
+                for (int i=0, off=0; i<usedEdges_numUsedEdges; i++, off += 56) {
+                    usedEdges[i] = new EdgeInfo(bb, off);
+                    usedEdges[i].read();
+                }
+            }
+        }
+        public void write() {
+            straightEdgeCoordinates.write();
+            calibratedStraightEdgeCoordinates.write();
+            backing.putDouble(32, angle);
+            backing.putDouble(40, calibratedAngle);
+            backing.putDouble(48, score);
+            backing.putDouble(56, straightness);
+            backing.putDouble(64, averageSignalToNoiseRatio);
+            backing.putInt(72, calibrationValid);
+            usedEdges_buf = ByteBuffer.allocateDirect(usedEdges.length*56);
+            for (int i=0, off=0; i<usedEdges.length; i++, off += 56) {
+                usedEdges[i].setBuffer(usedEdges_buf, off);
+                usedEdges[i].write();
+            }
+            backing.putInt(80, usedEdges.length);
+            putPointer(backing, 76, usedEdges_buf);
+        }
+        public int size() {
+            return 88;
+        }
+    }
+
+    public static class QRCodeSearchOptions extends DisposedStruct {
+        public QRRotationMode rotationMode; // Specifies the amount of QR code rotation the function should allow for.
+        public int skipLocation; // If set to TRUE, specifies that the function should assume that the QR code occupies the entire image (or the entire search region).
+        public int edgeThreshold; // The strength of the weakest edge the function uses to find the coarse location of the QR code in the image.
+        public QRDemodulationMode demodulationMode; // The demodulation mode the function uses to locate the QR code.
+        public QRCellSampleSize cellSampleSize; // The cell sample size the function uses to locate the QR code.
+        public QRCellFilterMode cellFilterMode; // The cell filter mode the function uses to locate the QR code.
+        public int skewDegreesAllowed; // Specifies the amount of skew in the QR code the function should allow for.
+
+        private void init() {
+            
+        }
+        public QRCodeSearchOptions() {
+            super(48);
+            init();
+        }
+        public QRCodeSearchOptions(QRRotationMode rotationMode, int skipLocation, int edgeThreshold, QRDemodulationMode demodulationMode, QRCellSampleSize cellSampleSize, QRCellFilterMode cellFilterMode, int skewDegreesAllowed) {
+            super(48);
+            this.rotationMode = rotationMode;
+            this.skipLocation = skipLocation;
+            this.edgeThreshold = edgeThreshold;
+            this.demodulationMode = demodulationMode;
+            this.cellSampleSize = cellSampleSize;
+            this.cellFilterMode = cellFilterMode;
+            this.skewDegreesAllowed = skewDegreesAllowed;
+        }
+        protected QRCodeSearchOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 48);
+            init();
+        }
+        protected QRCodeSearchOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 48);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 48);
+        }
+        public void read() {
+            rotationMode = QRRotationMode.fromValue(backing.getInt(0));
+            skipLocation = backing.getInt(4);
+            edgeThreshold = backing.getInt(8);
+            demodulationMode = QRDemodulationMode.fromValue(backing.getInt(16));
+            cellSampleSize = QRCellSampleSize.fromValue(backing.getInt(24));
+            cellFilterMode = QRCellFilterMode.fromValue(backing.getInt(32));
+            skewDegreesAllowed = backing.getInt(40);
+        }
+        public void write() {
+            if (rotationMode != null)
+                backing.putInt(0, rotationMode.getValue());
+            backing.putInt(4, skipLocation);
+            backing.putInt(8, edgeThreshold);
+            if (demodulationMode != null)
+                backing.putInt(16, demodulationMode.getValue());
+            if (cellSampleSize != null)
+                backing.putInt(24, cellSampleSize.getValue());
+            if (cellFilterMode != null)
+                backing.putInt(32, cellFilterMode.getValue());
+            backing.putInt(40, skewDegreesAllowed);
+        }
+        public int size() {
+            return 48;
+        }
+    }
+
+    public static class QRCodeSizeOptions extends DisposedStruct {
+        public int minSize; // Specifies the minimum size (in pixels) of the QR code in the image.
+        public int maxSize; // Specifies the maximum size (in pixels) of the QR code in the image.
+
+        private void init() {
+            
+        }
+        public QRCodeSizeOptions() {
+            super(8);
+            init();
+        }
+        public QRCodeSizeOptions(int minSize, int maxSize) {
+            super(8);
+            this.minSize = minSize;
+            this.maxSize = maxSize;
+        }
+        protected QRCodeSizeOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected QRCodeSizeOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            minSize = backing.getInt(0);
+            maxSize = backing.getInt(4);
+        }
+        public void write() {
+            backing.putInt(0, minSize);
+            backing.putInt(4, maxSize);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class QRCodeDescriptionOptions extends DisposedStruct {
+        public QRDimensions dimensions; // The number of rows and columns that are populated for the QR code, measured in cells.
+        public QRPolarities polarity; // The polarity of the QR code.
+        public QRMirrorMode mirror; // This element is TRUE if the QR code appears mirrored in the image and FALSE if the QR code appears normally in the image.
+        public QRModelType modelType; // This option allows you to specify the type of QR code.
+
+        private void init() {
+            
+        }
+        public QRCodeDescriptionOptions() {
+            super(32);
+            init();
+        }
+        public QRCodeDescriptionOptions(QRDimensions dimensions, QRPolarities polarity, QRMirrorMode mirror, QRModelType modelType) {
+            super(32);
+            this.dimensions = dimensions;
+            this.polarity = polarity;
+            this.mirror = mirror;
+            this.modelType = modelType;
+        }
+        protected QRCodeDescriptionOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected QRCodeDescriptionOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            dimensions = QRDimensions.fromValue(backing.getInt(0));
+            polarity = QRPolarities.fromValue(backing.getInt(8));
+            mirror = QRMirrorMode.fromValue(backing.getInt(16));
+            modelType = QRModelType.fromValue(backing.getInt(24));
+        }
+        public void write() {
+            if (dimensions != null)
+                backing.putInt(0, dimensions.getValue());
+            if (polarity != null)
+                backing.putInt(8, polarity.getValue());
+            if (mirror != null)
+                backing.putInt(16, mirror.getValue());
+            if (modelType != null)
+                backing.putInt(24, modelType.getValue());
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class QRCodeReport extends DisposedStruct {
+        public int found; // This element is TRUE if the function located and decoded a QR code and FALSE if the function failed to locate and decode a QR code.
+        public byte[] data; // The data encoded in the QR code.
+        public PointFloat[] boundingBox; // An array of four points describing the rectangle surrounding the QR code.
+        public QRCodeDataToken[] tokenizedData; // Contains the data tokenized in exactly the way it was encoded in the code.
+        public int numErrorsCorrected; // The number of errors the function corrected when decoding the QR code.
+        public int dimensions; // The number of rows and columns that are populated for the QR code, measured in cells.
+        public int version; // The version of the QR code.
+        public QRModelType modelType; // This option allows you to specify what type of QR code this is.
+        public QRStreamMode streamMode; // The format of the data encoded in the stream.
+        public QRPolarities matrixPolarity; // The polarity of the QR code.
+        public int mirrored; // This element is TRUE if the QR code appears mirrored in the image and FALSE if the QR code appears normally in the image.
+        public int positionInAppendStream; // Indicates what position the QR code is in with respect to the stream of data in all codes.
+        public int sizeOfAppendStream; // Specifies how many QR codes are part of a larger array of codes.
+        public int firstEAN128ApplicationID; // The first EAN-128 Application ID encountered in the stream.
+        public int firstECIDesignator; // The first Regional Language Designator encountered in the stream.
+        public int appendStreamIdentifier; // Specifies what stream the QR code is in relation to when the code is part of a larger array of codes.
+        public int minimumEdgeStrength; // The strength of the weakest edge the function used to find the coarse location of the QR code in the image.
+        public QRDemodulationMode demodulationMode; // The demodulation mode the function used to locate the QR code.
+        public QRCellSampleSize cellSampleSize; // The cell sample size the function used to locate the QR code.
+        public QRCellFilterMode cellFilterMode; // The cell filter mode the function used to locate the QR code.
+        private ByteBuffer data_buf;
+        private ByteBuffer tokenizedData_buf;
+
+        private void init() {
+            data = new byte[0];
+            boundingBox = new PointFloat[4];
+            
+            for (int i=0, off=12; i<4; i++, off += 8)
+                boundingBox[i] = new PointFloat(backing, off);
+            tokenizedData = new QRCodeDataToken[0];
+        }
+        public QRCodeReport() {
+            super(136);
+            init();
+        }
+        public QRCodeReport(int found, byte[] data, PointFloat[] boundingBox, QRCodeDataToken[] tokenizedData, int numErrorsCorrected, int dimensions, int version, QRModelType modelType, QRStreamMode streamMode, QRPolarities matrixPolarity, int mirrored, int positionInAppendStream, int sizeOfAppendStream, int firstEAN128ApplicationID, int firstECIDesignator, int appendStreamIdentifier, int minimumEdgeStrength, QRDemodulationMode demodulationMode, QRCellSampleSize cellSampleSize, QRCellFilterMode cellFilterMode) {
+            super(136);
+            this.found = found;
+            this.data = data;
+            this.boundingBox = boundingBox;
+            this.tokenizedData = tokenizedData;
+            this.numErrorsCorrected = numErrorsCorrected;
+            this.dimensions = dimensions;
+            this.version = version;
+            this.modelType = modelType;
+            this.streamMode = streamMode;
+            this.matrixPolarity = matrixPolarity;
+            this.mirrored = mirrored;
+            this.positionInAppendStream = positionInAppendStream;
+            this.sizeOfAppendStream = sizeOfAppendStream;
+            this.firstEAN128ApplicationID = firstEAN128ApplicationID;
+            this.firstECIDesignator = firstECIDesignator;
+            this.appendStreamIdentifier = appendStreamIdentifier;
+            this.minimumEdgeStrength = minimumEdgeStrength;
+            this.demodulationMode = demodulationMode;
+            this.cellSampleSize = cellSampleSize;
+            this.cellFilterMode = cellFilterMode;
+        }
+        protected QRCodeReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 136);
+            init();
+        }
+        protected QRCodeReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 136);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 136);
+        }
+        public void read() {
+            found = backing.getInt(0);
+            int data_dataLength = backing.getInt(8);
+            long data_addr = getPointer(backing, 4);
+            data = new byte[data_dataLength];
+            if (data_dataLength > 0 && data_addr != 0) {
+                getBytes(newDirectByteBuffer(data_addr, data_dataLength), data, 0, data_dataLength);
+            }
+            for (PointFloat it : boundingBox) {
+                it.read();
+            }
+            int tokenizedData_sizeOfTokenizedData = backing.getInt(48);
+            long tokenizedData_addr = getPointer(backing, 44);
+            tokenizedData = new QRCodeDataToken[tokenizedData_sizeOfTokenizedData];
+            if (tokenizedData_sizeOfTokenizedData > 0 && tokenizedData_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(tokenizedData_addr, tokenizedData_sizeOfTokenizedData*16);
+                for (int i=0, off=0; i<tokenizedData_sizeOfTokenizedData; i++, off += 16) {
+                    tokenizedData[i] = new QRCodeDataToken(bb, off);
+                    tokenizedData[i].read();
+                }
+            }
+            numErrorsCorrected = backing.getInt(52);
+            dimensions = backing.getInt(56);
+            version = backing.getInt(60);
+            modelType = QRModelType.fromValue(backing.getInt(64));
+            streamMode = QRStreamMode.fromValue(backing.getInt(68));
+            matrixPolarity = QRPolarities.fromValue(backing.getInt(72));
+            mirrored = backing.getInt(80);
+            positionInAppendStream = backing.getInt(84);
+            sizeOfAppendStream = backing.getInt(88);
+            firstEAN128ApplicationID = backing.getInt(92);
+            firstECIDesignator = backing.getInt(96);
+            appendStreamIdentifier = backing.getInt(100);
+            minimumEdgeStrength = backing.getInt(104);
+            demodulationMode = QRDemodulationMode.fromValue(backing.getInt(112));
+            cellSampleSize = QRCellSampleSize.fromValue(backing.getInt(120));
+            cellFilterMode = QRCellFilterMode.fromValue(backing.getInt(128));
+        }
+        public void write() {
+            backing.putInt(0, found);
+            data_buf = ByteBuffer.allocateDirect(data.length);
+            putBytes(data_buf, data, 0, data.length);
+            backing.putInt(8, data.length);
+            putPointer(backing, 4, data_buf);
+            for (PointFloat it : boundingBox) {
+                it.write();
+            }
+            tokenizedData_buf = ByteBuffer.allocateDirect(tokenizedData.length*16);
+            for (int i=0, off=0; i<tokenizedData.length; i++, off += 16) {
+                tokenizedData[i].setBuffer(tokenizedData_buf, off);
+                tokenizedData[i].write();
+            }
+            backing.putInt(48, tokenizedData.length);
+            putPointer(backing, 44, tokenizedData_buf);
+            backing.putInt(52, numErrorsCorrected);
+            backing.putInt(56, dimensions);
+            backing.putInt(60, version);
+            if (modelType != null)
+                backing.putInt(64, modelType.getValue());
+            if (streamMode != null)
+                backing.putInt(68, streamMode.getValue());
+            if (matrixPolarity != null)
+                backing.putInt(72, matrixPolarity.getValue());
+            backing.putInt(80, mirrored);
+            backing.putInt(84, positionInAppendStream);
+            backing.putInt(88, sizeOfAppendStream);
+            backing.putInt(92, firstEAN128ApplicationID);
+            backing.putInt(96, firstECIDesignator);
+            backing.putInt(100, appendStreamIdentifier);
+            backing.putInt(104, minimumEdgeStrength);
+            if (demodulationMode != null)
+                backing.putInt(112, demodulationMode.getValue());
+            if (cellSampleSize != null)
+                backing.putInt(120, cellSampleSize.getValue());
+            if (cellFilterMode != null)
+                backing.putInt(128, cellFilterMode.getValue());
+        }
+        public int size() {
+            return 136;
+        }
+    }
+
+    public static class AIMGradeReport extends DisposedStruct {
+        public AIMGrade overallGrade; // The overall letter grade, which is equal to the lowest of the other five letter grades.
+        public AIMGrade decodingGrade; // The letter grade assigned to a Data Matrix barcode based on the success of the function in decoding the Data Matrix barcode.
+        public AIMGrade symbolContrastGrade; // The letter grade assigned to a Data Matrix barcode based on the symbol contrast raw score.
+        public float symbolContrast; // The symbol contrast raw score representing the percentage difference between the mean of the reflectance of the darkest 10 percent and lightest 10 percent of the Data Matrix barcode.
+        public AIMGrade printGrowthGrade; // The print growth letter grade for the Data Matrix barcode.
+        public float printGrowth; // The print growth raw score for the barcode, which is based on the extent to which dark or light markings appropriately fill their module boundaries.
+        public AIMGrade axialNonuniformityGrade; // The axial nonuniformity grade for the Data Matrix barcode.
+        public float axialNonuniformity; // The axial nonuniformity raw score for the barcode, which is based on how much the sampling point spacing differs from one axis to another.
+        public AIMGrade unusedErrorCorrectionGrade; // The unused error correction letter grade for the Data Matrix barcode.
+        public float unusedErrorCorrection; // The unused error correction raw score for the Data Matrix barcode, which is based on the extent to which regional or spot damage in the Data Matrix barcode has eroded the reading safety margin provided by the error correction.
+
+        private void init() {
+            
+        }
+        public AIMGradeReport() {
+            super(40);
+            init();
+        }
+        public AIMGradeReport(AIMGrade overallGrade, AIMGrade decodingGrade, AIMGrade symbolContrastGrade, double symbolContrast, AIMGrade printGrowthGrade, double printGrowth, AIMGrade axialNonuniformityGrade, double axialNonuniformity, AIMGrade unusedErrorCorrectionGrade, double unusedErrorCorrection) {
+            super(40);
+            this.overallGrade = overallGrade;
+            this.decodingGrade = decodingGrade;
+            this.symbolContrastGrade = symbolContrastGrade;
+            this.symbolContrast = (float)symbolContrast;
+            this.printGrowthGrade = printGrowthGrade;
+            this.printGrowth = (float)printGrowth;
+            this.axialNonuniformityGrade = axialNonuniformityGrade;
+            this.axialNonuniformity = (float)axialNonuniformity;
+            this.unusedErrorCorrectionGrade = unusedErrorCorrectionGrade;
+            this.unusedErrorCorrection = (float)unusedErrorCorrection;
+        }
+        protected AIMGradeReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 40);
+            init();
+        }
+        protected AIMGradeReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 40);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 40);
+        }
+        public void read() {
+            overallGrade = AIMGrade.fromValue(backing.getInt(0));
+            decodingGrade = AIMGrade.fromValue(backing.getInt(4));
+            symbolContrastGrade = AIMGrade.fromValue(backing.getInt(8));
+            symbolContrast = backing.getFloat(12);
+            printGrowthGrade = AIMGrade.fromValue(backing.getInt(16));
+            printGrowth = backing.getFloat(20);
+            axialNonuniformityGrade = AIMGrade.fromValue(backing.getInt(24));
+            axialNonuniformity = backing.getFloat(28);
+            unusedErrorCorrectionGrade = AIMGrade.fromValue(backing.getInt(32));
+            unusedErrorCorrection = backing.getFloat(36);
+        }
+        public void write() {
+            if (overallGrade != null)
+                backing.putInt(0, overallGrade.getValue());
+            if (decodingGrade != null)
+                backing.putInt(4, decodingGrade.getValue());
+            if (symbolContrastGrade != null)
+                backing.putInt(8, symbolContrastGrade.getValue());
+            backing.putFloat(12, symbolContrast);
+            if (printGrowthGrade != null)
+                backing.putInt(16, printGrowthGrade.getValue());
+            backing.putFloat(20, printGrowth);
+            if (axialNonuniformityGrade != null)
+                backing.putInt(24, axialNonuniformityGrade.getValue());
+            backing.putFloat(28, axialNonuniformity);
+            if (unusedErrorCorrectionGrade != null)
+                backing.putInt(32, unusedErrorCorrectionGrade.getValue());
+            backing.putFloat(36, unusedErrorCorrection);
+        }
+        public int size() {
+            return 40;
+        }
+    }
+
+    public static class DataMatrixSizeOptions extends DisposedStruct {
+        public int minSize; // Specifies the minimum size (in pixels) of the Data Matrix barcode in the image.
+        public int maxSize; // Specifies the maximum size (in pixels) of the Data Matrix barcode in the image.
+        public int quietZoneWidth; // Specifies the expected minimum size of the quiet zone, in pixels.
+
+        private void init() {
+            
+        }
+        public DataMatrixSizeOptions() {
+            super(12);
+            init();
+        }
+        public DataMatrixSizeOptions(int minSize, int maxSize, int quietZoneWidth) {
+            super(12);
+            this.minSize = minSize;
+            this.maxSize = maxSize;
+            this.quietZoneWidth = quietZoneWidth;
+        }
+        protected DataMatrixSizeOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected DataMatrixSizeOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            minSize = backing.getInt(0);
+            maxSize = backing.getInt(4);
+            quietZoneWidth = backing.getInt(8);
+        }
+        public void write() {
+            backing.putInt(0, minSize);
+            backing.putInt(4, maxSize);
+            backing.putInt(8, quietZoneWidth);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class DataMatrixDescriptionOptions extends DisposedStruct {
+        public float aspectRatio; // Specifies the ratio of the width of each Data Matrix barcode cell (in pixels) to the height of the Data Matrix barcode (in pixels).
+        public int rows; // Specifies the number of rows in the Data Matrix barcode.
+        public int columns; // Specifies the number of columns in the Data Matrix barcode.
+        public int rectangle; // Set this element to TRUE to specify that the Data Matrix barcode is rectangular.
+        public DataMatrixECC ecc; // Specifies the ECC used for this Data Matrix barcode.
+        public DataMatrixPolarity polarity; // Specifies the data-to-background contrast for the Data Matrix barcode.
+        public DataMatrixCellFillMode cellFill; // Specifies the fill percentage for a cell of the Data Matrix barcode that is in the "ON" state.
+        public float minBorderIntegrity; // Specifies the minimum percentage of the border (locator pattern and timing pattern) the function should expect in the Data Matrix barcode.
+        public DataMatrixMirrorMode mirrorMode; // Specifies if the Data Matrix barcode appears normally in the image or if the barcode appears mirrored in the image.
+
+        private void init() {
+            
+        }
+        public DataMatrixDescriptionOptions() {
+            super(56);
+            init();
+        }
+        public DataMatrixDescriptionOptions(double aspectRatio, int rows, int columns, int rectangle, DataMatrixECC ecc, DataMatrixPolarity polarity, DataMatrixCellFillMode cellFill, double minBorderIntegrity, DataMatrixMirrorMode mirrorMode) {
+            super(56);
+            this.aspectRatio = (float)aspectRatio;
+            this.rows = rows;
+            this.columns = columns;
+            this.rectangle = rectangle;
+            this.ecc = ecc;
+            this.polarity = polarity;
+            this.cellFill = cellFill;
+            this.minBorderIntegrity = (float)minBorderIntegrity;
+            this.mirrorMode = mirrorMode;
+        }
+        protected DataMatrixDescriptionOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 56);
+            init();
+        }
+        protected DataMatrixDescriptionOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 56);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 56);
+        }
+        public void read() {
+            aspectRatio = backing.getFloat(0);
+            rows = backing.getInt(4);
+            columns = backing.getInt(8);
+            rectangle = backing.getInt(12);
+            ecc = DataMatrixECC.fromValue(backing.getInt(16));
+            polarity = DataMatrixPolarity.fromValue(backing.getInt(24));
+            cellFill = DataMatrixCellFillMode.fromValue(backing.getInt(32));
+            minBorderIntegrity = backing.getFloat(40);
+            mirrorMode = DataMatrixMirrorMode.fromValue(backing.getInt(48));
+        }
+        public void write() {
+            backing.putFloat(0, aspectRatio);
+            backing.putInt(4, rows);
+            backing.putInt(8, columns);
+            backing.putInt(12, rectangle);
+            if (ecc != null)
+                backing.putInt(16, ecc.getValue());
+            if (polarity != null)
+                backing.putInt(24, polarity.getValue());
+            if (cellFill != null)
+                backing.putInt(32, cellFill.getValue());
+            backing.putFloat(40, minBorderIntegrity);
+            if (mirrorMode != null)
+                backing.putInt(48, mirrorMode.getValue());
+        }
+        public int size() {
+            return 56;
+        }
+    }
+
+    public static class DataMatrixSearchOptions extends DisposedStruct {
+        public DataMatrixRotationMode rotationMode; // Specifies the amount of Data Matrix barcode rotation the function should allow for.
+        public int skipLocation; // If set to TRUE, specifies that the function should assume that the Data Matrix barcode occupies the entire image (or the entire search region).
+        public int edgeThreshold; // Specifies the minimum contrast a pixel must have in order to be considered part of a matrix cell edge.
+        public DataMatrixDemodulationMode demodulationMode; // Specifies the mode the function should use to demodulate (determine which cells are on and which cells are off) the Data Matrix barcode.
+        public DataMatrixCellSampleSize cellSampleSize; // Specifies the sample size, in pixels, the function should take to determine if each cell is on or off.
+        public DataMatrixCellFilterMode cellFilterMode; // Specifies the mode the function uses to determine the pixel value for each cell.
+        public int skewDegreesAllowed; // Specifies the amount of skew in the Data Matrix barcode the function should allow for.
+        public int maxIterations; // Specifies the maximum number of iterations before the function stops looking for the Data Matrix barcode.
+        public int initialSearchVectorWidth; // Specifies the number of pixels the function should average together to determine the location of an edge.
+
+        private void init() {
+            
+        }
+        public DataMatrixSearchOptions() {
+            super(56);
+            init();
+        }
+        public DataMatrixSearchOptions(DataMatrixRotationMode rotationMode, int skipLocation, int edgeThreshold, DataMatrixDemodulationMode demodulationMode, DataMatrixCellSampleSize cellSampleSize, DataMatrixCellFilterMode cellFilterMode, int skewDegreesAllowed, int maxIterations, int initialSearchVectorWidth) {
+            super(56);
+            this.rotationMode = rotationMode;
+            this.skipLocation = skipLocation;
+            this.edgeThreshold = edgeThreshold;
+            this.demodulationMode = demodulationMode;
+            this.cellSampleSize = cellSampleSize;
+            this.cellFilterMode = cellFilterMode;
+            this.skewDegreesAllowed = skewDegreesAllowed;
+            this.maxIterations = maxIterations;
+            this.initialSearchVectorWidth = initialSearchVectorWidth;
+        }
+        protected DataMatrixSearchOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 56);
+            init();
+        }
+        protected DataMatrixSearchOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 56);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 56);
+        }
+        public void read() {
+            rotationMode = DataMatrixRotationMode.fromValue(backing.getInt(0));
+            skipLocation = backing.getInt(4);
+            edgeThreshold = backing.getInt(8);
+            demodulationMode = DataMatrixDemodulationMode.fromValue(backing.getInt(16));
+            cellSampleSize = DataMatrixCellSampleSize.fromValue(backing.getInt(24));
+            cellFilterMode = DataMatrixCellFilterMode.fromValue(backing.getInt(32));
+            skewDegreesAllowed = backing.getInt(40);
+            maxIterations = backing.getInt(44);
+            initialSearchVectorWidth = backing.getInt(48);
+        }
+        public void write() {
+            if (rotationMode != null)
+                backing.putInt(0, rotationMode.getValue());
+            backing.putInt(4, skipLocation);
+            backing.putInt(8, edgeThreshold);
+            if (demodulationMode != null)
+                backing.putInt(16, demodulationMode.getValue());
+            if (cellSampleSize != null)
+                backing.putInt(24, cellSampleSize.getValue());
+            if (cellFilterMode != null)
+                backing.putInt(32, cellFilterMode.getValue());
+            backing.putInt(40, skewDegreesAllowed);
+            backing.putInt(44, maxIterations);
+            backing.putInt(48, initialSearchVectorWidth);
+        }
+        public int size() {
+            return 56;
+        }
+    }
+
+    public static class DataMatrixReport extends DisposedStruct {
+        public int found; // This element is TRUE if the function located and decoded a Data Matrix barcode and FALSE if the function failed to locate and decode a Data Matrix barcode.
+        public int binary; // This element is TRUE if the Data Matrix barcode contains binary data and FALSE if the Data Matrix barcode contains text data.
+        public byte[] data; // The data encoded in the Data Matrix barcode.
+        public PointFloat[] boundingBox; // An array of four points describing the rectangle surrounding the Data Matrix barcode.
+        public int numErrorsCorrected; // The number of errors the function corrected when decoding the Data Matrix barcode.
+        public int numErasuresCorrected; // The number of erasures the function corrected when decoding the Data Matrix barcode.
+        public float aspectRatio; // Specifies the aspect ratio of the Data Matrix barcode in the image, which equals the ratio of the width of a Data Matrix barcode cell (in pixels) to the height of a Data Matrix barcode cell (in pixels).
+        public int rows; // The number of rows in the Data Matrix barcode.
+        public int columns; // The number of columns in the Data Matrix barcode.
+        public DataMatrixECC ecc; // The Error Correction Code (ECC) used by the Data Matrix barcode.
+        public DataMatrixPolarity polarity; // The polarity of the Data Matrix barcode.
+        public DataMatrixCellFillMode cellFill; // The cell fill percentage of the Data Matrix barcode.
+        public float borderIntegrity; // The percentage of the Data Matrix barcode border that appears correctly in the image.
+        public int mirrored; // This element is TRUE if the Data Matrix barcode appears mirrored in the image and FALSE if the Data Matrix barcode appears normally in the image.
+        public int minimumEdgeStrength; // The strength of the weakest edge the function used to find the coarse location of the Data Matrix barcode in the image.
+        public DataMatrixDemodulationMode demodulationMode; // The demodulation mode the function used to locate the Data Matrix barcode.
+        public DataMatrixCellSampleSize cellSampleSize; // The cell sample size the function used to locate the Data Matrix barcode.
+        public DataMatrixCellFilterMode cellFilterMode; // The cell filter mode the function used to locate the Data Matrix barcode.
+        public int iterations; // The number of iterations the function took in attempting to locate the Data Matrix barcode.
+        private ByteBuffer data_buf;
+
+        private void init() {
+            data = new byte[0];
+            boundingBox = new PointFloat[4];
+            
+            for (int i=0, off=16; i<4; i++, off += 8)
+                boundingBox[i] = new PointFloat(backing, off);
+        }
+        public DataMatrixReport() {
+            super(144);
+            init();
+        }
+        public DataMatrixReport(int found, int binary, byte[] data, PointFloat[] boundingBox, int numErrorsCorrected, int numErasuresCorrected, double aspectRatio, int rows, int columns, DataMatrixECC ecc, DataMatrixPolarity polarity, DataMatrixCellFillMode cellFill, double borderIntegrity, int mirrored, int minimumEdgeStrength, DataMatrixDemodulationMode demodulationMode, DataMatrixCellSampleSize cellSampleSize, DataMatrixCellFilterMode cellFilterMode, int iterations) {
+            super(144);
+            this.found = found;
+            this.binary = binary;
+            this.data = data;
+            this.boundingBox = boundingBox;
+            this.numErrorsCorrected = numErrorsCorrected;
+            this.numErasuresCorrected = numErasuresCorrected;
+            this.aspectRatio = (float)aspectRatio;
+            this.rows = rows;
+            this.columns = columns;
+            this.ecc = ecc;
+            this.polarity = polarity;
+            this.cellFill = cellFill;
+            this.borderIntegrity = (float)borderIntegrity;
+            this.mirrored = mirrored;
+            this.minimumEdgeStrength = minimumEdgeStrength;
+            this.demodulationMode = demodulationMode;
+            this.cellSampleSize = cellSampleSize;
+            this.cellFilterMode = cellFilterMode;
+            this.iterations = iterations;
+        }
+        protected DataMatrixReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 144);
+            init();
+        }
+        protected DataMatrixReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 144);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 144);
+        }
+        public void read() {
+            found = backing.getInt(0);
+            binary = backing.getInt(4);
+            int data_dataLength = backing.getInt(12);
+            long data_addr = getPointer(backing, 8);
+            data = new byte[data_dataLength];
+            if (data_dataLength > 0 && data_addr != 0) {
+                getBytes(newDirectByteBuffer(data_addr, data_dataLength), data, 0, data_dataLength);
+            }
+            for (PointFloat it : boundingBox) {
+                it.read();
+            }
+            numErrorsCorrected = backing.getInt(48);
+            numErasuresCorrected = backing.getInt(52);
+            aspectRatio = backing.getFloat(56);
+            rows = backing.getInt(60);
+            columns = backing.getInt(64);
+            ecc = DataMatrixECC.fromValue(backing.getInt(72));
+            polarity = DataMatrixPolarity.fromValue(backing.getInt(80));
+            cellFill = DataMatrixCellFillMode.fromValue(backing.getInt(88));
+            borderIntegrity = backing.getFloat(96);
+            mirrored = backing.getInt(100);
+            minimumEdgeStrength = backing.getInt(104);
+            demodulationMode = DataMatrixDemodulationMode.fromValue(backing.getInt(112));
+            cellSampleSize = DataMatrixCellSampleSize.fromValue(backing.getInt(120));
+            cellFilterMode = DataMatrixCellFilterMode.fromValue(backing.getInt(128));
+            iterations = backing.getInt(136);
+        }
+        public void write() {
+            backing.putInt(0, found);
+            backing.putInt(4, binary);
+            data_buf = ByteBuffer.allocateDirect(data.length);
+            putBytes(data_buf, data, 0, data.length);
+            backing.putInt(12, data.length);
+            putPointer(backing, 8, data_buf);
+            for (PointFloat it : boundingBox) {
+                it.write();
+            }
+            backing.putInt(48, numErrorsCorrected);
+            backing.putInt(52, numErasuresCorrected);
+            backing.putFloat(56, aspectRatio);
+            backing.putInt(60, rows);
+            backing.putInt(64, columns);
+            if (ecc != null)
+                backing.putInt(72, ecc.getValue());
+            if (polarity != null)
+                backing.putInt(80, polarity.getValue());
+            if (cellFill != null)
+                backing.putInt(88, cellFill.getValue());
+            backing.putFloat(96, borderIntegrity);
+            backing.putInt(100, mirrored);
+            backing.putInt(104, minimumEdgeStrength);
+            if (demodulationMode != null)
+                backing.putInt(112, demodulationMode.getValue());
+            if (cellSampleSize != null)
+                backing.putInt(120, cellSampleSize.getValue());
+            if (cellFilterMode != null)
+                backing.putInt(128, cellFilterMode.getValue());
+            backing.putInt(136, iterations);
+        }
+        public int size() {
+            return 144;
+        }
+    }
+
+    public static class JPEG2000FileAdvancedOptions extends DisposedStruct {
+        public WaveletTransformMode waveletMode; // Determines which wavelet transform to use when writing the file.
+        public int useMultiComponentTransform; // Set this parameter to TRUE to use an additional transform on RGB images.
+        public int maxWaveletTransformLevel; // Specifies the maximum allowed level of wavelet transform.
+        public float quantizationStepSize; // Specifies the absolute base quantization step size for derived quantization mode.
+
+        private void init() {
+            
+        }
+        public JPEG2000FileAdvancedOptions() {
+            super(16);
+            init();
+        }
+        public JPEG2000FileAdvancedOptions(WaveletTransformMode waveletMode, int useMultiComponentTransform, int maxWaveletTransformLevel, double quantizationStepSize) {
+            super(16);
+            this.waveletMode = waveletMode;
+            this.useMultiComponentTransform = useMultiComponentTransform;
+            this.maxWaveletTransformLevel = maxWaveletTransformLevel;
+            this.quantizationStepSize = (float)quantizationStepSize;
+        }
+        protected JPEG2000FileAdvancedOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected JPEG2000FileAdvancedOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            waveletMode = WaveletTransformMode.fromValue(backing.getInt(0));
+            useMultiComponentTransform = backing.getInt(4);
+            maxWaveletTransformLevel = backing.getInt(8);
+            quantizationStepSize = backing.getFloat(12);
+        }
+        public void write() {
+            if (waveletMode != null)
+                backing.putInt(0, waveletMode.getValue());
+            backing.putInt(4, useMultiComponentTransform);
+            backing.putInt(8, maxWaveletTransformLevel);
+            backing.putFloat(12, quantizationStepSize);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class MatchGeometricPatternAdvancedOptions2 extends DisposedStruct {
+        public int minFeaturesUsed; // Specifies the minimum number of features the function uses when matching.
+        public int maxFeaturesUsed; // Specifies the maximum number of features the function uses when matching.
+        public int subpixelIterations; // Specifies the maximum number of incremental improvements used to refine matches with subpixel information.
+        public double subpixelTolerance; // Specifies the maximum amount of change, in pixels, between consecutive incremental improvements in the match position before the function stops refining the match position.
+        public int initialMatchListLength; // Specifies the maximum size of the match list.
+        public float matchTemplateCurveScore; // Set this element to TRUE to specify that the function should calculate the match curve to template curve score and return it for each match result.
+        public int correlationScore; // Set this element to TRUE to specify that the function should calculate the correlation score and return it for each match result.
+        public double minMatchSeparationDistance; // Specifies the minimum separation distance, in pixels, between the origins of two matches that have unique positions.
+        public double minMatchSeparationAngle; // Specifies the minimum angular difference, in degrees, between two matches that have unique angles.
+        public double minMatchSeparationScale; // Specifies the minimum difference in scale, expressed as a percentage, between two matches that have unique scales.
+        public double maxMatchOverlap; // Specifies the maximum amount of overlap, expressed as a percentage, allowed between the bounding rectangles of two unique matches.
+        public int coarseResult; // Specifies whether you want the function to spend less time accurately estimating the location of a match.
+        public int smoothContours; // Set this element to TRUE to specify smoothing be done on the contours of the inspection image before feature extraction.
+        public int enableCalibrationSupport; // Set this element to TRUE to specify the algorithm treat the inspection image as a calibrated image.
+
+        private void init() {
+            
+        }
+        public MatchGeometricPatternAdvancedOptions2() {
+            super(88);
+            init();
+        }
+        public MatchGeometricPatternAdvancedOptions2(int minFeaturesUsed, int maxFeaturesUsed, int subpixelIterations, double subpixelTolerance, int initialMatchListLength, double matchTemplateCurveScore, int correlationScore, double minMatchSeparationDistance, double minMatchSeparationAngle, double minMatchSeparationScale, double maxMatchOverlap, int coarseResult, int smoothContours, int enableCalibrationSupport) {
+            super(88);
+            this.minFeaturesUsed = minFeaturesUsed;
+            this.maxFeaturesUsed = maxFeaturesUsed;
+            this.subpixelIterations = subpixelIterations;
+            this.subpixelTolerance = subpixelTolerance;
+            this.initialMatchListLength = initialMatchListLength;
+            this.matchTemplateCurveScore = (float)matchTemplateCurveScore;
+            this.correlationScore = correlationScore;
+            this.minMatchSeparationDistance = minMatchSeparationDistance;
+            this.minMatchSeparationAngle = minMatchSeparationAngle;
+            this.minMatchSeparationScale = minMatchSeparationScale;
+            this.maxMatchOverlap = maxMatchOverlap;
+            this.coarseResult = coarseResult;
+            this.smoothContours = smoothContours;
+            this.enableCalibrationSupport = enableCalibrationSupport;
+        }
+        protected MatchGeometricPatternAdvancedOptions2(ByteBuffer backing, int offset) {
+            super(backing, offset, 88);
+            init();
+        }
+        protected MatchGeometricPatternAdvancedOptions2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 88);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 88);
+        }
+        public void read() {
+            minFeaturesUsed = backing.getInt(0);
+            maxFeaturesUsed = backing.getInt(4);
+            subpixelIterations = backing.getInt(8);
+            subpixelTolerance = backing.getDouble(16);
+            initialMatchListLength = backing.getInt(24);
+            matchTemplateCurveScore = backing.getFloat(28);
+            correlationScore = backing.getInt(32);
+            minMatchSeparationDistance = backing.getDouble(40);
+            minMatchSeparationAngle = backing.getDouble(48);
+            minMatchSeparationScale = backing.getDouble(56);
+            maxMatchOverlap = backing.getDouble(64);
+            coarseResult = backing.getInt(72);
+            smoothContours = backing.getInt(76);
+            enableCalibrationSupport = backing.getInt(80);
+        }
+        public void write() {
+            backing.putInt(0, minFeaturesUsed);
+            backing.putInt(4, maxFeaturesUsed);
+            backing.putInt(8, subpixelIterations);
+            backing.putDouble(16, subpixelTolerance);
+            backing.putInt(24, initialMatchListLength);
+            backing.putFloat(28, matchTemplateCurveScore);
+            backing.putInt(32, correlationScore);
+            backing.putDouble(40, minMatchSeparationDistance);
+            backing.putDouble(48, minMatchSeparationAngle);
+            backing.putDouble(56, minMatchSeparationScale);
+            backing.putDouble(64, maxMatchOverlap);
+            backing.putInt(72, coarseResult);
+            backing.putInt(76, smoothContours);
+            backing.putInt(80, enableCalibrationSupport);
+        }
+        public int size() {
+            return 88;
+        }
+    }
+
+    public static class InspectionAlignment extends DisposedStruct {
+        public PointFloat position; // The location of the center of the golden template in the image under inspection.
+        public float rotation; // The rotation of the golden template in the image under inspection, in degrees.
+        public float scale; // The percentage of the size of the area under inspection compared to the size of the golden template.
+
+        private void init() {
+            position = new PointFloat(backing, 0);
+        }
+        public InspectionAlignment() {
+            super(16);
+            init();
+        }
+        public InspectionAlignment(PointFloat position, double rotation, double scale) {
+            super(16);
+            this.position = position;
+            this.rotation = (float)rotation;
+            this.scale = (float)scale;
+        }
+        protected InspectionAlignment(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected InspectionAlignment(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            position.read();
+            rotation = backing.getFloat(8);
+            scale = backing.getFloat(12);
+        }
+        public void write() {
+            position.write();
+            backing.putFloat(8, rotation);
+            backing.putFloat(12, scale);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class InspectionOptions extends DisposedStruct {
+        public RegistrationMethod registrationMethod; // Specifies how the function registers the golden template and the target image.
+        public NormalizationMethod normalizationMethod; // Specifies how the function normalizes the golden template to the target image.
+        public int edgeThicknessToIgnore; // Specifies desired thickness of edges to be ignored.
+        public float brightThreshold; // Specifies the threshold for areas where the target image is brighter than the golden template.
+        public float darkThreshold; // Specifies the threshold for areas where the target image is darker than the golden template.
+        public int binary; // Specifies whether the function should return a binary image giving the location of defects, or a grayscale image giving the intensity of defects.
+
+        private void init() {
+            
+        }
+        public InspectionOptions() {
+            super(24);
+            init();
+        }
+        public InspectionOptions(RegistrationMethod registrationMethod, NormalizationMethod normalizationMethod, int edgeThicknessToIgnore, double brightThreshold, double darkThreshold, int binary) {
+            super(24);
+            this.registrationMethod = registrationMethod;
+            this.normalizationMethod = normalizationMethod;
+            this.edgeThicknessToIgnore = edgeThicknessToIgnore;
+            this.brightThreshold = (float)brightThreshold;
+            this.darkThreshold = (float)darkThreshold;
+            this.binary = binary;
+        }
+        protected InspectionOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected InspectionOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            registrationMethod = RegistrationMethod.fromValue(backing.getInt(0));
+            normalizationMethod = NormalizationMethod.fromValue(backing.getInt(4));
+            edgeThicknessToIgnore = backing.getInt(8);
+            brightThreshold = backing.getFloat(12);
+            darkThreshold = backing.getFloat(16);
+            binary = backing.getInt(20);
+        }
+        public void write() {
+            if (registrationMethod != null)
+                backing.putInt(0, registrationMethod.getValue());
+            if (normalizationMethod != null)
+                backing.putInt(4, normalizationMethod.getValue());
+            backing.putInt(8, edgeThicknessToIgnore);
+            backing.putFloat(12, brightThreshold);
+            backing.putFloat(16, darkThreshold);
+            backing.putInt(20, binary);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class CharReport2 extends DisposedStruct {
+        public String character; // The character value.
+        public PointFloat[] corner; // An array of four points that describes the rectangle that surrounds the character.
+        public int lowThreshold; // The minimum value of the threshold range used for this character.
+        public int highThreshold; // The maximum value of the threshold range used for this character.
+        public int classificationScore; // The degree to which the assigned character class represents the object better than the other character classes in the character set.
+        public int verificationScore; // The similarity of the character and the reference character for the character class.
+        public int verified; // This element is TRUE if a reference character was found for the character class and FALSE if a reference character was not found.
+        private ByteBuffer character_buf;
+
+        private void init() {
+            corner = new PointFloat[4];
+            
+            for (int i=0, off=4; i<4; i++, off += 8)
+                corner[i] = new PointFloat(backing, off);
+        }
+        public CharReport2() {
+            super(56);
+            init();
+        }
+        public CharReport2(String character, PointFloat[] corner, int lowThreshold, int highThreshold, int classificationScore, int verificationScore, int verified) {
+            super(56);
+            this.character = character;
+            this.corner = corner;
+            this.lowThreshold = lowThreshold;
+            this.highThreshold = highThreshold;
+            this.classificationScore = classificationScore;
+            this.verificationScore = verificationScore;
+            this.verified = verified;
+        }
+        protected CharReport2(ByteBuffer backing, int offset) {
+            super(backing, offset, 56);
+            init();
+        }
+        protected CharReport2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 56);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 56);
+        }
+        public void read() {
+            long character_addr = getPointer(backing, 0);
+            if (character_addr == 0)
+                character = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(character_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    character = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    character = "";
+                }
+            }
+            
+            for (PointFloat it : corner) {
+                it.read();
+            }
+            lowThreshold = backing.getInt(36);
+            highThreshold = backing.getInt(40);
+            classificationScore = backing.getInt(44);
+            verificationScore = backing.getInt(48);
+            verified = backing.getInt(52);
+        }
+        public void write() {
+            if (character != null) {
+                byte[] character_bytes;
+                try {
+                    character_bytes = character.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    character_bytes = new byte[0];
+                }
+                character_buf = ByteBuffer.allocateDirect(character_bytes.length+1);
+                putBytes(character_buf, character_bytes, 0, character_bytes.length).put(character_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, character == null ? 0 : getByteBufferAddress(character_buf));
+            for (PointFloat it : corner) {
+                it.write();
+            }
+            backing.putInt(36, lowThreshold);
+            backing.putInt(40, highThreshold);
+            backing.putInt(44, classificationScore);
+            backing.putInt(48, verificationScore);
+            backing.putInt(52, verified);
+        }
+        public int size() {
+            return 56;
+        }
+    }
+
+    public static class CharInfo2 extends DisposedStruct {
+        public String charValue; // Retrieves the character value of the corresponding character in the character set.
+        public Image charImage; // The image you used to train this character.
+        public Image internalImage; // The internal representation that NI Vision uses to match objects to this character.
+        public int isReferenceChar; // This element is TRUE if the character is the reference character for the character class.
+        private ByteBuffer charValue_buf;
+
+        private void init() {
+            
+        }
+        public CharInfo2() {
+            super(16);
+            init();
+        }
+        public CharInfo2(String charValue, Image charImage, Image internalImage, int isReferenceChar) {
+            super(16);
+            this.charValue = charValue;
+            this.charImage = charImage;
+            this.internalImage = internalImage;
+            this.isReferenceChar = isReferenceChar;
+        }
+        protected CharInfo2(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected CharInfo2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            long charValue_addr = getPointer(backing, 0);
+            if (charValue_addr == 0)
+                charValue = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(charValue_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    charValue = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    charValue = "";
+                }
+            }
+            
+            long charImage_addr = getPointer(backing, 4);
+            if (charImage_addr == 0)
+                charImage = null;
+            else
+                charImage = new Image(charImage_addr, false);
+            long internalImage_addr = getPointer(backing, 8);
+            if (internalImage_addr == 0)
+                internalImage = null;
+            else
+                internalImage = new Image(internalImage_addr, false);
+            isReferenceChar = backing.getInt(12);
+        }
+        public void write() {
+            if (charValue != null) {
+                byte[] charValue_bytes;
+                try {
+                    charValue_bytes = charValue.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    charValue_bytes = new byte[0];
+                }
+                charValue_buf = ByteBuffer.allocateDirect(charValue_bytes.length+1);
+                putBytes(charValue_buf, charValue_bytes, 0, charValue_bytes.length).put(charValue_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, charValue == null ? 0 : getByteBufferAddress(charValue_buf));
+            putPointer(backing, 4, charImage);
+            putPointer(backing, 8, internalImage);
+            backing.putInt(12, isReferenceChar);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class ReadTextReport2 extends DisposedStruct {
+        public String readString; // The read string.
+        public CharReport2[] characterReport; // An array of reports describing the properties of each identified character.
+        private ByteBuffer readString_buf;
+        private ByteBuffer characterReport_buf;
+
+        private void init() {
+            characterReport = new CharReport2[0];
+        }
+        public ReadTextReport2() {
+            super(12);
+            init();
+        }
+        public ReadTextReport2(String readString, CharReport2[] characterReport) {
+            super(12);
+            this.readString = readString;
+            this.characterReport = characterReport;
+        }
+        protected ReadTextReport2(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected ReadTextReport2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            long readString_addr = getPointer(backing, 0);
+            if (readString_addr == 0)
+                readString = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(readString_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    readString = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    readString = "";
+                }
+            }
+            
+            int characterReport_numCharacterReports = backing.getInt(8);
+            long characterReport_addr = getPointer(backing, 4);
+            characterReport = new CharReport2[characterReport_numCharacterReports];
+            if (characterReport_numCharacterReports > 0 && characterReport_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(characterReport_addr, characterReport_numCharacterReports*56);
+                for (int i=0, off=0; i<characterReport_numCharacterReports; i++, off += 56) {
+                    characterReport[i] = new CharReport2(bb, off);
+                    characterReport[i].read();
+                }
+            }
+        }
+        public void write() {
+            if (readString != null) {
+                byte[] readString_bytes;
+                try {
+                    readString_bytes = readString.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    readString_bytes = new byte[0];
+                }
+                readString_buf = ByteBuffer.allocateDirect(readString_bytes.length+1);
+                putBytes(readString_buf, readString_bytes, 0, readString_bytes.length).put(readString_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, readString == null ? 0 : getByteBufferAddress(readString_buf));
+            characterReport_buf = ByteBuffer.allocateDirect(characterReport.length*56);
+            for (int i=0, off=0; i<characterReport.length; i++, off += 56) {
+                characterReport[i].setBuffer(characterReport_buf, off);
+                characterReport[i].write();
+            }
+            backing.putInt(8, characterReport.length);
+            putPointer(backing, 4, characterReport_buf);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class EllipseFeature extends DisposedStruct {
+        public PointFloat position; // The location of the center of the ellipse.
+        public double rotation; // The orientation of the semi-major axis of the ellipse with respect to the horizontal.
+        public double minorRadius; // The length of the semi-minor axis of the ellipse.
+        public double majorRadius; // The length of the semi-major axis of the ellipse.
+
+        private void init() {
+            position = new PointFloat(backing, 0);
+        }
+        public EllipseFeature() {
+            super(32);
+            init();
+        }
+        public EllipseFeature(PointFloat position, double rotation, double minorRadius, double majorRadius) {
+            super(32);
+            this.position = position;
+            this.rotation = rotation;
+            this.minorRadius = minorRadius;
+            this.majorRadius = majorRadius;
+        }
+        protected EllipseFeature(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected EllipseFeature(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            position.read();
+            rotation = backing.getDouble(8);
+            minorRadius = backing.getDouble(16);
+            majorRadius = backing.getDouble(24);
+        }
+        public void write() {
+            position.write();
+            backing.putDouble(8, rotation);
+            backing.putDouble(16, minorRadius);
+            backing.putDouble(24, majorRadius);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class CircleFeature extends DisposedStruct {
+        public PointFloat position; // The location of the center of the circle.
+        public double radius; // The radius of the circle.
+
+        private void init() {
+            position = new PointFloat(backing, 0);
+        }
+        public CircleFeature() {
+            super(16);
+            init();
+        }
+        public CircleFeature(PointFloat position, double radius) {
+            super(16);
+            this.position = position;
+            this.radius = radius;
+        }
+        protected CircleFeature(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected CircleFeature(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            position.read();
+            radius = backing.getDouble(8);
+        }
+        public void write() {
+            position.write();
+            backing.putDouble(8, radius);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class ConstCurveFeature extends DisposedStruct {
+        public PointFloat position; // The center of the circle that this constant curve lies upon.
+        public double radius; // The radius of the circle that this constant curve lies upon.
+        public double startAngle; // When traveling along the constant curve from one endpoint to the next in a counterclockwise manner, this is the angular component of the vector originating at the center of the constant curve and pointing towards the first endpoint of the constant curve.
+        public double endAngle; // When traveling along the constant curve from one endpoint to the next in a counterclockwise manner, this is the angular component of the vector originating at the center of the constant curve and pointing towards the second endpoint of the constant curve.
+
+        private void init() {
+            position = new PointFloat(backing, 0);
+        }
+        public ConstCurveFeature() {
+            super(32);
+            init();
+        }
+        public ConstCurveFeature(PointFloat position, double radius, double startAngle, double endAngle) {
+            super(32);
+            this.position = position;
+            this.radius = radius;
+            this.startAngle = startAngle;
+            this.endAngle = endAngle;
+        }
+        protected ConstCurveFeature(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected ConstCurveFeature(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            position.read();
+            radius = backing.getDouble(8);
+            startAngle = backing.getDouble(16);
+            endAngle = backing.getDouble(24);
+        }
+        public void write() {
+            position.write();
+            backing.putDouble(8, radius);
+            backing.putDouble(16, startAngle);
+            backing.putDouble(24, endAngle);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class RectangleFeature extends DisposedStruct {
+        public PointFloat position; // The center of the rectangle.
+        public PointFloat[] corner; // The four corners of the rectangle.
+        public double rotation; // The orientation of the rectangle with respect to the horizontal.
+        public double width; // The width of the rectangle.
+        public double height; // The height of the rectangle.
+
+        private void init() {
+            position = new PointFloat(backing, 0);
+            corner = new PointFloat[4];
+            
+            for (int i=0, off=8; i<4; i++, off += 8)
+                corner[i] = new PointFloat(backing, off);
+        }
+        public RectangleFeature() {
+            super(64);
+            init();
+        }
+        public RectangleFeature(PointFloat position, PointFloat[] corner, double rotation, double width, double height) {
+            super(64);
+            this.position = position;
+            this.corner = corner;
+            this.rotation = rotation;
+            this.width = width;
+            this.height = height;
+        }
+        protected RectangleFeature(ByteBuffer backing, int offset) {
+            super(backing, offset, 64);
+            init();
+        }
+        protected RectangleFeature(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 64);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 64);
+        }
+        public void read() {
+            position.read();
+            for (PointFloat it : corner) {
+                it.read();
+            }
+            rotation = backing.getDouble(40);
+            width = backing.getDouble(48);
+            height = backing.getDouble(56);
+        }
+        public void write() {
+            position.write();
+            for (PointFloat it : corner) {
+                it.write();
+            }
+            backing.putDouble(40, rotation);
+            backing.putDouble(48, width);
+            backing.putDouble(56, height);
+        }
+        public int size() {
+            return 64;
+        }
+    }
+
+    public static class LegFeature extends DisposedStruct {
+        public PointFloat position; // The location of the leg feature.
+        public PointFloat[] corner; // The four corners of the leg feature.
+        public double rotation; // The orientation of the leg with respect to the horizontal.
+        public double width; // The width of the leg.
+        public double height; // The height of the leg.
+
+        private void init() {
+            position = new PointFloat(backing, 0);
+            corner = new PointFloat[4];
+            
+            for (int i=0, off=8; i<4; i++, off += 8)
+                corner[i] = new PointFloat(backing, off);
+        }
+        public LegFeature() {
+            super(64);
+            init();
+        }
+        public LegFeature(PointFloat position, PointFloat[] corner, double rotation, double width, double height) {
+            super(64);
+            this.position = position;
+            this.corner = corner;
+            this.rotation = rotation;
+            this.width = width;
+            this.height = height;
+        }
+        protected LegFeature(ByteBuffer backing, int offset) {
+            super(backing, offset, 64);
+            init();
+        }
+        protected LegFeature(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 64);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 64);
+        }
+        public void read() {
+            position.read();
+            for (PointFloat it : corner) {
+                it.read();
+            }
+            rotation = backing.getDouble(40);
+            width = backing.getDouble(48);
+            height = backing.getDouble(56);
+        }
+        public void write() {
+            position.write();
+            for (PointFloat it : corner) {
+                it.write();
+            }
+            backing.putDouble(40, rotation);
+            backing.putDouble(48, width);
+            backing.putDouble(56, height);
+        }
+        public int size() {
+            return 64;
+        }
+    }
+
+    public static class CornerFeature extends DisposedStruct {
+        public PointFloat position; // The location of the corner feature.
+        public double rotation; // The angular component of the vector bisecting the corner from position.
+        public double enclosedAngle; // The measure of the enclosed angle of the corner.
+        public int isVirtual;
+
+        private void init() {
+            position = new PointFloat(backing, 0);
+        }
+        public CornerFeature() {
+            super(32);
+            init();
+        }
+        public CornerFeature(PointFloat position, double rotation, double enclosedAngle, int isVirtual) {
+            super(32);
+            this.position = position;
+            this.rotation = rotation;
+            this.enclosedAngle = enclosedAngle;
+            this.isVirtual = isVirtual;
+        }
+        protected CornerFeature(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected CornerFeature(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            position.read();
+            rotation = backing.getDouble(8);
+            enclosedAngle = backing.getDouble(16);
+            isVirtual = backing.getInt(24);
+        }
+        public void write() {
+            position.write();
+            backing.putDouble(8, rotation);
+            backing.putDouble(16, enclosedAngle);
+            backing.putInt(24, isVirtual);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class LineFeature extends DisposedStruct {
+        public PointFloat startPoint; // The starting point of the line.
+        public PointFloat endPoint; // The ending point of the line.
+        public double length; // The length of the line measured in pixels from the start point to the end point.
+        public double rotation; // The orientation of the line with respect to the horizontal.
+
+        private void init() {
+            startPoint = new PointFloat(backing, 0);
+            endPoint = new PointFloat(backing, 8);
+        }
+        public LineFeature() {
+            super(32);
+            init();
+        }
+        public LineFeature(PointFloat startPoint, PointFloat endPoint, double length, double rotation) {
+            super(32);
+            this.startPoint = startPoint;
+            this.endPoint = endPoint;
+            this.length = length;
+            this.rotation = rotation;
+        }
+        protected LineFeature(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected LineFeature(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            startPoint.read();
+            endPoint.read();
+            length = backing.getDouble(16);
+            rotation = backing.getDouble(24);
+        }
+        public void write() {
+            startPoint.write();
+            endPoint.write();
+            backing.putDouble(16, length);
+            backing.putDouble(24, rotation);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class ParallelLinePairFeature extends DisposedStruct {
+        public PointFloat firstStartPoint; // The starting point of the first line of the pair.
+        public PointFloat firstEndPoint; // The ending point of the first line of the pair.
+        public PointFloat secondStartPoint; // The starting point of the second line of the pair.
+        public PointFloat secondEndPoint; // The ending point of the second line of the pair.
+        public double rotation; // The orientation of the feature with respect to the horizontal.
+        public double distance; // The distance from the first line to the second line.
+
+        private void init() {
+            firstStartPoint = new PointFloat(backing, 0);
+            firstEndPoint = new PointFloat(backing, 8);
+            secondStartPoint = new PointFloat(backing, 16);
+            secondEndPoint = new PointFloat(backing, 24);
+        }
+        public ParallelLinePairFeature() {
+            super(48);
+            init();
+        }
+        public ParallelLinePairFeature(PointFloat firstStartPoint, PointFloat firstEndPoint, PointFloat secondStartPoint, PointFloat secondEndPoint, double rotation, double distance) {
+            super(48);
+            this.firstStartPoint = firstStartPoint;
+            this.firstEndPoint = firstEndPoint;
+            this.secondStartPoint = secondStartPoint;
+            this.secondEndPoint = secondEndPoint;
+            this.rotation = rotation;
+            this.distance = distance;
+        }
+        protected ParallelLinePairFeature(ByteBuffer backing, int offset) {
+            super(backing, offset, 48);
+            init();
+        }
+        protected ParallelLinePairFeature(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 48);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 48);
+        }
+        public void read() {
+            firstStartPoint.read();
+            firstEndPoint.read();
+            secondStartPoint.read();
+            secondEndPoint.read();
+            rotation = backing.getDouble(32);
+            distance = backing.getDouble(40);
+        }
+        public void write() {
+            firstStartPoint.write();
+            firstEndPoint.write();
+            secondStartPoint.write();
+            secondEndPoint.write();
+            backing.putDouble(32, rotation);
+            backing.putDouble(40, distance);
+        }
+        public int size() {
+            return 48;
+        }
+    }
+
+    public static class PairOfParallelLinePairsFeature extends DisposedStruct {
+        public ParallelLinePairFeature firstParallelLinePair; // The first parallel line pair.
+        public ParallelLinePairFeature secondParallelLinePair; // The second parallel line pair.
+        public double rotation; // The orientation of the feature with respect to the horizontal.
+        public double distance; // The distance from the midline of the first parallel line pair to the midline of the second parallel line pair.
+
+        private void init() {
+            firstParallelLinePair = new ParallelLinePairFeature(backing, 0);
+            secondParallelLinePair = new ParallelLinePairFeature(backing, 48);
+        }
+        public PairOfParallelLinePairsFeature() {
+            super(112);
+            init();
+        }
+        public PairOfParallelLinePairsFeature(ParallelLinePairFeature firstParallelLinePair, ParallelLinePairFeature secondParallelLinePair, double rotation, double distance) {
+            super(112);
+            this.firstParallelLinePair = firstParallelLinePair;
+            this.secondParallelLinePair = secondParallelLinePair;
+            this.rotation = rotation;
+            this.distance = distance;
+        }
+        protected PairOfParallelLinePairsFeature(ByteBuffer backing, int offset) {
+            super(backing, offset, 112);
+            init();
+        }
+        protected PairOfParallelLinePairsFeature(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 112);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 112);
+        }
+        public void read() {
+            firstParallelLinePair.read();
+            secondParallelLinePair.read();
+            rotation = backing.getDouble(96);
+            distance = backing.getDouble(104);
+        }
+        public void write() {
+            firstParallelLinePair.write();
+            secondParallelLinePair.write();
+            backing.putDouble(96, rotation);
+            backing.putDouble(104, distance);
+        }
+        public int size() {
+            return 112;
+        }
+    }
+
+    public static class FeatureData extends DisposedStruct {
+        public FeatureType type; // An enumeration representing the type of the feature.
+        public PointFloat[] contourPoints; // A set of points describing the contour of the feature.
+        public CircleFeature circle; // A pointer to a CircleFeature.
+        public EllipseFeature ellipse; // A pointer to an EllipseFeature.
+        public ConstCurveFeature constCurve; // A pointer to a ConstCurveFeature.
+        public RectangleFeature rectangle; // A pointer to a RectangleFeature.
+        public LegFeature leg; // A pointer to a LegFeature.
+        public CornerFeature corner; // A pointer to a CornerFeature.
+        public ParallelLinePairFeature parallelLinePair; // A pointer to a ParallelLinePairFeature.
+        public PairOfParallelLinePairsFeature pairOfParallelLinePairs; // A pointer to a PairOfParallelLinePairsFeature.
+        public LineFeature line; // A pointer to a LineFeature.
+        public ClosedCurveFeature closedCurve; // A pointer to a ClosedCurveFeature.
+        private ByteBuffer contourPoints_buf;
+
+        private void init() {
+            contourPoints = new PointFloat[0];
+        }
+        public FeatureData() {
+            super(16);
+            init();
+        }
+        public FeatureData(FeatureType type, PointFloat[] contourPoints) {
+            super(16);
+            this.type = type;
+            this.contourPoints = contourPoints;
+        }
+        protected FeatureData(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected FeatureData(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            type = FeatureType.fromValue(backing.getInt(0));
+            int contourPoints_numContourPoints = backing.getInt(8);
+            long contourPoints_addr = getPointer(backing, 4);
+            contourPoints = new PointFloat[contourPoints_numContourPoints];
+            if (contourPoints_numContourPoints > 0 && contourPoints_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(contourPoints_addr, contourPoints_numContourPoints*8);
+                for (int i=0, off=0; i<contourPoints_numContourPoints; i++, off += 8) {
+                    contourPoints[i] = new PointFloat(bb, off);
+                    contourPoints[i].read();
+                }
+            }
+            if (type == FeatureType.CIRCLE_FEATURE) {
+                long circle_addr = getPointer(backing, 12);
+                if (circle_addr == 0)
+                    circle = null;
+                else
+                    circle = new CircleFeature(circle_addr, false);
+            }
+            if (type == FeatureType.ELLIPSE_FEATURE) {
+                long ellipse_addr = getPointer(backing, 12);
+                if (ellipse_addr == 0)
+                    ellipse = null;
+                else
+                    ellipse = new EllipseFeature(ellipse_addr, false);
+            }
+            if (type == FeatureType.CONST_CURVE_FEATURE) {
+                long constCurve_addr = getPointer(backing, 12);
+                if (constCurve_addr == 0)
+                    constCurve = null;
+                else
+                    constCurve = new ConstCurveFeature(constCurve_addr, false);
+            }
+            if (type == FeatureType.RECTANGLE_FEATURE) {
+                long rectangle_addr = getPointer(backing, 12);
+                if (rectangle_addr == 0)
+                    rectangle = null;
+                else
+                    rectangle = new RectangleFeature(rectangle_addr, false);
+            }
+            if (type == FeatureType.LEG_FEATURE) {
+                long leg_addr = getPointer(backing, 12);
+                if (leg_addr == 0)
+                    leg = null;
+                else
+                    leg = new LegFeature(leg_addr, false);
+            }
+            if (type == FeatureType.CORNER_FEATURE) {
+                long corner_addr = getPointer(backing, 12);
+                if (corner_addr == 0)
+                    corner = null;
+                else
+                    corner = new CornerFeature(corner_addr, false);
+            }
+            if (type == FeatureType.PARALLEL_LINE_PAIR_FEATURE) {
+                long parallelLinePair_addr = getPointer(backing, 12);
+                if (parallelLinePair_addr == 0)
+                    parallelLinePair = null;
+                else
+                    parallelLinePair = new ParallelLinePairFeature(parallelLinePair_addr, false);
+            }
+            if (type == FeatureType.PAIR_OF_PARALLEL_LINE_PAIRS_FEATURE) {
+                long pairOfParallelLinePairs_addr = getPointer(backing, 12);
+                if (pairOfParallelLinePairs_addr == 0)
+                    pairOfParallelLinePairs = null;
+                else
+                    pairOfParallelLinePairs = new PairOfParallelLinePairsFeature(pairOfParallelLinePairs_addr, false);
+            }
+            if (type == FeatureType.LINE_FEATURE) {
+                long line_addr = getPointer(backing, 12);
+                if (line_addr == 0)
+                    line = null;
+                else
+                    line = new LineFeature(line_addr, false);
+            }
+            if (type == FeatureType.CLOSED_CURVE_FEATURE) {
+                long closedCurve_addr = getPointer(backing, 12);
+                if (closedCurve_addr == 0)
+                    closedCurve = null;
+                else
+                    closedCurve = new ClosedCurveFeature(closedCurve_addr, false);
+            }
+        }
+        public void write() {
+            if (type != null)
+                backing.putInt(0, type.getValue());
+            contourPoints_buf = ByteBuffer.allocateDirect(contourPoints.length*8);
+            for (int i=0, off=0; i<contourPoints.length; i++, off += 8) {
+                contourPoints[i].setBuffer(contourPoints_buf, off);
+                contourPoints[i].write();
+            }
+            backing.putInt(8, contourPoints.length);
+            putPointer(backing, 4, contourPoints_buf);
+            if (type == FeatureType.CIRCLE_FEATURE) {
+                putPointer(backing, 12, circle);
+            }
+            if (type == FeatureType.ELLIPSE_FEATURE) {
+                putPointer(backing, 12, ellipse);
+            }
+            if (type == FeatureType.CONST_CURVE_FEATURE) {
+                putPointer(backing, 12, constCurve);
+            }
+            if (type == FeatureType.RECTANGLE_FEATURE) {
+                putPointer(backing, 12, rectangle);
+            }
+            if (type == FeatureType.LEG_FEATURE) {
+                putPointer(backing, 12, leg);
+            }
+            if (type == FeatureType.CORNER_FEATURE) {
+                putPointer(backing, 12, corner);
+            }
+            if (type == FeatureType.PARALLEL_LINE_PAIR_FEATURE) {
+                putPointer(backing, 12, parallelLinePair);
+            }
+            if (type == FeatureType.PAIR_OF_PARALLEL_LINE_PAIRS_FEATURE) {
+                putPointer(backing, 12, pairOfParallelLinePairs);
+            }
+            if (type == FeatureType.LINE_FEATURE) {
+                putPointer(backing, 12, line);
+            }
+            if (type == FeatureType.CLOSED_CURVE_FEATURE) {
+                putPointer(backing, 12, closedCurve);
+            }
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class GeometricPatternMatch2 extends DisposedStruct {
+        public PointFloat position; // The location of the origin of the template in the match.
+        public float rotation; // The rotation of the match relative to the template image, in degrees.
+        public float scale; // The size of the match relative to the size of the template image, expressed as a percentage.
+        public float score; // The accuracy of the match.
+        public PointFloat[] corner; // An array of four points describing the rectangle surrounding the template image.
+        public int inverse; // This element is TRUE if the match is an inverse of the template image.
+        public float occlusion; // The percentage of the match that is occluded.
+        public float templateMatchCurveScore; // The accuracy of the match obtained by comparing the template curves to the curves in the match region.
+        public float matchTemplateCurveScore; // The accuracy of the match obtained by comparing the curves in the match region to the template curves.
+        public float correlationScore; // The accuracy of the match obtained by comparing the template image to the match region using a correlation metric that compares the two regions as a function of their pixel values.
+        public String label; // The label corresponding to this match when the match is returned by imaqMatchMultipleGeometricPatterns().
+        public FeatureData[] featureData; // The features used in this match.
+        public PointFloat calibratedPosition; // The location of the origin of the template in the match.
+        public float calibratedRotation; // The rotation of the match relative to the template image, in degrees.
+        public PointFloat[] calibratedCorner; // An array of four points describing the rectangle surrounding the template image.
+        private ByteBuffer featureData_buf;
+
+        private void init() {
+            position = new PointFloat(backing, 0);
+            corner = new PointFloat[4];
+            
+            for (int i=0, off=20; i<4; i++, off += 8)
+                corner[i] = new PointFloat(backing, off);
+            featureData = new FeatureData[0];
+            calibratedPosition = new PointFloat(backing, 336);
+            calibratedCorner = new PointFloat[4];
+            
+            for (int i=0, off=348; i<4; i++, off += 8)
+                calibratedCorner[i] = new PointFloat(backing, off);
+        }
+        public GeometricPatternMatch2() {
+            super(380);
+            init();
+        }
+        public GeometricPatternMatch2(PointFloat position, double rotation, double scale, double score, PointFloat[] corner, int inverse, double occlusion, double templateMatchCurveScore, double matchTemplateCurveScore, double correlationScore, String label, FeatureData[] featureData, PointFloat calibratedPosition, double calibratedRotation, PointFloat[] calibratedCorner) {
+            super(380);
+            this.position = position;
+            this.rotation = (float)rotation;
+            this.scale = (float)scale;
+            this.score = (float)score;
+            this.corner = corner;
+            this.inverse = inverse;
+            this.occlusion = (float)occlusion;
+            this.templateMatchCurveScore = (float)templateMatchCurveScore;
+            this.matchTemplateCurveScore = (float)matchTemplateCurveScore;
+            this.correlationScore = (float)correlationScore;
+            this.label = label;
+            this.featureData = featureData;
+            this.calibratedPosition = calibratedPosition;
+            this.calibratedRotation = (float)calibratedRotation;
+            this.calibratedCorner = calibratedCorner;
+        }
+        protected GeometricPatternMatch2(ByteBuffer backing, int offset) {
+            super(backing, offset, 380);
+            init();
+        }
+        protected GeometricPatternMatch2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 380);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 380);
+        }
+        public void read() {
+            position.read();
+            rotation = backing.getFloat(8);
+            scale = backing.getFloat(12);
+            score = backing.getFloat(16);
+            for (PointFloat it : corner) {
+                it.read();
+            }
+            inverse = backing.getInt(52);
+            occlusion = backing.getFloat(56);
+            templateMatchCurveScore = backing.getFloat(60);
+            matchTemplateCurveScore = backing.getFloat(64);
+            correlationScore = backing.getFloat(68);
+            {
+                byte[] bytes = new byte[256];
+                getBytes(backing, bytes, 72, 256);
+                int len;
+                for (len=0; len<bytes.length && bytes[len] != 0; len++) {}
+                try {
+                    label = new String(bytes, 0, len, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    label = "";
+                }
+            }
+            int featureData_numFeatureData = backing.getInt(332);
+            long featureData_addr = getPointer(backing, 328);
+            featureData = new FeatureData[featureData_numFeatureData];
+            if (featureData_numFeatureData > 0 && featureData_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(featureData_addr, featureData_numFeatureData*16);
+                for (int i=0, off=0; i<featureData_numFeatureData; i++, off += 16) {
+                    featureData[i] = new FeatureData(bb, off);
+                    featureData[i].read();
+                }
+            }
+            calibratedPosition.read();
+            calibratedRotation = backing.getFloat(344);
+            for (PointFloat it : calibratedCorner) {
+                it.read();
+            }
+        }
+        public void write() {
+            position.write();
+            backing.putFloat(8, rotation);
+            backing.putFloat(12, scale);
+            backing.putFloat(16, score);
+            for (PointFloat it : corner) {
+                it.write();
+            }
+            backing.putInt(52, inverse);
+            backing.putFloat(56, occlusion);
+            backing.putFloat(60, templateMatchCurveScore);
+            backing.putFloat(64, matchTemplateCurveScore);
+            backing.putFloat(68, correlationScore);
+            if (label != null) {
+                byte[] bytes;
+                try {
+                    bytes = label.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    bytes = new byte[0];
+                }
+                putBytes(backing, bytes, 72, bytes.length);
+                for (int i=bytes.length; i<256; i++)
+                    backing.put(i, (byte)0); // fill with zero
+            }
+            featureData_buf = ByteBuffer.allocateDirect(featureData.length*16);
+            for (int i=0, off=0; i<featureData.length; i++, off += 16) {
+                featureData[i].setBuffer(featureData_buf, off);
+                featureData[i].write();
+            }
+            backing.putInt(332, featureData.length);
+            putPointer(backing, 328, featureData_buf);
+            calibratedPosition.write();
+            backing.putFloat(344, calibratedRotation);
+            for (PointFloat it : calibratedCorner) {
+                it.write();
+            }
+        }
+        public int size() {
+            return 380;
+        }
+    }
+
+    public static class ClosedCurveFeature extends DisposedStruct {
+        public PointFloat position; // The center of the closed curve feature.
+        public double arcLength; // The arc length of the closed curve feature.
+
+        private void init() {
+            position = new PointFloat(backing, 0);
+        }
+        public ClosedCurveFeature() {
+            super(16);
+            init();
+        }
+        public ClosedCurveFeature(PointFloat position, double arcLength) {
+            super(16);
+            this.position = position;
+            this.arcLength = arcLength;
+        }
+        protected ClosedCurveFeature(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected ClosedCurveFeature(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            position.read();
+            arcLength = backing.getDouble(8);
+        }
+        public void write() {
+            position.write();
+            backing.putDouble(8, arcLength);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class LineMatch extends DisposedStruct {
+        public PointFloat startPoint; // The starting point of the matched line.
+        public PointFloat endPoint; // The ending point of the matched line.
+        public double length; // The length of the line measured in pixels from the start point to the end point.
+        public double rotation; // The orientation of the matched line.
+        public double score; // The score of the matched line.
+
+        private void init() {
+            startPoint = new PointFloat(backing, 0);
+            endPoint = new PointFloat(backing, 8);
+        }
+        public LineMatch() {
+            super(40);
+            init();
+        }
+        public LineMatch(PointFloat startPoint, PointFloat endPoint, double length, double rotation, double score) {
+            super(40);
+            this.startPoint = startPoint;
+            this.endPoint = endPoint;
+            this.length = length;
+            this.rotation = rotation;
+            this.score = score;
+        }
+        protected LineMatch(ByteBuffer backing, int offset) {
+            super(backing, offset, 40);
+            init();
+        }
+        protected LineMatch(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 40);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 40);
+        }
+        public void read() {
+            startPoint.read();
+            endPoint.read();
+            length = backing.getDouble(16);
+            rotation = backing.getDouble(24);
+            score = backing.getDouble(32);
+        }
+        public void write() {
+            startPoint.write();
+            endPoint.write();
+            backing.putDouble(16, length);
+            backing.putDouble(24, rotation);
+            backing.putDouble(32, score);
+        }
+        public int size() {
+            return 40;
+        }
+    }
+
+    public static class LineDescriptor extends DisposedStruct {
+        public double minLength; // Specifies the minimum length of a line the function will return.
+        public double maxLength; // Specifies the maximum length of a line the function will return.
+
+        private void init() {
+            
+        }
+        public LineDescriptor() {
+            super(16);
+            init();
+        }
+        public LineDescriptor(double minLength, double maxLength) {
+            super(16);
+            this.minLength = minLength;
+            this.maxLength = maxLength;
+        }
+        protected LineDescriptor(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected LineDescriptor(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            minLength = backing.getDouble(0);
+            maxLength = backing.getDouble(8);
+        }
+        public void write() {
+            backing.putDouble(0, minLength);
+            backing.putDouble(8, maxLength);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class RectangleDescriptor extends DisposedStruct {
+        public double minWidth; // Specifies the minimum width of a rectangle the algorithm will return.
+        public double maxWidth; // Specifies the maximum width of a rectangle the algorithm will return.
+        public double minHeight; // Specifies the minimum height of a rectangle the algorithm will return.
+        public double maxHeight; // Specifies the maximum height of a rectangle the algorithm will return.
+
+        private void init() {
+            
+        }
+        public RectangleDescriptor() {
+            super(32);
+            init();
+        }
+        public RectangleDescriptor(double minWidth, double maxWidth, double minHeight, double maxHeight) {
+            super(32);
+            this.minWidth = minWidth;
+            this.maxWidth = maxWidth;
+            this.minHeight = minHeight;
+            this.maxHeight = maxHeight;
+        }
+        protected RectangleDescriptor(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected RectangleDescriptor(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            minWidth = backing.getDouble(0);
+            maxWidth = backing.getDouble(8);
+            minHeight = backing.getDouble(16);
+            maxHeight = backing.getDouble(24);
+        }
+        public void write() {
+            backing.putDouble(0, minWidth);
+            backing.putDouble(8, maxWidth);
+            backing.putDouble(16, minHeight);
+            backing.putDouble(24, maxHeight);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class RectangleMatch extends DisposedStruct {
+        public PointFloat[] corner; // The corners of the matched rectangle.
+        public double rotation; // The orientation of the matched rectangle.
+        public double width; // The width of the matched rectangle.
+        public double height; // The height of the matched rectangle.
+        public double score; // The score of the matched rectangle.
+
+        private void init() {
+            corner = new PointFloat[4];
+            
+            for (int i=0, off=0; i<4; i++, off += 8)
+                corner[i] = new PointFloat(backing, off);
+        }
+        public RectangleMatch() {
+            super(64);
+            init();
+        }
+        public RectangleMatch(PointFloat[] corner, double rotation, double width, double height, double score) {
+            super(64);
+            this.corner = corner;
+            this.rotation = rotation;
+            this.width = width;
+            this.height = height;
+            this.score = score;
+        }
+        protected RectangleMatch(ByteBuffer backing, int offset) {
+            super(backing, offset, 64);
+            init();
+        }
+        protected RectangleMatch(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 64);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 64);
+        }
+        public void read() {
+            for (PointFloat it : corner) {
+                it.read();
+            }
+            rotation = backing.getDouble(32);
+            width = backing.getDouble(40);
+            height = backing.getDouble(48);
+            score = backing.getDouble(56);
+        }
+        public void write() {
+            for (PointFloat it : corner) {
+                it.write();
+            }
+            backing.putDouble(32, rotation);
+            backing.putDouble(40, width);
+            backing.putDouble(48, height);
+            backing.putDouble(56, score);
+        }
+        public int size() {
+            return 64;
+        }
+    }
+
+    public static class EllipseDescriptor extends DisposedStruct {
+        public double minMajorRadius; // Specifies the minimum length of the semi-major axis of an ellipse the function will return.
+        public double maxMajorRadius; // Specifies the maximum length of the semi-major axis of an ellipse the function will return.
+        public double minMinorRadius; // Specifies the minimum length of the semi-minor axis of an ellipse the function will return.
+        public double maxMinorRadius; // Specifies the maximum length of the semi-minor axis of an ellipse the function will return.
+
+        private void init() {
+            
+        }
+        public EllipseDescriptor() {
+            super(32);
+            init();
+        }
+        public EllipseDescriptor(double minMajorRadius, double maxMajorRadius, double minMinorRadius, double maxMinorRadius) {
+            super(32);
+            this.minMajorRadius = minMajorRadius;
+            this.maxMajorRadius = maxMajorRadius;
+            this.minMinorRadius = minMinorRadius;
+            this.maxMinorRadius = maxMinorRadius;
+        }
+        protected EllipseDescriptor(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected EllipseDescriptor(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            minMajorRadius = backing.getDouble(0);
+            maxMajorRadius = backing.getDouble(8);
+            minMinorRadius = backing.getDouble(16);
+            maxMinorRadius = backing.getDouble(24);
+        }
+        public void write() {
+            backing.putDouble(0, minMajorRadius);
+            backing.putDouble(8, maxMajorRadius);
+            backing.putDouble(16, minMinorRadius);
+            backing.putDouble(24, maxMinorRadius);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class EllipseMatch extends DisposedStruct {
+        public PointFloat position; // The location of the center of the matched ellipse.
+        public double rotation; // The orientation of the matched ellipse.
+        public double majorRadius; // The length of the semi-major axis of the matched ellipse.
+        public double minorRadius; // The length of the semi-minor axis of the matched ellipse.
+        public double score; // The score of the matched ellipse.
+
+        private void init() {
+            position = new PointFloat(backing, 0);
+        }
+        public EllipseMatch() {
+            super(40);
+            init();
+        }
+        public EllipseMatch(PointFloat position, double rotation, double majorRadius, double minorRadius, double score) {
+            super(40);
+            this.position = position;
+            this.rotation = rotation;
+            this.majorRadius = majorRadius;
+            this.minorRadius = minorRadius;
+            this.score = score;
+        }
+        protected EllipseMatch(ByteBuffer backing, int offset) {
+            super(backing, offset, 40);
+            init();
+        }
+        protected EllipseMatch(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 40);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 40);
+        }
+        public void read() {
+            position.read();
+            rotation = backing.getDouble(8);
+            majorRadius = backing.getDouble(16);
+            minorRadius = backing.getDouble(24);
+            score = backing.getDouble(32);
+        }
+        public void write() {
+            position.write();
+            backing.putDouble(8, rotation);
+            backing.putDouble(16, majorRadius);
+            backing.putDouble(24, minorRadius);
+            backing.putDouble(32, score);
+        }
+        public int size() {
+            return 40;
+        }
+    }
+
+    public static class CircleMatch extends DisposedStruct {
+        public PointFloat position; // The location of the center of the matched circle.
+        public double radius; // The radius of the matched circle.
+        public double score; // The score of the matched circle.
+
+        private void init() {
+            position = new PointFloat(backing, 0);
+        }
+        public CircleMatch() {
+            super(24);
+            init();
+        }
+        public CircleMatch(PointFloat position, double radius, double score) {
+            super(24);
+            this.position = position;
+            this.radius = radius;
+            this.score = score;
+        }
+        protected CircleMatch(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected CircleMatch(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            position.read();
+            radius = backing.getDouble(8);
+            score = backing.getDouble(16);
+        }
+        public void write() {
+            position.write();
+            backing.putDouble(8, radius);
+            backing.putDouble(16, score);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class CircleDescriptor extends DisposedStruct {
+        public double minRadius; // Specifies the minimum radius of a circle the function will return.
+        public double maxRadius; // Specifies the maximum radius of a circle the function will return.
+
+        private void init() {
+            
+        }
+        public CircleDescriptor() {
+            super(16);
+            init();
+        }
+        public CircleDescriptor(double minRadius, double maxRadius) {
+            super(16);
+            this.minRadius = minRadius;
+            this.maxRadius = maxRadius;
+        }
+        protected CircleDescriptor(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected CircleDescriptor(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            minRadius = backing.getDouble(0);
+            maxRadius = backing.getDouble(8);
+        }
+        public void write() {
+            backing.putDouble(0, minRadius);
+            backing.putDouble(8, maxRadius);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class ShapeDetectionOptions extends DisposedStruct {
+        public int mode; // Specifies the method used when looking for the shape in the image.
+        public RangeFloat[] angleRanges; // An array of angle ranges, in degrees, where each range specifies how much you expect the shape to be rotated in the image.
+        public RangeFloat scaleRange; // A range that specifies the sizes of the shapes you expect to be in the image, expressed as a ratio percentage representing the size of the pattern in the image divided by size of the original pattern multiplied by 100.
+        public double minMatchScore;
+        private ByteBuffer angleRanges_buf;
+
+        private void init() {
+            angleRanges = new RangeFloat[0];
+            scaleRange = new RangeFloat(backing, 12);
+        }
+        public ShapeDetectionOptions() {
+            super(32);
+            init();
+        }
+        public ShapeDetectionOptions(int mode, RangeFloat[] angleRanges, RangeFloat scaleRange, double minMatchScore) {
+            super(32);
+            this.mode = mode;
+            this.angleRanges = angleRanges;
+            this.scaleRange = scaleRange;
+            this.minMatchScore = minMatchScore;
+        }
+        protected ShapeDetectionOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected ShapeDetectionOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            mode = backing.getInt(0);
+            int angleRanges_numAngleRanges = backing.getInt(8);
+            long angleRanges_addr = getPointer(backing, 4);
+            angleRanges = new RangeFloat[angleRanges_numAngleRanges];
+            if (angleRanges_numAngleRanges > 0 && angleRanges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(angleRanges_addr, angleRanges_numAngleRanges*8);
+                for (int i=0, off=0; i<angleRanges_numAngleRanges; i++, off += 8) {
+                    angleRanges[i] = new RangeFloat(bb, off);
+                    angleRanges[i].read();
+                }
+            }
+            scaleRange.read();
+            minMatchScore = backing.getDouble(24);
+        }
+        public void write() {
+            backing.putInt(0, mode);
+            angleRanges_buf = ByteBuffer.allocateDirect(angleRanges.length*8);
+            for (int i=0, off=0; i<angleRanges.length; i++, off += 8) {
+                angleRanges[i].setBuffer(angleRanges_buf, off);
+                angleRanges[i].write();
+            }
+            backing.putInt(8, angleRanges.length);
+            putPointer(backing, 4, angleRanges_buf);
+            scaleRange.write();
+            backing.putDouble(24, minMatchScore);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class Curve extends DisposedStruct {
+        public PointFloat[] points; // The points on the curve.
+        public int closed; // This element is TRUE if the curve is closed and FALSE if the curve is open.
+        public double curveLength; // The length of the curve.
+        public double minEdgeStrength; // The lowest edge strength detected on the curve.
+        public double maxEdgeStrength; // The highest edge strength detected on the curve.
+        public double averageEdgeStrength; // The average of all edge strengths detected on the curve.
+        private ByteBuffer points_buf;
+
+        private void init() {
+            points = new PointFloat[0];
+        }
+        public Curve() {
+            super(48);
+            init();
+        }
+        public Curve(PointFloat[] points, int closed, double curveLength, double minEdgeStrength, double maxEdgeStrength, double averageEdgeStrength) {
+            super(48);
+            this.points = points;
+            this.closed = closed;
+            this.curveLength = curveLength;
+            this.minEdgeStrength = minEdgeStrength;
+            this.maxEdgeStrength = maxEdgeStrength;
+            this.averageEdgeStrength = averageEdgeStrength;
+        }
+        protected Curve(ByteBuffer backing, int offset) {
+            super(backing, offset, 48);
+            init();
+        }
+        protected Curve(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 48);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 48);
+        }
+        public void read() {
+            int points_numPoints = backing.getInt(4);
+            long points_addr = getPointer(backing, 0);
+            points = new PointFloat[points_numPoints];
+            if (points_numPoints > 0 && points_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(points_addr, points_numPoints*8);
+                for (int i=0, off=0; i<points_numPoints; i++, off += 8) {
+                    points[i] = new PointFloat(bb, off);
+                    points[i].read();
+                }
+            }
+            closed = backing.getInt(8);
+            curveLength = backing.getDouble(16);
+            minEdgeStrength = backing.getDouble(24);
+            maxEdgeStrength = backing.getDouble(32);
+            averageEdgeStrength = backing.getDouble(40);
+        }
+        public void write() {
+            points_buf = ByteBuffer.allocateDirect(points.length*8);
+            for (int i=0, off=0; i<points.length; i++, off += 8) {
+                points[i].setBuffer(points_buf, off);
+                points[i].write();
+            }
+            backing.putInt(4, points.length);
+            putPointer(backing, 0, points_buf);
+            backing.putInt(8, closed);
+            backing.putDouble(16, curveLength);
+            backing.putDouble(24, minEdgeStrength);
+            backing.putDouble(32, maxEdgeStrength);
+            backing.putDouble(40, averageEdgeStrength);
+        }
+        public int size() {
+            return 48;
+        }
+    }
+
+    public static class CurveOptions extends DisposedStruct {
+        public ExtractionMode extractionMode; // Specifies the method the function uses to identify curves in the image.
+        public int threshold; // Specifies the minimum contrast a seed point must have in order to begin a curve.
+        public EdgeFilterSize filterSize; // Specifies the width of the edge filter the function uses to identify curves in the image.
+        public int minLength; // Specifies the length, in pixels, of the smallest curve the function will extract.
+        public int rowStepSize; // Specifies the distance, in the y direction, between lines the function inspects for curve seed points.
+        public int columnStepSize; // Specifies the distance, in the x direction, between columns the function inspects for curve seed points.
+        public int maxEndPointGap; // Specifies the maximum gap, in pixels, between the endpoints of a curve that the function identifies as a closed curve.
+        public int onlyClosed; // Set this element to TRUE to specify that the function should only identify closed curves in the image.
+        public int subpixelAccuracy; // Set this element to TRUE to specify that the function identifies the location of curves with subpixel accuracy by interpolating between points to find the crossing of threshold.
+
+        private void init() {
+            
+        }
+        public CurveOptions() {
+            super(36);
+            init();
+        }
+        public CurveOptions(ExtractionMode extractionMode, int threshold, EdgeFilterSize filterSize, int minLength, int rowStepSize, int columnStepSize, int maxEndPointGap, int onlyClosed, int subpixelAccuracy) {
+            super(36);
+            this.extractionMode = extractionMode;
+            this.threshold = threshold;
+            this.filterSize = filterSize;
+            this.minLength = minLength;
+            this.rowStepSize = rowStepSize;
+            this.columnStepSize = columnStepSize;
+            this.maxEndPointGap = maxEndPointGap;
+            this.onlyClosed = onlyClosed;
+            this.subpixelAccuracy = subpixelAccuracy;
+        }
+        protected CurveOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 36);
+            init();
+        }
+        protected CurveOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 36);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 36);
+        }
+        public void read() {
+            extractionMode = ExtractionMode.fromValue(backing.getInt(0));
+            threshold = backing.getInt(4);
+            filterSize = EdgeFilterSize.fromValue(backing.getInt(8));
+            minLength = backing.getInt(12);
+            rowStepSize = backing.getInt(16);
+            columnStepSize = backing.getInt(20);
+            maxEndPointGap = backing.getInt(24);
+            onlyClosed = backing.getInt(28);
+            subpixelAccuracy = backing.getInt(32);
+        }
+        public void write() {
+            if (extractionMode != null)
+                backing.putInt(0, extractionMode.getValue());
+            backing.putInt(4, threshold);
+            if (filterSize != null)
+                backing.putInt(8, filterSize.getValue());
+            backing.putInt(12, minLength);
+            backing.putInt(16, rowStepSize);
+            backing.putInt(20, columnStepSize);
+            backing.putInt(24, maxEndPointGap);
+            backing.putInt(28, onlyClosed);
+            backing.putInt(32, subpixelAccuracy);
+        }
+        public int size() {
+            return 36;
+        }
+    }
+
+    public static class Barcode2DInfo extends DisposedStruct {
+        public Barcode2DType type; // The type of the 2D barcode.
+        public int binary; // This element is TRUE if the 2D barcode contains binary data and FALSE if the 2D barcode contains text data.
+        public byte[] data; // The data encoded in the 2D barcode.
+        public PointFloat[] boundingBox; // An array of four points describing the rectangle surrounding the 2D barcode.
+        public int numErrorsCorrected; // The number of errors the function corrected when decoding the 2D barcode.
+        public int numErasuresCorrected; // The number of erasures the function corrected when decoding the 2D barcode.
+        public int rows; // The number of rows in the 2D barcode.
+        public int columns; // The number of columns in the 2D barcode.
+        private ByteBuffer data_buf;
+
+        private void init() {
+            data = new byte[0];
+            boundingBox = new PointFloat[4];
+            
+            for (int i=0, off=16; i<4; i++, off += 8)
+                boundingBox[i] = new PointFloat(backing, off);
+        }
+        public Barcode2DInfo() {
+            super(64);
+            init();
+        }
+        public Barcode2DInfo(Barcode2DType type, int binary, byte[] data, PointFloat[] boundingBox, int numErrorsCorrected, int numErasuresCorrected, int rows, int columns) {
+            super(64);
+            this.type = type;
+            this.binary = binary;
+            this.data = data;
+            this.boundingBox = boundingBox;
+            this.numErrorsCorrected = numErrorsCorrected;
+            this.numErasuresCorrected = numErasuresCorrected;
+            this.rows = rows;
+            this.columns = columns;
+        }
+        protected Barcode2DInfo(ByteBuffer backing, int offset) {
+            super(backing, offset, 64);
+            init();
+        }
+        protected Barcode2DInfo(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 64);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 64);
+        }
+        public void read() {
+            type = Barcode2DType.fromValue(backing.getInt(0));
+            binary = backing.getInt(4);
+            int data_dataLength = backing.getInt(12);
+            long data_addr = getPointer(backing, 8);
+            data = new byte[data_dataLength];
+            if (data_dataLength > 0 && data_addr != 0) {
+                getBytes(newDirectByteBuffer(data_addr, data_dataLength), data, 0, data_dataLength);
+            }
+            for (PointFloat it : boundingBox) {
+                it.read();
+            }
+            numErrorsCorrected = backing.getInt(48);
+            numErasuresCorrected = backing.getInt(52);
+            rows = backing.getInt(56);
+            columns = backing.getInt(60);
+        }
+        public void write() {
+            if (type != null)
+                backing.putInt(0, type.getValue());
+            backing.putInt(4, binary);
+            data_buf = ByteBuffer.allocateDirect(data.length);
+            putBytes(data_buf, data, 0, data.length);
+            backing.putInt(12, data.length);
+            putPointer(backing, 8, data_buf);
+            for (PointFloat it : boundingBox) {
+                it.write();
+            }
+            backing.putInt(48, numErrorsCorrected);
+            backing.putInt(52, numErasuresCorrected);
+            backing.putInt(56, rows);
+            backing.putInt(60, columns);
+        }
+        public int size() {
+            return 64;
+        }
+    }
+
+    public static class DataMatrixOptions extends DisposedStruct {
+        public Barcode2DSearchMode searchMode; // Specifies the mode the function uses to search for barcodes.
+        public Barcode2DContrast contrast; // Specifies the contrast of the barcodes that the function searches for.
+        public Barcode2DCellShape cellShape; // Specifies the shape of the barcode data cells, which affects how the function decodes the barcode.
+        public Barcode2DShape barcodeShape; // Specifies the shape of the barcodes that the function searches for.
+        public DataMatrixSubtype subtype; // Specifies the Data Matrix subtypes of the barcodes that the function searches for.
+
+        private void init() {
+            
+        }
+        public DataMatrixOptions() {
+            super(20);
+            init();
+        }
+        public DataMatrixOptions(Barcode2DSearchMode searchMode, Barcode2DContrast contrast, Barcode2DCellShape cellShape, Barcode2DShape barcodeShape, DataMatrixSubtype subtype) {
+            super(20);
+            this.searchMode = searchMode;
+            this.contrast = contrast;
+            this.cellShape = cellShape;
+            this.barcodeShape = barcodeShape;
+            this.subtype = subtype;
+        }
+        protected DataMatrixOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 20);
+            init();
+        }
+        protected DataMatrixOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 20);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 20);
+        }
+        public void read() {
+            searchMode = Barcode2DSearchMode.fromValue(backing.getInt(0));
+            contrast = Barcode2DContrast.fromValue(backing.getInt(4));
+            cellShape = Barcode2DCellShape.fromValue(backing.getInt(8));
+            barcodeShape = Barcode2DShape.fromValue(backing.getInt(12));
+            subtype = DataMatrixSubtype.fromValue(backing.getInt(16));
+        }
+        public void write() {
+            if (searchMode != null)
+                backing.putInt(0, searchMode.getValue());
+            if (contrast != null)
+                backing.putInt(4, contrast.getValue());
+            if (cellShape != null)
+                backing.putInt(8, cellShape.getValue());
+            if (barcodeShape != null)
+                backing.putInt(12, barcodeShape.getValue());
+            if (subtype != null)
+                backing.putInt(16, subtype.getValue());
+        }
+        public int size() {
+            return 20;
+        }
+    }
+
+    public static class ClassifierAccuracyReport extends DisposedStruct {
+        public float accuracy; // The overall accuracy of the classifier, from 0 to 1000.
+        public String[] classNames; // The names of the classes of this classifier.
+        public double[] classAccuracy; // An array of size elements that contains accuracy information for each class.
+        public double[] classPredictiveValue; // An array containing size elements that contains the predictive values of each class.
+        private ByteBuffer classNames_buf;
+        private ByteBuffer[] classNames_bufs;
+        private ByteBuffer classAccuracy_buf;
+        private ByteBuffer classPredictiveValue_buf;
+
+        private void init() {
+            classNames = new String[0];
+            classAccuracy = new double[0];
+            classPredictiveValue = new double[0];
+        }
+        public ClassifierAccuracyReport() {
+            super(24);
+            init();
+        }
+        public ClassifierAccuracyReport(double accuracy, String[] classNames, double[] classAccuracy, double[] classPredictiveValue) {
+            super(24);
+            this.accuracy = (float)accuracy;
+            this.classNames = classNames;
+            this.classAccuracy = classAccuracy;
+            this.classPredictiveValue = classPredictiveValue;
+        }
+        protected ClassifierAccuracyReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected ClassifierAccuracyReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            accuracy = backing.getFloat(4);
+            int classNames_size = backing.getInt(0);
+            long classNames_addr = getPointer(backing, 8);
+            classNames = new String[classNames_size];
+            if (classNames_size > 0 && classNames_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(classNames_addr, classNames_size*4);
+                for (int i=0, off=0; i<classNames_size; i++, off += 4) {
+                    long addr = getPointer(bb, off);
+                    if (addr == 0)
+                        classNames[i] = null;
+                    else {
+                        ByteBuffer bb2 = newDirectByteBuffer(addr, 1000); // FIXME
+                        while (bb2.get() != 0) {}
+                        byte[] bytes = new byte[bb2.position()-1];
+                        bb2.rewind();
+                        getBytes(bb2, bytes, 0, bytes.length);
+                        try {
+                            classNames[i] = new String(bytes, "UTF-8");
+                        } catch (UnsupportedEncodingException e) {
+                            classNames[i] = "";
+                        }
+                    }
+                }
+            }
+            int classAccuracy_size = backing.getInt(0);
+            long classAccuracy_addr = getPointer(backing, 12);
+            classAccuracy = new double[classAccuracy_size];
+            if (classAccuracy_size > 0 && classAccuracy_addr != 0) {
+                newDirectByteBuffer(classAccuracy_addr, classAccuracy_size*8).asDoubleBuffer().get(classAccuracy);
+            }
+            int classPredictiveValue_size = backing.getInt(0);
+            long classPredictiveValue_addr = getPointer(backing, 16);
+            classPredictiveValue = new double[classPredictiveValue_size];
+            if (classPredictiveValue_size > 0 && classPredictiveValue_addr != 0) {
+                newDirectByteBuffer(classPredictiveValue_addr, classPredictiveValue_size*8).asDoubleBuffer().get(classPredictiveValue);
+            }
+        }
+        public void write() {
+            backing.putFloat(4, accuracy);
+            classNames_buf = ByteBuffer.allocateDirect(classNames.length*4);
+            for (int i=0, off=0; i<classNames.length; i++, off += 4) {
+                if (classNames[i] == null)
+                    putPointer(classNames_buf, off, 0);
+                else {
+                    byte[] bytes;
+                    try {
+                        bytes = classNames[i].getBytes("UTF-8");
+                    } catch (UnsupportedEncodingException e) {
+                        bytes = new byte[0];
+                    }
+                    classNames_bufs[i] = ByteBuffer.allocateDirect(bytes.length+1);
+                    putBytes(classNames_bufs[i], bytes, 0, bytes.length).put(bytes.length, (byte)0);
+                    putPointer(classNames_buf, off, getByteBufferAddress(classNames_bufs[i]));
+                }
+            }
+            backing.putInt(0, classNames.length);
+            putPointer(backing, 8, classNames_buf);
+            classAccuracy_buf = ByteBuffer.allocateDirect(classAccuracy.length*8);
+            classAccuracy_buf.asDoubleBuffer().put(classAccuracy).rewind();
+            backing.putInt(0, classAccuracy.length);
+            putPointer(backing, 12, classAccuracy_buf);
+            classPredictiveValue_buf = ByteBuffer.allocateDirect(classPredictiveValue.length*8);
+            classPredictiveValue_buf.asDoubleBuffer().put(classPredictiveValue).rewind();
+            backing.putInt(0, classPredictiveValue.length);
+            putPointer(backing, 16, classPredictiveValue_buf);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class NearestNeighborClassResult extends DisposedStruct {
+        public String className; // The name of the class.
+        public float standardDeviation; // The standard deviation of the members of this class.
+        public int count; // The number of samples in this class.
+        private ByteBuffer className_buf;
+
+        private void init() {
+            
+        }
+        public NearestNeighborClassResult() {
+            super(12);
+            init();
+        }
+        public NearestNeighborClassResult(String className, double standardDeviation, int count) {
+            super(12);
+            this.className = className;
+            this.standardDeviation = (float)standardDeviation;
+            this.count = count;
+        }
+        protected NearestNeighborClassResult(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected NearestNeighborClassResult(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            long className_addr = getPointer(backing, 0);
+            if (className_addr == 0)
+                className = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(className_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    className = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    className = "";
+                }
+            }
+            
+            standardDeviation = backing.getFloat(4);
+            count = backing.getInt(8);
+        }
+        public void write() {
+            if (className != null) {
+                byte[] className_bytes;
+                try {
+                    className_bytes = className.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    className_bytes = new byte[0];
+                }
+                className_buf = ByteBuffer.allocateDirect(className_bytes.length+1);
+                putBytes(className_buf, className_bytes, 0, className_bytes.length).put(className_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, className == null ? 0 : getByteBufferAddress(className_buf));
+            backing.putFloat(4, standardDeviation);
+            backing.putInt(8, count);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class NearestNeighborTrainingReport extends DisposedStruct {
+        public NearestNeighborClassResult[] allScores; // All classes and their scores.
+        private ByteBuffer allScores_buf;
+
+        private void init() {
+            allScores = new NearestNeighborClassResult[0];
+        }
+        public NearestNeighborTrainingReport() {
+            super(12);
+            init();
+        }
+        public NearestNeighborTrainingReport(NearestNeighborClassResult[] allScores) {
+            super(12);
+            this.allScores = allScores;
+        }
+        protected NearestNeighborTrainingReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected NearestNeighborTrainingReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            int allScores_allScoresSize = backing.getInt(8);
+            long allScores_addr = getPointer(backing, 4);
+            allScores = new NearestNeighborClassResult[allScores_allScoresSize];
+            if (allScores_allScoresSize > 0 && allScores_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(allScores_addr, allScores_allScoresSize*12);
+                for (int i=0, off=0; i<allScores_allScoresSize; i++, off += 12) {
+                    allScores[i] = new NearestNeighborClassResult(bb, off);
+                    allScores[i].read();
+                }
+            }
+        }
+        public void write() {
+            allScores_buf = ByteBuffer.allocateDirect(allScores.length*12);
+            for (int i=0, off=0; i<allScores.length; i++, off += 12) {
+                allScores[i].setBuffer(allScores_buf, off);
+                allScores[i].write();
+            }
+            backing.putInt(8, allScores.length);
+            putPointer(backing, 4, allScores_buf);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class ParticleClassifierPreprocessingOptions extends DisposedStruct {
+        public int manualThreshold; // Set this element to TRUE to specify the threshold range manually.
+        public RangeFloat manualThresholdRange; // If a manual threshold is being done, the range of pixels to keep.
+        public ThresholdMethod autoThresholdMethod; // If an automatic threshold is being done, the method used to calculate the threshold range.
+        public RangeFloat limits; // The limits on the automatic threshold range.
+        public ParticleType particleType; // Specifies what kind of particles to look for.
+        public int rejectBorder; // Set this element to TRUE to reject border particles.
+        public int numErosions; // The number of erosions to perform.
+
+        private void init() {
+            manualThresholdRange = new RangeFloat(backing, 4);
+            limits = new RangeFloat(backing, 16);
+        }
+        public ParticleClassifierPreprocessingOptions() {
+            super(36);
+            init();
+        }
+        public ParticleClassifierPreprocessingOptions(int manualThreshold, RangeFloat manualThresholdRange, ThresholdMethod autoThresholdMethod, RangeFloat limits, ParticleType particleType, int rejectBorder, int numErosions) {
+            super(36);
+            this.manualThreshold = manualThreshold;
+            this.manualThresholdRange = manualThresholdRange;
+            this.autoThresholdMethod = autoThresholdMethod;
+            this.limits = limits;
+            this.particleType = particleType;
+            this.rejectBorder = rejectBorder;
+            this.numErosions = numErosions;
+        }
+        protected ParticleClassifierPreprocessingOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 36);
+            init();
+        }
+        protected ParticleClassifierPreprocessingOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 36);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 36);
+        }
+        public void read() {
+            manualThreshold = backing.getInt(0);
+            manualThresholdRange.read();
+            autoThresholdMethod = ThresholdMethod.fromValue(backing.getInt(12));
+            limits.read();
+            particleType = ParticleType.fromValue(backing.getInt(24));
+            rejectBorder = backing.getInt(28);
+            numErosions = backing.getInt(32);
+        }
+        public void write() {
+            backing.putInt(0, manualThreshold);
+            manualThresholdRange.write();
+            if (autoThresholdMethod != null)
+                backing.putInt(12, autoThresholdMethod.getValue());
+            limits.write();
+            if (particleType != null)
+                backing.putInt(24, particleType.getValue());
+            backing.putInt(28, rejectBorder);
+            backing.putInt(32, numErosions);
+        }
+        public int size() {
+            return 36;
+        }
+    }
+
+    public static class ClassifierSampleInfo extends DisposedStruct {
+        public String className; // The name of the class this sample is in.
+        public double[] featureVector; // The feature vector of this sample, or NULL if this is not a custom classifier session.
+        public Image thumbnail; // A thumbnail image of this sample, or NULL if no image was specified.
+        private ByteBuffer className_buf;
+        private ByteBuffer featureVector_buf;
+
+        private void init() {
+            featureVector = new double[0];
+        }
+        public ClassifierSampleInfo() {
+            super(16);
+            init();
+        }
+        public ClassifierSampleInfo(String className, double[] featureVector, Image thumbnail) {
+            super(16);
+            this.className = className;
+            this.featureVector = featureVector;
+            this.thumbnail = thumbnail;
+        }
+        protected ClassifierSampleInfo(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected ClassifierSampleInfo(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            long className_addr = getPointer(backing, 0);
+            if (className_addr == 0)
+                className = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(className_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    className = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    className = "";
+                }
+            }
+            
+            int featureVector_featureVectorSize = backing.getInt(8);
+            long featureVector_addr = getPointer(backing, 4);
+            featureVector = new double[featureVector_featureVectorSize];
+            if (featureVector_featureVectorSize > 0 && featureVector_addr != 0) {
+                newDirectByteBuffer(featureVector_addr, featureVector_featureVectorSize*8).asDoubleBuffer().get(featureVector);
+            }
+            long thumbnail_addr = getPointer(backing, 12);
+            if (thumbnail_addr == 0)
+                thumbnail = null;
+            else
+                thumbnail = new Image(thumbnail_addr, false);
+        }
+        public void write() {
+            if (className != null) {
+                byte[] className_bytes;
+                try {
+                    className_bytes = className.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    className_bytes = new byte[0];
+                }
+                className_buf = ByteBuffer.allocateDirect(className_bytes.length+1);
+                putBytes(className_buf, className_bytes, 0, className_bytes.length).put(className_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, className == null ? 0 : getByteBufferAddress(className_buf));
+            featureVector_buf = ByteBuffer.allocateDirect(featureVector.length*8);
+            featureVector_buf.asDoubleBuffer().put(featureVector).rewind();
+            backing.putInt(8, featureVector.length);
+            putPointer(backing, 4, featureVector_buf);
+            putPointer(backing, 12, thumbnail);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class ClassScore extends DisposedStruct {
+        public String className; // The name of the class.
+        public float distance; // The distance from the item to this class.
+        private ByteBuffer className_buf;
+
+        private void init() {
+            
+        }
+        public ClassScore() {
+            super(8);
+            init();
+        }
+        public ClassScore(String className, double distance) {
+            super(8);
+            this.className = className;
+            this.distance = (float)distance;
+        }
+        protected ClassScore(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected ClassScore(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            long className_addr = getPointer(backing, 0);
+            if (className_addr == 0)
+                className = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(className_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    className = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    className = "";
+                }
+            }
+            
+            distance = backing.getFloat(4);
+        }
+        public void write() {
+            if (className != null) {
+                byte[] className_bytes;
+                try {
+                    className_bytes = className.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    className_bytes = new byte[0];
+                }
+                className_buf = ByteBuffer.allocateDirect(className_bytes.length+1);
+                putBytes(className_buf, className_bytes, 0, className_bytes.length).put(className_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, className == null ? 0 : getByteBufferAddress(className_buf));
+            backing.putFloat(4, distance);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class ClassifierReport extends DisposedStruct {
+        public String bestClassName; // The name of the best class for the sample.
+        public float classificationScore; // The similarity of the sample and the two closest classes in the classifier.
+        public float identificationScore; // The similarity of the sample and the assigned class.
+        public ClassScore[] allScores; // All classes and their scores.
+        private ByteBuffer bestClassName_buf;
+        private ByteBuffer allScores_buf;
+
+        private void init() {
+            allScores = new ClassScore[0];
+        }
+        public ClassifierReport() {
+            super(20);
+            init();
+        }
+        public ClassifierReport(String bestClassName, double classificationScore, double identificationScore, ClassScore[] allScores) {
+            super(20);
+            this.bestClassName = bestClassName;
+            this.classificationScore = (float)classificationScore;
+            this.identificationScore = (float)identificationScore;
+            this.allScores = allScores;
+        }
+        protected ClassifierReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 20);
+            init();
+        }
+        protected ClassifierReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 20);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 20);
+        }
+        public void read() {
+            long bestClassName_addr = getPointer(backing, 0);
+            if (bestClassName_addr == 0)
+                bestClassName = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(bestClassName_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    bestClassName = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    bestClassName = "";
+                }
+            }
+            
+            classificationScore = backing.getFloat(4);
+            identificationScore = backing.getFloat(8);
+            int allScores_allScoresSize = backing.getInt(16);
+            long allScores_addr = getPointer(backing, 12);
+            allScores = new ClassScore[allScores_allScoresSize];
+            if (allScores_allScoresSize > 0 && allScores_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(allScores_addr, allScores_allScoresSize*8);
+                for (int i=0, off=0; i<allScores_allScoresSize; i++, off += 8) {
+                    allScores[i] = new ClassScore(bb, off);
+                    allScores[i].read();
+                }
+            }
+        }
+        public void write() {
+            if (bestClassName != null) {
+                byte[] bestClassName_bytes;
+                try {
+                    bestClassName_bytes = bestClassName.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    bestClassName_bytes = new byte[0];
+                }
+                bestClassName_buf = ByteBuffer.allocateDirect(bestClassName_bytes.length+1);
+                putBytes(bestClassName_buf, bestClassName_bytes, 0, bestClassName_bytes.length).put(bestClassName_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, bestClassName == null ? 0 : getByteBufferAddress(bestClassName_buf));
+            backing.putFloat(4, classificationScore);
+            backing.putFloat(8, identificationScore);
+            allScores_buf = ByteBuffer.allocateDirect(allScores.length*8);
+            for (int i=0, off=0; i<allScores.length; i++, off += 8) {
+                allScores[i].setBuffer(allScores_buf, off);
+                allScores[i].write();
+            }
+            backing.putInt(16, allScores.length);
+            putPointer(backing, 12, allScores_buf);
+        }
+        public int size() {
+            return 20;
+        }
+    }
+
+    public static class NearestNeighborOptions extends DisposedStruct {
+        public NearestNeighborMethod method; // The method to use.
+        public NearestNeighborMetric metric; // The metric to use.
+        public int k; // The value of k, if the IMAQ_K_NEAREST_NEIGHBOR method is used.
+
+        private void init() {
+            
+        }
+        public NearestNeighborOptions() {
+            super(12);
+            init();
+        }
+        public NearestNeighborOptions(NearestNeighborMethod method, NearestNeighborMetric metric, int k) {
+            super(12);
+            this.method = method;
+            this.metric = metric;
+            this.k = k;
+        }
+        protected NearestNeighborOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected NearestNeighborOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            method = NearestNeighborMethod.fromValue(backing.getInt(0));
+            metric = NearestNeighborMetric.fromValue(backing.getInt(4));
+            k = backing.getInt(8);
+        }
+        public void write() {
+            if (method != null)
+                backing.putInt(0, method.getValue());
+            if (metric != null)
+                backing.putInt(4, metric.getValue());
+            backing.putInt(8, k);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class ParticleClassifierOptions extends DisposedStruct {
+        public float scaleDependence; // The relative importance of scale when classifying particles.
+        public float mirrorDependence; // The relative importance of mirror symmetry when classifying particles.
+
+        private void init() {
+            
+        }
+        public ParticleClassifierOptions() {
+            super(8);
+            init();
+        }
+        public ParticleClassifierOptions(double scaleDependence, double mirrorDependence) {
+            super(8);
+            this.scaleDependence = (float)scaleDependence;
+            this.mirrorDependence = (float)mirrorDependence;
+        }
+        protected ParticleClassifierOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected ParticleClassifierOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            scaleDependence = backing.getFloat(0);
+            mirrorDependence = backing.getFloat(4);
+        }
+        public void write() {
+            backing.putFloat(0, scaleDependence);
+            backing.putFloat(4, mirrorDependence);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class RGBU64Value extends DisposedStruct {
+        public int B; // The blue value of the color.
+        public int G; // The green value of the color.
+        public int R; // The red value of the color.
+        public int alpha; // The alpha value of the color, which represents extra information about a color image, such as gamma correction.
+
+        private void init() {
+            
+        }
+        public RGBU64Value() {
+            super(8);
+            init();
+        }
+        public RGBU64Value(int B, int G, int R, int alpha) {
+            super(8);
+            this.B = B;
+            this.G = G;
+            this.R = R;
+            this.alpha = alpha;
+        }
+        protected RGBU64Value(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected RGBU64Value(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            B = backing.getInt(0);
+            G = backing.getInt(2);
+            R = backing.getInt(4);
+            alpha = backing.getInt(6);
+        }
+        public void write() {
+            backing.putInt(0, B);
+            backing.putInt(2, G);
+            backing.putInt(4, R);
+            backing.putInt(6, alpha);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class GeometricPatternMatch extends DisposedStruct {
+        public PointFloat position; // The location of the origin of the template in the match.
+        public float rotation; // The rotation of the match relative to the template image, in degrees.
+        public float scale; // The size of the match relative to the size of the template image, expressed as a percentage.
+        public float score; // The accuracy of the match.
+        public PointFloat[] corner; // An array of four points describing the rectangle surrounding the template image.
+        public int inverse; // This element is TRUE if the match is an inverse of the template image.
+        public float occlusion; // The percentage of the match that is occluded.
+        public float templateMatchCurveScore; // The accuracy of the match obtained by comparing the template curves to the curves in the match region.
+        public float matchTemplateCurveScore; // The accuracy of the match obtained by comparing the curves in the match region to the template curves.
+        public float correlationScore; // The accuracy of the match obtained by comparing the template image to the match region using a correlation metric that compares the two regions as a function of their pixel values.
+
+        private void init() {
+            position = new PointFloat(backing, 0);
+            corner = new PointFloat[4];
+            
+            for (int i=0, off=20; i<4; i++, off += 8)
+                corner[i] = new PointFloat(backing, off);
+        }
+        public GeometricPatternMatch() {
+            super(72);
+            init();
+        }
+        public GeometricPatternMatch(PointFloat position, double rotation, double scale, double score, PointFloat[] corner, int inverse, double occlusion, double templateMatchCurveScore, double matchTemplateCurveScore, double correlationScore) {
+            super(72);
+            this.position = position;
+            this.rotation = (float)rotation;
+            this.scale = (float)scale;
+            this.score = (float)score;
+            this.corner = corner;
+            this.inverse = inverse;
+            this.occlusion = (float)occlusion;
+            this.templateMatchCurveScore = (float)templateMatchCurveScore;
+            this.matchTemplateCurveScore = (float)matchTemplateCurveScore;
+            this.correlationScore = (float)correlationScore;
+        }
+        protected GeometricPatternMatch(ByteBuffer backing, int offset) {
+            super(backing, offset, 72);
+            init();
+        }
+        protected GeometricPatternMatch(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 72);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 72);
+        }
+        public void read() {
+            position.read();
+            rotation = backing.getFloat(8);
+            scale = backing.getFloat(12);
+            score = backing.getFloat(16);
+            for (PointFloat it : corner) {
+                it.read();
+            }
+            inverse = backing.getInt(52);
+            occlusion = backing.getFloat(56);
+            templateMatchCurveScore = backing.getFloat(60);
+            matchTemplateCurveScore = backing.getFloat(64);
+            correlationScore = backing.getFloat(68);
+        }
+        public void write() {
+            position.write();
+            backing.putFloat(8, rotation);
+            backing.putFloat(12, scale);
+            backing.putFloat(16, score);
+            for (PointFloat it : corner) {
+                it.write();
+            }
+            backing.putInt(52, inverse);
+            backing.putFloat(56, occlusion);
+            backing.putFloat(60, templateMatchCurveScore);
+            backing.putFloat(64, matchTemplateCurveScore);
+            backing.putFloat(68, correlationScore);
+        }
+        public int size() {
+            return 72;
+        }
+    }
+
+    public static class MatchGeometricPatternAdvancedOptions extends DisposedStruct {
+        public int minFeaturesUsed; // Specifies the minimum number of features the function uses when matching.
+        public int maxFeaturesUsed; // Specifies the maximum number of features the function uses when matching.
+        public int subpixelIterations; // Specifies the maximum number of incremental improvements used to refine matches with subpixel information.
+        public double subpixelTolerance; // Specifies the maximum amount of change, in pixels, between consecutive incremental improvements in the match position before the function stops refining the match position.
+        public int initialMatchListLength; // Specifies the maximum size of the match list.
+        public int matchTemplateCurveScore; // Set this element to TRUE to specify that the function should calculate the match curve to template curve score and return it for each match result.
+        public int correlationScore; // Set this element to TRUE to specify that the function should calculate the correlation score and return it for each match result.
+        public double minMatchSeparationDistance; // Specifies the minimum separation distance, in pixels, between the origins of two matches that have unique positions.
+        public double minMatchSeparationAngle; // Specifies the minimum angular difference, in degrees, between two matches that have unique angles.
+        public double minMatchSeparationScale; // Specifies the minimum difference in scale, expressed as a percentage, between two matches that have unique scales.
+        public double maxMatchOverlap; // Specifies the maximum amount of overlap, expressed as a percentage, allowed between the bounding rectangles of two unique matches.
+        public int coarseResult; // Specifies whether you want the function to spend less time accurately estimating the location of a match.
+
+        private void init() {
+            
+        }
+        public MatchGeometricPatternAdvancedOptions() {
+            super(80);
+            init();
+        }
+        public MatchGeometricPatternAdvancedOptions(int minFeaturesUsed, int maxFeaturesUsed, int subpixelIterations, double subpixelTolerance, int initialMatchListLength, int matchTemplateCurveScore, int correlationScore, double minMatchSeparationDistance, double minMatchSeparationAngle, double minMatchSeparationScale, double maxMatchOverlap, int coarseResult) {
+            super(80);
+            this.minFeaturesUsed = minFeaturesUsed;
+            this.maxFeaturesUsed = maxFeaturesUsed;
+            this.subpixelIterations = subpixelIterations;
+            this.subpixelTolerance = subpixelTolerance;
+            this.initialMatchListLength = initialMatchListLength;
+            this.matchTemplateCurveScore = matchTemplateCurveScore;
+            this.correlationScore = correlationScore;
+            this.minMatchSeparationDistance = minMatchSeparationDistance;
+            this.minMatchSeparationAngle = minMatchSeparationAngle;
+            this.minMatchSeparationScale = minMatchSeparationScale;
+            this.maxMatchOverlap = maxMatchOverlap;
+            this.coarseResult = coarseResult;
+        }
+        protected MatchGeometricPatternAdvancedOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 80);
+            init();
+        }
+        protected MatchGeometricPatternAdvancedOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 80);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 80);
+        }
+        public void read() {
+            minFeaturesUsed = backing.getInt(0);
+            maxFeaturesUsed = backing.getInt(4);
+            subpixelIterations = backing.getInt(8);
+            subpixelTolerance = backing.getDouble(16);
+            initialMatchListLength = backing.getInt(24);
+            matchTemplateCurveScore = backing.getInt(28);
+            correlationScore = backing.getInt(32);
+            minMatchSeparationDistance = backing.getDouble(40);
+            minMatchSeparationAngle = backing.getDouble(48);
+            minMatchSeparationScale = backing.getDouble(56);
+            maxMatchOverlap = backing.getDouble(64);
+            coarseResult = backing.getInt(72);
+        }
+        public void write() {
+            backing.putInt(0, minFeaturesUsed);
+            backing.putInt(4, maxFeaturesUsed);
+            backing.putInt(8, subpixelIterations);
+            backing.putDouble(16, subpixelTolerance);
+            backing.putInt(24, initialMatchListLength);
+            backing.putInt(28, matchTemplateCurveScore);
+            backing.putInt(32, correlationScore);
+            backing.putDouble(40, minMatchSeparationDistance);
+            backing.putDouble(48, minMatchSeparationAngle);
+            backing.putDouble(56, minMatchSeparationScale);
+            backing.putDouble(64, maxMatchOverlap);
+            backing.putInt(72, coarseResult);
+        }
+        public int size() {
+            return 80;
+        }
+    }
+
+    public static class MatchGeometricPatternOptions extends DisposedStruct {
+        public int mode; // Specifies the method imaqMatchGeometricPattern() uses when looking for the pattern in the image.
+        public int subpixelAccuracy; // Set this element to TRUE to specify that the function should calculate match locations with subpixel accuracy.
+        public RangeFloat[] angleRanges; // An array of angle ranges, in degrees, where each range specifies how much you expect the template to be rotated in the image.
+        public RangeFloat scaleRange; // A range that specifies the sizes of the pattern you expect to be in the image, expressed as a ratio percentage representing the size of the pattern in the image divided by size of the original pattern multiplied by 100.
+        public RangeFloat occlusionRange; // A range that specifies the percentage of the pattern you expect to be occluded in the image.
+        public int numMatchesRequested; // Number of valid matches expected.
+        public float minMatchScore; // The minimum score a match can have for the function to consider the match valid.
+        private ByteBuffer angleRanges_buf;
+
+        private void init() {
+            angleRanges = new RangeFloat[0];
+            scaleRange = new RangeFloat(backing, 16);
+            occlusionRange = new RangeFloat(backing, 24);
+        }
+        public MatchGeometricPatternOptions() {
+            super(40);
+            init();
+        }
+        public MatchGeometricPatternOptions(int mode, int subpixelAccuracy, RangeFloat[] angleRanges, RangeFloat scaleRange, RangeFloat occlusionRange, int numMatchesRequested, double minMatchScore) {
+            super(40);
+            this.mode = mode;
+            this.subpixelAccuracy = subpixelAccuracy;
+            this.angleRanges = angleRanges;
+            this.scaleRange = scaleRange;
+            this.occlusionRange = occlusionRange;
+            this.numMatchesRequested = numMatchesRequested;
+            this.minMatchScore = (float)minMatchScore;
+        }
+        protected MatchGeometricPatternOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 40);
+            init();
+        }
+        protected MatchGeometricPatternOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 40);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 40);
+        }
+        public void read() {
+            mode = backing.getInt(0);
+            subpixelAccuracy = backing.getInt(4);
+            int angleRanges_numAngleRanges = backing.getInt(12);
+            long angleRanges_addr = getPointer(backing, 8);
+            angleRanges = new RangeFloat[angleRanges_numAngleRanges];
+            if (angleRanges_numAngleRanges > 0 && angleRanges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(angleRanges_addr, angleRanges_numAngleRanges*8);
+                for (int i=0, off=0; i<angleRanges_numAngleRanges; i++, off += 8) {
+                    angleRanges[i] = new RangeFloat(bb, off);
+                    angleRanges[i].read();
+                }
+            }
+            scaleRange.read();
+            occlusionRange.read();
+            numMatchesRequested = backing.getInt(32);
+            minMatchScore = backing.getFloat(36);
+        }
+        public void write() {
+            backing.putInt(0, mode);
+            backing.putInt(4, subpixelAccuracy);
+            angleRanges_buf = ByteBuffer.allocateDirect(angleRanges.length*8);
+            for (int i=0, off=0; i<angleRanges.length; i++, off += 8) {
+                angleRanges[i].setBuffer(angleRanges_buf, off);
+                angleRanges[i].write();
+            }
+            backing.putInt(12, angleRanges.length);
+            putPointer(backing, 8, angleRanges_buf);
+            scaleRange.write();
+            occlusionRange.write();
+            backing.putInt(32, numMatchesRequested);
+            backing.putFloat(36, minMatchScore);
+        }
+        public int size() {
+            return 40;
+        }
+    }
+
+    public static class LearnGeometricPatternAdvancedOptions extends DisposedStruct {
+        public int minRectLength; // Specifies the minimum length for each side of a rectangular feature.
+        public double minRectAspectRatio; // Specifies the minimum aspect ratio of a rectangular feature.
+        public int minRadius; // Specifies the minimum radius for a circular feature.
+        public int minLineLength; // Specifies the minimum length for a linear feature.
+        public double minFeatureStrength; // Specifies the minimum strength for a feature.
+        public int maxFeaturesUsed; // Specifies the maximum number of features the function uses when learning.
+        public int maxPixelDistanceFromLine; // Specifies the maximum number of pixels between an edge pixel and a linear feature for the function to consider that edge pixel as part of the linear feature.
+
+        private void init() {
+            
+        }
+        public LearnGeometricPatternAdvancedOptions() {
+            super(40);
+            init();
+        }
+        public LearnGeometricPatternAdvancedOptions(int minRectLength, double minRectAspectRatio, int minRadius, int minLineLength, double minFeatureStrength, int maxFeaturesUsed, int maxPixelDistanceFromLine) {
+            super(40);
+            this.minRectLength = minRectLength;
+            this.minRectAspectRatio = minRectAspectRatio;
+            this.minRadius = minRadius;
+            this.minLineLength = minLineLength;
+            this.minFeatureStrength = minFeatureStrength;
+            this.maxFeaturesUsed = maxFeaturesUsed;
+            this.maxPixelDistanceFromLine = maxPixelDistanceFromLine;
+        }
+        protected LearnGeometricPatternAdvancedOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 40);
+            init();
+        }
+        protected LearnGeometricPatternAdvancedOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 40);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 40);
+        }
+        public void read() {
+            minRectLength = backing.getInt(0);
+            minRectAspectRatio = backing.getDouble(8);
+            minRadius = backing.getInt(16);
+            minLineLength = backing.getInt(20);
+            minFeatureStrength = backing.getDouble(24);
+            maxFeaturesUsed = backing.getInt(32);
+            maxPixelDistanceFromLine = backing.getInt(36);
+        }
+        public void write() {
+            backing.putInt(0, minRectLength);
+            backing.putDouble(8, minRectAspectRatio);
+            backing.putInt(16, minRadius);
+            backing.putInt(20, minLineLength);
+            backing.putDouble(24, minFeatureStrength);
+            backing.putInt(32, maxFeaturesUsed);
+            backing.putInt(36, maxPixelDistanceFromLine);
+        }
+        public int size() {
+            return 40;
+        }
+    }
+
+    public static class FitEllipseOptions extends DisposedStruct {
+        public int rejectOutliers; // Whether to use every given point or only a subset of the points to fit the ellipse.
+        public double minScore; // Specifies the required quality of the fitted ellipse.
+        public double pixelRadius; // The acceptable distance, in pixels, that a point determined to belong to the ellipse can be from the circumference of the ellipse.
+        public int maxIterations; // Specifies the number of refinement iterations you allow the function to perform on the initial subset of points.
+
+        private void init() {
+            
+        }
+        public FitEllipseOptions() {
+            super(32);
+            init();
+        }
+        public FitEllipseOptions(int rejectOutliers, double minScore, double pixelRadius, int maxIterations) {
+            super(32);
+            this.rejectOutliers = rejectOutliers;
+            this.minScore = minScore;
+            this.pixelRadius = pixelRadius;
+            this.maxIterations = maxIterations;
+        }
+        protected FitEllipseOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected FitEllipseOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            rejectOutliers = backing.getInt(0);
+            minScore = backing.getDouble(8);
+            pixelRadius = backing.getDouble(16);
+            maxIterations = backing.getInt(24);
+        }
+        public void write() {
+            backing.putInt(0, rejectOutliers);
+            backing.putDouble(8, minScore);
+            backing.putDouble(16, pixelRadius);
+            backing.putInt(24, maxIterations);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class FitCircleOptions extends DisposedStruct {
+        public int rejectOutliers; // Whether to use every given point or only a subset of the points to fit the circle.
+        public double minScore; // Specifies the required quality of the fitted circle.
+        public double pixelRadius; // The acceptable distance, in pixels, that a point determined to belong to the circle can be from the circumference of the circle.
+        public int maxIterations; // Specifies the number of refinement iterations you allow the function to perform on the initial subset of points.
+
+        private void init() {
+            
+        }
+        public FitCircleOptions() {
+            super(32);
+            init();
+        }
+        public FitCircleOptions(int rejectOutliers, double minScore, double pixelRadius, int maxIterations) {
+            super(32);
+            this.rejectOutliers = rejectOutliers;
+            this.minScore = minScore;
+            this.pixelRadius = pixelRadius;
+            this.maxIterations = maxIterations;
+        }
+        protected FitCircleOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected FitCircleOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            rejectOutliers = backing.getInt(0);
+            minScore = backing.getDouble(8);
+            pixelRadius = backing.getDouble(16);
+            maxIterations = backing.getInt(24);
+        }
+        public void write() {
+            backing.putInt(0, rejectOutliers);
+            backing.putDouble(8, minScore);
+            backing.putDouble(16, pixelRadius);
+            backing.putInt(24, maxIterations);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class ConstructROIOptions2 extends DisposedStruct {
+        public int windowNumber; // The window number of the image window.
+        public String windowTitle; // Specifies the message string that the function displays in the title bar of the window.
+        public PaletteType type; // The palette type to use.
+        public RGBValue[] palette; // If type is IMAQ_PALETTE_USER, this array is the palette of colors to use with the window.
+        public int maxContours; // The maximum number of contours the user will be able to select.
+        private ByteBuffer windowTitle_buf;
+        private ByteBuffer palette_buf;
+
+        private void init() {
+            palette = new RGBValue[0];
+        }
+        public ConstructROIOptions2() {
+            super(24);
+            init();
+        }
+        public ConstructROIOptions2(int windowNumber, String windowTitle, PaletteType type, RGBValue[] palette, int maxContours) {
+            super(24);
+            this.windowNumber = windowNumber;
+            this.windowTitle = windowTitle;
+            this.type = type;
+            this.palette = palette;
+            this.maxContours = maxContours;
+        }
+        protected ConstructROIOptions2(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected ConstructROIOptions2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            windowNumber = backing.getInt(0);
+            long windowTitle_addr = getPointer(backing, 4);
+            if (windowTitle_addr == 0)
+                windowTitle = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(windowTitle_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    windowTitle = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    windowTitle = "";
+                }
+            }
+            
+            type = PaletteType.fromValue(backing.getInt(8));
+            int palette_numColors = backing.getInt(16);
+            long palette_addr = getPointer(backing, 12);
+            palette = new RGBValue[palette_numColors];
+            if (palette_numColors > 0 && palette_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(palette_addr, palette_numColors*4);
+                for (int i=0, off=0; i<palette_numColors; i++, off += 4) {
+                    palette[i] = new RGBValue(bb, off);
+                    palette[i].read();
+                }
+            }
+            maxContours = backing.getInt(20);
+        }
+        public void write() {
+            backing.putInt(0, windowNumber);
+            if (windowTitle != null) {
+                byte[] windowTitle_bytes;
+                try {
+                    windowTitle_bytes = windowTitle.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    windowTitle_bytes = new byte[0];
+                }
+                windowTitle_buf = ByteBuffer.allocateDirect(windowTitle_bytes.length+1);
+                putBytes(windowTitle_buf, windowTitle_bytes, 0, windowTitle_bytes.length).put(windowTitle_bytes.length, (byte)0);
+            }
+            putPointer(backing, 4, windowTitle == null ? 0 : getByteBufferAddress(windowTitle_buf));
+            if (type != null)
+                backing.putInt(8, type.getValue());
+            palette_buf = ByteBuffer.allocateDirect(palette.length*4);
+            for (int i=0, off=0; i<palette.length; i++, off += 4) {
+                palette[i].setBuffer(palette_buf, off);
+                palette[i].write();
+            }
+            backing.putInt(16, palette.length);
+            putPointer(backing, 12, palette_buf);
+            backing.putInt(20, maxContours);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class HSLValue extends DisposedStruct {
+        public short L; // The color luminance.
+        public short S; // The color saturation.
+        public short H; // The color hue.
+        public short alpha; // The alpha value of the color, which represents extra information about a color image, such as gamma correction.
+
+        private void init() {
+            
+        }
+        public HSLValue() {
+            super(4);
+            init();
+        }
+        public HSLValue(int L, int S, int H, int alpha) {
+            super(4);
+            this.L = (short)L;
+            this.S = (short)S;
+            this.H = (short)H;
+            this.alpha = (short)alpha;
+        }
+        protected HSLValue(ByteBuffer backing, int offset) {
+            super(backing, offset, 4);
+            init();
+        }
+        protected HSLValue(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 4);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 4);
+        }
+        public void read() {
+            L = backing.getShort(0);
+            S = backing.getShort(1);
+            H = backing.getShort(2);
+            alpha = backing.getShort(3);
+        }
+        public void write() {
+            backing.putShort(0, L);
+            backing.putShort(1, S);
+            backing.putShort(2, H);
+            backing.putShort(3, alpha);
+        }
+        public int size() {
+            return 4;
+        }
+    }
+
+    public static class HSVValue extends DisposedStruct {
+        public short V; // The color value.
+        public short S; // The color saturation.
+        public short H; // The color hue.
+        public short alpha; // The alpha value of the color, which represents extra information about a color image, such as gamma correction.
+
+        private void init() {
+            
+        }
+        public HSVValue() {
+            super(4);
+            init();
+        }
+        public HSVValue(int V, int S, int H, int alpha) {
+            super(4);
+            this.V = (short)V;
+            this.S = (short)S;
+            this.H = (short)H;
+            this.alpha = (short)alpha;
+        }
+        protected HSVValue(ByteBuffer backing, int offset) {
+            super(backing, offset, 4);
+            init();
+        }
+        protected HSVValue(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 4);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 4);
+        }
+        public void read() {
+            V = backing.getShort(0);
+            S = backing.getShort(1);
+            H = backing.getShort(2);
+            alpha = backing.getShort(3);
+        }
+        public void write() {
+            backing.putShort(0, V);
+            backing.putShort(1, S);
+            backing.putShort(2, H);
+            backing.putShort(3, alpha);
+        }
+        public int size() {
+            return 4;
+        }
+    }
+
+    public static class HSIValue extends DisposedStruct {
+        public short I; // The color intensity.
+        public short S; // The color saturation.
+        public short H; // The color hue.
+        public short alpha; // The alpha value of the color, which represents extra information about a color image, such as gamma correction.
+
+        private void init() {
+            
+        }
+        public HSIValue() {
+            super(4);
+            init();
+        }
+        public HSIValue(int I, int S, int H, int alpha) {
+            super(4);
+            this.I = (short)I;
+            this.S = (short)S;
+            this.H = (short)H;
+            this.alpha = (short)alpha;
+        }
+        protected HSIValue(ByteBuffer backing, int offset) {
+            super(backing, offset, 4);
+            init();
+        }
+        protected HSIValue(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 4);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 4);
+        }
+        public void read() {
+            I = backing.getShort(0);
+            S = backing.getShort(1);
+            H = backing.getShort(2);
+            alpha = backing.getShort(3);
+        }
+        public void write() {
+            backing.putShort(0, I);
+            backing.putShort(1, S);
+            backing.putShort(2, H);
+            backing.putShort(3, alpha);
+        }
+        public int size() {
+            return 4;
+        }
+    }
+
+    public static class CIELabValue extends DisposedStruct {
+        public double b; // The yellow/blue information of the color.
+        public double a; // The red/green information of the color.
+        public double L; // The color lightness.
+        public short alpha; // The alpha value of the color, which represents extra information about a color image, such as gamma correction.
+
+        private void init() {
+            
+        }
+        public CIELabValue() {
+            super(32);
+            init();
+        }
+        public CIELabValue(double b, double a, double L, int alpha) {
+            super(32);
+            this.b = b;
+            this.a = a;
+            this.L = L;
+            this.alpha = (short)alpha;
+        }
+        protected CIELabValue(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected CIELabValue(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            b = backing.getDouble(0);
+            a = backing.getDouble(8);
+            L = backing.getDouble(16);
+            alpha = backing.getShort(24);
+        }
+        public void write() {
+            backing.putDouble(0, b);
+            backing.putDouble(8, a);
+            backing.putDouble(16, L);
+            backing.putShort(24, alpha);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class CIEXYZValue extends DisposedStruct {
+        public double Z; // The Z color information.
+        public double Y; // The color luminance.
+        public double X; // The X color information.
+        public short alpha; // The alpha value of the color, which represents extra information about a color image, such as gamma correction.
+
+        private void init() {
+            
+        }
+        public CIEXYZValue() {
+            super(32);
+            init();
+        }
+        public CIEXYZValue(double Z, double Y, double X, int alpha) {
+            super(32);
+            this.Z = Z;
+            this.Y = Y;
+            this.X = X;
+            this.alpha = (short)alpha;
+        }
+        protected CIEXYZValue(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected CIEXYZValue(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            Z = backing.getDouble(0);
+            Y = backing.getDouble(8);
+            X = backing.getDouble(16);
+            alpha = backing.getShort(24);
+        }
+        public void write() {
+            backing.putDouble(0, Z);
+            backing.putDouble(8, Y);
+            backing.putDouble(16, X);
+            backing.putShort(24, alpha);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class BestEllipse2 extends DisposedStruct {
+        public PointFloat center; // The coordinate location of the center of the ellipse.
+        public PointFloat majorAxisStart; // The coordinate location of the start of the major axis of the ellipse.
+        public PointFloat majorAxisEnd; // The coordinate location of the end of the major axis of the ellipse.
+        public PointFloat minorAxisStart; // The coordinate location of the start of the minor axis of the ellipse.
+        public PointFloat minorAxisEnd; // The coordinate location of the end of the minor axis of the ellipse.
+        public double area; // The area of the ellipse.
+        public double perimeter; // The length of the perimeter of the ellipse.
+        public double error; // Represents the least square error of the fitted ellipse to the entire set of points.
+        public int valid; // This element is TRUE if the function achieved the minimum score within the number of allowed refinement iterations and FALSE if the function did not achieve the minimum score.
+        public int[] pointsUsed; // An array of the indexes for the points array indicating which points the function used to fit the ellipse.
+        private ByteBuffer pointsUsed_buf;
+
+        private void init() {
+            center = new PointFloat(backing, 0);
+            majorAxisStart = new PointFloat(backing, 8);
+            majorAxisEnd = new PointFloat(backing, 16);
+            minorAxisStart = new PointFloat(backing, 24);
+            minorAxisEnd = new PointFloat(backing, 32);
+            pointsUsed = new int[0];
+        }
+        public BestEllipse2() {
+            super(80);
+            init();
+        }
+        public BestEllipse2(PointFloat center, PointFloat majorAxisStart, PointFloat majorAxisEnd, PointFloat minorAxisStart, PointFloat minorAxisEnd, double area, double perimeter, double error, int valid, int[] pointsUsed) {
+            super(80);
+            this.center = center;
+            this.majorAxisStart = majorAxisStart;
+            this.majorAxisEnd = majorAxisEnd;
+            this.minorAxisStart = minorAxisStart;
+            this.minorAxisEnd = minorAxisEnd;
+            this.area = area;
+            this.perimeter = perimeter;
+            this.error = error;
+            this.valid = valid;
+            this.pointsUsed = pointsUsed;
+        }
+        protected BestEllipse2(ByteBuffer backing, int offset) {
+            super(backing, offset, 80);
+            init();
+        }
+        protected BestEllipse2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 80);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 80);
+        }
+        public void read() {
+            center.read();
+            majorAxisStart.read();
+            majorAxisEnd.read();
+            minorAxisStart.read();
+            minorAxisEnd.read();
+            area = backing.getDouble(40);
+            perimeter = backing.getDouble(48);
+            error = backing.getDouble(56);
+            valid = backing.getInt(64);
+            int pointsUsed_numPointsUsed = backing.getInt(72);
+            long pointsUsed_addr = getPointer(backing, 68);
+            pointsUsed = new int[pointsUsed_numPointsUsed];
+            if (pointsUsed_numPointsUsed > 0 && pointsUsed_addr != 0) {
+                newDirectByteBuffer(pointsUsed_addr, pointsUsed_numPointsUsed*4).asIntBuffer().get(pointsUsed);
+            }
+        }
+        public void write() {
+            center.write();
+            majorAxisStart.write();
+            majorAxisEnd.write();
+            minorAxisStart.write();
+            minorAxisEnd.write();
+            backing.putDouble(40, area);
+            backing.putDouble(48, perimeter);
+            backing.putDouble(56, error);
+            backing.putInt(64, valid);
+            pointsUsed_buf = ByteBuffer.allocateDirect(pointsUsed.length*4);
+            pointsUsed_buf.asIntBuffer().put(pointsUsed).rewind();
+            backing.putInt(72, pointsUsed.length);
+            putPointer(backing, 68, pointsUsed_buf);
+        }
+        public int size() {
+            return 80;
+        }
+    }
+
+    public static class LearnPatternAdvancedOptions extends DisposedStruct {
+        public LearnPatternAdvancedShiftOptions shiftOptions; // Use this element to control the behavior of imaqLearnPattern2() during the shift-invariant learning phase.
+        public LearnPatternAdvancedRotationOptions rotationOptions; // Use this element to control the behavior of imaqLearnPattern2()during the rotation-invariant learning phase.
+
+        private void init() {
+            
+        }
+        public LearnPatternAdvancedOptions() {
+            super(8);
+            init();
+        }
+        public LearnPatternAdvancedOptions(LearnPatternAdvancedShiftOptions shiftOptions, LearnPatternAdvancedRotationOptions rotationOptions) {
+            super(8);
+            this.shiftOptions = shiftOptions;
+            this.rotationOptions = rotationOptions;
+        }
+        protected LearnPatternAdvancedOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected LearnPatternAdvancedOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            long shiftOptions_addr = getPointer(backing, 0);
+            if (shiftOptions_addr == 0)
+                shiftOptions = null;
+            else
+                shiftOptions = new LearnPatternAdvancedShiftOptions(shiftOptions_addr, false);
+            long rotationOptions_addr = getPointer(backing, 4);
+            if (rotationOptions_addr == 0)
+                rotationOptions = null;
+            else
+                rotationOptions = new LearnPatternAdvancedRotationOptions(rotationOptions_addr, false);
+        }
+        public void write() {
+            putPointer(backing, 0, shiftOptions);
+            putPointer(backing, 4, rotationOptions);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class AVIInfo extends DisposedStruct {
+        public int width; // The width of each frame.
+        public int height; // The height of each frame.
+        public ImageType imageType; // The type of images this AVI contains.
+        public int numFrames; // The number of frames in the AVI.
+        public int framesPerSecond; // The number of frames per second this AVI should be shown at.
+        public String filterName; // The name of the compression filter used to create this AVI.
+        public int hasData; // Specifies whether this AVI has data attached to each frame or not.
+        public int maxDataSize; // If this AVI has data, the maximum size of the data in each frame.
+        private ByteBuffer filterName_buf;
+
+        private void init() {
+            
+        }
+        public AVIInfo() {
+            super(32);
+            init();
+        }
+        public AVIInfo(int width, int height, ImageType imageType, int numFrames, int framesPerSecond, String filterName, int hasData, int maxDataSize) {
+            super(32);
+            this.width = width;
+            this.height = height;
+            this.imageType = imageType;
+            this.numFrames = numFrames;
+            this.framesPerSecond = framesPerSecond;
+            this.filterName = filterName;
+            this.hasData = hasData;
+            this.maxDataSize = maxDataSize;
+        }
+        protected AVIInfo(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected AVIInfo(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            width = backing.getInt(0);
+            height = backing.getInt(4);
+            imageType = ImageType.fromValue(backing.getInt(8));
+            numFrames = backing.getInt(12);
+            framesPerSecond = backing.getInt(16);
+            long filterName_addr = getPointer(backing, 20);
+            if (filterName_addr == 0)
+                filterName = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(filterName_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    filterName = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    filterName = "";
+                }
+            }
+            
+            hasData = backing.getInt(24);
+            maxDataSize = backing.getInt(28);
+        }
+        public void write() {
+            backing.putInt(0, width);
+            backing.putInt(4, height);
+            if (imageType != null)
+                backing.putInt(8, imageType.getValue());
+            backing.putInt(12, numFrames);
+            backing.putInt(16, framesPerSecond);
+            if (filterName != null) {
+                byte[] filterName_bytes;
+                try {
+                    filterName_bytes = filterName.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    filterName_bytes = new byte[0];
+                }
+                filterName_buf = ByteBuffer.allocateDirect(filterName_bytes.length+1);
+                putBytes(filterName_buf, filterName_bytes, 0, filterName_bytes.length).put(filterName_bytes.length, (byte)0);
+            }
+            putPointer(backing, 20, filterName == null ? 0 : getByteBufferAddress(filterName_buf));
+            backing.putInt(24, hasData);
+            backing.putInt(28, maxDataSize);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class LearnPatternAdvancedShiftOptions extends DisposedStruct {
+        public int initialStepSize; // The largest number of image pixels to shift the sample across the inspection image during the initial phase of shift-invariant matching.
+        public int initialSampleSize; // Specifies the number of template pixels that you want to include in a sample for the initial phase of shift-invariant matching.
+        public double initialSampleSizeFactor; // Specifies the size of the sample for the initial phase of shift-invariant matching as a percent of the template size, in pixels.
+        public int finalSampleSize; // Specifies the number of template pixels you want to add to initialSampleSize for the final phase of shift-invariant matching.
+        public double finalSampleSizeFactor; // Specifies the size of the sample for the final phase of shift-invariant matching as a percent of the edge points in the template, in pixels.
+        public int subpixelSampleSize; // Specifies the number of template pixels that you want to include in a sample for the subpixel phase of shift-invariant matching.
+        public double subpixelSampleSizeFactor; // Specifies the size of the sample for the subpixel phase of shift-invariant matching as a percent of the template size, in pixels.
+
+        private void init() {
+            
+        }
+        public LearnPatternAdvancedShiftOptions() {
+            super(48);
+            init();
+        }
+        public LearnPatternAdvancedShiftOptions(int initialStepSize, int initialSampleSize, double initialSampleSizeFactor, int finalSampleSize, double finalSampleSizeFactor, int subpixelSampleSize, double subpixelSampleSizeFactor) {
+            super(48);
+            this.initialStepSize = initialStepSize;
+            this.initialSampleSize = initialSampleSize;
+            this.initialSampleSizeFactor = initialSampleSizeFactor;
+            this.finalSampleSize = finalSampleSize;
+            this.finalSampleSizeFactor = finalSampleSizeFactor;
+            this.subpixelSampleSize = subpixelSampleSize;
+            this.subpixelSampleSizeFactor = subpixelSampleSizeFactor;
+        }
+        protected LearnPatternAdvancedShiftOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 48);
+            init();
+        }
+        protected LearnPatternAdvancedShiftOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 48);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 48);
+        }
+        public void read() {
+            initialStepSize = backing.getInt(0);
+            initialSampleSize = backing.getInt(4);
+            initialSampleSizeFactor = backing.getDouble(8);
+            finalSampleSize = backing.getInt(16);
+            finalSampleSizeFactor = backing.getDouble(24);
+            subpixelSampleSize = backing.getInt(32);
+            subpixelSampleSizeFactor = backing.getDouble(40);
+        }
+        public void write() {
+            backing.putInt(0, initialStepSize);
+            backing.putInt(4, initialSampleSize);
+            backing.putDouble(8, initialSampleSizeFactor);
+            backing.putInt(16, finalSampleSize);
+            backing.putDouble(24, finalSampleSizeFactor);
+            backing.putInt(32, subpixelSampleSize);
+            backing.putDouble(40, subpixelSampleSizeFactor);
+        }
+        public int size() {
+            return 48;
+        }
+    }
+
+    public static class LearnPatternAdvancedRotationOptions extends DisposedStruct {
+        public SearchStrategy searchStrategySupport; // Specifies the aggressiveness of the rotation search strategy available during the matching phase.
+        public int initialStepSize; // The largest number of image pixels to shift the sample across the inspection image during the initial phase of matching.
+        public int initialSampleSize; // Specifies the number of template pixels that you want to include in a sample for the initial phase of rotation-invariant matching.
+        public double initialSampleSizeFactor; // Specifies the size of the sample for the initial phase of rotation-invariant matching as a percent of the template size, in pixels.
+        public int initialAngularAccuracy; // Sets the angle accuracy, in degrees, to use during the initial phase of rotation-invariant matching.
+        public int finalSampleSize; // Specifies the number of template pixels you want to add to initialSampleSize for the final phase of rotation-invariant matching.
+        public double finalSampleSizeFactor; // Specifies the size of the sample for the final phase of rotation-invariant matching as a percent of the edge points in the template, in pixels.
+        public int finalAngularAccuracy; // Sets the angle accuracy, in degrees, to use during the final phase of the rotation-invariant matching.
+        public int subpixelSampleSize; // Specifies the number of template pixels that you want to include in a sample for the subpixel phase of rotation-invariant matching.
+        public double subpixelSampleSizeFactor; // Specifies the size of the sample for the subpixel phase of rotation-invariant matching as a percent of the template size, in pixels.
+
+        private void init() {
+            
+        }
+        public LearnPatternAdvancedRotationOptions() {
+            super(56);
+            init();
+        }
+        public LearnPatternAdvancedRotationOptions(SearchStrategy searchStrategySupport, int initialStepSize, int initialSampleSize, double initialSampleSizeFactor, int initialAngularAccuracy, int finalSampleSize, double finalSampleSizeFactor, int finalAngularAccuracy, int subpixelSampleSize, double subpixelSampleSizeFactor) {
+            super(56);
+            this.searchStrategySupport = searchStrategySupport;
+            this.initialStepSize = initialStepSize;
+            this.initialSampleSize = initialSampleSize;
+            this.initialSampleSizeFactor = initialSampleSizeFactor;
+            this.initialAngularAccuracy = initialAngularAccuracy;
+            this.finalSampleSize = finalSampleSize;
+            this.finalSampleSizeFactor = finalSampleSizeFactor;
+            this.finalAngularAccuracy = finalAngularAccuracy;
+            this.subpixelSampleSize = subpixelSampleSize;
+            this.subpixelSampleSizeFactor = subpixelSampleSizeFactor;
+        }
+        protected LearnPatternAdvancedRotationOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 56);
+            init();
+        }
+        protected LearnPatternAdvancedRotationOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 56);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 56);
+        }
+        public void read() {
+            searchStrategySupport = SearchStrategy.fromValue(backing.getInt(0));
+            initialStepSize = backing.getInt(4);
+            initialSampleSize = backing.getInt(8);
+            initialSampleSizeFactor = backing.getDouble(16);
+            initialAngularAccuracy = backing.getInt(24);
+            finalSampleSize = backing.getInt(28);
+            finalSampleSizeFactor = backing.getDouble(32);
+            finalAngularAccuracy = backing.getInt(40);
+            subpixelSampleSize = backing.getInt(44);
+            subpixelSampleSizeFactor = backing.getDouble(48);
+        }
+        public void write() {
+            if (searchStrategySupport != null)
+                backing.putInt(0, searchStrategySupport.getValue());
+            backing.putInt(4, initialStepSize);
+            backing.putInt(8, initialSampleSize);
+            backing.putDouble(16, initialSampleSizeFactor);
+            backing.putInt(24, initialAngularAccuracy);
+            backing.putInt(28, finalSampleSize);
+            backing.putDouble(32, finalSampleSizeFactor);
+            backing.putInt(40, finalAngularAccuracy);
+            backing.putInt(44, subpixelSampleSize);
+            backing.putDouble(48, subpixelSampleSizeFactor);
+        }
+        public int size() {
+            return 56;
+        }
+    }
+
+    public static class MatchPatternAdvancedOptions extends DisposedStruct {
+        public int subpixelIterations; // Defines the maximum number of incremental improvements used to refine matching using subpixel information.
+        public double subpixelTolerance; // Defines the maximum amount of change, in pixels, between consecutive incremental improvements in the match position that you want to trigger the end of the refinement process.
+        public int initialMatchListLength; // Specifies the maximum size of the match list.
+        public int matchListReductionFactor; // Specifies the reduction of the match list as matches are refined.
+        public int initialStepSize; // Specifies the number of pixels to shift the sample across the inspection image during the initial phase of shift-invariant matching.
+        public SearchStrategy searchStrategy; // Specifies the aggressiveness of the rotation search strategy.
+        public int intermediateAngularAccuracy; // Specifies the accuracy to use during the intermediate phase of rotation-invariant matching.
+
+        private void init() {
+            
+        }
+        public MatchPatternAdvancedOptions() {
+            super(40);
+            init();
+        }
+        public MatchPatternAdvancedOptions(int subpixelIterations, double subpixelTolerance, int initialMatchListLength, int matchListReductionFactor, int initialStepSize, SearchStrategy searchStrategy, int intermediateAngularAccuracy) {
+            super(40);
+            this.subpixelIterations = subpixelIterations;
+            this.subpixelTolerance = subpixelTolerance;
+            this.initialMatchListLength = initialMatchListLength;
+            this.matchListReductionFactor = matchListReductionFactor;
+            this.initialStepSize = initialStepSize;
+            this.searchStrategy = searchStrategy;
+            this.intermediateAngularAccuracy = intermediateAngularAccuracy;
+        }
+        protected MatchPatternAdvancedOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 40);
+            init();
+        }
+        protected MatchPatternAdvancedOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 40);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 40);
+        }
+        public void read() {
+            subpixelIterations = backing.getInt(0);
+            subpixelTolerance = backing.getDouble(8);
+            initialMatchListLength = backing.getInt(16);
+            matchListReductionFactor = backing.getInt(20);
+            initialStepSize = backing.getInt(24);
+            searchStrategy = SearchStrategy.fromValue(backing.getInt(28));
+            intermediateAngularAccuracy = backing.getInt(32);
+        }
+        public void write() {
+            backing.putInt(0, subpixelIterations);
+            backing.putDouble(8, subpixelTolerance);
+            backing.putInt(16, initialMatchListLength);
+            backing.putInt(20, matchListReductionFactor);
+            backing.putInt(24, initialStepSize);
+            if (searchStrategy != null)
+                backing.putInt(28, searchStrategy.getValue());
+            backing.putInt(32, intermediateAngularAccuracy);
+        }
+        public int size() {
+            return 40;
+        }
+    }
+
+    public static class ParticleFilterCriteria2 extends DisposedStruct {
+        public MeasurementType parameter; // The morphological measurement that the function uses for filtering.
+        public float lower; // The lower bound of the criteria range.
+        public float upper; // The upper bound of the criteria range.
+        public int calibrated; // Set this element to TRUE to take calibrated measurements.
+        public int exclude; // Set this element to TRUE to indicate that a match occurs when the measurement is outside the criteria range.
+
+        private void init() {
+            
+        }
+        public ParticleFilterCriteria2() {
+            super(20);
+            init();
+        }
+        public ParticleFilterCriteria2(MeasurementType parameter, double lower, double upper, int calibrated, int exclude) {
+            super(20);
+            this.parameter = parameter;
+            this.lower = (float)lower;
+            this.upper = (float)upper;
+            this.calibrated = calibrated;
+            this.exclude = exclude;
+        }
+        protected ParticleFilterCriteria2(ByteBuffer backing, int offset) {
+            super(backing, offset, 20);
+            init();
+        }
+        protected ParticleFilterCriteria2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 20);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 20);
+        }
+        public void read() {
+            parameter = MeasurementType.fromValue(backing.getInt(0));
+            lower = backing.getFloat(4);
+            upper = backing.getFloat(8);
+            calibrated = backing.getInt(12);
+            exclude = backing.getInt(16);
+        }
+        public void write() {
+            if (parameter != null)
+                backing.putInt(0, parameter.getValue());
+            backing.putFloat(4, lower);
+            backing.putFloat(8, upper);
+            backing.putInt(12, calibrated);
+            backing.putInt(16, exclude);
+        }
+        public int size() {
+            return 20;
+        }
+    }
+
+    public static class BestCircle2 extends DisposedStruct {
+        public PointFloat center; // The coordinate location of the center of the circle.
+        public double radius; // The radius of the circle.
+        public double area; // The area of the circle.
+        public double perimeter; // The length of the perimeter of the circle.
+        public double error; // Represents the least square error of the fitted circle to the entire set of points.
+        public int valid; // This element is TRUE if the function achieved the minimum score within the number of allowed refinement iterations and FALSE if the function did not achieve the minimum score.
+        public int[] pointsUsed; // An array of the indexes for the points array indicating which points the function used to fit the circle.
+        private ByteBuffer pointsUsed_buf;
+
+        private void init() {
+            center = new PointFloat(backing, 0);
+            pointsUsed = new int[0];
+        }
+        public BestCircle2() {
+            super(56);
+            init();
+        }
+        public BestCircle2(PointFloat center, double radius, double area, double perimeter, double error, int valid, int[] pointsUsed) {
+            super(56);
+            this.center = center;
+            this.radius = radius;
+            this.area = area;
+            this.perimeter = perimeter;
+            this.error = error;
+            this.valid = valid;
+            this.pointsUsed = pointsUsed;
+        }
+        protected BestCircle2(ByteBuffer backing, int offset) {
+            super(backing, offset, 56);
+            init();
+        }
+        protected BestCircle2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 56);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 56);
+        }
+        public void read() {
+            center.read();
+            radius = backing.getDouble(8);
+            area = backing.getDouble(16);
+            perimeter = backing.getDouble(24);
+            error = backing.getDouble(32);
+            valid = backing.getInt(40);
+            int pointsUsed_numPointsUsed = backing.getInt(48);
+            long pointsUsed_addr = getPointer(backing, 44);
+            pointsUsed = new int[pointsUsed_numPointsUsed];
+            if (pointsUsed_numPointsUsed > 0 && pointsUsed_addr != 0) {
+                newDirectByteBuffer(pointsUsed_addr, pointsUsed_numPointsUsed*4).asIntBuffer().get(pointsUsed);
+            }
+        }
+        public void write() {
+            center.write();
+            backing.putDouble(8, radius);
+            backing.putDouble(16, area);
+            backing.putDouble(24, perimeter);
+            backing.putDouble(32, error);
+            backing.putInt(40, valid);
+            pointsUsed_buf = ByteBuffer.allocateDirect(pointsUsed.length*4);
+            pointsUsed_buf.asIntBuffer().put(pointsUsed).rewind();
+            backing.putInt(48, pointsUsed.length);
+            putPointer(backing, 44, pointsUsed_buf);
+        }
+        public int size() {
+            return 56;
+        }
+    }
+
+    public static class OCRSpacingOptions extends DisposedStruct {
+        public int minCharSpacing; // The minimum number of pixels that must be between two characters for NI Vision to train or read the characters separately.
+        public int minCharSize; // The minimum number of pixels required for an object to be a potentially identifiable character.
+        public int maxCharSize; // The maximum number of pixels required for an object to be a potentially identifiable character.
+        public int maxHorizontalElementSpacing; // The maximum horizontal spacing, in pixels, allowed between character elements to train or read the character elements as a single character.
+        public int maxVerticalElementSpacing; // The maximum vertical element spacing in pixels.
+        public int minBoundingRectWidth; // The minimum possible width, in pixels, for a character bounding rectangle.
+        public int maxBoundingRectWidth; // The maximum possible width, in pixels, for a character bounding rectangle.
+        public int minBoundingRectHeight; // The minimum possible height, in pixels, for a character bounding rectangle.
+        public int maxBoundingRectHeight; // The maximum possible height, in pixels, for a character bounding rectangle.
+        public int autoSplit; // Set this element to TRUE to automatically adjust the location of the character bounding rectangle when characters overlap vertically.
+
+        private void init() {
+            
+        }
+        public OCRSpacingOptions() {
+            super(40);
+            init();
+        }
+        public OCRSpacingOptions(int minCharSpacing, int minCharSize, int maxCharSize, int maxHorizontalElementSpacing, int maxVerticalElementSpacing, int minBoundingRectWidth, int maxBoundingRectWidth, int minBoundingRectHeight, int maxBoundingRectHeight, int autoSplit) {
+            super(40);
+            this.minCharSpacing = minCharSpacing;
+            this.minCharSize = minCharSize;
+            this.maxCharSize = maxCharSize;
+            this.maxHorizontalElementSpacing = maxHorizontalElementSpacing;
+            this.maxVerticalElementSpacing = maxVerticalElementSpacing;
+            this.minBoundingRectWidth = minBoundingRectWidth;
+            this.maxBoundingRectWidth = maxBoundingRectWidth;
+            this.minBoundingRectHeight = minBoundingRectHeight;
+            this.maxBoundingRectHeight = maxBoundingRectHeight;
+            this.autoSplit = autoSplit;
+        }
+        protected OCRSpacingOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 40);
+            init();
+        }
+        protected OCRSpacingOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 40);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 40);
+        }
+        public void read() {
+            minCharSpacing = backing.getInt(0);
+            minCharSize = backing.getInt(4);
+            maxCharSize = backing.getInt(8);
+            maxHorizontalElementSpacing = backing.getInt(12);
+            maxVerticalElementSpacing = backing.getInt(16);
+            minBoundingRectWidth = backing.getInt(20);
+            maxBoundingRectWidth = backing.getInt(24);
+            minBoundingRectHeight = backing.getInt(28);
+            maxBoundingRectHeight = backing.getInt(32);
+            autoSplit = backing.getInt(36);
+        }
+        public void write() {
+            backing.putInt(0, minCharSpacing);
+            backing.putInt(4, minCharSize);
+            backing.putInt(8, maxCharSize);
+            backing.putInt(12, maxHorizontalElementSpacing);
+            backing.putInt(16, maxVerticalElementSpacing);
+            backing.putInt(20, minBoundingRectWidth);
+            backing.putInt(24, maxBoundingRectWidth);
+            backing.putInt(28, minBoundingRectHeight);
+            backing.putInt(32, maxBoundingRectHeight);
+            backing.putInt(36, autoSplit);
+        }
+        public int size() {
+            return 40;
+        }
+    }
+
+    public static class OCRProcessingOptions extends DisposedStruct {
+        public ThresholdMode mode; // The thresholding mode.
+        public int lowThreshold; // The low threshold value when you set mode to IMAQ_FIXED_RANGE.
+        public int highThreshold; // The high threshold value when you set mode to IMAQ_FIXED_RANGE.
+        public int blockCount; // The number of blocks for threshold calculation algorithms that require blocks.
+        public int fastThreshold; // Set this element to TRUE to use a faster, less accurate threshold calculation algorithm.
+        public int biModalCalculation; // Set this element to TRUE to calculate both the low and high threshold values when using the fast thresholding method.
+        public int darkCharacters; // Set this element to TRUE to read or train dark characters on a light background.
+        public int removeParticlesTouchingROI; // Set this element to TRUE to remove the particles touching the ROI.
+        public int erosionCount; // The number of erosions to perform.
+
+        private void init() {
+            
+        }
+        public OCRProcessingOptions() {
+            super(36);
+            init();
+        }
+        public OCRProcessingOptions(ThresholdMode mode, int lowThreshold, int highThreshold, int blockCount, int fastThreshold, int biModalCalculation, int darkCharacters, int removeParticlesTouchingROI, int erosionCount) {
+            super(36);
+            this.mode = mode;
+            this.lowThreshold = lowThreshold;
+            this.highThreshold = highThreshold;
+            this.blockCount = blockCount;
+            this.fastThreshold = fastThreshold;
+            this.biModalCalculation = biModalCalculation;
+            this.darkCharacters = darkCharacters;
+            this.removeParticlesTouchingROI = removeParticlesTouchingROI;
+            this.erosionCount = erosionCount;
+        }
+        protected OCRProcessingOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 36);
+            init();
+        }
+        protected OCRProcessingOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 36);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 36);
+        }
+        public void read() {
+            mode = ThresholdMode.fromValue(backing.getInt(0));
+            lowThreshold = backing.getInt(4);
+            highThreshold = backing.getInt(8);
+            blockCount = backing.getInt(12);
+            fastThreshold = backing.getInt(16);
+            biModalCalculation = backing.getInt(20);
+            darkCharacters = backing.getInt(24);
+            removeParticlesTouchingROI = backing.getInt(28);
+            erosionCount = backing.getInt(32);
+        }
+        public void write() {
+            if (mode != null)
+                backing.putInt(0, mode.getValue());
+            backing.putInt(4, lowThreshold);
+            backing.putInt(8, highThreshold);
+            backing.putInt(12, blockCount);
+            backing.putInt(16, fastThreshold);
+            backing.putInt(20, biModalCalculation);
+            backing.putInt(24, darkCharacters);
+            backing.putInt(28, removeParticlesTouchingROI);
+            backing.putInt(32, erosionCount);
+        }
+        public int size() {
+            return 36;
+        }
+    }
+
+    public static class ReadTextOptions extends DisposedStruct {
+        public String[] validChars; // An array of strings that specifies the valid characters.
+        public byte substitutionChar; // The character to substitute for objects that the function cannot match with any of the trained characters.
+        public ReadStrategy readStrategy; // The read strategy, which determines how closely the function analyzes images in the reading process to match objects with trained characters.
+        public int acceptanceLevel; // The minimum acceptance level at which an object is considered a trained character.
+        public int aspectRatio; // The maximum aspect ratio variance percentage for valid characters.
+        public ReadResolution readResolution; // The read resolution, which determines how much of the trained character data the function uses to match objects to trained characters.
+        private ByteBuffer validChars_buf;
+        private ByteBuffer[] validChars_bufs;
+
+        private void init() {
+            validChars = new String[0];
+        }
+        public ReadTextOptions() {
+            super(65304);
+            init();
+        }
+        public ReadTextOptions(String[] validChars, byte substitutionChar, ReadStrategy readStrategy, int acceptanceLevel, int aspectRatio, ReadResolution readResolution) {
+            super(65304);
+            this.validChars = validChars;
+            this.substitutionChar = substitutionChar;
+            this.readStrategy = readStrategy;
+            this.acceptanceLevel = acceptanceLevel;
+            this.aspectRatio = aspectRatio;
+            this.readResolution = readResolution;
+        }
+        protected ReadTextOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 65304);
+            init();
+        }
+        protected ReadTextOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 65304);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 65304);
+        }
+        public void read() {
+            int validChars_numValidChars = backing.getInt(65280);
+            long validChars_addr = getPointer(backing, 0);
+            validChars = new String[validChars_numValidChars];
+            if (validChars_numValidChars > 0 && validChars_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(validChars_addr, validChars_numValidChars*4);
+                for (int i=0, off=0; i<validChars_numValidChars; i++, off += 4) {
+                    long addr = getPointer(bb, off);
+                    if (addr == 0)
+                        validChars[i] = null;
+                    else {
+                        ByteBuffer bb2 = newDirectByteBuffer(addr, 1000); // FIXME
+                        while (bb2.get() != 0) {}
+                        byte[] bytes = new byte[bb2.position()-1];
+                        bb2.rewind();
+                        getBytes(bb2, bytes, 0, bytes.length);
+                        try {
+                            validChars[i] = new String(bytes, "UTF-8");
+                        } catch (UnsupportedEncodingException e) {
+                            validChars[i] = "";
+                        }
+                    }
+                }
+            }
+            substitutionChar = backing.get(65284);
+            readStrategy = ReadStrategy.fromValue(backing.getInt(65288));
+            acceptanceLevel = backing.getInt(65292);
+            aspectRatio = backing.getInt(65296);
+            readResolution = ReadResolution.fromValue(backing.getInt(65300));
+        }
+        public void write() {
+            validChars_buf = ByteBuffer.allocateDirect(validChars.length*4);
+            for (int i=0, off=0; i<validChars.length; i++, off += 4) {
+                if (validChars[i] == null)
+                    putPointer(validChars_buf, off, 0);
+                else {
+                    byte[] bytes;
+                    try {
+                        bytes = validChars[i].getBytes("UTF-8");
+                    } catch (UnsupportedEncodingException e) {
+                        bytes = new byte[0];
+                    }
+                    validChars_bufs[i] = ByteBuffer.allocateDirect(bytes.length+1);
+                    putBytes(validChars_bufs[i], bytes, 0, bytes.length).put(bytes.length, (byte)0);
+                    putPointer(validChars_buf, off, getByteBufferAddress(validChars_bufs[i]));
+                }
+            }
+            backing.putInt(65280, validChars.length);
+            putPointer(backing, 0, validChars_buf);
+            backing.put(65284, substitutionChar);
+            if (readStrategy != null)
+                backing.putInt(65288, readStrategy.getValue());
+            backing.putInt(65292, acceptanceLevel);
+            backing.putInt(65296, aspectRatio);
+            if (readResolution != null)
+                backing.putInt(65300, readResolution.getValue());
+        }
+        public int size() {
+            return 65304;
+        }
+    }
+
+    public static class CharInfo extends DisposedStruct {
+        public String charValue; // Retrieves the character value of the corresponding character in the character set.
+        public Image charImage; // The image you used to train this character.
+        public Image internalImage; // The internal representation that NI Vision uses to match objects to this character.
+        private ByteBuffer charValue_buf;
+
+        private void init() {
+            
+        }
+        public CharInfo() {
+            super(12);
+            init();
+        }
+        public CharInfo(String charValue, Image charImage, Image internalImage) {
+            super(12);
+            this.charValue = charValue;
+            this.charImage = charImage;
+            this.internalImage = internalImage;
+        }
+        protected CharInfo(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected CharInfo(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            long charValue_addr = getPointer(backing, 0);
+            if (charValue_addr == 0)
+                charValue = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(charValue_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    charValue = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    charValue = "";
+                }
+            }
+            
+            long charImage_addr = getPointer(backing, 4);
+            if (charImage_addr == 0)
+                charImage = null;
+            else
+                charImage = new Image(charImage_addr, false);
+            long internalImage_addr = getPointer(backing, 8);
+            if (internalImage_addr == 0)
+                internalImage = null;
+            else
+                internalImage = new Image(internalImage_addr, false);
+        }
+        public void write() {
+            if (charValue != null) {
+                byte[] charValue_bytes;
+                try {
+                    charValue_bytes = charValue.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    charValue_bytes = new byte[0];
+                }
+                charValue_buf = ByteBuffer.allocateDirect(charValue_bytes.length+1);
+                putBytes(charValue_buf, charValue_bytes, 0, charValue_bytes.length).put(charValue_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, charValue == null ? 0 : getByteBufferAddress(charValue_buf));
+            putPointer(backing, 4, charImage);
+            putPointer(backing, 8, internalImage);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class Rect extends DisposedStruct {
+        public int top; // Location of the top edge of the rectangle.
+        public int left; // Location of the left edge of the rectangle.
+        public int height; // Height of the rectangle.
+        public int width; // Width of the rectangle.
+
+        private void init() {
+            
+        }
+        public Rect() {
+            super(16);
+            init();
+        }
+        public Rect(int top, int left, int height, int width) {
+            super(16);
+            this.top = top;
+            this.left = left;
+            this.height = height;
+            this.width = width;
+        }
+        protected Rect(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected Rect(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            top = backing.getInt(0);
+            left = backing.getInt(4);
+            height = backing.getInt(8);
+            width = backing.getInt(12);
+        }
+        public void write() {
+            backing.putInt(0, top);
+            backing.putInt(4, left);
+            backing.putInt(8, height);
+            backing.putInt(12, width);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class CharReport extends DisposedStruct {
+        public String character; // The character value.
+        public PointFloat[] corner; // An array of four points that describes the rectangle that surrounds the character.
+        public int reserved; // This element is reserved.
+        public int lowThreshold; // The minimum value of the threshold range used for this character.
+        public int highThreshold; // The maximum value of the threshold range used for this character.
+        private ByteBuffer character_buf;
+
+        private void init() {
+            corner = new PointFloat[4];
+            
+            for (int i=0, off=4; i<4; i++, off += 8)
+                corner[i] = new PointFloat(backing, off);
+        }
+        public CharReport() {
+            super(48);
+            init();
+        }
+        public CharReport(String character, PointFloat[] corner, int reserved, int lowThreshold, int highThreshold) {
+            super(48);
+            this.character = character;
+            this.corner = corner;
+            this.reserved = reserved;
+            this.lowThreshold = lowThreshold;
+            this.highThreshold = highThreshold;
+        }
+        protected CharReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 48);
+            init();
+        }
+        protected CharReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 48);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 48);
+        }
+        public void read() {
+            long character_addr = getPointer(backing, 0);
+            if (character_addr == 0)
+                character = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(character_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    character = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    character = "";
+                }
+            }
+            
+            for (PointFloat it : corner) {
+                it.read();
+            }
+            reserved = backing.getInt(36);
+            lowThreshold = backing.getInt(40);
+            highThreshold = backing.getInt(44);
+        }
+        public void write() {
+            if (character != null) {
+                byte[] character_bytes;
+                try {
+                    character_bytes = character.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    character_bytes = new byte[0];
+                }
+                character_buf = ByteBuffer.allocateDirect(character_bytes.length+1);
+                putBytes(character_buf, character_bytes, 0, character_bytes.length).put(character_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, character == null ? 0 : getByteBufferAddress(character_buf));
+            for (PointFloat it : corner) {
+                it.write();
+            }
+            backing.putInt(36, reserved);
+            backing.putInt(40, lowThreshold);
+            backing.putInt(44, highThreshold);
+        }
+        public int size() {
+            return 48;
+        }
+    }
+
+    public static class ReadTextReport extends DisposedStruct {
+        public String readString; // The read string.
+        public CharReport[] characterReport; // An array of reports describing the properties of each identified character.
+        private ByteBuffer readString_buf;
+        private ByteBuffer characterReport_buf;
+
+        private void init() {
+            characterReport = new CharReport[0];
+        }
+        public ReadTextReport() {
+            super(12);
+            init();
+        }
+        public ReadTextReport(String readString, CharReport[] characterReport) {
+            super(12);
+            this.readString = readString;
+            this.characterReport = characterReport;
+        }
+        protected ReadTextReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected ReadTextReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            long readString_addr = getPointer(backing, 0);
+            if (readString_addr == 0)
+                readString = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(readString_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    readString = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    readString = "";
+                }
+            }
+            
+            int characterReport_numCharacterReports = backing.getInt(8);
+            long characterReport_addr = getPointer(backing, 4);
+            characterReport = new CharReport[characterReport_numCharacterReports];
+            if (characterReport_numCharacterReports > 0 && characterReport_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(characterReport_addr, characterReport_numCharacterReports*48);
+                for (int i=0, off=0; i<characterReport_numCharacterReports; i++, off += 48) {
+                    characterReport[i] = new CharReport(bb, off);
+                    characterReport[i].read();
+                }
+            }
+        }
+        public void write() {
+            if (readString != null) {
+                byte[] readString_bytes;
+                try {
+                    readString_bytes = readString.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    readString_bytes = new byte[0];
+                }
+                readString_buf = ByteBuffer.allocateDirect(readString_bytes.length+1);
+                putBytes(readString_buf, readString_bytes, 0, readString_bytes.length).put(readString_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, readString == null ? 0 : getByteBufferAddress(readString_buf));
+            characterReport_buf = ByteBuffer.allocateDirect(characterReport.length*48);
+            for (int i=0, off=0; i<characterReport.length; i++, off += 48) {
+                characterReport[i].setBuffer(characterReport_buf, off);
+                characterReport[i].write();
+            }
+            backing.putInt(8, characterReport.length);
+            putPointer(backing, 4, characterReport_buf);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class Point extends DisposedStruct {
+        public int x; // The x-coordinate of the point.
+        public int y; // The y-coordinate of the point.
+
+        private void init() {
+            
+        }
+        public Point() {
+            super(8);
+            init();
+        }
+        public Point(int x, int y) {
+            super(8);
+            this.x = x;
+            this.y = y;
+        }
+        protected Point(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected Point(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            x = backing.getInt(0);
+            y = backing.getInt(4);
+        }
+        public void write() {
+            backing.putInt(0, x);
+            backing.putInt(4, y);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class Annulus extends DisposedStruct {
+        public Point center; // The coordinate location of the center of the annulus.
+        public int innerRadius; // The internal radius of the annulus.
+        public int outerRadius; // The external radius of the annulus.
+        public double startAngle; // The start angle, in degrees, of the annulus.
+        public double endAngle; // The end angle, in degrees, of the annulus.
+
+        private void init() {
+            center = new Point(backing, 0);
+        }
+        public Annulus() {
+            super(32);
+            init();
+        }
+        public Annulus(Point center, int innerRadius, int outerRadius, double startAngle, double endAngle) {
+            super(32);
+            this.center = center;
+            this.innerRadius = innerRadius;
+            this.outerRadius = outerRadius;
+            this.startAngle = startAngle;
+            this.endAngle = endAngle;
+        }
+        protected Annulus(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected Annulus(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            center.read();
+            innerRadius = backing.getInt(8);
+            outerRadius = backing.getInt(12);
+            startAngle = backing.getDouble(16);
+            endAngle = backing.getDouble(24);
+        }
+        public void write() {
+            center.write();
+            backing.putInt(8, innerRadius);
+            backing.putInt(12, outerRadius);
+            backing.putDouble(16, startAngle);
+            backing.putDouble(24, endAngle);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class EdgeLocationReport extends DisposedStruct {
+        public PointFloat[] edges; // The coordinate location of all edges detected by the search line.
+        private ByteBuffer edges_buf;
+
+        private void init() {
+            edges = new PointFloat[0];
+        }
+        public EdgeLocationReport() {
+            super(8);
+            init();
+        }
+        public EdgeLocationReport(PointFloat[] edges) {
+            super(8);
+            this.edges = edges;
+        }
+        protected EdgeLocationReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected EdgeLocationReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            int edges_numEdges = backing.getInt(4);
+            long edges_addr = getPointer(backing, 0);
+            edges = new PointFloat[edges_numEdges];
+            if (edges_numEdges > 0 && edges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(edges_addr, edges_numEdges*8);
+                for (int i=0, off=0; i<edges_numEdges; i++, off += 8) {
+                    edges[i] = new PointFloat(bb, off);
+                    edges[i].read();
+                }
+            }
+        }
+        public void write() {
+            edges_buf = ByteBuffer.allocateDirect(edges.length*8);
+            for (int i=0, off=0; i<edges.length; i++, off += 8) {
+                edges[i].setBuffer(edges_buf, off);
+                edges[i].write();
+            }
+            backing.putInt(4, edges.length);
+            putPointer(backing, 0, edges_buf);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class EdgeOptions extends DisposedStruct {
+        public int threshold; // Specifies the threshold value for the contrast of the edge.
+        public int width; // The number of pixels that the function averages to find the contrast at either side of the edge.
+        public int steepness; // The span, in pixels, of the slope of the edge projected along the path specified by the input points.
+        public InterpolationMethod subpixelType; // The method for interpolating.
+        public int subpixelDivisions; // The number of samples the function obtains from a pixel.
+
+        private void init() {
+            
+        }
+        public EdgeOptions() {
+            super(20);
+            init();
+        }
+        public EdgeOptions(int threshold, int width, int steepness, InterpolationMethod subpixelType, int subpixelDivisions) {
+            super(20);
+            this.threshold = threshold;
+            this.width = width;
+            this.steepness = steepness;
+            this.subpixelType = subpixelType;
+            this.subpixelDivisions = subpixelDivisions;
+        }
+        protected EdgeOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 20);
+            init();
+        }
+        protected EdgeOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 20);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 20);
+        }
+        public void read() {
+            threshold = backing.getInt(0);
+            width = backing.getInt(4);
+            steepness = backing.getInt(8);
+            subpixelType = InterpolationMethod.fromValue(backing.getInt(12));
+            subpixelDivisions = backing.getInt(16);
+        }
+        public void write() {
+            backing.putInt(0, threshold);
+            backing.putInt(4, width);
+            backing.putInt(8, steepness);
+            if (subpixelType != null)
+                backing.putInt(12, subpixelType.getValue());
+            backing.putInt(16, subpixelDivisions);
+        }
+        public int size() {
+            return 20;
+        }
+    }
+
+    public static class EdgeReport extends DisposedStruct {
+        public float location; // The location of the edge from the first point in the points array.
+        public float contrast; // The contrast at the edge.
+        public PolarityType polarity; // The polarity of the edge.
+        public float reserved; // This element is reserved.
+        public PointFloat coordinate; // The coordinates of the edge.
+
+        private void init() {
+            coordinate = new PointFloat(backing, 20);
+        }
+        public EdgeReport() {
+            super(32);
+            init();
+        }
+        public EdgeReport(double location, double contrast, PolarityType polarity, double reserved, PointFloat coordinate) {
+            super(32);
+            this.location = (float)location;
+            this.contrast = (float)contrast;
+            this.polarity = polarity;
+            this.reserved = (float)reserved;
+            this.coordinate = coordinate;
+        }
+        protected EdgeReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected EdgeReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            location = backing.getFloat(0);
+            contrast = backing.getFloat(4);
+            polarity = PolarityType.fromValue(backing.getInt(8));
+            reserved = backing.getFloat(16);
+            coordinate.read();
+        }
+        public void write() {
+            backing.putFloat(0, location);
+            backing.putFloat(4, contrast);
+            if (polarity != null)
+                backing.putInt(8, polarity.getValue());
+            backing.putFloat(16, reserved);
+            coordinate.write();
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class ExtremeReport extends DisposedStruct {
+        public double location; // The locations of the extreme.
+        public double amplitude; // The amplitude of the extreme.
+        public double secondDerivative; // The second derivative of the extreme.
+
+        private void init() {
+            
+        }
+        public ExtremeReport() {
+            super(24);
+            init();
+        }
+        public ExtremeReport(double location, double amplitude, double secondDerivative) {
+            super(24);
+            this.location = location;
+            this.amplitude = amplitude;
+            this.secondDerivative = secondDerivative;
+        }
+        protected ExtremeReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected ExtremeReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            location = backing.getDouble(0);
+            amplitude = backing.getDouble(8);
+            secondDerivative = backing.getDouble(16);
+        }
+        public void write() {
+            backing.putDouble(0, location);
+            backing.putDouble(8, amplitude);
+            backing.putDouble(16, secondDerivative);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class FitLineOptions extends DisposedStruct {
+        public float minScore; // Specifies the required quality of the fitted line.
+        public float pixelRadius; // Specifies the neighborhood pixel relationship for the initial subset of points being used.
+        public int numRefinements; // Specifies the number of refinement iterations you allow the function to perform on the initial subset of points.
+
+        private void init() {
+            
+        }
+        public FitLineOptions() {
+            super(12);
+            init();
+        }
+        public FitLineOptions(double minScore, double pixelRadius, int numRefinements) {
+            super(12);
+            this.minScore = (float)minScore;
+            this.pixelRadius = (float)pixelRadius;
+            this.numRefinements = numRefinements;
+        }
+        protected FitLineOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected FitLineOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            minScore = backing.getFloat(0);
+            pixelRadius = backing.getFloat(4);
+            numRefinements = backing.getInt(8);
+        }
+        public void write() {
+            backing.putFloat(0, minScore);
+            backing.putFloat(4, pixelRadius);
+            backing.putInt(8, numRefinements);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class DisplayMapping extends DisposedStruct {
+        public MappingMethod method; // Describes the method for converting 16-bit pixels to 8-bit pixels.
+        public int minimumValue; // When method is IMAQ_RANGE, minimumValue represents the value that is mapped to 0.
+        public int maximumValue; // When method is IMAQ_RANGE, maximumValue represents the value that is mapped to 255.
+        public int shiftCount; // When method is IMAQ_DOWNSHIFT, shiftCount represents the number of bits the function right-shifts the 16-bit pixel values.
+
+        private void init() {
+            
+        }
+        public DisplayMapping() {
+            super(16);
+            init();
+        }
+        public DisplayMapping(MappingMethod method, int minimumValue, int maximumValue, int shiftCount) {
+            super(16);
+            this.method = method;
+            this.minimumValue = minimumValue;
+            this.maximumValue = maximumValue;
+            this.shiftCount = shiftCount;
+        }
+        protected DisplayMapping(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected DisplayMapping(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            method = MappingMethod.fromValue(backing.getInt(0));
+            minimumValue = backing.getInt(4);
+            maximumValue = backing.getInt(8);
+            shiftCount = backing.getInt(12);
+        }
+        public void write() {
+            if (method != null)
+                backing.putInt(0, method.getValue());
+            backing.putInt(4, minimumValue);
+            backing.putInt(8, maximumValue);
+            backing.putInt(12, shiftCount);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class DetectExtremesOptions extends DisposedStruct {
+        public double threshold; // Defines which extremes are too small.
+        public int width; // Specifies the number of consecutive data points the function uses in the quadratic least-squares fit.
+
+        private void init() {
+            
+        }
+        public DetectExtremesOptions() {
+            super(16);
+            init();
+        }
+        public DetectExtremesOptions(double threshold, int width) {
+            super(16);
+            this.threshold = threshold;
+            this.width = width;
+        }
+        protected DetectExtremesOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected DetectExtremesOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            threshold = backing.getDouble(0);
+            width = backing.getInt(8);
+        }
+        public void write() {
+            backing.putDouble(0, threshold);
+            backing.putInt(8, width);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class ImageInfo extends DisposedStruct {
+        public CalibrationUnit imageUnit; // If you set calibration information with imaqSetSimpleCalibrationInfo(), imageUnit is the calibration unit.
+        public float stepX; // If you set calibration information with imaqSetCalibrationInfo(), stepX is the distance in the calibration unit between two pixels in the x direction.
+        public float stepY; // If you set calibration information with imaqSetCalibrationInfo(), stepY is the distance in the calibration unit between two pixels in the y direction.
+        public ImageType imageType; // The type of the image.
+        public int xRes; // The number of columns in the image.
+        public int yRes; // The number of rows in the image.
+        public int xOffset; // If you set mask offset information with imaqSetMaskOffset(), xOffset is the offset of the mask origin in the x direction.
+        public int yOffset; // If you set mask offset information with imaqSetMaskOffset(), yOffset is the offset of the mask origin in the y direction.
+        public int border; // The number of border pixels around the image.
+        public int pixelsPerLine; // The number of pixels stored for each line of the image.
+
+        private void init() {
+            
+        }
+        public ImageInfo() {
+            super(52);
+            init();
+        }
+        public ImageInfo(CalibrationUnit imageUnit, double stepX, double stepY, ImageType imageType, int xRes, int yRes, int xOffset, int yOffset, int border, int pixelsPerLine) {
+            super(52);
+            this.imageUnit = imageUnit;
+            this.stepX = (float)stepX;
+            this.stepY = (float)stepY;
+            this.imageType = imageType;
+            this.xRes = xRes;
+            this.yRes = yRes;
+            this.xOffset = xOffset;
+            this.yOffset = yOffset;
+            this.border = border;
+            this.pixelsPerLine = pixelsPerLine;
+        }
+        protected ImageInfo(ByteBuffer backing, int offset) {
+            super(backing, offset, 52);
+            init();
+        }
+        protected ImageInfo(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 52);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 52);
+        }
+        public void read() {
+            imageUnit = CalibrationUnit.fromValue(backing.getInt(0));
+            stepX = backing.getFloat(4);
+            stepY = backing.getFloat(8);
+            imageType = ImageType.fromValue(backing.getInt(12));
+            xRes = backing.getInt(16);
+            yRes = backing.getInt(20);
+            xOffset = backing.getInt(24);
+            yOffset = backing.getInt(28);
+            border = backing.getInt(32);
+            pixelsPerLine = backing.getInt(36);
+        }
+        public void write() {
+            if (imageUnit != null)
+                backing.putInt(0, imageUnit.getValue());
+            backing.putFloat(4, stepX);
+            backing.putFloat(8, stepY);
+            if (imageType != null)
+                backing.putInt(12, imageType.getValue());
+            backing.putInt(16, xRes);
+            backing.putInt(20, yRes);
+            backing.putInt(24, xOffset);
+            backing.putInt(28, yOffset);
+            backing.putInt(32, border);
+            backing.putInt(36, pixelsPerLine);
+        }
+        public int size() {
+            return 52;
+        }
+    }
+
+    public static class LCDOptions extends DisposedStruct {
+        public int litSegments; // Set this parameter to TRUE if the segments are brighter than the background.
+        public float threshold; // Determines whether a segment is ON or OFF.
+        public int sign; // Indicates whether the function must read the sign of the indicator.
+        public int decimalPoint; // Determines whether to look for a decimal separator after each digit.
+
+        private void init() {
+            
+        }
+        public LCDOptions() {
+            super(16);
+            init();
+        }
+        public LCDOptions(int litSegments, double threshold, int sign, int decimalPoint) {
+            super(16);
+            this.litSegments = litSegments;
+            this.threshold = (float)threshold;
+            this.sign = sign;
+            this.decimalPoint = decimalPoint;
+        }
+        protected LCDOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected LCDOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            litSegments = backing.getInt(0);
+            threshold = backing.getFloat(4);
+            sign = backing.getInt(8);
+            decimalPoint = backing.getInt(12);
+        }
+        public void write() {
+            backing.putInt(0, litSegments);
+            backing.putFloat(4, threshold);
+            backing.putInt(8, sign);
+            backing.putInt(12, decimalPoint);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class LCDReport extends DisposedStruct {
+        public String text; // A string of the characters of the LCD.
+        public LCDSegments[] segmentInfo; // An array of LCDSegment structures describing which segments of each digit are on.
+        private ByteBuffer text_buf;
+        private ByteBuffer segmentInfo_buf;
+
+        private void init() {
+            segmentInfo = new LCDSegments[0];
+        }
+        public LCDReport() {
+            super(16);
+            init();
+        }
+        public LCDReport(String text, LCDSegments[] segmentInfo) {
+            super(16);
+            this.text = text;
+            this.segmentInfo = segmentInfo;
+        }
+        protected LCDReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected LCDReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            long text_addr = getPointer(backing, 0);
+            if (text_addr == 0)
+                text = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(text_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    text = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    text = "";
+                }
+            }
+            
+            int segmentInfo_numCharacters = backing.getInt(8);
+            long segmentInfo_addr = getPointer(backing, 4);
+            segmentInfo = new LCDSegments[segmentInfo_numCharacters];
+            if (segmentInfo_numCharacters > 0 && segmentInfo_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(segmentInfo_addr, segmentInfo_numCharacters*4);
+                for (int i=0, off=0; i<segmentInfo_numCharacters; i++, off += 4) {
+                    segmentInfo[i] = new LCDSegments(bb, off);
+                    segmentInfo[i].read();
+                }
+            }
+        }
+        public void write() {
+            if (text != null) {
+                byte[] text_bytes;
+                try {
+                    text_bytes = text.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    text_bytes = new byte[0];
+                }
+                text_buf = ByteBuffer.allocateDirect(text_bytes.length+1);
+                putBytes(text_buf, text_bytes, 0, text_bytes.length).put(text_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, text == null ? 0 : getByteBufferAddress(text_buf));
+            segmentInfo_buf = ByteBuffer.allocateDirect(segmentInfo.length*4);
+            for (int i=0, off=0; i<segmentInfo.length; i++, off += 4) {
+                segmentInfo[i].setBuffer(segmentInfo_buf, off);
+                segmentInfo[i].write();
+            }
+            backing.putInt(8, segmentInfo.length);
+            putPointer(backing, 4, segmentInfo_buf);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class LCDSegments extends DisposedStruct {
+        
+
+        private void init() {
+            
+        }
+        public LCDSegments() {
+            super(4);
+            init();
+        }
+        protected LCDSegments(ByteBuffer backing, int offset) {
+            super(backing, offset, 4);
+            init();
+        }
+        protected LCDSegments(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 4);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 4);
+        }
+        public void read() {
+            
+        }
+        public void write() {
+            
+        }
+        public int size() {
+            return 4;
+        }
+    }
+
+    public static class LearnCalibrationOptions extends DisposedStruct {
+        public CalibrationMode mode; // Specifies the type of algorithm you want to use to reduce distortion in your image.
+        public ScalingMethod method; // Defines the scaling method correction functions use to correct the image.
+        public CalibrationROI roi; // Specifies the ROI correction functions use when correcting an image.
+        public int learnMap; // Set this element to TRUE if you want the function to calculate and store an error map during the learning process.
+        public int learnTable; // Set this element to TRUE if you want the function to calculate and store the correction table.
+
+        private void init() {
+            
+        }
+        public LearnCalibrationOptions() {
+            super(20);
+            init();
+        }
+        public LearnCalibrationOptions(CalibrationMode mode, ScalingMethod method, CalibrationROI roi, int learnMap, int learnTable) {
+            super(20);
+            this.mode = mode;
+            this.method = method;
+            this.roi = roi;
+            this.learnMap = learnMap;
+            this.learnTable = learnTable;
+        }
+        protected LearnCalibrationOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 20);
+            init();
+        }
+        protected LearnCalibrationOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 20);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 20);
+        }
+        public void read() {
+            mode = CalibrationMode.fromValue(backing.getInt(0));
+            method = ScalingMethod.fromValue(backing.getInt(4));
+            roi = CalibrationROI.fromValue(backing.getInt(8));
+            learnMap = backing.getInt(12);
+            learnTable = backing.getInt(16);
+        }
+        public void write() {
+            if (mode != null)
+                backing.putInt(0, mode.getValue());
+            if (method != null)
+                backing.putInt(4, method.getValue());
+            if (roi != null)
+                backing.putInt(8, roi.getValue());
+            backing.putInt(12, learnMap);
+            backing.putInt(16, learnTable);
+        }
+        public int size() {
+            return 20;
+        }
+    }
+
+    public static class LearnColorPatternOptions extends DisposedStruct {
+        public LearningMode learnMode; // Specifies the invariance mode the function uses when learning the pattern.
+        public ImageFeatureMode featureMode; // Specifies the features the function uses when learning the color pattern.
+        public int threshold; // Specifies the saturation threshold the function uses to distinguish between two colors that have the same hue values.
+        public ColorIgnoreMode ignoreMode; // Specifies whether the function excludes certain colors from the color features of the template image.
+        public ColorInformation[] colorsToIgnore; // An array of ColorInformation structures providing a set of colors to exclude from the color features of the template image.
+        private ByteBuffer colorsToIgnore_buf;
+
+        private void init() {
+            colorsToIgnore = new ColorInformation[0];
+        }
+        public LearnColorPatternOptions() {
+            super(24);
+            init();
+        }
+        public LearnColorPatternOptions(LearningMode learnMode, ImageFeatureMode featureMode, int threshold, ColorIgnoreMode ignoreMode, ColorInformation[] colorsToIgnore) {
+            super(24);
+            this.learnMode = learnMode;
+            this.featureMode = featureMode;
+            this.threshold = threshold;
+            this.ignoreMode = ignoreMode;
+            this.colorsToIgnore = colorsToIgnore;
+        }
+        protected LearnColorPatternOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected LearnColorPatternOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            learnMode = LearningMode.fromValue(backing.getInt(0));
+            featureMode = ImageFeatureMode.fromValue(backing.getInt(4));
+            threshold = backing.getInt(8);
+            ignoreMode = ColorIgnoreMode.fromValue(backing.getInt(12));
+            int colorsToIgnore_numColorsToIgnore = backing.getInt(20);
+            long colorsToIgnore_addr = getPointer(backing, 16);
+            colorsToIgnore = new ColorInformation[colorsToIgnore_numColorsToIgnore];
+            if (colorsToIgnore_numColorsToIgnore > 0 && colorsToIgnore_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(colorsToIgnore_addr, colorsToIgnore_numColorsToIgnore*12);
+                for (int i=0, off=0; i<colorsToIgnore_numColorsToIgnore; i++, off += 12) {
+                    colorsToIgnore[i] = new ColorInformation(bb, off);
+                    colorsToIgnore[i].read();
+                }
+            }
+        }
+        public void write() {
+            if (learnMode != null)
+                backing.putInt(0, learnMode.getValue());
+            if (featureMode != null)
+                backing.putInt(4, featureMode.getValue());
+            backing.putInt(8, threshold);
+            if (ignoreMode != null)
+                backing.putInt(12, ignoreMode.getValue());
+            colorsToIgnore_buf = ByteBuffer.allocateDirect(colorsToIgnore.length*12);
+            for (int i=0, off=0; i<colorsToIgnore.length; i++, off += 12) {
+                colorsToIgnore[i].setBuffer(colorsToIgnore_buf, off);
+                colorsToIgnore[i].write();
+            }
+            backing.putInt(20, colorsToIgnore.length);
+            putPointer(backing, 16, colorsToIgnore_buf);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class Line extends DisposedStruct {
+        public Point start; // The coordinate location of the start of the line.
+        public Point end; // The coordinate location of the end of the line.
+
+        private void init() {
+            start = new Point(backing, 0);
+            end = new Point(backing, 8);
+        }
+        public Line() {
+            super(16);
+            init();
+        }
+        public Line(Point start, Point end) {
+            super(16);
+            this.start = start;
+            this.end = end;
+        }
+        protected Line(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected Line(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            start.read();
+            end.read();
+        }
+        public void write() {
+            start.write();
+            end.write();
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class LinearAverages extends DisposedStruct {
+        public float[] columnAverages; // An array containing the mean pixel value of each column.
+        public float[] rowAverages; // An array containing the mean pixel value of each row.
+        public float[] risingDiagAverages; // An array containing the mean pixel value of each diagonal running from the lower left to the upper right of the inspected area of the image.
+        public float[] fallingDiagAverages; // An array containing the mean pixel value of each diagonal running from the upper left to the lower right of the inspected area of the image.
+        private ByteBuffer columnAverages_buf;
+        private ByteBuffer rowAverages_buf;
+        private ByteBuffer risingDiagAverages_buf;
+        private ByteBuffer fallingDiagAverages_buf;
+
+        private void init() {
+            columnAverages = new float[0];
+            rowAverages = new float[0];
+            risingDiagAverages = new float[0];
+            fallingDiagAverages = new float[0];
+        }
+        public LinearAverages() {
+            super(32);
+            init();
+        }
+        public LinearAverages(float[] columnAverages, float[] rowAverages, float[] risingDiagAverages, float[] fallingDiagAverages) {
+            super(32);
+            this.columnAverages = columnAverages;
+            this.rowAverages = rowAverages;
+            this.risingDiagAverages = risingDiagAverages;
+            this.fallingDiagAverages = fallingDiagAverages;
+        }
+        protected LinearAverages(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected LinearAverages(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            int columnAverages_columnCount = backing.getInt(4);
+            long columnAverages_addr = getPointer(backing, 0);
+            columnAverages = new float[columnAverages_columnCount];
+            if (columnAverages_columnCount > 0 && columnAverages_addr != 0) {
+                newDirectByteBuffer(columnAverages_addr, columnAverages_columnCount*4).asFloatBuffer().get(columnAverages);
+            }
+            int rowAverages_rowCount = backing.getInt(12);
+            long rowAverages_addr = getPointer(backing, 8);
+            rowAverages = new float[rowAverages_rowCount];
+            if (rowAverages_rowCount > 0 && rowAverages_addr != 0) {
+                newDirectByteBuffer(rowAverages_addr, rowAverages_rowCount*4).asFloatBuffer().get(rowAverages);
+            }
+            int risingDiagAverages_risingDiagCount = backing.getInt(20);
+            long risingDiagAverages_addr = getPointer(backing, 16);
+            risingDiagAverages = new float[risingDiagAverages_risingDiagCount];
+            if (risingDiagAverages_risingDiagCount > 0 && risingDiagAverages_addr != 0) {
+                newDirectByteBuffer(risingDiagAverages_addr, risingDiagAverages_risingDiagCount*4).asFloatBuffer().get(risingDiagAverages);
+            }
+            int fallingDiagAverages_fallingDiagCount = backing.getInt(28);
+            long fallingDiagAverages_addr = getPointer(backing, 24);
+            fallingDiagAverages = new float[fallingDiagAverages_fallingDiagCount];
+            if (fallingDiagAverages_fallingDiagCount > 0 && fallingDiagAverages_addr != 0) {
+                newDirectByteBuffer(fallingDiagAverages_addr, fallingDiagAverages_fallingDiagCount*4).asFloatBuffer().get(fallingDiagAverages);
+            }
+        }
+        public void write() {
+            columnAverages_buf = ByteBuffer.allocateDirect(columnAverages.length*4);
+            columnAverages_buf.asFloatBuffer().put(columnAverages).rewind();
+            backing.putInt(4, columnAverages.length);
+            putPointer(backing, 0, columnAverages_buf);
+            rowAverages_buf = ByteBuffer.allocateDirect(rowAverages.length*4);
+            rowAverages_buf.asFloatBuffer().put(rowAverages).rewind();
+            backing.putInt(12, rowAverages.length);
+            putPointer(backing, 8, rowAverages_buf);
+            risingDiagAverages_buf = ByteBuffer.allocateDirect(risingDiagAverages.length*4);
+            risingDiagAverages_buf.asFloatBuffer().put(risingDiagAverages).rewind();
+            backing.putInt(20, risingDiagAverages.length);
+            putPointer(backing, 16, risingDiagAverages_buf);
+            fallingDiagAverages_buf = ByteBuffer.allocateDirect(fallingDiagAverages.length*4);
+            fallingDiagAverages_buf.asFloatBuffer().put(fallingDiagAverages).rewind();
+            backing.putInt(28, fallingDiagAverages.length);
+            putPointer(backing, 24, fallingDiagAverages_buf);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class LineProfile extends DisposedStruct {
+        public float[] profileData; // An array containing the value of each pixel in the line.
+        public Rect boundingBox; // The bounding rectangle of the line.
+        public float min; // The smallest pixel value in the line profile.
+        public float max; // The largest pixel value in the line profile.
+        public float mean; // The mean value of the pixels in the line profile.
+        public float stdDev; // The standard deviation of the line profile.
+        private ByteBuffer profileData_buf;
+
+        private void init() {
+            profileData = new float[0];
+            boundingBox = new Rect(backing, 4);
+        }
+        public LineProfile() {
+            super(40);
+            init();
+        }
+        public LineProfile(float[] profileData, Rect boundingBox, double min, double max, double mean, double stdDev) {
+            super(40);
+            this.profileData = profileData;
+            this.boundingBox = boundingBox;
+            this.min = (float)min;
+            this.max = (float)max;
+            this.mean = (float)mean;
+            this.stdDev = (float)stdDev;
+        }
+        protected LineProfile(ByteBuffer backing, int offset) {
+            super(backing, offset, 40);
+            init();
+        }
+        protected LineProfile(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 40);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 40);
+        }
+        public void read() {
+            int profileData_dataCount = backing.getInt(36);
+            long profileData_addr = getPointer(backing, 0);
+            profileData = new float[profileData_dataCount];
+            if (profileData_dataCount > 0 && profileData_addr != 0) {
+                newDirectByteBuffer(profileData_addr, profileData_dataCount*4).asFloatBuffer().get(profileData);
+            }
+            boundingBox.read();
+            min = backing.getFloat(20);
+            max = backing.getFloat(24);
+            mean = backing.getFloat(28);
+            stdDev = backing.getFloat(32);
+        }
+        public void write() {
+            profileData_buf = ByteBuffer.allocateDirect(profileData.length*4);
+            profileData_buf.asFloatBuffer().put(profileData).rewind();
+            backing.putInt(36, profileData.length);
+            putPointer(backing, 0, profileData_buf);
+            boundingBox.write();
+            backing.putFloat(20, min);
+            backing.putFloat(24, max);
+            backing.putFloat(28, mean);
+            backing.putFloat(32, stdDev);
+        }
+        public int size() {
+            return 40;
+        }
+    }
+
+    public static class MatchColorPatternOptions extends DisposedStruct {
+        public MatchingMode matchMode; // Specifies the method to use when looking for the color pattern in the image.
+        public ImageFeatureMode featureMode; // Specifies the features to use when looking for the color pattern in the image.
+        public int minContrast; // Specifies the minimum contrast expected in the image.
+        public int subpixelAccuracy; // Set this parameter to TRUE to return areas in the image that match the pattern area with subpixel accuracy.
+        public RotationAngleRange[] angleRanges; // An array of angle ranges, in degrees, where each range specifies how much you expect the pattern to be rotated in the image.
+        public double colorWeight; // Determines the percent contribution of the color score to the final color pattern matching score.
+        public ColorSensitivity sensitivity; // Specifies the sensitivity of the color information in the image.
+        public SearchStrategy strategy; // Specifies how the color features of the image are used during the search phase.
+        public int numMatchesRequested; // Number of valid matches expected.
+        public float minMatchScore; // The minimum score a match can have for the function to consider the match valid.
+        private ByteBuffer angleRanges_buf;
+
+        private void init() {
+            angleRanges = new RotationAngleRange[0];
+        }
+        public MatchColorPatternOptions() {
+            super(48);
+            init();
+        }
+        public MatchColorPatternOptions(MatchingMode matchMode, ImageFeatureMode featureMode, int minContrast, int subpixelAccuracy, RotationAngleRange[] angleRanges, double colorWeight, ColorSensitivity sensitivity, SearchStrategy strategy, int numMatchesRequested, double minMatchScore) {
+            super(48);
+            this.matchMode = matchMode;
+            this.featureMode = featureMode;
+            this.minContrast = minContrast;
+            this.subpixelAccuracy = subpixelAccuracy;
+            this.angleRanges = angleRanges;
+            this.colorWeight = colorWeight;
+            this.sensitivity = sensitivity;
+            this.strategy = strategy;
+            this.numMatchesRequested = numMatchesRequested;
+            this.minMatchScore = (float)minMatchScore;
+        }
+        protected MatchColorPatternOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 48);
+            init();
+        }
+        protected MatchColorPatternOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 48);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 48);
+        }
+        public void read() {
+            matchMode = MatchingMode.fromValue(backing.getInt(0));
+            featureMode = ImageFeatureMode.fromValue(backing.getInt(4));
+            minContrast = backing.getInt(8);
+            subpixelAccuracy = backing.getInt(12);
+            int angleRanges_numRanges = backing.getInt(20);
+            long angleRanges_addr = getPointer(backing, 16);
+            angleRanges = new RotationAngleRange[angleRanges_numRanges];
+            if (angleRanges_numRanges > 0 && angleRanges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(angleRanges_addr, angleRanges_numRanges*8);
+                for (int i=0, off=0; i<angleRanges_numRanges; i++, off += 8) {
+                    angleRanges[i] = new RotationAngleRange(bb, off);
+                    angleRanges[i].read();
+                }
+            }
+            colorWeight = backing.getDouble(24);
+            sensitivity = ColorSensitivity.fromValue(backing.getInt(32));
+            strategy = SearchStrategy.fromValue(backing.getInt(36));
+            numMatchesRequested = backing.getInt(40);
+            minMatchScore = backing.getFloat(44);
+        }
+        public void write() {
+            if (matchMode != null)
+                backing.putInt(0, matchMode.getValue());
+            if (featureMode != null)
+                backing.putInt(4, featureMode.getValue());
+            backing.putInt(8, minContrast);
+            backing.putInt(12, subpixelAccuracy);
+            angleRanges_buf = ByteBuffer.allocateDirect(angleRanges.length*8);
+            for (int i=0, off=0; i<angleRanges.length; i++, off += 8) {
+                angleRanges[i].setBuffer(angleRanges_buf, off);
+                angleRanges[i].write();
+            }
+            backing.putInt(20, angleRanges.length);
+            putPointer(backing, 16, angleRanges_buf);
+            backing.putDouble(24, colorWeight);
+            if (sensitivity != null)
+                backing.putInt(32, sensitivity.getValue());
+            if (strategy != null)
+                backing.putInt(36, strategy.getValue());
+            backing.putInt(40, numMatchesRequested);
+            backing.putFloat(44, minMatchScore);
+        }
+        public int size() {
+            return 48;
+        }
+    }
+
+    public static class HistogramReport extends DisposedStruct {
+        public int[] histogram; // An array describing the number of pixels that fell into each class.
+        public float min; // The smallest pixel value that the function classified.
+        public float max; // The largest pixel value that the function classified.
+        public float start; // The smallest pixel value that fell into the first class.
+        public float width; // The size of each class.
+        public float mean; // The mean value of the pixels that the function classified.
+        public float stdDev; // The standard deviation of the pixels that the function classified.
+        public int numPixels; // The number of pixels that the function classified.
+        private ByteBuffer histogram_buf;
+
+        private void init() {
+            histogram = new int[0];
+        }
+        public HistogramReport() {
+            super(36);
+            init();
+        }
+        public HistogramReport(int[] histogram, double min, double max, double start, double width, double mean, double stdDev, int numPixels) {
+            super(36);
+            this.histogram = histogram;
+            this.min = (float)min;
+            this.max = (float)max;
+            this.start = (float)start;
+            this.width = (float)width;
+            this.mean = (float)mean;
+            this.stdDev = (float)stdDev;
+            this.numPixels = numPixels;
+        }
+        protected HistogramReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 36);
+            init();
+        }
+        protected HistogramReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 36);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 36);
+        }
+        public void read() {
+            int histogram_histogramCount = backing.getInt(4);
+            long histogram_addr = getPointer(backing, 0);
+            histogram = new int[histogram_histogramCount];
+            if (histogram_histogramCount > 0 && histogram_addr != 0) {
+                newDirectByteBuffer(histogram_addr, histogram_histogramCount*4).asIntBuffer().get(histogram);
+            }
+            min = backing.getFloat(8);
+            max = backing.getFloat(12);
+            start = backing.getFloat(16);
+            width = backing.getFloat(20);
+            mean = backing.getFloat(24);
+            stdDev = backing.getFloat(28);
+            numPixels = backing.getInt(32);
+        }
+        public void write() {
+            histogram_buf = ByteBuffer.allocateDirect(histogram.length*4);
+            histogram_buf.asIntBuffer().put(histogram).rewind();
+            backing.putInt(4, histogram.length);
+            putPointer(backing, 0, histogram_buf);
+            backing.putFloat(8, min);
+            backing.putFloat(12, max);
+            backing.putFloat(16, start);
+            backing.putFloat(20, width);
+            backing.putFloat(24, mean);
+            backing.putFloat(28, stdDev);
+            backing.putInt(32, numPixels);
+        }
+        public int size() {
+            return 36;
+        }
+    }
+
+    public static class ArcInfo extends DisposedStruct {
+        public Rect boundingBox; // The coordinate location of the bounding box of the arc.
+        public double startAngle; // The counterclockwise angle from the x-axis in degrees to the start of the arc.
+        public double endAngle; // The counterclockwise angle from the x-axis in degrees to the end of the arc.
+
+        private void init() {
+            boundingBox = new Rect(backing, 0);
+        }
+        public ArcInfo() {
+            super(32);
+            init();
+        }
+        public ArcInfo(Rect boundingBox, double startAngle, double endAngle) {
+            super(32);
+            this.boundingBox = boundingBox;
+            this.startAngle = startAngle;
+            this.endAngle = endAngle;
+        }
+        protected ArcInfo(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected ArcInfo(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            boundingBox.read();
+            startAngle = backing.getDouble(16);
+            endAngle = backing.getDouble(24);
+        }
+        public void write() {
+            boundingBox.write();
+            backing.putDouble(16, startAngle);
+            backing.putDouble(24, endAngle);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class AxisReport extends DisposedStruct {
+        public PointFloat origin; // The origin of the coordinate system, which is the intersection of the two axes of the coordinate system.
+        public PointFloat mainAxisEnd; // The end of the main axis, which is the result of the computation of the intersection of the main axis with the rectangular search area.
+        public PointFloat secondaryAxisEnd; // The end of the secondary axis, which is the result of the computation of the intersection of the secondary axis with the rectangular search area.
+
+        private void init() {
+            origin = new PointFloat(backing, 0);
+            mainAxisEnd = new PointFloat(backing, 8);
+            secondaryAxisEnd = new PointFloat(backing, 16);
+        }
+        public AxisReport() {
+            super(24);
+            init();
+        }
+        public AxisReport(PointFloat origin, PointFloat mainAxisEnd, PointFloat secondaryAxisEnd) {
+            super(24);
+            this.origin = origin;
+            this.mainAxisEnd = mainAxisEnd;
+            this.secondaryAxisEnd = secondaryAxisEnd;
+        }
+        protected AxisReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected AxisReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            origin.read();
+            mainAxisEnd.read();
+            secondaryAxisEnd.read();
+        }
+        public void write() {
+            origin.write();
+            mainAxisEnd.write();
+            secondaryAxisEnd.write();
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class BarcodeInfo extends DisposedStruct {
+        public String outputString; // A string containing the decoded barcode data.
+        public int size; // The size of the output string.
+        public byte outputChar1; // The contents of this character depend on the barcode type.
+        public byte outputChar2; // The contents of this character depend on the barcode type.
+        public double confidenceLevel; // A quality measure of the decoded barcode ranging from 0 to 100, with 100 being the best.
+        public BarcodeType type; // The type of barcode.
+        private ByteBuffer outputString_buf;
+
+        private void init() {
+            
+        }
+        public BarcodeInfo() {
+            super(32);
+            init();
+        }
+        public BarcodeInfo(String outputString, int size, byte outputChar1, byte outputChar2, double confidenceLevel, BarcodeType type) {
+            super(32);
+            this.outputString = outputString;
+            this.size = size;
+            this.outputChar1 = outputChar1;
+            this.outputChar2 = outputChar2;
+            this.confidenceLevel = confidenceLevel;
+            this.type = type;
+        }
+        protected BarcodeInfo(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected BarcodeInfo(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            long outputString_addr = getPointer(backing, 0);
+            if (outputString_addr == 0)
+                outputString = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(outputString_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    outputString = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    outputString = "";
+                }
+            }
+            
+            size = backing.getInt(4);
+            outputChar1 = backing.get(8);
+            outputChar2 = backing.get(9);
+            confidenceLevel = backing.getDouble(16);
+            type = BarcodeType.fromValue(backing.getInt(24));
+        }
+        public void write() {
+            if (outputString != null) {
+                byte[] outputString_bytes;
+                try {
+                    outputString_bytes = outputString.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    outputString_bytes = new byte[0];
+                }
+                outputString_buf = ByteBuffer.allocateDirect(outputString_bytes.length+1);
+                putBytes(outputString_buf, outputString_bytes, 0, outputString_bytes.length).put(outputString_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, outputString == null ? 0 : getByteBufferAddress(outputString_buf));
+            backing.putInt(4, size);
+            backing.put(8, outputChar1);
+            backing.put(9, outputChar2);
+            backing.putDouble(16, confidenceLevel);
+            if (type != null)
+                backing.putInt(24, type.getValue());
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class BCGOptions extends DisposedStruct {
+        public float brightness; // Adjusts the brightness of the image.
+        public float contrast; // Adjusts the contrast of the image.
+        public float gamma; // Performs gamma correction.
+
+        private void init() {
+            
+        }
+        public BCGOptions() {
+            super(12);
+            init();
+        }
+        public BCGOptions(double brightness, double contrast, double gamma) {
+            super(12);
+            this.brightness = (float)brightness;
+            this.contrast = (float)contrast;
+            this.gamma = (float)gamma;
+        }
+        protected BCGOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected BCGOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            brightness = backing.getFloat(0);
+            contrast = backing.getFloat(4);
+            gamma = backing.getFloat(8);
+        }
+        public void write() {
+            backing.putFloat(0, brightness);
+            backing.putFloat(4, contrast);
+            backing.putFloat(8, gamma);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class BestCircle extends DisposedStruct {
+        public PointFloat center; // The coordinate location of the center of the circle.
+        public double radius; // The radius of the circle.
+        public double area; // The area of the circle.
+        public double perimeter; // The length of the perimeter of the circle.
+        public double error; // Represents the least square error of the fitted circle to the entire set of points.
+
+        private void init() {
+            center = new PointFloat(backing, 0);
+        }
+        public BestCircle() {
+            super(40);
+            init();
+        }
+        public BestCircle(PointFloat center, double radius, double area, double perimeter, double error) {
+            super(40);
+            this.center = center;
+            this.radius = radius;
+            this.area = area;
+            this.perimeter = perimeter;
+            this.error = error;
+        }
+        protected BestCircle(ByteBuffer backing, int offset) {
+            super(backing, offset, 40);
+            init();
+        }
+        protected BestCircle(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 40);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 40);
+        }
+        public void read() {
+            center.read();
+            radius = backing.getDouble(8);
+            area = backing.getDouble(16);
+            perimeter = backing.getDouble(24);
+            error = backing.getDouble(32);
+        }
+        public void write() {
+            center.write();
+            backing.putDouble(8, radius);
+            backing.putDouble(16, area);
+            backing.putDouble(24, perimeter);
+            backing.putDouble(32, error);
+        }
+        public int size() {
+            return 40;
+        }
+    }
+
+    public static class BestEllipse extends DisposedStruct {
+        public PointFloat center; // The coordinate location of the center of the ellipse.
+        public PointFloat majorAxisStart; // The coordinate location of the start of the major axis of the ellipse.
+        public PointFloat majorAxisEnd; // The coordinate location of the end of the major axis of the ellipse.
+        public PointFloat minorAxisStart; // The coordinate location of the start of the minor axis of the ellipse.
+        public PointFloat minorAxisEnd; // The coordinate location of the end of the minor axis of the ellipse.
+        public double area; // The area of the ellipse.
+        public double perimeter; // The length of the perimeter of the ellipse.
+
+        private void init() {
+            center = new PointFloat(backing, 0);
+            majorAxisStart = new PointFloat(backing, 8);
+            majorAxisEnd = new PointFloat(backing, 16);
+            minorAxisStart = new PointFloat(backing, 24);
+            minorAxisEnd = new PointFloat(backing, 32);
+        }
+        public BestEllipse() {
+            super(56);
+            init();
+        }
+        public BestEllipse(PointFloat center, PointFloat majorAxisStart, PointFloat majorAxisEnd, PointFloat minorAxisStart, PointFloat minorAxisEnd, double area, double perimeter) {
+            super(56);
+            this.center = center;
+            this.majorAxisStart = majorAxisStart;
+            this.majorAxisEnd = majorAxisEnd;
+            this.minorAxisStart = minorAxisStart;
+            this.minorAxisEnd = minorAxisEnd;
+            this.area = area;
+            this.perimeter = perimeter;
+        }
+        protected BestEllipse(ByteBuffer backing, int offset) {
+            super(backing, offset, 56);
+            init();
+        }
+        protected BestEllipse(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 56);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 56);
+        }
+        public void read() {
+            center.read();
+            majorAxisStart.read();
+            majorAxisEnd.read();
+            minorAxisStart.read();
+            minorAxisEnd.read();
+            area = backing.getDouble(40);
+            perimeter = backing.getDouble(48);
+        }
+        public void write() {
+            center.write();
+            majorAxisStart.write();
+            majorAxisEnd.write();
+            minorAxisStart.write();
+            minorAxisEnd.write();
+            backing.putDouble(40, area);
+            backing.putDouble(48, perimeter);
+        }
+        public int size() {
+            return 56;
+        }
+    }
+
+    public static class BestLine extends DisposedStruct {
+        public PointFloat start; // The coordinate location of the start of the line.
+        public PointFloat end; // The coordinate location of the end of the line.
+        public LineEquation equation; // Defines the three coefficients of the equation of the best fit line.
+        public int valid; // This element is TRUE if the function achieved the minimum score within the number of allowed refinement iterations and FALSE if the function did not achieve the minimum score.
+        public double error; // Represents the least square error of the fitted line to the entire set of points.
+        public int[] pointsUsed; // An array of the indexes for the points array indicating which points the function used to fit the line.
+        private ByteBuffer pointsUsed_buf;
+
+        private void init() {
+            start = new PointFloat(backing, 0);
+            end = new PointFloat(backing, 8);
+            equation = new LineEquation(backing, 16);
+            pointsUsed = new int[0];
+        }
+        public BestLine() {
+            super(64);
+            init();
+        }
+        public BestLine(PointFloat start, PointFloat end, LineEquation equation, int valid, double error, int[] pointsUsed) {
+            super(64);
+            this.start = start;
+            this.end = end;
+            this.equation = equation;
+            this.valid = valid;
+            this.error = error;
+            this.pointsUsed = pointsUsed;
+        }
+        protected BestLine(ByteBuffer backing, int offset) {
+            super(backing, offset, 64);
+            init();
+        }
+        protected BestLine(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 64);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 64);
+        }
+        public void read() {
+            start.read();
+            end.read();
+            equation.read();
+            valid = backing.getInt(40);
+            error = backing.getDouble(48);
+            int pointsUsed_numPointsUsed = backing.getInt(60);
+            long pointsUsed_addr = getPointer(backing, 56);
+            pointsUsed = new int[pointsUsed_numPointsUsed];
+            if (pointsUsed_numPointsUsed > 0 && pointsUsed_addr != 0) {
+                newDirectByteBuffer(pointsUsed_addr, pointsUsed_numPointsUsed*4).asIntBuffer().get(pointsUsed);
+            }
+        }
+        public void write() {
+            start.write();
+            end.write();
+            equation.write();
+            backing.putInt(40, valid);
+            backing.putDouble(48, error);
+            pointsUsed_buf = ByteBuffer.allocateDirect(pointsUsed.length*4);
+            pointsUsed_buf.asIntBuffer().put(pointsUsed).rewind();
+            backing.putInt(60, pointsUsed.length);
+            putPointer(backing, 56, pointsUsed_buf);
+        }
+        public int size() {
+            return 64;
+        }
+    }
+
+    public static class BrowserOptions extends DisposedStruct {
+        public int width; // The width to make the browser.
+        public int height; // The height to make the browser image.
+        public int imagesPerLine; // The number of images to place on a single line.
+        public RGBValue backgroundColor; // The background color of the browser.
+        public int frameSize; // Specifies the number of pixels with which to border each thumbnail.
+        public BrowserFrameStyle style; // The style for the frame around each thumbnail.
+        public float ratio; // Specifies the width to height ratio of each thumbnail.
+        public RGBValue focusColor; // The color to use to display focused cells.
+
+        private void init() {
+            backgroundColor = new RGBValue(backing, 12);
+            focusColor = new RGBValue(backing, 28);
+        }
+        public BrowserOptions() {
+            super(32);
+            init();
+        }
+        public BrowserOptions(int width, int height, int imagesPerLine, RGBValue backgroundColor, int frameSize, BrowserFrameStyle style, double ratio, RGBValue focusColor) {
+            super(32);
+            this.width = width;
+            this.height = height;
+            this.imagesPerLine = imagesPerLine;
+            this.backgroundColor = backgroundColor;
+            this.frameSize = frameSize;
+            this.style = style;
+            this.ratio = (float)ratio;
+            this.focusColor = focusColor;
+        }
+        protected BrowserOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected BrowserOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            width = backing.getInt(0);
+            height = backing.getInt(4);
+            imagesPerLine = backing.getInt(8);
+            backgroundColor.read();
+            frameSize = backing.getInt(16);
+            style = BrowserFrameStyle.fromValue(backing.getInt(20));
+            ratio = backing.getFloat(24);
+            focusColor.read();
+        }
+        public void write() {
+            backing.putInt(0, width);
+            backing.putInt(4, height);
+            backing.putInt(8, imagesPerLine);
+            backgroundColor.write();
+            backing.putInt(16, frameSize);
+            if (style != null)
+                backing.putInt(20, style.getValue());
+            backing.putFloat(24, ratio);
+            focusColor.write();
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class CoordinateSystem extends DisposedStruct {
+        public PointFloat origin; // The origin of the coordinate system.
+        public float angle; // The angle, in degrees, of the x-axis of the coordinate system relative to the image x-axis.
+        public AxisOrientation axisOrientation; // The direction of the y-axis of the coordinate reference system.
+
+        private void init() {
+            origin = new PointFloat(backing, 0);
+        }
+        public CoordinateSystem() {
+            super(16);
+            init();
+        }
+        public CoordinateSystem(PointFloat origin, double angle, AxisOrientation axisOrientation) {
+            super(16);
+            this.origin = origin;
+            this.angle = (float)angle;
+            this.axisOrientation = axisOrientation;
+        }
+        protected CoordinateSystem(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected CoordinateSystem(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            origin.read();
+            angle = backing.getFloat(8);
+            axisOrientation = AxisOrientation.fromValue(backing.getInt(12));
+        }
+        public void write() {
+            origin.write();
+            backing.putFloat(8, angle);
+            if (axisOrientation != null)
+                backing.putInt(12, axisOrientation.getValue());
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class CalibrationInfo extends DisposedStruct {
+        public int mapColumns; // The number of columns in the error map.
+        public int mapRows; // The number of rows in the error map.
+        public ROI userRoi; // Specifies the ROI the user provided when learning the calibration.
+        public ROI calibrationRoi; // Specifies the ROI that corresponds to the region of the image where the calibration information is accurate.
+        public LearnCalibrationOptions options; // Specifies the calibration options the user provided when learning the calibration.
+        public GridDescriptor grid; // Specifies the scaling constants for the image.
+        public CoordinateSystem system; // Specifies the coordinate system for the real world coordinates.
+        public RangeFloat range; // The range of the grayscale the function used to represent the circles in the grid image.
+        public float quality; // The quality score of the learning process, which is a value between 0-1000.
+
+        private void init() {
+            options = new LearnCalibrationOptions(backing, 20);
+            grid = new GridDescriptor(backing, 40);
+            system = new CoordinateSystem(backing, 52);
+            range = new RangeFloat(backing, 68);
+        }
+        public CalibrationInfo() {
+            super(80);
+            init();
+        }
+        public CalibrationInfo(int mapColumns, int mapRows, ROI userRoi, ROI calibrationRoi, LearnCalibrationOptions options, GridDescriptor grid, CoordinateSystem system, RangeFloat range, double quality) {
+            super(80);
+            this.mapColumns = mapColumns;
+            this.mapRows = mapRows;
+            this.userRoi = userRoi;
+            this.calibrationRoi = calibrationRoi;
+            this.options = options;
+            this.grid = grid;
+            this.system = system;
+            this.range = range;
+            this.quality = (float)quality;
+        }
+        protected CalibrationInfo(ByteBuffer backing, int offset) {
+            super(backing, offset, 80);
+            init();
+        }
+        protected CalibrationInfo(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 80);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 80);
+        }
+        public void read() {
+            mapColumns = backing.getInt(4);
+            mapRows = backing.getInt(8);
+            long userRoi_addr = getPointer(backing, 12);
+            if (userRoi_addr == 0)
+                userRoi = null;
+            else
+                userRoi = new ROI(userRoi_addr, false);
+            long calibrationRoi_addr = getPointer(backing, 16);
+            if (calibrationRoi_addr == 0)
+                calibrationRoi = null;
+            else
+                calibrationRoi = new ROI(calibrationRoi_addr, false);
+            options.read();
+            grid.read();
+            system.read();
+            range.read();
+            quality = backing.getFloat(76);
+        }
+        public void write() {
+            backing.putInt(4, mapColumns);
+            backing.putInt(8, mapRows);
+            putPointer(backing, 12, userRoi);
+            putPointer(backing, 16, calibrationRoi);
+            options.write();
+            grid.write();
+            system.write();
+            range.write();
+            backing.putFloat(76, quality);
+        }
+        public int size() {
+            return 80;
+        }
+    }
+
+    public static class CalibrationPoints extends DisposedStruct {
+        public PointFloat[] pixelCoordinates; // The array of pixel coordinates.
+        public PointFloat[] realWorldCoordinates; // The array of corresponding real-world coordinates.
+        private ByteBuffer pixelCoordinates_buf;
+        private ByteBuffer realWorldCoordinates_buf;
+
+        private void init() {
+            pixelCoordinates = new PointFloat[0];
+            realWorldCoordinates = new PointFloat[0];
+        }
+        public CalibrationPoints() {
+            super(12);
+            init();
+        }
+        public CalibrationPoints(PointFloat[] pixelCoordinates, PointFloat[] realWorldCoordinates) {
+            super(12);
+            this.pixelCoordinates = pixelCoordinates;
+            this.realWorldCoordinates = realWorldCoordinates;
+        }
+        protected CalibrationPoints(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected CalibrationPoints(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            int pixelCoordinates_numCoordinates = backing.getInt(8);
+            long pixelCoordinates_addr = getPointer(backing, 0);
+            pixelCoordinates = new PointFloat[pixelCoordinates_numCoordinates];
+            if (pixelCoordinates_numCoordinates > 0 && pixelCoordinates_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(pixelCoordinates_addr, pixelCoordinates_numCoordinates*8);
+                for (int i=0, off=0; i<pixelCoordinates_numCoordinates; i++, off += 8) {
+                    pixelCoordinates[i] = new PointFloat(bb, off);
+                    pixelCoordinates[i].read();
+                }
+            }
+            int realWorldCoordinates_numCoordinates = backing.getInt(8);
+            long realWorldCoordinates_addr = getPointer(backing, 4);
+            realWorldCoordinates = new PointFloat[realWorldCoordinates_numCoordinates];
+            if (realWorldCoordinates_numCoordinates > 0 && realWorldCoordinates_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(realWorldCoordinates_addr, realWorldCoordinates_numCoordinates*8);
+                for (int i=0, off=0; i<realWorldCoordinates_numCoordinates; i++, off += 8) {
+                    realWorldCoordinates[i] = new PointFloat(bb, off);
+                    realWorldCoordinates[i].read();
+                }
+            }
+        }
+        public void write() {
+            pixelCoordinates_buf = ByteBuffer.allocateDirect(pixelCoordinates.length*8);
+            for (int i=0, off=0; i<pixelCoordinates.length; i++, off += 8) {
+                pixelCoordinates[i].setBuffer(pixelCoordinates_buf, off);
+                pixelCoordinates[i].write();
+            }
+            backing.putInt(8, pixelCoordinates.length);
+            putPointer(backing, 0, pixelCoordinates_buf);
+            realWorldCoordinates_buf = ByteBuffer.allocateDirect(realWorldCoordinates.length*8);
+            for (int i=0, off=0; i<realWorldCoordinates.length; i++, off += 8) {
+                realWorldCoordinates[i].setBuffer(realWorldCoordinates_buf, off);
+                realWorldCoordinates[i].write();
+            }
+            backing.putInt(8, realWorldCoordinates.length);
+            putPointer(backing, 4, realWorldCoordinates_buf);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class CaliperOptions extends DisposedStruct {
+        public TwoEdgePolarityType polarity; // Specifies the edge polarity of the edge pairs.
+        public float separation; // The distance between edge pairs.
+        public float separationDeviation; // Sets the range around the separation value.
+
+        private void init() {
+            
+        }
+        public CaliperOptions() {
+            super(12);
+            init();
+        }
+        public CaliperOptions(TwoEdgePolarityType polarity, double separation, double separationDeviation) {
+            super(12);
+            this.polarity = polarity;
+            this.separation = (float)separation;
+            this.separationDeviation = (float)separationDeviation;
+        }
+        protected CaliperOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected CaliperOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            polarity = TwoEdgePolarityType.fromValue(backing.getInt(0));
+            separation = backing.getFloat(4);
+            separationDeviation = backing.getFloat(8);
+        }
+        public void write() {
+            if (polarity != null)
+                backing.putInt(0, polarity.getValue());
+            backing.putFloat(4, separation);
+            backing.putFloat(8, separationDeviation);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class CaliperReport extends DisposedStruct {
+        public float edge1Contrast; // The contrast of the first edge.
+        public PointFloat edge1Coord; // The coordinates of the first edge.
+        public float edge2Contrast; // The contrast of the second edge.
+        public PointFloat edge2Coord; // The coordinates of the second edge.
+        public float separation; // The distance between the two edges.
+
+        private void init() {
+            edge1Coord = new PointFloat(backing, 4);
+            edge2Coord = new PointFloat(backing, 16);
+        }
+        public CaliperReport() {
+            super(32);
+            init();
+        }
+        public CaliperReport(double edge1Contrast, PointFloat edge1Coord, double edge2Contrast, PointFloat edge2Coord, double separation) {
+            super(32);
+            this.edge1Contrast = (float)edge1Contrast;
+            this.edge1Coord = edge1Coord;
+            this.edge2Contrast = (float)edge2Contrast;
+            this.edge2Coord = edge2Coord;
+            this.separation = (float)separation;
+        }
+        protected CaliperReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected CaliperReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            edge1Contrast = backing.getFloat(0);
+            edge1Coord.read();
+            edge2Contrast = backing.getFloat(12);
+            edge2Coord.read();
+            separation = backing.getFloat(24);
+        }
+        public void write() {
+            backing.putFloat(0, edge1Contrast);
+            edge1Coord.write();
+            backing.putFloat(12, edge2Contrast);
+            edge2Coord.write();
+            backing.putFloat(24, separation);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class DrawTextOptions extends DisposedStruct {
+        public String fontName; // The font name to use.
+        public int fontSize; // The size of the font.
+        public int bold; // Set this parameter to TRUE to bold text.
+        public int italic; // Set this parameter to TRUE to italicize text.
+        public int underline; // Set this parameter to TRUE to underline text.
+        public int strikeout; // Set this parameter to TRUE to strikeout text.
+        public TextAlignment textAlignment; // Sets the alignment of text.
+        public FontColor fontColor; // Sets the font color.
+
+        private void init() {
+            
+        }
+        public DrawTextOptions() {
+            super(60);
+            init();
+        }
+        public DrawTextOptions(String fontName, int fontSize, int bold, int italic, int underline, int strikeout, TextAlignment textAlignment, FontColor fontColor) {
+            super(60);
+            this.fontName = fontName;
+            this.fontSize = fontSize;
+            this.bold = bold;
+            this.italic = italic;
+            this.underline = underline;
+            this.strikeout = strikeout;
+            this.textAlignment = textAlignment;
+            this.fontColor = fontColor;
+        }
+        protected DrawTextOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 60);
+            init();
+        }
+        protected DrawTextOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 60);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 60);
+        }
+        public void read() {
+            {
+                byte[] bytes = new byte[32];
+                getBytes(backing, bytes, 0, 32);
+                int len;
+                for (len=0; len<bytes.length && bytes[len] != 0; len++) {}
+                try {
+                    fontName = new String(bytes, 0, len, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    fontName = "";
+                }
+            }
+            fontSize = backing.getInt(32);
+            bold = backing.getInt(36);
+            italic = backing.getInt(40);
+            underline = backing.getInt(44);
+            strikeout = backing.getInt(48);
+            textAlignment = TextAlignment.fromValue(backing.getInt(52));
+            fontColor = FontColor.fromValue(backing.getInt(56));
+        }
+        public void write() {
+            if (fontName != null) {
+                byte[] bytes;
+                try {
+                    bytes = fontName.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    bytes = new byte[0];
+                }
+                putBytes(backing, bytes, 0, bytes.length);
+                for (int i=bytes.length; i<32; i++)
+                    backing.put(i, (byte)0); // fill with zero
+            }
+            backing.putInt(32, fontSize);
+            backing.putInt(36, bold);
+            backing.putInt(40, italic);
+            backing.putInt(44, underline);
+            backing.putInt(48, strikeout);
+            if (textAlignment != null)
+                backing.putInt(52, textAlignment.getValue());
+            if (fontColor != null)
+                backing.putInt(56, fontColor.getValue());
+        }
+        public int size() {
+            return 60;
+        }
+    }
+
+    public static class CircleReport extends DisposedStruct {
+        public Point center; // The coordinate point of the center of the circle.
+        public int radius; // The radius of the circle, in pixels.
+        public int area; // The area of the circle, in pixels.
+
+        private void init() {
+            center = new Point(backing, 0);
+        }
+        public CircleReport() {
+            super(16);
+            init();
+        }
+        public CircleReport(Point center, int radius, int area) {
+            super(16);
+            this.center = center;
+            this.radius = radius;
+            this.area = area;
+        }
+        protected CircleReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected CircleReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            center.read();
+            radius = backing.getInt(8);
+            area = backing.getInt(12);
+        }
+        public void write() {
+            center.write();
+            backing.putInt(8, radius);
+            backing.putInt(12, area);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class ClosedContour extends DisposedStruct {
+        public Point[] points; // The points that make up the closed contour.
+        private ByteBuffer points_buf;
+
+        private void init() {
+            points = new Point[0];
+        }
+        public ClosedContour() {
+            super(8);
+            init();
+        }
+        public ClosedContour(Point[] points) {
+            super(8);
+            this.points = points;
+        }
+        protected ClosedContour(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected ClosedContour(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            int points_numPoints = backing.getInt(4);
+            long points_addr = getPointer(backing, 0);
+            points = new Point[points_numPoints];
+            if (points_numPoints > 0 && points_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(points_addr, points_numPoints*8);
+                for (int i=0, off=0; i<points_numPoints; i++, off += 8) {
+                    points[i] = new Point(bb, off);
+                    points[i].read();
+                }
+            }
+        }
+        public void write() {
+            points_buf = ByteBuffer.allocateDirect(points.length*8);
+            for (int i=0, off=0; i<points.length; i++, off += 8) {
+                points[i].setBuffer(points_buf, off);
+                points[i].write();
+            }
+            backing.putInt(4, points.length);
+            putPointer(backing, 0, points_buf);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class ColorHistogramReport extends DisposedStruct {
+        public HistogramReport plane1; // The histogram report of the first color plane.
+        public HistogramReport plane2; // The histogram report of the second plane.
+        public HistogramReport plane3; // The histogram report of the third plane.
+
+        private void init() {
+            plane1 = new HistogramReport(backing, 0);
+            plane2 = new HistogramReport(backing, 36);
+            plane3 = new HistogramReport(backing, 72);
+        }
+        public ColorHistogramReport() {
+            super(108);
+            init();
+        }
+        public ColorHistogramReport(HistogramReport plane1, HistogramReport plane2, HistogramReport plane3) {
+            super(108);
+            this.plane1 = plane1;
+            this.plane2 = plane2;
+            this.plane3 = plane3;
+        }
+        protected ColorHistogramReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 108);
+            init();
+        }
+        protected ColorHistogramReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 108);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 108);
+        }
+        public void read() {
+            plane1.read();
+            plane2.read();
+            plane3.read();
+        }
+        public void write() {
+            plane1.write();
+            plane2.write();
+            plane3.write();
+        }
+        public int size() {
+            return 108;
+        }
+    }
+
+    public static class ColorInformation extends DisposedStruct {
+        public int saturation; // The saturation level the function uses to learn the color information.
+        public double[] info; // An array of color information that represents the color spectrum analysis of a region of an image in a compact form.
+        private ByteBuffer info_buf;
+
+        private void init() {
+            info = new double[0];
+        }
+        public ColorInformation() {
+            super(12);
+            init();
+        }
+        public ColorInformation(int saturation, double[] info) {
+            super(12);
+            this.saturation = saturation;
+            this.info = info;
+        }
+        protected ColorInformation(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected ColorInformation(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            saturation = backing.getInt(4);
+            int info_infoCount = backing.getInt(0);
+            long info_addr = getPointer(backing, 8);
+            info = new double[info_infoCount];
+            if (info_infoCount > 0 && info_addr != 0) {
+                newDirectByteBuffer(info_addr, info_infoCount*8).asDoubleBuffer().get(info);
+            }
+        }
+        public void write() {
+            backing.putInt(4, saturation);
+            info_buf = ByteBuffer.allocateDirect(info.length*8);
+            info_buf.asDoubleBuffer().put(info).rewind();
+            backing.putInt(0, info.length);
+            putPointer(backing, 8, info_buf);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class Complex extends DisposedStruct {
+        public float r; // The real part of the value.
+        public float i; // The imaginary part of the value.
+
+        private void init() {
+            
+        }
+        public Complex() {
+            super(8);
+            init();
+        }
+        public Complex(double r, double i) {
+            super(8);
+            this.r = (float)r;
+            this.i = (float)i;
+        }
+        protected Complex(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected Complex(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            r = backing.getFloat(0);
+            i = backing.getFloat(4);
+        }
+        public void write() {
+            backing.putFloat(0, r);
+            backing.putFloat(4, i);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class ConcentricRakeReport extends DisposedStruct {
+        public ArcInfo[] rakeArcs; // An array containing the location of each concentric arc line used for edge detection.
+        public PointFloat[] firstEdges; // The coordinate location of all edges detected as first edges.
+        public PointFloat[] lastEdges; // The coordinate location of all edges detected as last edges.
+        public EdgeLocationReport[] allEdges; // An array of reports describing the location of the edges located by each concentric rake arc line.
+        public int[] linesWithEdges; // An array of indices into the rakeArcs array indicating the concentric rake arc lines on which the function detected at least one edge.
+        private ByteBuffer rakeArcs_buf;
+        private ByteBuffer firstEdges_buf;
+        private ByteBuffer lastEdges_buf;
+        private ByteBuffer allEdges_buf;
+        private ByteBuffer linesWithEdges_buf;
+
+        private void init() {
+            rakeArcs = new ArcInfo[0];
+            firstEdges = new PointFloat[0];
+            lastEdges = new PointFloat[0];
+            allEdges = new EdgeLocationReport[0];
+            linesWithEdges = new int[0];
+        }
+        public ConcentricRakeReport() {
+            super(36);
+            init();
+        }
+        public ConcentricRakeReport(ArcInfo[] rakeArcs, PointFloat[] firstEdges, PointFloat[] lastEdges, EdgeLocationReport[] allEdges, int[] linesWithEdges) {
+            super(36);
+            this.rakeArcs = rakeArcs;
+            this.firstEdges = firstEdges;
+            this.lastEdges = lastEdges;
+            this.allEdges = allEdges;
+            this.linesWithEdges = linesWithEdges;
+        }
+        protected ConcentricRakeReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 36);
+            init();
+        }
+        protected ConcentricRakeReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 36);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 36);
+        }
+        public void read() {
+            int rakeArcs_numArcs = backing.getInt(4);
+            long rakeArcs_addr = getPointer(backing, 0);
+            rakeArcs = new ArcInfo[rakeArcs_numArcs];
+            if (rakeArcs_numArcs > 0 && rakeArcs_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(rakeArcs_addr, rakeArcs_numArcs*32);
+                for (int i=0, off=0; i<rakeArcs_numArcs; i++, off += 32) {
+                    rakeArcs[i] = new ArcInfo(bb, off);
+                    rakeArcs[i].read();
+                }
+            }
+            int firstEdges_numFirstEdges = backing.getInt(12);
+            long firstEdges_addr = getPointer(backing, 8);
+            firstEdges = new PointFloat[firstEdges_numFirstEdges];
+            if (firstEdges_numFirstEdges > 0 && firstEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(firstEdges_addr, firstEdges_numFirstEdges*8);
+                for (int i=0, off=0; i<firstEdges_numFirstEdges; i++, off += 8) {
+                    firstEdges[i] = new PointFloat(bb, off);
+                    firstEdges[i].read();
+                }
+            }
+            int lastEdges_numLastEdges = backing.getInt(20);
+            long lastEdges_addr = getPointer(backing, 16);
+            lastEdges = new PointFloat[lastEdges_numLastEdges];
+            if (lastEdges_numLastEdges > 0 && lastEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(lastEdges_addr, lastEdges_numLastEdges*8);
+                for (int i=0, off=0; i<lastEdges_numLastEdges; i++, off += 8) {
+                    lastEdges[i] = new PointFloat(bb, off);
+                    lastEdges[i].read();
+                }
+            }
+            int allEdges_numLinesWithEdges = backing.getInt(32);
+            long allEdges_addr = getPointer(backing, 24);
+            allEdges = new EdgeLocationReport[allEdges_numLinesWithEdges];
+            if (allEdges_numLinesWithEdges > 0 && allEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(allEdges_addr, allEdges_numLinesWithEdges*8);
+                for (int i=0, off=0; i<allEdges_numLinesWithEdges; i++, off += 8) {
+                    allEdges[i] = new EdgeLocationReport(bb, off);
+                    allEdges[i].read();
+                }
+            }
+            int linesWithEdges_numLinesWithEdges = backing.getInt(32);
+            long linesWithEdges_addr = getPointer(backing, 28);
+            linesWithEdges = new int[linesWithEdges_numLinesWithEdges];
+            if (linesWithEdges_numLinesWithEdges > 0 && linesWithEdges_addr != 0) {
+                newDirectByteBuffer(linesWithEdges_addr, linesWithEdges_numLinesWithEdges*4).asIntBuffer().get(linesWithEdges);
+            }
+        }
+        public void write() {
+            rakeArcs_buf = ByteBuffer.allocateDirect(rakeArcs.length*32);
+            for (int i=0, off=0; i<rakeArcs.length; i++, off += 32) {
+                rakeArcs[i].setBuffer(rakeArcs_buf, off);
+                rakeArcs[i].write();
+            }
+            backing.putInt(4, rakeArcs.length);
+            putPointer(backing, 0, rakeArcs_buf);
+            firstEdges_buf = ByteBuffer.allocateDirect(firstEdges.length*8);
+            for (int i=0, off=0; i<firstEdges.length; i++, off += 8) {
+                firstEdges[i].setBuffer(firstEdges_buf, off);
+                firstEdges[i].write();
+            }
+            backing.putInt(12, firstEdges.length);
+            putPointer(backing, 8, firstEdges_buf);
+            lastEdges_buf = ByteBuffer.allocateDirect(lastEdges.length*8);
+            for (int i=0, off=0; i<lastEdges.length; i++, off += 8) {
+                lastEdges[i].setBuffer(lastEdges_buf, off);
+                lastEdges[i].write();
+            }
+            backing.putInt(20, lastEdges.length);
+            putPointer(backing, 16, lastEdges_buf);
+            allEdges_buf = ByteBuffer.allocateDirect(allEdges.length*8);
+            for (int i=0, off=0; i<allEdges.length; i++, off += 8) {
+                allEdges[i].setBuffer(allEdges_buf, off);
+                allEdges[i].write();
+            }
+            backing.putInt(32, allEdges.length);
+            putPointer(backing, 24, allEdges_buf);
+            linesWithEdges_buf = ByteBuffer.allocateDirect(linesWithEdges.length*4);
+            linesWithEdges_buf.asIntBuffer().put(linesWithEdges).rewind();
+            backing.putInt(32, linesWithEdges.length);
+            putPointer(backing, 28, linesWithEdges_buf);
+        }
+        public int size() {
+            return 36;
+        }
+    }
+
+    public static class ConstructROIOptions extends DisposedStruct {
+        public int windowNumber; // The window number of the image window.
+        public String windowTitle; // Specifies the message string that the function displays in the title bar of the window.
+        public PaletteType type; // The palette type to use.
+        public RGBValue[] palette; // If type is IMAQ_PALETTE_USER, this array is the palette of colors to use with the window.
+        private ByteBuffer windowTitle_buf;
+        private ByteBuffer palette_buf;
+
+        private void init() {
+            palette = new RGBValue[0];
+        }
+        public ConstructROIOptions() {
+            super(20);
+            init();
+        }
+        public ConstructROIOptions(int windowNumber, String windowTitle, PaletteType type, RGBValue[] palette) {
+            super(20);
+            this.windowNumber = windowNumber;
+            this.windowTitle = windowTitle;
+            this.type = type;
+            this.palette = palette;
+        }
+        protected ConstructROIOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 20);
+            init();
+        }
+        protected ConstructROIOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 20);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 20);
+        }
+        public void read() {
+            windowNumber = backing.getInt(0);
+            long windowTitle_addr = getPointer(backing, 4);
+            if (windowTitle_addr == 0)
+                windowTitle = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(windowTitle_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    windowTitle = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    windowTitle = "";
+                }
+            }
+            
+            type = PaletteType.fromValue(backing.getInt(8));
+            int palette_numColors = backing.getInt(16);
+            long palette_addr = getPointer(backing, 12);
+            palette = new RGBValue[palette_numColors];
+            if (palette_numColors > 0 && palette_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(palette_addr, palette_numColors*4);
+                for (int i=0, off=0; i<palette_numColors; i++, off += 4) {
+                    palette[i] = new RGBValue(bb, off);
+                    palette[i].read();
+                }
+            }
+        }
+        public void write() {
+            backing.putInt(0, windowNumber);
+            if (windowTitle != null) {
+                byte[] windowTitle_bytes;
+                try {
+                    windowTitle_bytes = windowTitle.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    windowTitle_bytes = new byte[0];
+                }
+                windowTitle_buf = ByteBuffer.allocateDirect(windowTitle_bytes.length+1);
+                putBytes(windowTitle_buf, windowTitle_bytes, 0, windowTitle_bytes.length).put(windowTitle_bytes.length, (byte)0);
+            }
+            putPointer(backing, 4, windowTitle == null ? 0 : getByteBufferAddress(windowTitle_buf));
+            if (type != null)
+                backing.putInt(8, type.getValue());
+            palette_buf = ByteBuffer.allocateDirect(palette.length*4);
+            for (int i=0, off=0; i<palette.length; i++, off += 4) {
+                palette[i].setBuffer(palette_buf, off);
+                palette[i].write();
+            }
+            backing.putInt(16, palette.length);
+            putPointer(backing, 12, palette_buf);
+        }
+        public int size() {
+            return 20;
+        }
+    }
+
+    public static class ContourInfo extends DisposedStruct {
+        public ContourType type; // The contour type.
+        public Point[] points; // The points describing the contour.
+        public RGBValue contourColor; // The contour color.
+        private ByteBuffer points_buf;
+
+        private void init() {
+            points = new Point[0];
+            contourColor = new RGBValue(backing, 12);
+        }
+        public ContourInfo() {
+            super(16);
+            init();
+        }
+        public ContourInfo(ContourType type, Point[] points, RGBValue contourColor) {
+            super(16);
+            this.type = type;
+            this.points = points;
+            this.contourColor = contourColor;
+        }
+        protected ContourInfo(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected ContourInfo(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            type = ContourType.fromValue(backing.getInt(0));
+            int points_numPoints = backing.getInt(4);
+            long points_addr = getPointer(backing, 8);
+            points = new Point[points_numPoints];
+            if (points_numPoints > 0 && points_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(points_addr, points_numPoints*8);
+                for (int i=0, off=0; i<points_numPoints; i++, off += 8) {
+                    points[i] = new Point(bb, off);
+                    points[i].read();
+                }
+            }
+            contourColor.read();
+        }
+        public void write() {
+            if (type != null)
+                backing.putInt(0, type.getValue());
+            points_buf = ByteBuffer.allocateDirect(points.length*8);
+            for (int i=0, off=0; i<points.length; i++, off += 8) {
+                points[i].setBuffer(points_buf, off);
+                points[i].write();
+            }
+            backing.putInt(4, points.length);
+            putPointer(backing, 8, points_buf);
+            contourColor.write();
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class ContourInfo2 extends DisposedStruct {
+        public ContourType type; // The contour type.
+        public RGBValue color; // The contour color.
+        public Point point; // Use this member when the contour is of type IMAQ_POINT.
+        public Line line; // Use this member when the contour is of type IMAQ_LINE.
+        public Rect rect; // Use this member when the contour is of type IMAQ_RECT.
+        public Rect ovalBoundingBox; // Use this member when the contour is of type IMAQ_OVAL.
+        public ClosedContour closedContour; // Use this member when the contour is of type IMAQ_CLOSED_CONTOUR.
+        public OpenContour openContour; // Use this member when the contour is of type IMAQ_OPEN_CONTOUR.
+        public Annulus annulus; // Use this member when the contour is of type IMAQ_ANNULUS.
+        public RotatedRect rotatedRect; // Use this member when the contour is of type IMAQ_ROTATED_RECT.
+
+        private void init() {
+            color = new RGBValue(backing, 4);
+        }
+        public ContourInfo2() {
+            super(12);
+            init();
+        }
+        public ContourInfo2(ContourType type, RGBValue color) {
+            super(12);
+            this.type = type;
+            this.color = color;
+        }
+        protected ContourInfo2(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected ContourInfo2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            type = ContourType.fromValue(backing.getInt(0));
+            color.read();
+            if (type == ContourType.POINT) {
+                long point_addr = getPointer(backing, 8);
+                if (point_addr == 0)
+                    point = null;
+                else
+                    point = new Point(point_addr, false);
+            }
+            if (type == ContourType.LINE) {
+                long line_addr = getPointer(backing, 8);
+                if (line_addr == 0)
+                    line = null;
+                else
+                    line = new Line(line_addr, false);
+            }
+            if (type == ContourType.RECT) {
+                long rect_addr = getPointer(backing, 8);
+                if (rect_addr == 0)
+                    rect = null;
+                else
+                    rect = new Rect(rect_addr, false);
+            }
+            if (type == ContourType.OVAL) {
+                long ovalBoundingBox_addr = getPointer(backing, 8);
+                if (ovalBoundingBox_addr == 0)
+                    ovalBoundingBox = null;
+                else
+                    ovalBoundingBox = new Rect(ovalBoundingBox_addr, false);
+            }
+            if (type == ContourType.CLOSED_CONTOUR) {
+                long closedContour_addr = getPointer(backing, 8);
+                if (closedContour_addr == 0)
+                    closedContour = null;
+                else
+                    closedContour = new ClosedContour(closedContour_addr, false);
+            }
+            if (type == ContourType.OPEN_CONTOUR) {
+                long openContour_addr = getPointer(backing, 8);
+                if (openContour_addr == 0)
+                    openContour = null;
+                else
+                    openContour = new OpenContour(openContour_addr, false);
+            }
+            if (type == ContourType.ANNULUS) {
+                long annulus_addr = getPointer(backing, 8);
+                if (annulus_addr == 0)
+                    annulus = null;
+                else
+                    annulus = new Annulus(annulus_addr, false);
+            }
+            if (type == ContourType.ROTATED_RECT) {
+                long rotatedRect_addr = getPointer(backing, 8);
+                if (rotatedRect_addr == 0)
+                    rotatedRect = null;
+                else
+                    rotatedRect = new RotatedRect(rotatedRect_addr, false);
+            }
+        }
+        public void write() {
+            if (type != null)
+                backing.putInt(0, type.getValue());
+            color.write();
+            if (type == ContourType.POINT) {
+                putPointer(backing, 8, point);
+            }
+            if (type == ContourType.LINE) {
+                putPointer(backing, 8, line);
+            }
+            if (type == ContourType.RECT) {
+                putPointer(backing, 8, rect);
+            }
+            if (type == ContourType.OVAL) {
+                putPointer(backing, 8, ovalBoundingBox);
+            }
+            if (type == ContourType.CLOSED_CONTOUR) {
+                putPointer(backing, 8, closedContour);
+            }
+            if (type == ContourType.OPEN_CONTOUR) {
+                putPointer(backing, 8, openContour);
+            }
+            if (type == ContourType.ANNULUS) {
+                putPointer(backing, 8, annulus);
+            }
+            if (type == ContourType.ROTATED_RECT) {
+                putPointer(backing, 8, rotatedRect);
+            }
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class ContourPoint extends DisposedStruct {
+        public double x; // The x-coordinate value in the image.
+        public double y; // The y-coordinate value in the image.
+        public double curvature; // The change in slope at this edge point of the segment.
+        public double xDisplacement; // The x displacement of the current edge pixel from a cubic spline fit of the current edge segment.
+        public double yDisplacement; // The y displacement of the current edge pixel from a cubic spline fit of the current edge segment.
+
+        private void init() {
+            
+        }
+        public ContourPoint() {
+            super(40);
+            init();
+        }
+        public ContourPoint(double x, double y, double curvature, double xDisplacement, double yDisplacement) {
+            super(40);
+            this.x = x;
+            this.y = y;
+            this.curvature = curvature;
+            this.xDisplacement = xDisplacement;
+            this.yDisplacement = yDisplacement;
+        }
+        protected ContourPoint(ByteBuffer backing, int offset) {
+            super(backing, offset, 40);
+            init();
+        }
+        protected ContourPoint(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 40);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 40);
+        }
+        public void read() {
+            x = backing.getDouble(0);
+            y = backing.getDouble(8);
+            curvature = backing.getDouble(16);
+            xDisplacement = backing.getDouble(24);
+            yDisplacement = backing.getDouble(32);
+        }
+        public void write() {
+            backing.putDouble(0, x);
+            backing.putDouble(8, y);
+            backing.putDouble(16, curvature);
+            backing.putDouble(24, xDisplacement);
+            backing.putDouble(32, yDisplacement);
+        }
+        public int size() {
+            return 40;
+        }
+    }
+
+    public static class CoordinateTransform extends DisposedStruct {
+        public Point initialOrigin; // The origin of the initial coordinate system.
+        public float initialAngle; // The angle, in degrees, of the x-axis of the initial coordinate system relative to the image x-axis.
+        public Point finalOrigin; // The origin of the final coordinate system.
+        public float finalAngle; // The angle, in degrees, of the x-axis of the final coordinate system relative to the image x-axis.
+
+        private void init() {
+            initialOrigin = new Point(backing, 0);
+            finalOrigin = new Point(backing, 12);
+        }
+        public CoordinateTransform() {
+            super(24);
+            init();
+        }
+        public CoordinateTransform(Point initialOrigin, double initialAngle, Point finalOrigin, double finalAngle) {
+            super(24);
+            this.initialOrigin = initialOrigin;
+            this.initialAngle = (float)initialAngle;
+            this.finalOrigin = finalOrigin;
+            this.finalAngle = (float)finalAngle;
+        }
+        protected CoordinateTransform(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected CoordinateTransform(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            initialOrigin.read();
+            initialAngle = backing.getFloat(8);
+            finalOrigin.read();
+            finalAngle = backing.getFloat(20);
+        }
+        public void write() {
+            initialOrigin.write();
+            backing.putFloat(8, initialAngle);
+            finalOrigin.write();
+            backing.putFloat(20, finalAngle);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class CoordinateTransform2 extends DisposedStruct {
+        public CoordinateSystem referenceSystem; // Defines the coordinate system for input coordinates.
+        public CoordinateSystem measurementSystem; // Defines the coordinate system in which the function should perform measurements.
+
+        private void init() {
+            referenceSystem = new CoordinateSystem(backing, 0);
+            measurementSystem = new CoordinateSystem(backing, 16);
+        }
+        public CoordinateTransform2() {
+            super(32);
+            init();
+        }
+        public CoordinateTransform2(CoordinateSystem referenceSystem, CoordinateSystem measurementSystem) {
+            super(32);
+            this.referenceSystem = referenceSystem;
+            this.measurementSystem = measurementSystem;
+        }
+        protected CoordinateTransform2(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected CoordinateTransform2(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            referenceSystem.read();
+            measurementSystem.read();
+        }
+        public void write() {
+            referenceSystem.write();
+            measurementSystem.write();
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class CannyOptions extends DisposedStruct {
+        public float sigma; // The sigma of the Gaussian smoothing filter that the function applies to the image before edge detection.
+        public float upperThreshold; // The upper fraction of pixel values in the image from which the function chooses a seed or starting point of an edge segment.
+        public float lowerThreshold; // The function multiplies this value by upperThreshold to determine the lower threshold for all the pixels in an edge segment.
+        public int windowSize; // The window size of the Gaussian filter that the function applies to the image.
+
+        private void init() {
+            
+        }
+        public CannyOptions() {
+            super(16);
+            init();
+        }
+        public CannyOptions(double sigma, double upperThreshold, double lowerThreshold, int windowSize) {
+            super(16);
+            this.sigma = (float)sigma;
+            this.upperThreshold = (float)upperThreshold;
+            this.lowerThreshold = (float)lowerThreshold;
+            this.windowSize = windowSize;
+        }
+        protected CannyOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected CannyOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            sigma = backing.getFloat(0);
+            upperThreshold = backing.getFloat(4);
+            lowerThreshold = backing.getFloat(8);
+            windowSize = backing.getInt(12);
+        }
+        public void write() {
+            backing.putFloat(0, sigma);
+            backing.putFloat(4, upperThreshold);
+            backing.putFloat(8, lowerThreshold);
+            backing.putInt(12, windowSize);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class Range extends DisposedStruct {
+        public int minValue; // The minimum value of the range.
+        public int maxValue; // The maximum value of the range.
+
+        private void init() {
+            
+        }
+        public Range() {
+            super(8);
+            init();
+        }
+        public Range(int minValue, int maxValue) {
+            super(8);
+            this.minValue = minValue;
+            this.maxValue = maxValue;
+        }
+        protected Range(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected Range(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            minValue = backing.getInt(0);
+            maxValue = backing.getInt(4);
+        }
+        public void write() {
+            backing.putInt(0, minValue);
+            backing.putInt(4, maxValue);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class UserPointSymbol extends DisposedStruct {
+        public int cols; // Number of columns in the symbol.
+        public int rows; // Number of rows in the symbol.
+
+        private void init() {
+            
+        }
+        public UserPointSymbol() {
+            super(12);
+            init();
+        }
+        public UserPointSymbol(int cols, int rows) {
+            super(12);
+            this.cols = cols;
+            this.rows = rows;
+        }
+        protected UserPointSymbol(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected UserPointSymbol(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            cols = backing.getInt(0);
+            rows = backing.getInt(4);
+        }
+        public void write() {
+            backing.putInt(0, cols);
+            backing.putInt(4, rows);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class View3DOptions extends DisposedStruct {
+        public int sizeReduction; // A divisor the function uses when determining the final height and width of the 3D image.
+        public int maxHeight; // Defines the maximum height of a pixel from the image source drawn in 3D.
+        public Direction3D direction; // Defines the 3D orientation.
+        public float alpha; // Determines the angle between the horizontal and the baseline.
+        public float beta; // Determines the angle between the horizontal and the second baseline.
+        public int border; // Defines the border size.
+        public int background; // Defines the background color.
+        public Plane3D plane; // Indicates the view a function uses to show complex images.
+
+        private void init() {
+            
+        }
+        public View3DOptions() {
+            super(32);
+            init();
+        }
+        public View3DOptions(int sizeReduction, int maxHeight, Direction3D direction, double alpha, double beta, int border, int background, Plane3D plane) {
+            super(32);
+            this.sizeReduction = sizeReduction;
+            this.maxHeight = maxHeight;
+            this.direction = direction;
+            this.alpha = (float)alpha;
+            this.beta = (float)beta;
+            this.border = border;
+            this.background = background;
+            this.plane = plane;
+        }
+        protected View3DOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected View3DOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            sizeReduction = backing.getInt(0);
+            maxHeight = backing.getInt(4);
+            direction = Direction3D.fromValue(backing.getInt(8));
+            alpha = backing.getFloat(12);
+            beta = backing.getFloat(16);
+            border = backing.getInt(20);
+            background = backing.getInt(24);
+            plane = Plane3D.fromValue(backing.getInt(28));
+        }
+        public void write() {
+            backing.putInt(0, sizeReduction);
+            backing.putInt(4, maxHeight);
+            if (direction != null)
+                backing.putInt(8, direction.getValue());
+            backing.putFloat(12, alpha);
+            backing.putFloat(16, beta);
+            backing.putInt(20, border);
+            backing.putInt(24, background);
+            if (plane != null)
+                backing.putInt(28, plane.getValue());
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class MatchPatternOptions extends DisposedStruct {
+        public MatchingMode mode; // Specifies the method to use when looking for the pattern in the image.
+        public int minContrast; // Specifies the minimum contrast expected in the image.
+        public int subpixelAccuracy; // Set this element to TRUE to return areas in the image that match the pattern area with subpixel accuracy.
+        public RotationAngleRange[] angleRanges; // An array of angle ranges, in degrees, where each range specifies how much you expect the pattern to be rotated in the image.
+        public int numMatchesRequested; // Number of valid matches expected.
+        public int matchFactor; // Controls the number of potential matches that the function examines.
+        public float minMatchScore; // The minimum score a match can have for the function to consider the match valid.
+        private ByteBuffer angleRanges_buf;
+
+        private void init() {
+            angleRanges = new RotationAngleRange[0];
+        }
+        public MatchPatternOptions() {
+            super(32);
+            init();
+        }
+        public MatchPatternOptions(MatchingMode mode, int minContrast, int subpixelAccuracy, RotationAngleRange[] angleRanges, int numMatchesRequested, int matchFactor, double minMatchScore) {
+            super(32);
+            this.mode = mode;
+            this.minContrast = minContrast;
+            this.subpixelAccuracy = subpixelAccuracy;
+            this.angleRanges = angleRanges;
+            this.numMatchesRequested = numMatchesRequested;
+            this.matchFactor = matchFactor;
+            this.minMatchScore = (float)minMatchScore;
+        }
+        protected MatchPatternOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected MatchPatternOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            mode = MatchingMode.fromValue(backing.getInt(0));
+            minContrast = backing.getInt(4);
+            subpixelAccuracy = backing.getInt(8);
+            int angleRanges_numRanges = backing.getInt(16);
+            long angleRanges_addr = getPointer(backing, 12);
+            angleRanges = new RotationAngleRange[angleRanges_numRanges];
+            if (angleRanges_numRanges > 0 && angleRanges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(angleRanges_addr, angleRanges_numRanges*8);
+                for (int i=0, off=0; i<angleRanges_numRanges; i++, off += 8) {
+                    angleRanges[i] = new RotationAngleRange(bb, off);
+                    angleRanges[i].read();
+                }
+            }
+            numMatchesRequested = backing.getInt(20);
+            matchFactor = backing.getInt(24);
+            minMatchScore = backing.getFloat(28);
+        }
+        public void write() {
+            if (mode != null)
+                backing.putInt(0, mode.getValue());
+            backing.putInt(4, minContrast);
+            backing.putInt(8, subpixelAccuracy);
+            angleRanges_buf = ByteBuffer.allocateDirect(angleRanges.length*8);
+            for (int i=0, off=0; i<angleRanges.length; i++, off += 8) {
+                angleRanges[i].setBuffer(angleRanges_buf, off);
+                angleRanges[i].write();
+            }
+            backing.putInt(16, angleRanges.length);
+            putPointer(backing, 12, angleRanges_buf);
+            backing.putInt(20, numMatchesRequested);
+            backing.putInt(24, matchFactor);
+            backing.putFloat(28, minMatchScore);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    public static class TIFFFileOptions extends DisposedStruct {
+        public int rowsPerStrip; // Indicates the number of rows that the function writes per strip.
+        public PhotometricMode photoInterp; // Designates which photometric interpretation to use.
+        public TIFFCompressionType compressionType; // Indicates the type of compression to use on the TIFF file.
+
+        private void init() {
+            
+        }
+        public TIFFFileOptions() {
+            super(12);
+            init();
+        }
+        public TIFFFileOptions(int rowsPerStrip, PhotometricMode photoInterp, TIFFCompressionType compressionType) {
+            super(12);
+            this.rowsPerStrip = rowsPerStrip;
+            this.photoInterp = photoInterp;
+            this.compressionType = compressionType;
+        }
+        protected TIFFFileOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected TIFFFileOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            rowsPerStrip = backing.getInt(0);
+            photoInterp = PhotometricMode.fromValue(backing.getInt(4));
+            compressionType = TIFFCompressionType.fromValue(backing.getInt(8));
+        }
+        public void write() {
+            backing.putInt(0, rowsPerStrip);
+            if (photoInterp != null)
+                backing.putInt(4, photoInterp.getValue());
+            if (compressionType != null)
+                backing.putInt(8, compressionType.getValue());
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class OpenContour extends DisposedStruct {
+        public Point[] points; // The points that make up the open contour.
+        private ByteBuffer points_buf;
+
+        private void init() {
+            points = new Point[0];
+        }
+        public OpenContour() {
+            super(8);
+            init();
+        }
+        public OpenContour(Point[] points) {
+            super(8);
+            this.points = points;
+        }
+        protected OpenContour(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected OpenContour(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            int points_numPoints = backing.getInt(4);
+            long points_addr = getPointer(backing, 0);
+            points = new Point[points_numPoints];
+            if (points_numPoints > 0 && points_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(points_addr, points_numPoints*8);
+                for (int i=0, off=0; i<points_numPoints; i++, off += 8) {
+                    points[i] = new Point(bb, off);
+                    points[i].read();
+                }
+            }
+        }
+        public void write() {
+            points_buf = ByteBuffer.allocateDirect(points.length*8);
+            for (int i=0, off=0; i<points.length; i++, off += 8) {
+                points[i].setBuffer(points_buf, off);
+                points[i].write();
+            }
+            backing.putInt(4, points.length);
+            putPointer(backing, 0, points_buf);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class OverlayTextOptions extends DisposedStruct {
+        public String fontName; // The name of the font to use.
+        public int fontSize; // The size of the font.
+        public int bold; // Set this element to TRUE to bold the text.
+        public int italic; // Set this element to TRUE to italicize the text.
+        public int underline; // Set this element to TRUE to underline the text.
+        public int strikeout; // Set this element to TRUE to strikeout the text.
+        public TextAlignment horizontalTextAlignment; // Sets the alignment of the text.
+        public VerticalTextAlignment verticalTextAlignment; // Sets the vertical alignment for the text.
+        public RGBValue backgroundColor; // Sets the color for the text background pixels.
+        public double angle; // The counterclockwise angle, in degrees, of the text relative to the x-axis.
+        private ByteBuffer fontName_buf;
+
+        private void init() {
+            backgroundColor = new RGBValue(backing, 32);
+        }
+        public OverlayTextOptions() {
+            super(48);
+            init();
+        }
+        public OverlayTextOptions(String fontName, int fontSize, int bold, int italic, int underline, int strikeout, TextAlignment horizontalTextAlignment, VerticalTextAlignment verticalTextAlignment, RGBValue backgroundColor, double angle) {
+            super(48);
+            this.fontName = fontName;
+            this.fontSize = fontSize;
+            this.bold = bold;
+            this.italic = italic;
+            this.underline = underline;
+            this.strikeout = strikeout;
+            this.horizontalTextAlignment = horizontalTextAlignment;
+            this.verticalTextAlignment = verticalTextAlignment;
+            this.backgroundColor = backgroundColor;
+            this.angle = angle;
+        }
+        protected OverlayTextOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 48);
+            init();
+        }
+        protected OverlayTextOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 48);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 48);
+        }
+        public void read() {
+            long fontName_addr = getPointer(backing, 0);
+            if (fontName_addr == 0)
+                fontName = null;
+            else {
+                ByteBuffer bb = newDirectByteBuffer(fontName_addr, 1000); // FIXME
+                while (bb.get() != 0) {}
+                byte[] bytes = new byte[bb.position()-1];
+                getBytes(bb, bytes, 0, bytes.length);
+                try {
+                    fontName = new String(bytes, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    fontName = "";
+                }
+            }
+            
+            fontSize = backing.getInt(4);
+            bold = backing.getInt(8);
+            italic = backing.getInt(12);
+            underline = backing.getInt(16);
+            strikeout = backing.getInt(20);
+            horizontalTextAlignment = TextAlignment.fromValue(backing.getInt(24));
+            verticalTextAlignment = VerticalTextAlignment.fromValue(backing.getInt(28));
+            backgroundColor.read();
+            angle = backing.getDouble(40);
+        }
+        public void write() {
+            if (fontName != null) {
+                byte[] fontName_bytes;
+                try {
+                    fontName_bytes = fontName.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    fontName_bytes = new byte[0];
+                }
+                fontName_buf = ByteBuffer.allocateDirect(fontName_bytes.length+1);
+                putBytes(fontName_buf, fontName_bytes, 0, fontName_bytes.length).put(fontName_bytes.length, (byte)0);
+            }
+            putPointer(backing, 0, fontName == null ? 0 : getByteBufferAddress(fontName_buf));
+            backing.putInt(4, fontSize);
+            backing.putInt(8, bold);
+            backing.putInt(12, italic);
+            backing.putInt(16, underline);
+            backing.putInt(20, strikeout);
+            if (horizontalTextAlignment != null)
+                backing.putInt(24, horizontalTextAlignment.getValue());
+            if (verticalTextAlignment != null)
+                backing.putInt(28, verticalTextAlignment.getValue());
+            backgroundColor.write();
+            backing.putDouble(40, angle);
+        }
+        public int size() {
+            return 48;
+        }
+    }
+
+    public static class ParticleFilterCriteria extends DisposedStruct {
+        public MeasurementValue parameter; // The morphological measurement that the function uses for filtering.
+        public float lower; // The lower bound of the criteria range.
+        public float upper; // The upper bound of the criteria range.
+        public int exclude; // Set this element to TRUE to indicate that a match occurs when the value is outside the criteria range.
+
+        private void init() {
+            
+        }
+        public ParticleFilterCriteria() {
+            super(16);
+            init();
+        }
+        public ParticleFilterCriteria(MeasurementValue parameter, double lower, double upper, int exclude) {
+            super(16);
+            this.parameter = parameter;
+            this.lower = (float)lower;
+            this.upper = (float)upper;
+            this.exclude = exclude;
+        }
+        protected ParticleFilterCriteria(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected ParticleFilterCriteria(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            parameter = MeasurementValue.fromValue(backing.getInt(0));
+            lower = backing.getFloat(4);
+            upper = backing.getFloat(8);
+            exclude = backing.getInt(12);
+        }
+        public void write() {
+            if (parameter != null)
+                backing.putInt(0, parameter.getValue());
+            backing.putFloat(4, lower);
+            backing.putFloat(8, upper);
+            backing.putInt(12, exclude);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class ParticleReport extends DisposedStruct {
+        public int area; // The number of pixels in the particle.
+        public float calibratedArea; // The size of the particle, calibrated to the calibration information of the image.
+        public float perimeter; // The length of the perimeter, calibrated to the calibration information of the image.
+        public int numHoles; // The number of holes in the particle.
+        public int areaOfHoles; // The total surface area, in pixels, of all the holes in a particle.
+        public float perimeterOfHoles; // The length of the perimeter of all the holes in the particle calibrated to the calibration information of the image.
+        public Rect boundingBox; // The smallest rectangle that encloses the particle.
+        public float sigmaX; // The sum of the particle pixels on the x-axis.
+        public float sigmaY; // The sum of the particle pixels on the y-axis.
+        public float sigmaXX; // The sum of the particle pixels on the x-axis, squared.
+        public float sigmaYY; // The sum of the particle pixels on the y-axis, squared.
+        public float sigmaXY; // The sum of the particle pixels on the x-axis and y-axis.
+        public int longestLength; // The length of the longest horizontal line segment.
+        public Point longestPoint; // The location of the leftmost pixel of the longest segment in the particle.
+        public int projectionX; // The length of the particle when projected onto the x-axis.
+        public int projectionY; // The length of the particle when projected onto the y-axis.
+        public int connect8; // This element is TRUE if the function used connectivity-8 to determine if particles are touching.
+
+        private void init() {
+            boundingBox = new Rect(backing, 24);
+            longestPoint = new Point(backing, 64);
+        }
+        public ParticleReport() {
+            super(84);
+            init();
+        }
+        public ParticleReport(int area, double calibratedArea, double perimeter, int numHoles, int areaOfHoles, double perimeterOfHoles, Rect boundingBox, double sigmaX, double sigmaY, double sigmaXX, double sigmaYY, double sigmaXY, int longestLength, Point longestPoint, int projectionX, int projectionY, int connect8) {
+            super(84);
+            this.area = area;
+            this.calibratedArea = (float)calibratedArea;
+            this.perimeter = (float)perimeter;
+            this.numHoles = numHoles;
+            this.areaOfHoles = areaOfHoles;
+            this.perimeterOfHoles = (float)perimeterOfHoles;
+            this.boundingBox = boundingBox;
+            this.sigmaX = (float)sigmaX;
+            this.sigmaY = (float)sigmaY;
+            this.sigmaXX = (float)sigmaXX;
+            this.sigmaYY = (float)sigmaYY;
+            this.sigmaXY = (float)sigmaXY;
+            this.longestLength = longestLength;
+            this.longestPoint = longestPoint;
+            this.projectionX = projectionX;
+            this.projectionY = projectionY;
+            this.connect8 = connect8;
+        }
+        protected ParticleReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 84);
+            init();
+        }
+        protected ParticleReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 84);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 84);
+        }
+        public void read() {
+            area = backing.getInt(0);
+            calibratedArea = backing.getFloat(4);
+            perimeter = backing.getFloat(8);
+            numHoles = backing.getInt(12);
+            areaOfHoles = backing.getInt(16);
+            perimeterOfHoles = backing.getFloat(20);
+            boundingBox.read();
+            sigmaX = backing.getFloat(40);
+            sigmaY = backing.getFloat(44);
+            sigmaXX = backing.getFloat(48);
+            sigmaYY = backing.getFloat(52);
+            sigmaXY = backing.getFloat(56);
+            longestLength = backing.getInt(60);
+            longestPoint.read();
+            projectionX = backing.getInt(72);
+            projectionY = backing.getInt(76);
+            connect8 = backing.getInt(80);
+        }
+        public void write() {
+            backing.putInt(0, area);
+            backing.putFloat(4, calibratedArea);
+            backing.putFloat(8, perimeter);
+            backing.putInt(12, numHoles);
+            backing.putInt(16, areaOfHoles);
+            backing.putFloat(20, perimeterOfHoles);
+            boundingBox.write();
+            backing.putFloat(40, sigmaX);
+            backing.putFloat(44, sigmaY);
+            backing.putFloat(48, sigmaXX);
+            backing.putFloat(52, sigmaYY);
+            backing.putFloat(56, sigmaXY);
+            backing.putInt(60, longestLength);
+            longestPoint.write();
+            backing.putInt(72, projectionX);
+            backing.putInt(76, projectionY);
+            backing.putInt(80, connect8);
+        }
+        public int size() {
+            return 84;
+        }
+    }
+
+    public static class PatternMatch extends DisposedStruct {
+        public PointFloat position; // The location of the center of the match.
+        public float rotation; // The rotation of the match relative to the template image, in degrees.
+        public float scale; // The size of the match relative to the size of the template image, expressed as a percentage.
+        public float score; // The accuracy of the match.
+        public PointFloat[] corner; // An array of four points describing the rectangle surrounding the template image.
+
+        private void init() {
+            position = new PointFloat(backing, 0);
+            corner = new PointFloat[4];
+            
+            for (int i=0, off=20; i<4; i++, off += 8)
+                corner[i] = new PointFloat(backing, off);
+        }
+        public PatternMatch() {
+            super(52);
+            init();
+        }
+        public PatternMatch(PointFloat position, double rotation, double scale, double score, PointFloat[] corner) {
+            super(52);
+            this.position = position;
+            this.rotation = (float)rotation;
+            this.scale = (float)scale;
+            this.score = (float)score;
+            this.corner = corner;
+        }
+        protected PatternMatch(ByteBuffer backing, int offset) {
+            super(backing, offset, 52);
+            init();
+        }
+        protected PatternMatch(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 52);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 52);
+        }
+        public void read() {
+            position.read();
+            rotation = backing.getFloat(8);
+            scale = backing.getFloat(12);
+            score = backing.getFloat(16);
+            for (PointFloat it : corner) {
+                it.read();
+            }
+        }
+        public void write() {
+            position.write();
+            backing.putFloat(8, rotation);
+            backing.putFloat(12, scale);
+            backing.putFloat(16, score);
+            for (PointFloat it : corner) {
+                it.write();
+            }
+        }
+        public int size() {
+            return 52;
+        }
+    }
+
+    public static class QuantifyData extends DisposedStruct {
+        public float mean; // The mean value of the pixel values.
+        public float stdDev; // The standard deviation of the pixel values.
+        public float min; // The smallest pixel value.
+        public float max; // The largest pixel value.
+        public float calibratedArea; // The area, calibrated to the calibration information of the image.
+        public int pixelArea; // The area, in number of pixels.
+        public float relativeSize; // The proportion, expressed as a percentage, of the associated region relative to the whole image.
+
+        private void init() {
+            
+        }
+        public QuantifyData() {
+            super(28);
+            init();
+        }
+        public QuantifyData(double mean, double stdDev, double min, double max, double calibratedArea, int pixelArea, double relativeSize) {
+            super(28);
+            this.mean = (float)mean;
+            this.stdDev = (float)stdDev;
+            this.min = (float)min;
+            this.max = (float)max;
+            this.calibratedArea = (float)calibratedArea;
+            this.pixelArea = pixelArea;
+            this.relativeSize = (float)relativeSize;
+        }
+        protected QuantifyData(ByteBuffer backing, int offset) {
+            super(backing, offset, 28);
+            init();
+        }
+        protected QuantifyData(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 28);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 28);
+        }
+        public void read() {
+            mean = backing.getFloat(0);
+            stdDev = backing.getFloat(4);
+            min = backing.getFloat(8);
+            max = backing.getFloat(12);
+            calibratedArea = backing.getFloat(16);
+            pixelArea = backing.getInt(20);
+            relativeSize = backing.getFloat(24);
+        }
+        public void write() {
+            backing.putFloat(0, mean);
+            backing.putFloat(4, stdDev);
+            backing.putFloat(8, min);
+            backing.putFloat(12, max);
+            backing.putFloat(16, calibratedArea);
+            backing.putInt(20, pixelArea);
+            backing.putFloat(24, relativeSize);
+        }
+        public int size() {
+            return 28;
+        }
+    }
+
+    public static class QuantifyReport extends DisposedStruct {
+        public QuantifyData global; // Statistical data of the whole image.
+        public QuantifyData[] regions; // An array of QuantifyData structures containing statistical data of each region of the image.
+        private ByteBuffer regions_buf;
+
+        private void init() {
+            global = new QuantifyData(backing, 0);
+            regions = new QuantifyData[0];
+        }
+        public QuantifyReport() {
+            super(36);
+            init();
+        }
+        public QuantifyReport(QuantifyData global, QuantifyData[] regions) {
+            super(36);
+            this.global = global;
+            this.regions = regions;
+        }
+        protected QuantifyReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 36);
+            init();
+        }
+        protected QuantifyReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 36);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 36);
+        }
+        public void read() {
+            global.read();
+            int regions_regionCount = backing.getInt(32);
+            long regions_addr = getPointer(backing, 28);
+            regions = new QuantifyData[regions_regionCount];
+            if (regions_regionCount > 0 && regions_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(regions_addr, regions_regionCount*28);
+                for (int i=0, off=0; i<regions_regionCount; i++, off += 28) {
+                    regions[i] = new QuantifyData(bb, off);
+                    regions[i].read();
+                }
+            }
+        }
+        public void write() {
+            global.write();
+            regions_buf = ByteBuffer.allocateDirect(regions.length*28);
+            for (int i=0, off=0; i<regions.length; i++, off += 28) {
+                regions[i].setBuffer(regions_buf, off);
+                regions[i].write();
+            }
+            backing.putInt(32, regions.length);
+            putPointer(backing, 28, regions_buf);
+        }
+        public int size() {
+            return 36;
+        }
+    }
+
+    public static class RakeOptions extends DisposedStruct {
+        public int threshold; // Specifies the threshold value for the contrast of the edge.
+        public int width; // The number of pixels that the function averages to find the contrast at either side of the edge.
+        public int steepness; // The span, in pixels, of the slope of the edge projected along the path specified by the input points.
+        public int subsamplingRatio; // Specifies the number of pixels that separate two consecutive search lines.
+        public InterpolationMethod subpixelType; // The method for interpolating.
+        public int subpixelDivisions; // The number of samples the function obtains from a pixel.
+
+        private void init() {
+            
+        }
+        public RakeOptions() {
+            super(24);
+            init();
+        }
+        public RakeOptions(int threshold, int width, int steepness, int subsamplingRatio, InterpolationMethod subpixelType, int subpixelDivisions) {
+            super(24);
+            this.threshold = threshold;
+            this.width = width;
+            this.steepness = steepness;
+            this.subsamplingRatio = subsamplingRatio;
+            this.subpixelType = subpixelType;
+            this.subpixelDivisions = subpixelDivisions;
+        }
+        protected RakeOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected RakeOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            threshold = backing.getInt(0);
+            width = backing.getInt(4);
+            steepness = backing.getInt(8);
+            subsamplingRatio = backing.getInt(12);
+            subpixelType = InterpolationMethod.fromValue(backing.getInt(16));
+            subpixelDivisions = backing.getInt(20);
+        }
+        public void write() {
+            backing.putInt(0, threshold);
+            backing.putInt(4, width);
+            backing.putInt(8, steepness);
+            backing.putInt(12, subsamplingRatio);
+            if (subpixelType != null)
+                backing.putInt(16, subpixelType.getValue());
+            backing.putInt(20, subpixelDivisions);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class RakeReport extends DisposedStruct {
+        public LineFloat[] rakeLines; // The coordinate location of each of the rake lines used by the function.
+        public PointFloat[] firstEdges; // The coordinate location of all edges detected as first edges.
+        public PointFloat[] lastEdges; // The coordinate location of all edges detected as last edges.
+        public EdgeLocationReport[] allEdges; // An array of reports describing the location of the edges located by each rake line.
+        public int[] linesWithEdges; // An array of indices into the rakeLines array indicating the rake lines on which the function detected at least one edge.
+        private ByteBuffer rakeLines_buf;
+        private ByteBuffer firstEdges_buf;
+        private ByteBuffer lastEdges_buf;
+        private ByteBuffer allEdges_buf;
+        private ByteBuffer linesWithEdges_buf;
+
+        private void init() {
+            rakeLines = new LineFloat[0];
+            firstEdges = new PointFloat[0];
+            lastEdges = new PointFloat[0];
+            allEdges = new EdgeLocationReport[0];
+            linesWithEdges = new int[0];
+        }
+        public RakeReport() {
+            super(36);
+            init();
+        }
+        public RakeReport(LineFloat[] rakeLines, PointFloat[] firstEdges, PointFloat[] lastEdges, EdgeLocationReport[] allEdges, int[] linesWithEdges) {
+            super(36);
+            this.rakeLines = rakeLines;
+            this.firstEdges = firstEdges;
+            this.lastEdges = lastEdges;
+            this.allEdges = allEdges;
+            this.linesWithEdges = linesWithEdges;
+        }
+        protected RakeReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 36);
+            init();
+        }
+        protected RakeReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 36);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 36);
+        }
+        public void read() {
+            int rakeLines_numRakeLines = backing.getInt(4);
+            long rakeLines_addr = getPointer(backing, 0);
+            rakeLines = new LineFloat[rakeLines_numRakeLines];
+            if (rakeLines_numRakeLines > 0 && rakeLines_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(rakeLines_addr, rakeLines_numRakeLines*16);
+                for (int i=0, off=0; i<rakeLines_numRakeLines; i++, off += 16) {
+                    rakeLines[i] = new LineFloat(bb, off);
+                    rakeLines[i].read();
+                }
+            }
+            int firstEdges_numFirstEdges = backing.getInt(12);
+            long firstEdges_addr = getPointer(backing, 8);
+            firstEdges = new PointFloat[firstEdges_numFirstEdges];
+            if (firstEdges_numFirstEdges > 0 && firstEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(firstEdges_addr, firstEdges_numFirstEdges*8);
+                for (int i=0, off=0; i<firstEdges_numFirstEdges; i++, off += 8) {
+                    firstEdges[i] = new PointFloat(bb, off);
+                    firstEdges[i].read();
+                }
+            }
+            int lastEdges_numLastEdges = backing.getInt(20);
+            long lastEdges_addr = getPointer(backing, 16);
+            lastEdges = new PointFloat[lastEdges_numLastEdges];
+            if (lastEdges_numLastEdges > 0 && lastEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(lastEdges_addr, lastEdges_numLastEdges*8);
+                for (int i=0, off=0; i<lastEdges_numLastEdges; i++, off += 8) {
+                    lastEdges[i] = new PointFloat(bb, off);
+                    lastEdges[i].read();
+                }
+            }
+            int allEdges_numLinesWithEdges = backing.getInt(32);
+            long allEdges_addr = getPointer(backing, 24);
+            allEdges = new EdgeLocationReport[allEdges_numLinesWithEdges];
+            if (allEdges_numLinesWithEdges > 0 && allEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(allEdges_addr, allEdges_numLinesWithEdges*8);
+                for (int i=0, off=0; i<allEdges_numLinesWithEdges; i++, off += 8) {
+                    allEdges[i] = new EdgeLocationReport(bb, off);
+                    allEdges[i].read();
+                }
+            }
+            int linesWithEdges_numLinesWithEdges = backing.getInt(32);
+            long linesWithEdges_addr = getPointer(backing, 28);
+            linesWithEdges = new int[linesWithEdges_numLinesWithEdges];
+            if (linesWithEdges_numLinesWithEdges > 0 && linesWithEdges_addr != 0) {
+                newDirectByteBuffer(linesWithEdges_addr, linesWithEdges_numLinesWithEdges*4).asIntBuffer().get(linesWithEdges);
+            }
+        }
+        public void write() {
+            rakeLines_buf = ByteBuffer.allocateDirect(rakeLines.length*16);
+            for (int i=0, off=0; i<rakeLines.length; i++, off += 16) {
+                rakeLines[i].setBuffer(rakeLines_buf, off);
+                rakeLines[i].write();
+            }
+            backing.putInt(4, rakeLines.length);
+            putPointer(backing, 0, rakeLines_buf);
+            firstEdges_buf = ByteBuffer.allocateDirect(firstEdges.length*8);
+            for (int i=0, off=0; i<firstEdges.length; i++, off += 8) {
+                firstEdges[i].setBuffer(firstEdges_buf, off);
+                firstEdges[i].write();
+            }
+            backing.putInt(12, firstEdges.length);
+            putPointer(backing, 8, firstEdges_buf);
+            lastEdges_buf = ByteBuffer.allocateDirect(lastEdges.length*8);
+            for (int i=0, off=0; i<lastEdges.length; i++, off += 8) {
+                lastEdges[i].setBuffer(lastEdges_buf, off);
+                lastEdges[i].write();
+            }
+            backing.putInt(20, lastEdges.length);
+            putPointer(backing, 16, lastEdges_buf);
+            allEdges_buf = ByteBuffer.allocateDirect(allEdges.length*8);
+            for (int i=0, off=0; i<allEdges.length; i++, off += 8) {
+                allEdges[i].setBuffer(allEdges_buf, off);
+                allEdges[i].write();
+            }
+            backing.putInt(32, allEdges.length);
+            putPointer(backing, 24, allEdges_buf);
+            linesWithEdges_buf = ByteBuffer.allocateDirect(linesWithEdges.length*4);
+            linesWithEdges_buf.asIntBuffer().put(linesWithEdges).rewind();
+            backing.putInt(32, linesWithEdges.length);
+            putPointer(backing, 28, linesWithEdges_buf);
+        }
+        public int size() {
+            return 36;
+        }
+    }
+
+    public static class TransformReport extends DisposedStruct {
+        public PointFloat[] points; // An array of transformed coordinates.
+        public int[] validPoints; // An array of values that describe the validity of each of the coordinates according to the region of interest you calibrated using either imaqLearnCalibrationGrid() or imaqLearnCalibrationPoints().
+        private ByteBuffer points_buf;
+        private ByteBuffer validPoints_buf;
+
+        private void init() {
+            points = new PointFloat[0];
+            validPoints = new int[0];
+        }
+        public TransformReport() {
+            super(12);
+            init();
+        }
+        public TransformReport(PointFloat[] points, int[] validPoints) {
+            super(12);
+            this.points = points;
+            this.validPoints = validPoints;
+        }
+        protected TransformReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected TransformReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            int points_numPoints = backing.getInt(8);
+            long points_addr = getPointer(backing, 0);
+            points = new PointFloat[points_numPoints];
+            if (points_numPoints > 0 && points_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(points_addr, points_numPoints*8);
+                for (int i=0, off=0; i<points_numPoints; i++, off += 8) {
+                    points[i] = new PointFloat(bb, off);
+                    points[i].read();
+                }
+            }
+            int validPoints_numPoints = backing.getInt(8);
+            long validPoints_addr = getPointer(backing, 4);
+            validPoints = new int[validPoints_numPoints];
+            if (validPoints_numPoints > 0 && validPoints_addr != 0) {
+                newDirectByteBuffer(validPoints_addr, validPoints_numPoints*4).asIntBuffer().get(validPoints);
+            }
+        }
+        public void write() {
+            points_buf = ByteBuffer.allocateDirect(points.length*8);
+            for (int i=0, off=0; i<points.length; i++, off += 8) {
+                points[i].setBuffer(points_buf, off);
+                points[i].write();
+            }
+            backing.putInt(8, points.length);
+            putPointer(backing, 0, points_buf);
+            validPoints_buf = ByteBuffer.allocateDirect(validPoints.length*4);
+            validPoints_buf.asIntBuffer().put(validPoints).rewind();
+            backing.putInt(8, validPoints.length);
+            putPointer(backing, 4, validPoints_buf);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class ShapeReport extends DisposedStruct {
+        public Rect coordinates; // The bounding rectangle of the object.
+        public Point centroid; // The coordinate location of the centroid of the object.
+        public int size; // The size, in pixels, of the object.
+        public double score; // A value ranging between 1 and 1,000 that specifies how similar the object in the image is to the template.
+
+        private void init() {
+            coordinates = new Rect(backing, 0);
+            centroid = new Point(backing, 16);
+        }
+        public ShapeReport() {
+            super(40);
+            init();
+        }
+        public ShapeReport(Rect coordinates, Point centroid, int size, double score) {
+            super(40);
+            this.coordinates = coordinates;
+            this.centroid = centroid;
+            this.size = size;
+            this.score = score;
+        }
+        protected ShapeReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 40);
+            init();
+        }
+        protected ShapeReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 40);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 40);
+        }
+        public void read() {
+            coordinates.read();
+            centroid.read();
+            size = backing.getInt(24);
+            score = backing.getDouble(32);
+        }
+        public void write() {
+            coordinates.write();
+            centroid.write();
+            backing.putInt(24, size);
+            backing.putDouble(32, score);
+        }
+        public int size() {
+            return 40;
+        }
+    }
+
+    public static class MeterArc extends DisposedStruct {
+        public PointFloat needleBase; // The coordinate location of the base of the meter needle.
+        public PointFloat[] arcCoordPoints; // An array of points describing the coordinate location of the meter arc.
+        public int needleColor; // This element is TRUE when the meter has a light-colored needle on a dark background.
+        private ByteBuffer arcCoordPoints_buf;
+
+        private void init() {
+            needleBase = new PointFloat(backing, 0);
+            arcCoordPoints = new PointFloat[0];
+        }
+        public MeterArc() {
+            super(20);
+            init();
+        }
+        public MeterArc(PointFloat needleBase, PointFloat[] arcCoordPoints, int needleColor) {
+            super(20);
+            this.needleBase = needleBase;
+            this.arcCoordPoints = arcCoordPoints;
+            this.needleColor = needleColor;
+        }
+        protected MeterArc(ByteBuffer backing, int offset) {
+            super(backing, offset, 20);
+            init();
+        }
+        protected MeterArc(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 20);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 20);
+        }
+        public void read() {
+            needleBase.read();
+            int arcCoordPoints_numOfArcCoordPoints = backing.getInt(12);
+            long arcCoordPoints_addr = getPointer(backing, 8);
+            arcCoordPoints = new PointFloat[arcCoordPoints_numOfArcCoordPoints];
+            if (arcCoordPoints_numOfArcCoordPoints > 0 && arcCoordPoints_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(arcCoordPoints_addr, arcCoordPoints_numOfArcCoordPoints*8);
+                for (int i=0, off=0; i<arcCoordPoints_numOfArcCoordPoints; i++, off += 8) {
+                    arcCoordPoints[i] = new PointFloat(bb, off);
+                    arcCoordPoints[i].read();
+                }
+            }
+            needleColor = backing.getInt(16);
+        }
+        public void write() {
+            needleBase.write();
+            arcCoordPoints_buf = ByteBuffer.allocateDirect(arcCoordPoints.length*8);
+            for (int i=0, off=0; i<arcCoordPoints.length; i++, off += 8) {
+                arcCoordPoints[i].setBuffer(arcCoordPoints_buf, off);
+                arcCoordPoints[i].write();
+            }
+            backing.putInt(12, arcCoordPoints.length);
+            putPointer(backing, 8, arcCoordPoints_buf);
+            backing.putInt(16, needleColor);
+        }
+        public int size() {
+            return 20;
+        }
+    }
+
+    public static class ThresholdData extends DisposedStruct {
+        public float rangeMin; // The lower boundary of the range to keep.
+        public float rangeMax; // The upper boundary of the range to keep.
+        public float newValue; // If useNewValue is TRUE, newValue is the replacement value for pixels within the range.
+        public int useNewValue; // If TRUE, the function sets pixel values within [rangeMin, rangeMax] to the value specified in newValue.
+
+        private void init() {
+            
+        }
+        public ThresholdData() {
+            super(16);
+            init();
+        }
+        public ThresholdData(double rangeMin, double rangeMax, double newValue, int useNewValue) {
+            super(16);
+            this.rangeMin = (float)rangeMin;
+            this.rangeMax = (float)rangeMax;
+            this.newValue = (float)newValue;
+            this.useNewValue = useNewValue;
+        }
+        protected ThresholdData(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected ThresholdData(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            rangeMin = backing.getFloat(0);
+            rangeMax = backing.getFloat(4);
+            newValue = backing.getFloat(8);
+            useNewValue = backing.getInt(12);
+        }
+        public void write() {
+            backing.putFloat(0, rangeMin);
+            backing.putFloat(4, rangeMax);
+            backing.putFloat(8, newValue);
+            backing.putInt(12, useNewValue);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class StructuringElement extends DisposedStruct {
+        public int matrixCols; // Number of columns in the matrix.
+        public int matrixRows; // Number of rows in the matrix.
+        public int hexa; // Set this element to TRUE if you specify a hexagonal structuring element in kernel.
+
+        private void init() {
+            
+        }
+        public StructuringElement() {
+            super(16);
+            init();
+        }
+        public StructuringElement(int matrixCols, int matrixRows, int hexa) {
+            super(16);
+            this.matrixCols = matrixCols;
+            this.matrixRows = matrixRows;
+            this.hexa = hexa;
+        }
+        protected StructuringElement(ByteBuffer backing, int offset) {
+            super(backing, offset, 16);
+            init();
+        }
+        protected StructuringElement(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 16);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 16);
+        }
+        public void read() {
+            matrixCols = backing.getInt(0);
+            matrixRows = backing.getInt(4);
+            hexa = backing.getInt(8);
+        }
+        public void write() {
+            backing.putInt(0, matrixCols);
+            backing.putInt(4, matrixRows);
+            backing.putInt(8, hexa);
+        }
+        public int size() {
+            return 16;
+        }
+    }
+
+    public static class SpokeReport extends DisposedStruct {
+        public LineFloat[] spokeLines; // The coordinate location of each of the spoke lines used by the function.
+        public PointFloat[] firstEdges; // The coordinate location of all edges detected as first edges.
+        public PointFloat[] lastEdges; // The coordinate location of all edges detected as last edges.
+        public EdgeLocationReport[] allEdges; // An array of reports describing the location of the edges located by each spoke line.
+        public int[] linesWithEdges; // An array of indices into the spokeLines array indicating the rake lines on which the function detected at least one edge.
+        private ByteBuffer spokeLines_buf;
+        private ByteBuffer firstEdges_buf;
+        private ByteBuffer lastEdges_buf;
+        private ByteBuffer allEdges_buf;
+        private ByteBuffer linesWithEdges_buf;
+
+        private void init() {
+            spokeLines = new LineFloat[0];
+            firstEdges = new PointFloat[0];
+            lastEdges = new PointFloat[0];
+            allEdges = new EdgeLocationReport[0];
+            linesWithEdges = new int[0];
+        }
+        public SpokeReport() {
+            super(36);
+            init();
+        }
+        public SpokeReport(LineFloat[] spokeLines, PointFloat[] firstEdges, PointFloat[] lastEdges, EdgeLocationReport[] allEdges, int[] linesWithEdges) {
+            super(36);
+            this.spokeLines = spokeLines;
+            this.firstEdges = firstEdges;
+            this.lastEdges = lastEdges;
+            this.allEdges = allEdges;
+            this.linesWithEdges = linesWithEdges;
+        }
+        protected SpokeReport(ByteBuffer backing, int offset) {
+            super(backing, offset, 36);
+            init();
+        }
+        protected SpokeReport(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 36);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 36);
+        }
+        public void read() {
+            int spokeLines_numSpokeLines = backing.getInt(4);
+            long spokeLines_addr = getPointer(backing, 0);
+            spokeLines = new LineFloat[spokeLines_numSpokeLines];
+            if (spokeLines_numSpokeLines > 0 && spokeLines_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(spokeLines_addr, spokeLines_numSpokeLines*16);
+                for (int i=0, off=0; i<spokeLines_numSpokeLines; i++, off += 16) {
+                    spokeLines[i] = new LineFloat(bb, off);
+                    spokeLines[i].read();
+                }
+            }
+            int firstEdges_numFirstEdges = backing.getInt(12);
+            long firstEdges_addr = getPointer(backing, 8);
+            firstEdges = new PointFloat[firstEdges_numFirstEdges];
+            if (firstEdges_numFirstEdges > 0 && firstEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(firstEdges_addr, firstEdges_numFirstEdges*8);
+                for (int i=0, off=0; i<firstEdges_numFirstEdges; i++, off += 8) {
+                    firstEdges[i] = new PointFloat(bb, off);
+                    firstEdges[i].read();
+                }
+            }
+            int lastEdges_numLastEdges = backing.getInt(20);
+            long lastEdges_addr = getPointer(backing, 16);
+            lastEdges = new PointFloat[lastEdges_numLastEdges];
+            if (lastEdges_numLastEdges > 0 && lastEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(lastEdges_addr, lastEdges_numLastEdges*8);
+                for (int i=0, off=0; i<lastEdges_numLastEdges; i++, off += 8) {
+                    lastEdges[i] = new PointFloat(bb, off);
+                    lastEdges[i].read();
+                }
+            }
+            int allEdges_numLinesWithEdges = backing.getInt(32);
+            long allEdges_addr = getPointer(backing, 24);
+            allEdges = new EdgeLocationReport[allEdges_numLinesWithEdges];
+            if (allEdges_numLinesWithEdges > 0 && allEdges_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(allEdges_addr, allEdges_numLinesWithEdges*8);
+                for (int i=0, off=0; i<allEdges_numLinesWithEdges; i++, off += 8) {
+                    allEdges[i] = new EdgeLocationReport(bb, off);
+                    allEdges[i].read();
+                }
+            }
+            int linesWithEdges_numLinesWithEdges = backing.getInt(32);
+            long linesWithEdges_addr = getPointer(backing, 28);
+            linesWithEdges = new int[linesWithEdges_numLinesWithEdges];
+            if (linesWithEdges_numLinesWithEdges > 0 && linesWithEdges_addr != 0) {
+                newDirectByteBuffer(linesWithEdges_addr, linesWithEdges_numLinesWithEdges*4).asIntBuffer().get(linesWithEdges);
+            }
+        }
+        public void write() {
+            spokeLines_buf = ByteBuffer.allocateDirect(spokeLines.length*16);
+            for (int i=0, off=0; i<spokeLines.length; i++, off += 16) {
+                spokeLines[i].setBuffer(spokeLines_buf, off);
+                spokeLines[i].write();
+            }
+            backing.putInt(4, spokeLines.length);
+            putPointer(backing, 0, spokeLines_buf);
+            firstEdges_buf = ByteBuffer.allocateDirect(firstEdges.length*8);
+            for (int i=0, off=0; i<firstEdges.length; i++, off += 8) {
+                firstEdges[i].setBuffer(firstEdges_buf, off);
+                firstEdges[i].write();
+            }
+            backing.putInt(12, firstEdges.length);
+            putPointer(backing, 8, firstEdges_buf);
+            lastEdges_buf = ByteBuffer.allocateDirect(lastEdges.length*8);
+            for (int i=0, off=0; i<lastEdges.length; i++, off += 8) {
+                lastEdges[i].setBuffer(lastEdges_buf, off);
+                lastEdges[i].write();
+            }
+            backing.putInt(20, lastEdges.length);
+            putPointer(backing, 16, lastEdges_buf);
+            allEdges_buf = ByteBuffer.allocateDirect(allEdges.length*8);
+            for (int i=0, off=0; i<allEdges.length; i++, off += 8) {
+                allEdges[i].setBuffer(allEdges_buf, off);
+                allEdges[i].write();
+            }
+            backing.putInt(32, allEdges.length);
+            putPointer(backing, 24, allEdges_buf);
+            linesWithEdges_buf = ByteBuffer.allocateDirect(linesWithEdges.length*4);
+            linesWithEdges_buf.asIntBuffer().put(linesWithEdges).rewind();
+            backing.putInt(32, linesWithEdges.length);
+            putPointer(backing, 28, linesWithEdges_buf);
+        }
+        public int size() {
+            return 36;
+        }
+    }
+
+    public static class SimpleEdgeOptions extends DisposedStruct {
+        public LevelType type; // Determines how the function evaluates the threshold and hysteresis values.
+        public int threshold; // The pixel value at which an edge occurs.
+        public int hysteresis; // A value that helps determine edges in noisy images.
+        public EdgeProcess process; // Determines which edges the function looks for.
+        public int subpixel; // Set this element to TRUE to find edges with subpixel accuracy by interpolating between points to find the crossing of the given threshold.
+
+        private void init() {
+            
+        }
+        public SimpleEdgeOptions() {
+            super(20);
+            init();
+        }
+        public SimpleEdgeOptions(LevelType type, int threshold, int hysteresis, EdgeProcess process, int subpixel) {
+            super(20);
+            this.type = type;
+            this.threshold = threshold;
+            this.hysteresis = hysteresis;
+            this.process = process;
+            this.subpixel = subpixel;
+        }
+        protected SimpleEdgeOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 20);
+            init();
+        }
+        protected SimpleEdgeOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 20);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 20);
+        }
+        public void read() {
+            type = LevelType.fromValue(backing.getInt(0));
+            threshold = backing.getInt(4);
+            hysteresis = backing.getInt(8);
+            process = EdgeProcess.fromValue(backing.getInt(12));
+            subpixel = backing.getInt(16);
+        }
+        public void write() {
+            if (type != null)
+                backing.putInt(0, type.getValue());
+            backing.putInt(4, threshold);
+            backing.putInt(8, hysteresis);
+            if (process != null)
+                backing.putInt(12, process.getValue());
+            backing.putInt(16, subpixel);
+        }
+        public int size() {
+            return 20;
+        }
+    }
+
+    public static class SelectParticleCriteria extends DisposedStruct {
+        public MeasurementValue parameter; // The morphological measurement that the function uses for filtering.
+        public float lower; // The lower boundary of the criteria range.
+        public float upper; // The upper boundary of the criteria range.
+
+        private void init() {
+            
+        }
+        public SelectParticleCriteria() {
+            super(12);
+            init();
+        }
+        public SelectParticleCriteria(MeasurementValue parameter, double lower, double upper) {
+            super(12);
+            this.parameter = parameter;
+            this.lower = (float)lower;
+            this.upper = (float)upper;
+        }
+        protected SelectParticleCriteria(ByteBuffer backing, int offset) {
+            super(backing, offset, 12);
+            init();
+        }
+        protected SelectParticleCriteria(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 12);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 12);
+        }
+        public void read() {
+            parameter = MeasurementValue.fromValue(backing.getInt(0));
+            lower = backing.getFloat(4);
+            upper = backing.getFloat(8);
+        }
+        public void write() {
+            if (parameter != null)
+                backing.putInt(0, parameter.getValue());
+            backing.putFloat(4, lower);
+            backing.putFloat(8, upper);
+        }
+        public int size() {
+            return 12;
+        }
+    }
+
+    public static class SegmentInfo extends DisposedStruct {
+        public int numberOfPoints; // The number of points in the segment.
+        public int isOpen; // If TRUE, the contour is open.
+        public double weight; // The significance of the edge in terms of the gray values that constitute the edge.
+        public ContourPoint points; // The points of the segment.
+
+        private void init() {
+            
+        }
+        public SegmentInfo() {
+            super(24);
+            init();
+        }
+        public SegmentInfo(int numberOfPoints, int isOpen, double weight, ContourPoint points) {
+            super(24);
+            this.numberOfPoints = numberOfPoints;
+            this.isOpen = isOpen;
+            this.weight = weight;
+            this.points = points;
+        }
+        protected SegmentInfo(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected SegmentInfo(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            numberOfPoints = backing.getInt(0);
+            isOpen = backing.getInt(4);
+            weight = backing.getDouble(8);
+            long points_addr = getPointer(backing, 16);
+            if (points_addr == 0)
+                points = null;
+            else
+                points = new ContourPoint(points_addr, false);
+        }
+        public void write() {
+            backing.putInt(0, numberOfPoints);
+            backing.putInt(4, isOpen);
+            backing.putDouble(8, weight);
+            putPointer(backing, 16, points);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class RotationAngleRange extends DisposedStruct {
+        public float lower; // The lowest amount of rotation, in degrees, a valid pattern can have.
+        public float upper; // The highest amount of rotation, in degrees, a valid pattern can have.
+
+        private void init() {
+            
+        }
+        public RotationAngleRange() {
+            super(8);
+            init();
+        }
+        public RotationAngleRange(double lower, double upper) {
+            super(8);
+            this.lower = (float)lower;
+            this.upper = (float)upper;
+        }
+        protected RotationAngleRange(ByteBuffer backing, int offset) {
+            super(backing, offset, 8);
+            init();
+        }
+        protected RotationAngleRange(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 8);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 8);
+        }
+        public void read() {
+            lower = backing.getFloat(0);
+            upper = backing.getFloat(4);
+        }
+        public void write() {
+            backing.putFloat(0, lower);
+            backing.putFloat(4, upper);
+        }
+        public int size() {
+            return 8;
+        }
+    }
+
+    public static class RotatedRect extends DisposedStruct {
+        public int top; // Location of the top edge of the rectangle before rotation.
+        public int left; // Location of the left edge of the rectangle before rotation.
+        public int height; // Height of the rectangle.
+        public int width; // Width of the rectangle.
+        public double angle; // The rotation, in degrees, of the rectangle.
+
+        private void init() {
+            
+        }
+        public RotatedRect() {
+            super(24);
+            init();
+        }
+        public RotatedRect(int top, int left, int height, int width, double angle) {
+            super(24);
+            this.top = top;
+            this.left = left;
+            this.height = height;
+            this.width = width;
+            this.angle = angle;
+        }
+        protected RotatedRect(ByteBuffer backing, int offset) {
+            super(backing, offset, 24);
+            init();
+        }
+        protected RotatedRect(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 24);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 24);
+        }
+        public void read() {
+            top = backing.getInt(0);
+            left = backing.getInt(4);
+            height = backing.getInt(8);
+            width = backing.getInt(12);
+            angle = backing.getDouble(16);
+        }
+        public void write() {
+            backing.putInt(0, top);
+            backing.putInt(4, left);
+            backing.putInt(8, height);
+            backing.putInt(12, width);
+            backing.putDouble(16, angle);
+        }
+        public int size() {
+            return 24;
+        }
+    }
+
+    public static class ROIProfile extends DisposedStruct {
+        public LineProfile report; // Quantifying information about the points along the edge of each contour in the ROI.
+        public Point pixels; // An array of the points along the edge of each contour in the ROI.
+
+        private void init() {
+            report = new LineProfile(backing, 0);
+        }
+        public ROIProfile() {
+            super(44);
+            init();
+        }
+        public ROIProfile(LineProfile report, Point pixels) {
+            super(44);
+            this.report = report;
+            this.pixels = pixels;
+        }
+        protected ROIProfile(ByteBuffer backing, int offset) {
+            super(backing, offset, 44);
+            init();
+        }
+        protected ROIProfile(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 44);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 44);
+        }
+        public void read() {
+            report.read();
+            long pixels_addr = getPointer(backing, 40);
+            if (pixels_addr == 0)
+                pixels = null;
+            else
+                pixels = new Point(pixels_addr, false);
+        }
+        public void write() {
+            report.write();
+            putPointer(backing, 40, pixels);
+        }
+        public int size() {
+            return 44;
+        }
+    }
+
+    public static class ToolWindowOptions extends DisposedStruct {
+        public int showSelectionTool; // If TRUE, the selection tool becomes visible.
+        public int showZoomTool; // If TRUE, the zoom tool becomes visible.
+        public int showPointTool; // If TRUE, the point tool becomes visible.
+        public int showLineTool; // If TRUE, the line tool becomes visible.
+        public int showRectangleTool; // If TRUE, the rectangle tool becomes visible.
+        public int showOvalTool; // If TRUE, the oval tool becomes visible.
+        public int showPolygonTool; // If TRUE, the polygon tool becomes visible.
+        public int showClosedFreehandTool; // If TRUE, the closed freehand tool becomes visible.
+        public int showPolyLineTool; // If TRUE, the polyline tool becomes visible.
+        public int showFreehandTool; // If TRUE, the freehand tool becomes visible.
+        public int showAnnulusTool; // If TRUE, the annulus becomes visible.
+        public int showRotatedRectangleTool; // If TRUE, the rotated rectangle tool becomes visible.
+        public int showPanTool; // If TRUE, the pan tool becomes visible.
+        public int showZoomOutTool; // If TRUE, the zoom out tool becomes visible.
+
+        private void init() {
+            
+        }
+        public ToolWindowOptions() {
+            super(68);
+            init();
+        }
+        public ToolWindowOptions(int showSelectionTool, int showZoomTool, int showPointTool, int showLineTool, int showRectangleTool, int showOvalTool, int showPolygonTool, int showClosedFreehandTool, int showPolyLineTool, int showFreehandTool, int showAnnulusTool, int showRotatedRectangleTool, int showPanTool, int showZoomOutTool) {
+            super(68);
+            this.showSelectionTool = showSelectionTool;
+            this.showZoomTool = showZoomTool;
+            this.showPointTool = showPointTool;
+            this.showLineTool = showLineTool;
+            this.showRectangleTool = showRectangleTool;
+            this.showOvalTool = showOvalTool;
+            this.showPolygonTool = showPolygonTool;
+            this.showClosedFreehandTool = showClosedFreehandTool;
+            this.showPolyLineTool = showPolyLineTool;
+            this.showFreehandTool = showFreehandTool;
+            this.showAnnulusTool = showAnnulusTool;
+            this.showRotatedRectangleTool = showRotatedRectangleTool;
+            this.showPanTool = showPanTool;
+            this.showZoomOutTool = showZoomOutTool;
+        }
+        protected ToolWindowOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 68);
+            init();
+        }
+        protected ToolWindowOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 68);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 68);
+        }
+        public void read() {
+            showSelectionTool = backing.getInt(0);
+            showZoomTool = backing.getInt(4);
+            showPointTool = backing.getInt(8);
+            showLineTool = backing.getInt(12);
+            showRectangleTool = backing.getInt(16);
+            showOvalTool = backing.getInt(20);
+            showPolygonTool = backing.getInt(24);
+            showClosedFreehandTool = backing.getInt(28);
+            showPolyLineTool = backing.getInt(32);
+            showFreehandTool = backing.getInt(36);
+            showAnnulusTool = backing.getInt(40);
+            showRotatedRectangleTool = backing.getInt(44);
+            showPanTool = backing.getInt(48);
+            showZoomOutTool = backing.getInt(52);
+        }
+        public void write() {
+            backing.putInt(0, showSelectionTool);
+            backing.putInt(4, showZoomTool);
+            backing.putInt(8, showPointTool);
+            backing.putInt(12, showLineTool);
+            backing.putInt(16, showRectangleTool);
+            backing.putInt(20, showOvalTool);
+            backing.putInt(24, showPolygonTool);
+            backing.putInt(28, showClosedFreehandTool);
+            backing.putInt(32, showPolyLineTool);
+            backing.putInt(36, showFreehandTool);
+            backing.putInt(40, showAnnulusTool);
+            backing.putInt(44, showRotatedRectangleTool);
+            backing.putInt(48, showPanTool);
+            backing.putInt(52, showZoomOutTool);
+        }
+        public int size() {
+            return 68;
+        }
+    }
+
+    public static class SpokeOptions extends DisposedStruct {
+        public int threshold; // Specifies the threshold value for the contrast of the edge.
+        public int width; // The number of pixels that the function averages to find the contrast at either side of the edge.
+        public int steepness; // The span, in pixels, of the slope of the edge projected along the path specified by the input points.
+        public double subsamplingRatio; // The angle, in degrees, between each radial search line in the spoke.
+        public InterpolationMethod subpixelType; // The method for interpolating.
+        public int subpixelDivisions; // The number of samples the function obtains from a pixel.
+
+        private void init() {
+            
+        }
+        public SpokeOptions() {
+            super(32);
+            init();
+        }
+        public SpokeOptions(int threshold, int width, int steepness, double subsamplingRatio, InterpolationMethod subpixelType, int subpixelDivisions) {
+            super(32);
+            this.threshold = threshold;
+            this.width = width;
+            this.steepness = steepness;
+            this.subsamplingRatio = subsamplingRatio;
+            this.subpixelType = subpixelType;
+            this.subpixelDivisions = subpixelDivisions;
+        }
+        protected SpokeOptions(ByteBuffer backing, int offset) {
+            super(backing, offset, 32);
+            init();
+        }
+        protected SpokeOptions(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 32);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 32);
+        }
+        public void read() {
+            threshold = backing.getInt(0);
+            width = backing.getInt(4);
+            steepness = backing.getInt(8);
+            subsamplingRatio = backing.getDouble(16);
+            subpixelType = InterpolationMethod.fromValue(backing.getInt(24));
+            subpixelDivisions = backing.getInt(28);
+        }
+        public void write() {
+            backing.putInt(0, threshold);
+            backing.putInt(4, width);
+            backing.putInt(8, steepness);
+            backing.putDouble(16, subsamplingRatio);
+            if (subpixelType != null)
+                backing.putInt(24, subpixelType.getValue());
+            backing.putInt(28, subpixelDivisions);
+        }
+        public int size() {
+            return 32;
+        }
+    }
+
+    /**
+     * Globals
+     */
+    public static final Rect NO_RECT = new Rect( 0, 0, 0x7FFFFFFF, 0x7FFFFFFF);
+    public static final RotatedRect NO_ROTATED_RECT = new RotatedRect( 0, 0, 0x7FFFFFFF, 0x7FFFFFFF, 0);
+    public static final Point NO_POINT = new Point( -1, -1);
+    public static final PointFloat NO_POINT_FLOAT = new PointFloat( -1.0, -1.0 );
+    public static final PointFloat NO_OFFSET = new PointFloat( 0.0, 0.0 );
+    public static final RGBValue RGB_TRANSPARENT = new RGBValue(0, 0, 0, 1);
+    public static final RGBValue RGB_RED = new RGBValue(0, 0, 255, 0);
+    public static final RGBValue RGB_BLUE = new RGBValue(255, 0, 0, 0);
+    public static final RGBValue RGB_GREEN = new RGBValue(0, 255, 0, 0);
+    public static final RGBValue RGB_YELLOW = new RGBValue(0, 255, 255, 0);
+    public static final RGBValue RGB_WHITE = new RGBValue(255, 255, 255, 0);
+    public static final RGBValue RGB_BLACK = new RGBValue(0, 0, 0, 0);
+
+    /**
+     * Logical functions
+     */
+
+    public static void imaqAnd(Image dest, Image sourceA, Image sourceB) {
+        
+        _imaqAnd(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());
+        
+    }
+    private static native void _imaqAnd(long dest, long sourceA, long sourceB);
+
+    public static void imaqCompare(Image dest, Image source, Image compareImage, ComparisonFunction compare) {
+        
+        _imaqCompare(dest.getAddress(), source.getAddress(), compareImage.getAddress(), compare.getValue());
+        
+    }
+    private static native void _imaqCompare(long dest, long source, long compareImage, int compare);
+
+    public static void imaqLogicalDifference(Image dest, Image sourceA, Image sourceB) {
+        
+        _imaqLogicalDifference(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());
+        
+    }
+    private static native void _imaqLogicalDifference(long dest, long sourceA, long sourceB);
+
+    public static void imaqNand(Image dest, Image sourceA, Image sourceB) {
+        
+        _imaqNand(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());
+        
+    }
+    private static native void _imaqNand(long dest, long sourceA, long sourceB);
+
+    public static void imaqNor(Image dest, Image sourceA, Image sourceB) {
+        
+        _imaqNor(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());
+        
+    }
+    private static native void _imaqNor(long dest, long sourceA, long sourceB);
+
+    public static void imaqOr(Image dest, Image sourceA, Image sourceB) {
+        
+        _imaqOr(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());
+        
+    }
+    private static native void _imaqOr(long dest, long sourceA, long sourceB);
+
+    public static void imaqXnor(Image dest, Image sourceA, Image sourceB) {
+        
+        _imaqXnor(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());
+        
+    }
+    private static native void _imaqXnor(long dest, long sourceA, long sourceB);
+
+    public static void imaqXor(Image dest, Image sourceA, Image sourceB) {
+        
+        _imaqXor(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());
+        
+    }
+    private static native void _imaqXor(long dest, long sourceA, long sourceB);
+
+    /**
+     * Particle Analysis functions
+     */
+
+    public static int imaqCountParticles(Image image, int connectivity8) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqCountParticles(image.getAddress(), connectivity8, rv_addr+0);
+        int numParticles;
+        numParticles = rv_buf.getInt(0);
+        return numParticles;
+    }
+    private static native int _imaqCountParticles(long image, int connectivity8, long numParticles);
+
+    public static double imaqMeasureParticle(Image image, int particleNumber, int calibrated, MeasurementType measurement) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        double jn_rv = _imaqMeasureParticle(image.getAddress(), particleNumber, calibrated, measurement.getValue(), rv_addr+0);
+        double value;
+        value = rv_buf.getDouble(0);
+        return value;
+    }
+    private static native double _imaqMeasureParticle(long image, int particleNumber, int calibrated, int measurement, long value);
+
+    public static MeasureParticlesReport imaqMeasureParticles(Image image, MeasureParticlesCalibrationMode calibrationMode, MeasurementType[] measurements) {
+        int numMeasurements = measurements.length;
+        ByteBuffer measurements_buf = null;
+        measurements_buf = ByteBuffer.allocateDirect(measurements.length*4);
+        for (int i=0, off=0; i<measurements.length; i++, off += 4) {
+            if (measurements != null)
+                measurements_buf.putInt(off, measurements[i].getValue());
+        }
+        long jn_rv = _imaqMeasureParticles(image.getAddress(), calibrationMode.getValue(), getByteBufferAddress(measurements_buf), numMeasurements);
+        
+        return new MeasureParticlesReport(jn_rv, true);
+    }
+    private static native long _imaqMeasureParticles(long image, int calibrationMode, long measurements, int numMeasurements);
+
+    public static int imaqParticleFilter4(Image dest, Image source, ParticleFilterCriteria2[] criteria, ParticleFilterOptions2 options, ROI roi) {
+        int criteriaCount = criteria.length;
+        ByteBuffer criteria_buf = null;
+        criteria_buf = ByteBuffer.allocateDirect(criteria.length*20);
+        for (int i=0, off=0; i<criteria.length; i++, off += 20) {
+            criteria[i].setBuffer(criteria_buf, off);
+            criteria[i].write();
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqParticleFilter4(dest.getAddress(), source.getAddress(), getByteBufferAddress(criteria_buf), criteriaCount, options.getAddress(), roi.getAddress(), rv_addr+0);
+        int numParticles;
+        numParticles = rv_buf.getInt(0);
+        return numParticles;
+    }
+    private static native int _imaqParticleFilter4(long dest, long source, long criteria, int criteriaCount, long options, long roi, long numParticles);
+
+    /**
+     * Morphology functions
+     */
+
+    public static void imaqConvexHull(Image dest, Image source, int connectivity8) {
+        
+        _imaqConvexHull(dest.getAddress(), source.getAddress(), connectivity8);
+        
+    }
+    private static native void _imaqConvexHull(long dest, long source, int connectivity8);
+
+    public static void imaqDanielssonDistance(Image dest, Image source) {
+        
+        _imaqDanielssonDistance(dest.getAddress(), source.getAddress());
+        
+    }
+    private static native void _imaqDanielssonDistance(long dest, long source);
+
+    public static void imaqFillHoles(Image dest, Image source, int connectivity8) {
+        
+        _imaqFillHoles(dest.getAddress(), source.getAddress(), connectivity8);
+        
+    }
+    private static native void _imaqFillHoles(long dest, long source, int connectivity8);
+
+    public static class FindCirclesResult {
+        public CircleReport[] array;
+        private long array_addr;
+        private FindCirclesResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numCircles;
+            array_numCircles = rv_buf.getInt(0);
+            array = new CircleReport[array_numCircles];
+            if (array_numCircles > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numCircles*16);
+                for (int i=0, off=0; i<array_numCircles; i++, off += 16) {
+                    array[i] = new CircleReport(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static FindCirclesResult imaqFindCircles(Image dest, Image source, float minRadius, float maxRadius) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqFindCircles(dest.getAddress(), source.getAddress(), minRadius, maxRadius, rv_addr+0);
+        FindCirclesResult rv = new FindCirclesResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqFindCircles(long dest, long source, float minRadius, float maxRadius, long numCircles);
+
+    public static int imaqLabel2(Image dest, Image source, int connectivity8) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqLabel2(dest.getAddress(), source.getAddress(), connectivity8, rv_addr+0);
+        int particleCount;
+        particleCount = rv_buf.getInt(0);
+        return particleCount;
+    }
+    private static native int _imaqLabel2(long dest, long source, int connectivity8, long particleCount);
+
+    public static void imaqMorphology(Image dest, Image source, MorphologyMethod method, StructuringElement structuringElement) {
+        
+        _imaqMorphology(dest.getAddress(), source.getAddress(), method.getValue(), structuringElement == null ? 0 : structuringElement.getAddress());
+        
+    }
+    private static native void _imaqMorphology(long dest, long source, int method, long structuringElement);
+
+    public static void imaqRejectBorder(Image dest, Image source, int connectivity8) {
+        
+        _imaqRejectBorder(dest.getAddress(), source.getAddress(), connectivity8);
+        
+    }
+    private static native void _imaqRejectBorder(long dest, long source, int connectivity8);
+
+    public static void imaqSegmentation(Image dest, Image source) {
+        
+        _imaqSegmentation(dest.getAddress(), source.getAddress());
+        
+    }
+    private static native void _imaqSegmentation(long dest, long source);
+
+    public static void imaqSeparation(Image dest, Image source, int erosions, StructuringElement structuringElement) {
+        
+        _imaqSeparation(dest.getAddress(), source.getAddress(), erosions, structuringElement == null ? 0 : structuringElement.getAddress());
+        
+    }
+    private static native void _imaqSeparation(long dest, long source, int erosions, long structuringElement);
+
+    public static void imaqSimpleDistance(Image dest, Image source, StructuringElement structuringElement) {
+        
+        _imaqSimpleDistance(dest.getAddress(), source.getAddress(), structuringElement == null ? 0 : structuringElement.getAddress());
+        
+    }
+    private static native void _imaqSimpleDistance(long dest, long source, long structuringElement);
+
+    public static void imaqSizeFilter(Image dest, Image source, int connectivity8, int erosions, SizeType keepSize, StructuringElement structuringElement) {
+        
+        _imaqSizeFilter(dest.getAddress(), source.getAddress(), connectivity8, erosions, keepSize.getValue(), structuringElement == null ? 0 : structuringElement.getAddress());
+        
+    }
+    private static native void _imaqSizeFilter(long dest, long source, int connectivity8, int erosions, int keepSize, long structuringElement);
+
+    public static void imaqSkeleton(Image dest, Image source, SkeletonMethod method) {
+        
+        _imaqSkeleton(dest.getAddress(), source.getAddress(), method.getValue());
+        
+    }
+    private static native void _imaqSkeleton(long dest, long source, int method);
+
+    /**
+     * Acquisition functions
+     */
+
+    public static class CopyFromRingResult {
+        public int imageNumber;
+        public Image val;
+        private CopyFromRingResult(ByteBuffer rv_buf) {
+            imageNumber = rv_buf.getInt(0);
+        }
+    }
+
+    public static CopyFromRingResult imaqCopyFromRing(long sessionID, Image image, int imageToCopy, Rect rect) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqCopyFromRing(sessionID, image == null ? 0 : image.getAddress(), imageToCopy, rv_addr+0, rect.getAddress());
+        CopyFromRingResult rv = new CopyFromRingResult(rv_buf);
+        rv.val = new Image(jn_rv, true);
+        return rv;
+    }
+    private static native long _imaqCopyFromRing(long sessionID, long image, int imageToCopy, long imageNumber, long rect);
+
+    public static Image imaqEasyAcquire(String interfaceName) {
+        ByteBuffer interfaceName_buf = null;
+        if (interfaceName != null) {
+            byte[] interfaceName_bytes;
+            try {
+                interfaceName_bytes = interfaceName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                interfaceName_bytes = new byte[0];
+            }
+            interfaceName_buf = ByteBuffer.allocateDirect(interfaceName_bytes.length+1);
+            putBytes(interfaceName_buf, interfaceName_bytes, 0, interfaceName_bytes.length).put(interfaceName_bytes.length, (byte)0);
+        }
+        long jn_rv = _imaqEasyAcquire(interfaceName == null ? 0 : getByteBufferAddress(interfaceName_buf));
+        
+        return new Image(jn_rv, true);
+    }
+    private static native long _imaqEasyAcquire(long interfaceName);
+
+    public static class ExtractFromRingResult {
+        public int imageNumber;
+        public Image val;
+        private ExtractFromRingResult(ByteBuffer rv_buf) {
+            imageNumber = rv_buf.getInt(0);
+        }
+    }
+
+    public static ExtractFromRingResult imaqExtractFromRing(long sessionID, int imageToExtract) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqExtractFromRing(sessionID, imageToExtract, rv_addr+0);
+        ExtractFromRingResult rv = new ExtractFromRingResult(rv_buf);
+        rv.val = new Image(jn_rv, false);
+        return rv;
+    }
+    private static native long _imaqExtractFromRing(long sessionID, int imageToExtract, long imageNumber);
+
+    public static Image imaqGrab(long sessionID, Image image, int immediate) {
+        
+        long jn_rv = _imaqGrab(sessionID, image == null ? 0 : image.getAddress(), immediate);
+        
+        return new Image(jn_rv, true);
+    }
+    private static native long _imaqGrab(long sessionID, long image, int immediate);
+
+    public static void imaqReleaseImage(long sessionID) {
+        
+        _imaqReleaseImage(sessionID);
+        
+    }
+    private static native void _imaqReleaseImage(long sessionID);
+
+    public static void imaqSetupGrab(long sessionID, Rect rect) {
+        
+        _imaqSetupGrab(sessionID, rect.getAddress());
+        
+    }
+    private static native void _imaqSetupGrab(long sessionID, long rect);
+
+    public static void imaqSetupRing(long sessionID, Image[] images, int skipCount, Rect rect) {
+        int numImages = images.length;
+        ByteBuffer images_buf = null;
+        images_buf = ByteBuffer.allocateDirect(images.length*4);
+        for (int i=0, off=0; i<images.length; i++, off += 4) {
+            putPointer(images_buf, off, images[i]);
+        }
+        _imaqSetupRing(sessionID, getByteBufferAddress(images_buf), numImages, skipCount, rect.getAddress());
+        
+    }
+    private static native void _imaqSetupRing(long sessionID, long images, int numImages, int skipCount, long rect);
+
+    public static void imaqSetupSequence(long sessionID, Image[] images, int skipCount, Rect rect) {
+        int numImages = images.length;
+        ByteBuffer images_buf = null;
+        images_buf = ByteBuffer.allocateDirect(images.length*4);
+        for (int i=0, off=0; i<images.length; i++, off += 4) {
+            putPointer(images_buf, off, images[i]);
+        }
+        _imaqSetupSequence(sessionID, getByteBufferAddress(images_buf), numImages, skipCount, rect.getAddress());
+        
+    }
+    private static native void _imaqSetupSequence(long sessionID, long images, int numImages, int skipCount, long rect);
+
+    public static Image imaqSnap(long sessionID, Image image, Rect rect) {
+        
+        long jn_rv = _imaqSnap(sessionID, image == null ? 0 : image.getAddress(), rect.getAddress());
+        
+        return new Image(jn_rv, true);
+    }
+    private static native long _imaqSnap(long sessionID, long image, long rect);
+
+    public static void imaqStartAcquisition(long sessionID) {
+        
+        _imaqStartAcquisition(sessionID);
+        
+    }
+    private static native void _imaqStartAcquisition(long sessionID);
+
+    public static void imaqStopAcquisition(long sessionID) {
+        
+        _imaqStopAcquisition(sessionID);
+        
+    }
+    private static native void _imaqStopAcquisition(long sessionID);
+
+    /**
+     * Arithmetic functions
+     */
+
+    public static void imaqAbsoluteDifference(Image dest, Image sourceA, Image sourceB) {
+        
+        _imaqAbsoluteDifference(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());
+        
+    }
+    private static native void _imaqAbsoluteDifference(long dest, long sourceA, long sourceB);
+
+    public static void imaqAdd(Image dest, Image sourceA, Image sourceB) {
+        
+        _imaqAdd(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());
+        
+    }
+    private static native void _imaqAdd(long dest, long sourceA, long sourceB);
+
+    public static void imaqAverage(Image dest, Image sourceA, Image sourceB) {
+        
+        _imaqAverage(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());
+        
+    }
+    private static native void _imaqAverage(long dest, long sourceA, long sourceB);
+
+    public static void imaqDivide2(Image dest, Image sourceA, Image sourceB, RoundingMode roundingMode) {
+        
+        _imaqDivide2(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress(), roundingMode.getValue());
+        
+    }
+    private static native void _imaqDivide2(long dest, long sourceA, long sourceB, int roundingMode);
+
+    public static void imaqMax(Image dest, Image sourceA, Image sourceB) {
+        
+        _imaqMax(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());
+        
+    }
+    private static native void _imaqMax(long dest, long sourceA, long sourceB);
+
+    public static void imaqMin(Image dest, Image sourceA, Image sourceB) {
+        
+        _imaqMin(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());
+        
+    }
+    private static native void _imaqMin(long dest, long sourceA, long sourceB);
+
+    public static void imaqModulo(Image dest, Image sourceA, Image sourceB) {
+        
+        _imaqModulo(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());
+        
+    }
+    private static native void _imaqModulo(long dest, long sourceA, long sourceB);
+
+    public static void imaqMulDiv(Image dest, Image sourceA, Image sourceB, float value) {
+        
+        _imaqMulDiv(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress(), value);
+        
+    }
+    private static native void _imaqMulDiv(long dest, long sourceA, long sourceB, float value);
+
+    public static void imaqMultiply(Image dest, Image sourceA, Image sourceB) {
+        
+        _imaqMultiply(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());
+        
+    }
+    private static native void _imaqMultiply(long dest, long sourceA, long sourceB);
+
+    public static void imaqSubtract(Image dest, Image sourceA, Image sourceB) {
+        
+        _imaqSubtract(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());
+        
+    }
+    private static native void _imaqSubtract(long dest, long sourceA, long sourceB);
+
+    /**
+     * Caliper functions
+     */
+
+    public static class CaliperToolResult {
+        public CaliperReport[] array;
+        private long array_addr;
+        private CaliperToolResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numEdgePairs;
+            array_numEdgePairs = rv_buf.getInt(0);
+            array = new CaliperReport[array_numEdgePairs];
+            if (array_numEdgePairs > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numEdgePairs*32);
+                for (int i=0, off=0; i<array_numEdgePairs; i++, off += 32) {
+                    array[i] = new CaliperReport(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static CaliperToolResult imaqCaliperTool(Image image, Point[] points, EdgeOptions edgeOptions, CaliperOptions caliperOptions) {
+        int numPoints = points.length;
+        ByteBuffer points_buf = null;
+        points_buf = ByteBuffer.allocateDirect(points.length*8);
+        for (int i=0, off=0; i<points.length; i++, off += 8) {
+            points[i].setBuffer(points_buf, off);
+            points[i].write();
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqCaliperTool(image.getAddress(), getByteBufferAddress(points_buf), numPoints, edgeOptions.getAddress(), caliperOptions.getAddress(), rv_addr+0);
+        CaliperToolResult rv = new CaliperToolResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqCaliperTool(long image, long points, int numPoints, long edgeOptions, long caliperOptions, long numEdgePairs);
+
+    public static class ConcentricRake2Result {
+        public EdgeOptions2 edgeOptions;
+        public ConcentricRakeReport2 val;
+        private ConcentricRake2Result(ByteBuffer rv_buf) {
+            edgeOptions = new EdgeOptions2(rv_buf, 0);
+            edgeOptions.read();
+        }
+    }
+
+    public static ConcentricRake2Result imaqConcentricRake2(Image image, ROI roi, ConcentricRakeDirection direction, EdgeProcess process, int stepSize) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqConcentricRake2(image.getAddress(), roi.getAddress(), direction.getValue(), process.getValue(), stepSize, rv_addr+0);
+        ConcentricRake2Result rv = new ConcentricRake2Result(rv_buf);
+        rv.val = new ConcentricRakeReport2(jn_rv, true);
+        return rv;
+    }
+    private static native long _imaqConcentricRake2(long image, long roi, int direction, int process, int stepSize, long edgeOptions);
+
+    public static class DetectExtremesResult {
+        public ExtremeReport[] array;
+        private long array_addr;
+        private DetectExtremesResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numExtremes;
+            array_numExtremes = rv_buf.getInt(0);
+            array = new ExtremeReport[array_numExtremes];
+            if (array_numExtremes > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numExtremes*24);
+                for (int i=0, off=0; i<array_numExtremes; i++, off += 24) {
+                    array[i] = new ExtremeReport(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static DetectExtremesResult imaqDetectExtremes(double[] pixels, DetectionMode mode, DetectExtremesOptions options) {
+        int numPixels = pixels.length;
+        ByteBuffer pixels_buf = null;
+        pixels_buf = ByteBuffer.allocateDirect(pixels.length*8);
+        pixels_buf.asDoubleBuffer().put(pixels).rewind();
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqDetectExtremes(getByteBufferAddress(pixels_buf), numPixels, mode.getValue(), options.getAddress(), rv_addr+0);
+        DetectExtremesResult rv = new DetectExtremesResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqDetectExtremes(long pixels, int numPixels, int mode, long options, long numExtremes);
+
+    public static double imaqDetectRotation(Image referenceImage, Image testImage, PointFloat referenceCenter, PointFloat testCenter, int radius, float precision) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        double jn_rv = _imaqDetectRotation(referenceImage.getAddress(), testImage.getAddress(), referenceCenter.getAddress(), testCenter.getAddress(), radius, precision, rv_addr+0);
+        double angle;
+        angle = rv_buf.getDouble(0);
+        return angle;
+    }
+    private static native double _imaqDetectRotation(long referenceImage, long testImage, long referenceCenter, long testCenter, int radius, float precision, long angle);
+
+    public static class EdgeTool4Result {
+        public EdgeOptions2 edgeOptions;
+        public EdgeReport2 val;
+        private EdgeTool4Result(ByteBuffer rv_buf) {
+            edgeOptions = new EdgeOptions2(rv_buf, 0);
+            edgeOptions.read();
+        }
+    }
+
+    public static EdgeTool4Result imaqEdgeTool4(Image image, ROI roi, EdgeProcess processType, int reverseDirection) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqEdgeTool4(image.getAddress(), roi.getAddress(), processType.getValue(), rv_addr+0, reverseDirection);
+        EdgeTool4Result rv = new EdgeTool4Result(rv_buf);
+        rv.val = new EdgeReport2(jn_rv, true);
+        return rv;
+    }
+    private static native long _imaqEdgeTool4(long image, long roi, int processType, long edgeOptions, int reverseDirection);
+
+    public static FindEdgeReport imaqFindEdge2(Image image, ROI roi, CoordinateSystem baseSystem, CoordinateSystem newSystem, FindEdgeOptions2 findEdgeOptions, StraightEdgeOptions straightEdgeOptions) {
+        
+        long jn_rv = _imaqFindEdge2(image.getAddress(), roi.getAddress(), baseSystem.getAddress(), newSystem.getAddress(), findEdgeOptions.getAddress(), straightEdgeOptions.getAddress());
+        
+        return new FindEdgeReport(jn_rv, true);
+    }
+    private static native long _imaqFindEdge2(long image, long roi, long baseSystem, long newSystem, long findEdgeOptions, long straightEdgeOptions);
+
+    public static class FindTransformRect2Result {
+        public CoordinateSystem baseSystem;
+        public CoordinateSystem newSystem;
+        public AxisReport axisReport;
+        private FindTransformRect2Result(ByteBuffer rv_buf) {
+            baseSystem = new CoordinateSystem(rv_buf, 0);
+            baseSystem.read();
+            newSystem = new CoordinateSystem(rv_buf, 8);
+            newSystem.read();
+            axisReport = new AxisReport(rv_buf, 16);
+            axisReport.read();
+        }
+    }
+
+    public static FindTransformRect2Result imaqFindTransformRect2(Image image, ROI roi, FindTransformMode mode, FindTransformRectOptions2 findTransformOptions, StraightEdgeOptions straightEdgeOptions) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(32);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqFindTransformRect2(image.getAddress(), roi.getAddress(), mode.getValue(), rv_addr+0, rv_addr+8, findTransformOptions.getAddress(), straightEdgeOptions.getAddress(), rv_addr+16);
+        FindTransformRect2Result rv = new FindTransformRect2Result(rv_buf);
+        return rv;
+    }
+    private static native void _imaqFindTransformRect2(long image, long roi, int mode, long baseSystem, long newSystem, long findTransformOptions, long straightEdgeOptions, long axisReport);
+
+    public static class FindTransformRects2Result {
+        public CoordinateSystem baseSystem;
+        public CoordinateSystem newSystem;
+        public AxisReport axisReport;
+        private FindTransformRects2Result(ByteBuffer rv_buf) {
+            baseSystem = new CoordinateSystem(rv_buf, 0);
+            baseSystem.read();
+            newSystem = new CoordinateSystem(rv_buf, 8);
+            newSystem.read();
+            axisReport = new AxisReport(rv_buf, 16);
+            axisReport.read();
+        }
+    }
+
+    public static FindTransformRects2Result imaqFindTransformRects2(Image image, ROI primaryROI, ROI secondaryROI, FindTransformMode mode, FindTransformRectsOptions2 findTransformOptions, StraightEdgeOptions primaryStraightEdgeOptions, StraightEdgeOptions secondaryStraightEdgeOptions) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(32);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqFindTransformRects2(image.getAddress(), primaryROI.getAddress(), secondaryROI.getAddress(), mode.getValue(), rv_addr+0, rv_addr+8, findTransformOptions.getAddress(), primaryStraightEdgeOptions.getAddress(), secondaryStraightEdgeOptions.getAddress(), rv_addr+16);
+        FindTransformRects2Result rv = new FindTransformRects2Result(rv_buf);
+        return rv;
+    }
+    private static native void _imaqFindTransformRects2(long image, long primaryROI, long secondaryROI, int mode, long baseSystem, long newSystem, long findTransformOptions, long primaryStraightEdgeOptions, long secondaryStraightEdgeOptions, long axisReport);
+
+    public static float imaqLineGaugeTool2(Image image, Point start, Point end, LineGaugeMethod method, EdgeOptions edgeOptions, CoordinateTransform2 transform) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        float jn_rv = _imaqLineGaugeTool2(image.getAddress(), start.getAddress(), end.getAddress(), method.getValue(), edgeOptions.getAddress(), transform.getAddress(), rv_addr+0);
+        float distance;
+        distance = rv_buf.getFloat(0);
+        return distance;
+    }
+    private static native float _imaqLineGaugeTool2(long image, long start, long end, int method, long edgeOptions, long transform, long distance);
+
+    public static class Rake2Result {
+        public EdgeOptions2 edgeOptions;
+        public RakeReport2 val;
+        private Rake2Result(ByteBuffer rv_buf) {
+            edgeOptions = new EdgeOptions2(rv_buf, 0);
+            edgeOptions.read();
+        }
+    }
+
+    public static Rake2Result imaqRake2(Image image, ROI roi, RakeDirection direction, EdgeProcess process, int stepSize) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqRake2(image.getAddress(), roi.getAddress(), direction.getValue(), process.getValue(), stepSize, rv_addr+0);
+        Rake2Result rv = new Rake2Result(rv_buf);
+        rv.val = new RakeReport2(jn_rv, true);
+        return rv;
+    }
+    private static native long _imaqRake2(long image, long roi, int direction, int process, int stepSize, long edgeOptions);
+
+    public static class SimpleEdgeResult {
+        public PointFloat[] array;
+        private long array_addr;
+        private SimpleEdgeResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numEdges;
+            array_numEdges = rv_buf.getInt(0);
+            array = new PointFloat[array_numEdges];
+            if (array_numEdges > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numEdges*8);
+                for (int i=0, off=0; i<array_numEdges; i++, off += 8) {
+                    array[i] = new PointFloat(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static SimpleEdgeResult imaqSimpleEdge(Image image, Point[] points, SimpleEdgeOptions options) {
+        int numPoints = points.length;
+        ByteBuffer points_buf = null;
+        points_buf = ByteBuffer.allocateDirect(points.length*8);
+        for (int i=0, off=0; i<points.length; i++, off += 8) {
+            points[i].setBuffer(points_buf, off);
+            points[i].write();
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqSimpleEdge(image.getAddress(), getByteBufferAddress(points_buf), numPoints, options.getAddress(), rv_addr+0);
+        SimpleEdgeResult rv = new SimpleEdgeResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqSimpleEdge(long image, long points, int numPoints, long options, long numEdges);
+
+    public static class Spoke2Result {
+        public EdgeOptions2 edgeOptions;
+        public SpokeReport2 val;
+        private Spoke2Result(ByteBuffer rv_buf) {
+            edgeOptions = new EdgeOptions2(rv_buf, 0);
+            edgeOptions.read();
+        }
+    }
+
+    public static Spoke2Result imaqSpoke2(Image image, ROI roi, SpokeDirection direction, EdgeProcess process, int stepSize) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqSpoke2(image.getAddress(), roi.getAddress(), direction.getValue(), process.getValue(), stepSize, rv_addr+0);
+        Spoke2Result rv = new Spoke2Result(rv_buf);
+        rv.val = new SpokeReport2(jn_rv, true);
+        return rv;
+    }
+    private static native long _imaqSpoke2(long image, long roi, int direction, int process, int stepSize, long edgeOptions);
+
+    public static StraightEdgeReport2 imaqStraightEdge(Image image, ROI roi, SearchDirection searchDirection, EdgeOptions2 edgeOptions, StraightEdgeOptions straightEdgeOptions) {
+        
+        long jn_rv = _imaqStraightEdge(image.getAddress(), roi.getAddress(), searchDirection.getValue(), edgeOptions.getAddress(), straightEdgeOptions.getAddress());
+        
+        return new StraightEdgeReport2(jn_rv, true);
+    }
+    private static native long _imaqStraightEdge(long image, long roi, int searchDirection, long edgeOptions, long straightEdgeOptions);
+
+    public static StraightEdgeReport2 imaqStraightEdge2(Image image, ROI roi, SearchDirection searchDirection, EdgeOptions2 edgeOptions, StraightEdgeOptions straightEdgeOptions, int optimizedMode) {
+        
+        long jn_rv = _imaqStraightEdge2(image.getAddress(), roi.getAddress(), searchDirection.getValue(), edgeOptions.getAddress(), straightEdgeOptions.getAddress(), optimizedMode);
+        
+        return new StraightEdgeReport2(jn_rv, true);
+    }
+    private static native long _imaqStraightEdge2(long image, long roi, int searchDirection, long edgeOptions, long straightEdgeOptions, int optimizedMode);
+
+    /**
+     * Spatial Filters functions
+     */
+
+    public static void imaqCannyEdgeFilter(Image dest, Image source, CannyOptions options) {
+        
+        _imaqCannyEdgeFilter(dest.getAddress(), source.getAddress(), options == null ? 0 : options.getAddress());
+        
+    }
+    private static native void _imaqCannyEdgeFilter(long dest, long source, long options);
+
+    public static void imaqCorrelate(Image dest, Image source, Image templateImage, Rect rect) {
+        
+        _imaqCorrelate(dest.getAddress(), source.getAddress(), templateImage.getAddress(), rect.getAddress());
+        
+    }
+    private static native void _imaqCorrelate(long dest, long source, long templateImage, long rect);
+
+    public static void imaqEdgeFilter(Image dest, Image source, OutlineMethod method, Image mask) {
+        
+        _imaqEdgeFilter(dest.getAddress(), source.getAddress(), method.getValue(), mask == null ? 0 : mask.getAddress());
+        
+    }
+    private static native void _imaqEdgeFilter(long dest, long source, int method, long mask);
+
+    public static void imaqLowPass(Image dest, Image source, int width, int height, float tolerance, Image mask) {
+        
+        _imaqLowPass(dest.getAddress(), source.getAddress(), width, height, tolerance, mask == null ? 0 : mask.getAddress());
+        
+    }
+    private static native void _imaqLowPass(long dest, long source, int width, int height, float tolerance, long mask);
+
+    public static void imaqMedianFilter(Image dest, Image source, int width, int height, Image mask) {
+        
+        _imaqMedianFilter(dest.getAddress(), source.getAddress(), width, height, mask == null ? 0 : mask.getAddress());
+        
+    }
+    private static native void _imaqMedianFilter(long dest, long source, int width, int height, long mask);
+
+    public static void imaqNthOrderFilter(Image dest, Image source, int width, int height, int n, Image mask) {
+        
+        _imaqNthOrderFilter(dest.getAddress(), source.getAddress(), width, height, n, mask == null ? 0 : mask.getAddress());
+        
+    }
+    private static native void _imaqNthOrderFilter(long dest, long source, int width, int height, int n, long mask);
+
+    /**
+     * Drawing functions
+     */
+
+    public static void imaqDrawLineOnImage(Image dest, Image source, DrawMode mode, Point start, Point end, float newPixelValue) {
+        
+        _imaqDrawLineOnImage(dest.getAddress(), source.getAddress(), mode.getValue(), start.getAddress(), end.getAddress(), newPixelValue);
+        
+    }
+    private static native void _imaqDrawLineOnImage(long dest, long source, int mode, long start, long end, float newPixelValue);
+
+    public static void imaqDrawShapeOnImage(Image dest, Image source, Rect rect, DrawMode mode, ShapeMode shape, float newPixelValue) {
+        
+        _imaqDrawShapeOnImage(dest.getAddress(), source.getAddress(), rect.getAddress(), mode.getValue(), shape.getValue(), newPixelValue);
+        
+    }
+    private static native void _imaqDrawShapeOnImage(long dest, long source, long rect, int mode, int shape, float newPixelValue);
+
+    public static int imaqDrawTextOnImage(Image dest, Image source, Point coord, String text, DrawTextOptions options) {
+        ByteBuffer text_buf = null;
+        if (text != null) {
+            byte[] text_bytes;
+            try {
+                text_bytes = text.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                text_bytes = new byte[0];
+            }
+            text_buf = ByteBuffer.allocateDirect(text_bytes.length+1);
+            putBytes(text_buf, text_bytes, 0, text_bytes.length).put(text_bytes.length, (byte)0);
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqDrawTextOnImage(dest.getAddress(), source.getAddress(), coord.getAddress(), text == null ? 0 : getByteBufferAddress(text_buf), options == null ? 0 : options.getAddress(), rv_addr+0);
+        int fontNameUsed;
+        fontNameUsed = rv_buf.getInt(0);
+        return fontNameUsed;
+    }
+    private static native int _imaqDrawTextOnImage(long dest, long source, long coord, long text, long options, long fontNameUsed);
+
+    /**
+     * Interlacing functions
+     */
+
+    public static void imaqInterlaceCombine(Image frame, Image odd, Image even) {
+        
+        _imaqInterlaceCombine(frame.getAddress(), odd.getAddress(), even.getAddress());
+        
+    }
+    private static native void _imaqInterlaceCombine(long frame, long odd, long even);
+
+    public static void imaqInterlaceSeparate(Image frame, Image odd, Image even) {
+        
+        _imaqInterlaceSeparate(frame.getAddress(), odd == null ? 0 : odd.getAddress(), even == null ? 0 : even.getAddress());
+        
+    }
+    private static native void _imaqInterlaceSeparate(long frame, long odd, long even);
+
+    /**
+     * Image Information functions
+     */
+
+    public static int imaqGetBitDepth(Image image) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqGetBitDepth(image.getAddress(), rv_addr+0);
+        int bitDepth;
+        bitDepth = rv_buf.getInt(0);
+        return bitDepth;
+    }
+    private static native int _imaqGetBitDepth(long image, long bitDepth);
+
+    public static int imaqGetBytesPerPixel(Image image) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqGetBytesPerPixel(image.getAddress(), rv_addr+0);
+        int byteCount;
+        byteCount = rv_buf.getInt(0);
+        return byteCount;
+    }
+    private static native int _imaqGetBytesPerPixel(long image, long byteCount);
+
+    public static ImageInfo imaqGetImageInfo(Image image) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetImageInfo(image.getAddress(), rv_addr+0);
+        ImageInfo info;
+        info = new ImageInfo(rv_buf, 0);
+        info.read();
+        return info;
+    }
+    private static native long _imaqGetImageInfo(long image, long info);
+
+    public static class GetImageSizeResult {
+        public int width;
+        public int height;
+        private GetImageSizeResult(ByteBuffer rv_buf) {
+            width = rv_buf.getInt(0);
+            height = rv_buf.getInt(8);
+        }
+    }
+
+    public static GetImageSizeResult imaqGetImageSize(Image image) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqGetImageSize(image.getAddress(), rv_addr+0, rv_addr+8);
+        GetImageSizeResult rv = new GetImageSizeResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqGetImageSize(long image, long width, long height);
+
+    public static ImageType imaqGetImageType(Image image) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqGetImageType(image.getAddress(), rv_addr+0);
+        ImageType type;
+        type = ImageType.fromValue(rv_buf.getInt(0));
+        return type;
+    }
+    private static native int _imaqGetImageType(long image, long type);
+
+    public static Point imaqGetMaskOffset(Image image) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetMaskOffset(image.getAddress(), rv_addr+0);
+        Point offset;
+        offset = new Point(rv_buf, 0);
+        offset.read();
+        return offset;
+    }
+    private static native long _imaqGetMaskOffset(long image, long offset);
+
+    public static int imaqGetVisionInfoTypes(Image image) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqGetVisionInfoTypes(image.getAddress(), rv_addr+0);
+        int present;
+        present = rv_buf.getInt(0);
+        return present;
+    }
+    private static native int _imaqGetVisionInfoTypes(long image, long present);
+
+    public static int imaqIsImageEmpty(Image image) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqIsImageEmpty(image.getAddress(), rv_addr+0);
+        int empty;
+        empty = rv_buf.getInt(0);
+        return empty;
+    }
+    private static native int _imaqIsImageEmpty(long image, long empty);
+
+    public static void imaqRemoveCustomData(Image image, String key) {
+        ByteBuffer key_buf = null;
+        if (key != null) {
+            byte[] key_bytes;
+            try {
+                key_bytes = key.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                key_bytes = new byte[0];
+            }
+            key_buf = ByteBuffer.allocateDirect(key_bytes.length+1);
+            putBytes(key_buf, key_bytes, 0, key_bytes.length).put(key_bytes.length, (byte)0);
+        }
+        _imaqRemoveCustomData(image.getAddress(), key == null ? 0 : getByteBufferAddress(key_buf));
+        
+    }
+    private static native void _imaqRemoveCustomData(long image, long key);
+
+    public static void imaqRemoveVisionInfo2(Image image, int info) {
+        
+        _imaqRemoveVisionInfo2(image.getAddress(), info);
+        
+    }
+    private static native void _imaqRemoveVisionInfo2(long image, int info);
+
+    public static void imaqSetBitDepth(Image image, int bitDepth) {
+        
+        _imaqSetBitDepth(image.getAddress(), bitDepth);
+        
+    }
+    private static native void _imaqSetBitDepth(long image, int bitDepth);
+
+    public static void imaqSetImageSize(Image image, int width, int height) {
+        
+        _imaqSetImageSize(image.getAddress(), width, height);
+        
+    }
+    private static native void _imaqSetImageSize(long image, int width, int height);
+
+    public static void imaqSetMaskOffset(Image image, Point offset) {
+        
+        _imaqSetMaskOffset(image.getAddress(), offset.getAddress());
+        
+    }
+    private static native void _imaqSetMaskOffset(long image, long offset);
+
+    /**
+     * Display functions
+     */
+
+    public static int imaqAreToolsContextSensitive() {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqAreToolsContextSensitive(rv_addr+0);
+        int sensitive;
+        sensitive = rv_buf.getInt(0);
+        return sensitive;
+    }
+    private static native int _imaqAreToolsContextSensitive(long sensitive);
+
+    public static void imaqCloseWindow(int windowNumber) {
+        
+        _imaqCloseWindow(windowNumber);
+        
+    }
+    private static native void _imaqCloseWindow(int windowNumber);
+
+    public static void imaqDisplayImage(Image image, int windowNumber, int resize) {
+        
+        _imaqDisplayImage(image.getAddress(), windowNumber, resize);
+        
+    }
+    private static native void _imaqDisplayImage(long image, int windowNumber, int resize);
+
+    public static class GetLastKeyResult {
+        public byte keyPressed;
+        public int windowNumber;
+        public int modifiers;
+        private GetLastKeyResult(ByteBuffer rv_buf) {
+            keyPressed = rv_buf.get(0);
+            windowNumber = rv_buf.getInt(8);
+            modifiers = rv_buf.getInt(16);
+        }
+    }
+
+    public static GetLastKeyResult imaqGetLastKey() {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(32);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqGetLastKey(rv_addr+0, rv_addr+8, rv_addr+16);
+        GetLastKeyResult rv = new GetLastKeyResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqGetLastKey(long keyPressed, long windowNumber, long modifiers);
+
+    public static Point imaqGetWindowCenterPos(int windowNumber) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetWindowCenterPos(windowNumber, rv_addr+0);
+        Point centerPosition;
+        centerPosition = new Point(rv_buf, 0);
+        centerPosition.read();
+        return centerPosition;
+    }
+    private static native long _imaqGetWindowCenterPos(int windowNumber, long centerPosition);
+
+    public static void imaqSetToolContextSensitivity(int sensitive) {
+        
+        _imaqSetToolContextSensitivity(sensitive);
+        
+    }
+    private static native void _imaqSetToolContextSensitivity(int sensitive);
+
+    public static void imaqShowWindow(int windowNumber, int visible) {
+        
+        _imaqShowWindow(windowNumber, visible);
+        
+    }
+    private static native void _imaqShowWindow(int windowNumber, int visible);
+
+    /**
+     * Image Manipulation functions
+     */
+
+    public static void imaqCopyRect(Image dest, Image source, Rect rect, Point destLoc) {
+        
+        _imaqCopyRect(dest.getAddress(), source.getAddress(), rect.getAddress(), destLoc.getAddress());
+        
+    }
+    private static native void _imaqCopyRect(long dest, long source, long rect, long destLoc);
+
+    public static void imaqDuplicate(Image dest, Image source) {
+        
+        _imaqDuplicate(dest.getAddress(), source.getAddress());
+        
+    }
+    private static native void _imaqDuplicate(long dest, long source);
+
+    public static void imaqFlip(Image dest, Image source, FlipAxis axis) {
+        
+        _imaqFlip(dest.getAddress(), source.getAddress(), axis.getValue());
+        
+    }
+    private static native void _imaqFlip(long dest, long source, int axis);
+
+    public static void imaqMask(Image dest, Image source, Image mask) {
+        
+        _imaqMask(dest.getAddress(), source.getAddress(), mask.getAddress());
+        
+    }
+    private static native void _imaqMask(long dest, long source, long mask);
+
+    public static void imaqResample(Image dest, Image source, int newWidth, int newHeight, InterpolationMethod method, Rect rect) {
+        
+        _imaqResample(dest.getAddress(), source.getAddress(), newWidth, newHeight, method.getValue(), rect.getAddress());
+        
+    }
+    private static native void _imaqResample(long dest, long source, int newWidth, int newHeight, int method, long rect);
+
+    public static void imaqScale(Image dest, Image source, int xScale, int yScale, ScalingMode scaleMode, Rect rect) {
+        
+        _imaqScale(dest.getAddress(), source.getAddress(), xScale, yScale, scaleMode.getValue(), rect.getAddress());
+        
+    }
+    private static native void _imaqScale(long dest, long source, int xScale, int yScale, int scaleMode, long rect);
+
+    public static void imaqTranspose(Image dest, Image source) {
+        
+        _imaqTranspose(dest.getAddress(), source.getAddress());
+        
+    }
+    private static native void _imaqTranspose(long dest, long source);
+
+    public static void imaqUnwrapImage(Image dest, Image source, Annulus annulus, RectOrientation orientation, InterpolationMethod method) {
+        
+        _imaqUnwrapImage(dest.getAddress(), source.getAddress(), annulus.getAddress(), orientation.getValue(), method.getValue());
+        
+    }
+    private static native void _imaqUnwrapImage(long dest, long source, long annulus, int orientation, int method);
+
+    public static void imaqView3D(Image dest, Image source, View3DOptions options) {
+        
+        _imaqView3D(dest.getAddress(), source.getAddress(), options.getAddress());
+        
+    }
+    private static native void _imaqView3D(long dest, long source, long options);
+
+    /**
+     * File I/O functions
+     */
+
+    public static void imaqCloseAVI(int session) {
+        
+        _imaqCloseAVI(session);
+        
+    }
+    private static native void _imaqCloseAVI(int session);
+
+    public static int imaqCreateAVI(String fileName, String compressionFilter, int quality, int framesPerSecond, int maxDataSize) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        ByteBuffer compressionFilter_buf = null;
+        if (compressionFilter != null) {
+            byte[] compressionFilter_bytes;
+            try {
+                compressionFilter_bytes = compressionFilter.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                compressionFilter_bytes = new byte[0];
+            }
+            compressionFilter_buf = ByteBuffer.allocateDirect(compressionFilter_bytes.length+1);
+            putBytes(compressionFilter_buf, compressionFilter_bytes, 0, compressionFilter_bytes.length).put(compressionFilter_bytes.length, (byte)0);
+        }
+        int jn_rv = _imaqCreateAVI(fileName == null ? 0 : getByteBufferAddress(fileName_buf), compressionFilter == null ? 0 : getByteBufferAddress(compressionFilter_buf), quality, framesPerSecond, maxDataSize);
+        
+        return jn_rv;
+    }
+    private static native int _imaqCreateAVI(long fileName, long compressionFilter, int quality, int framesPerSecond, int maxDataSize);
+
+    public static AVIInfo imaqGetAVIInfo(int session) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetAVIInfo(session, rv_addr+0);
+        AVIInfo info;
+        info = new AVIInfo(rv_buf, 0);
+        info.read();
+        return info;
+    }
+    private static native long _imaqGetAVIInfo(int session, long info);
+
+    public static class GetFileInfoResult {
+        public CalibrationUnit calibrationUnit;
+        public float calibrationX;
+        public float calibrationY;
+        public int width;
+        public int height;
+        public ImageType imageType;
+        private GetFileInfoResult(ByteBuffer rv_buf) {
+            calibrationUnit = CalibrationUnit.fromValue(rv_buf.getInt(0));
+            calibrationX = rv_buf.getFloat(8);
+            calibrationY = rv_buf.getFloat(16);
+            width = rv_buf.getInt(24);
+            height = rv_buf.getInt(32);
+            imageType = ImageType.fromValue(rv_buf.getInt(40));
+        }
+    }
+
+    public static GetFileInfoResult imaqGetFileInfo(String fileName) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(56);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqGetFileInfo(fileName == null ? 0 : getByteBufferAddress(fileName_buf), rv_addr+0, rv_addr+8, rv_addr+16, rv_addr+24, rv_addr+32, rv_addr+40);
+        GetFileInfoResult rv = new GetFileInfoResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqGetFileInfo(long fileName, long calibrationUnit, long calibrationX, long calibrationY, long width, long height, long imageType);
+
+    public static class GetFilterNamesResult {
+        public String[] array;
+        private long array_addr;
+        private GetFilterNamesResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numFilters;
+            array_numFilters = rv_buf.getInt(0);
+            array = new String[array_numFilters];
+            if (array_numFilters > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numFilters*4);
+                for (int i=0, off=0; i<array_numFilters; i++, off += 4) {
+                    long addr = getPointer(bb, off);
+                    if (addr == 0)
+                        array[i] = null;
+                    else {
+                        ByteBuffer bb2 = newDirectByteBuffer(addr, 1000); // FIXME
+                        while (bb2.get() != 0) {}
+                        byte[] bytes = new byte[bb2.position()-1];
+                        bb2.rewind();
+                        getBytes(bb2, bytes, 0, bytes.length);
+                        try {
+                            array[i] = new String(bytes, "UTF-8");
+                        } catch (UnsupportedEncodingException e) {
+                            array[i] = "";
+                        }
+                    }
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static GetFilterNamesResult imaqGetFilterNames() {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetFilterNames(rv_addr+0);
+        GetFilterNamesResult rv = new GetFilterNamesResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqGetFilterNames(long numFilters);
+
+    public static int imaqOpenAVI(String fileName) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        int jn_rv = _imaqOpenAVI(fileName == null ? 0 : getByteBufferAddress(fileName_buf));
+        
+        return jn_rv;
+    }
+    private static native int _imaqOpenAVI(long fileName);
+
+    public static class ReadFileResult {
+        public RGBValue colorTable;
+        public int numColors;
+        private ReadFileResult(ByteBuffer rv_buf) {
+            colorTable = new RGBValue(rv_buf, 0);
+            colorTable.read();
+            numColors = rv_buf.getInt(8);
+        }
+    }
+
+    public static ReadFileResult imaqReadFile(Image image, String fileName) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqReadFile(image.getAddress(), fileName == null ? 0 : getByteBufferAddress(fileName_buf), rv_addr+0, rv_addr+8);
+        ReadFileResult rv = new ReadFileResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqReadFile(long image, long fileName, long colorTable, long numColors);
+
+    public static class ReadVisionFileResult {
+        public RGBValue colorTable;
+        public int numColors;
+        private ReadVisionFileResult(ByteBuffer rv_buf) {
+            colorTable = new RGBValue(rv_buf, 0);
+            colorTable.read();
+            numColors = rv_buf.getInt(8);
+        }
+    }
+
+    public static ReadVisionFileResult imaqReadVisionFile(Image image, String fileName) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqReadVisionFile(image.getAddress(), fileName == null ? 0 : getByteBufferAddress(fileName_buf), rv_addr+0, rv_addr+8);
+        ReadVisionFileResult rv = new ReadVisionFileResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqReadVisionFile(long image, long fileName, long colorTable, long numColors);
+
+    public static void imaqWriteBMPFile(Image image, String fileName, int compress, RGBValue colorTable) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        _imaqWriteBMPFile(image.getAddress(), fileName == null ? 0 : getByteBufferAddress(fileName_buf), compress, colorTable == null ? 0 : colorTable.getAddress());
+        
+    }
+    private static native void _imaqWriteBMPFile(long image, long fileName, int compress, long colorTable);
+
+    public static void imaqWriteFile(Image image, String fileName, RGBValue colorTable) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        _imaqWriteFile(image.getAddress(), fileName == null ? 0 : getByteBufferAddress(fileName_buf), colorTable == null ? 0 : colorTable.getAddress());
+        
+    }
+    private static native void _imaqWriteFile(long image, long fileName, long colorTable);
+
+    public static void imaqWriteJPEG2000File(Image image, String fileName, int lossless, float compressionRatio, JPEG2000FileAdvancedOptions advancedOptions, RGBValue colorTable) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        _imaqWriteJPEG2000File(image.getAddress(), fileName == null ? 0 : getByteBufferAddress(fileName_buf), lossless, compressionRatio, advancedOptions.getAddress(), colorTable.getAddress());
+        
+    }
+    private static native void _imaqWriteJPEG2000File(long image, long fileName, int lossless, float compressionRatio, long advancedOptions, long colorTable);
+
+    public static void imaqWritePNGFile2(Image image, String fileName, int compressionSpeed, RGBValue colorTable, int useBitDepth) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        _imaqWritePNGFile2(image.getAddress(), fileName == null ? 0 : getByteBufferAddress(fileName_buf), compressionSpeed, colorTable == null ? 0 : colorTable.getAddress(), useBitDepth);
+        
+    }
+    private static native void _imaqWritePNGFile2(long image, long fileName, int compressionSpeed, long colorTable, int useBitDepth);
+
+    public static void imaqWriteTIFFFile(Image image, String fileName, TIFFFileOptions options, RGBValue colorTable) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        _imaqWriteTIFFFile(image.getAddress(), fileName == null ? 0 : getByteBufferAddress(fileName_buf), options == null ? 0 : options.getAddress(), colorTable == null ? 0 : colorTable.getAddress());
+        
+    }
+    private static native void _imaqWriteTIFFFile(long image, long fileName, long options, long colorTable);
+
+    public static void imaqWriteVisionFile(Image image, String fileName, RGBValue colorTable) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        _imaqWriteVisionFile(image.getAddress(), fileName == null ? 0 : getByteBufferAddress(fileName_buf), colorTable.getAddress());
+        
+    }
+    private static native void _imaqWriteVisionFile(long image, long fileName, long colorTable);
+
+    /**
+     * Analytic Geometry functions
+     */
+
+    public static CoordinateSystem imaqBuildCoordinateSystem(Point points, ReferenceMode mode, AxisOrientation orientation) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqBuildCoordinateSystem(points.getAddress(), mode.getValue(), orientation.getValue(), rv_addr+0);
+        CoordinateSystem system;
+        system = new CoordinateSystem(rv_buf, 0);
+        system.read();
+        return system;
+    }
+    private static native long _imaqBuildCoordinateSystem(long points, int mode, int orientation, long system);
+
+    public static BestCircle2 imaqFitCircle2(PointFloat[] points, FitCircleOptions options) {
+        int numPoints = points.length;
+        ByteBuffer points_buf = null;
+        points_buf = ByteBuffer.allocateDirect(points.length*8);
+        for (int i=0, off=0; i<points.length; i++, off += 8) {
+            points[i].setBuffer(points_buf, off);
+            points[i].write();
+        }
+        long jn_rv = _imaqFitCircle2(getByteBufferAddress(points_buf), numPoints, options.getAddress());
+        
+        return new BestCircle2(jn_rv, true);
+    }
+    private static native long _imaqFitCircle2(long points, int numPoints, long options);
+
+    public static BestEllipse2 imaqFitEllipse2(PointFloat[] points, FitEllipseOptions options) {
+        int numPoints = points.length;
+        ByteBuffer points_buf = null;
+        points_buf = ByteBuffer.allocateDirect(points.length*8);
+        for (int i=0, off=0; i<points.length; i++, off += 8) {
+            points[i].setBuffer(points_buf, off);
+            points[i].write();
+        }
+        long jn_rv = _imaqFitEllipse2(getByteBufferAddress(points_buf), numPoints, options.getAddress());
+        
+        return new BestEllipse2(jn_rv, true);
+    }
+    private static native long _imaqFitEllipse2(long points, int numPoints, long options);
+
+    public static BestLine imaqFitLine(PointFloat[] points, FitLineOptions options) {
+        int numPoints = points.length;
+        ByteBuffer points_buf = null;
+        points_buf = ByteBuffer.allocateDirect(points.length*8);
+        for (int i=0, off=0; i<points.length; i++, off += 8) {
+            points[i].setBuffer(points_buf, off);
+            points[i].write();
+        }
+        long jn_rv = _imaqFitLine(getByteBufferAddress(points_buf), numPoints, options.getAddress());
+        
+        return new BestLine(jn_rv, true);
+    }
+    private static native long _imaqFitLine(long points, int numPoints, long options);
+
+    public static float imaqGetAngle(PointFloat start1, PointFloat end1, PointFloat start2, PointFloat end2) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        float jn_rv = _imaqGetAngle(start1.getAddress(), end1.getAddress(), start2.getAddress(), end2.getAddress(), rv_addr+0);
+        float angle;
+        angle = rv_buf.getFloat(0);
+        return angle;
+    }
+    private static native float _imaqGetAngle(long start1, long end1, long start2, long end2, long angle);
+
+    public static class GetBisectingLineResult {
+        public PointFloat bisectStart;
+        public PointFloat bisectEnd;
+        private GetBisectingLineResult(ByteBuffer rv_buf) {
+            bisectStart = new PointFloat(rv_buf, 0);
+            bisectStart.read();
+            bisectEnd = new PointFloat(rv_buf, 8);
+            bisectEnd.read();
+        }
+    }
+
+    public static GetBisectingLineResult imaqGetBisectingLine(PointFloat start1, PointFloat end1, PointFloat start2, PointFloat end2) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqGetBisectingLine(start1.getAddress(), end1.getAddress(), start2.getAddress(), end2.getAddress(), rv_addr+0, rv_addr+8);
+        GetBisectingLineResult rv = new GetBisectingLineResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqGetBisectingLine(long start1, long end1, long start2, long end2, long bisectStart, long bisectEnd);
+
+    public static float imaqGetDistance(PointFloat point1, PointFloat point2) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        float jn_rv = _imaqGetDistance(point1.getAddress(), point2.getAddress(), rv_addr+0);
+        float distance;
+        distance = rv_buf.getFloat(0);
+        return distance;
+    }
+    private static native float _imaqGetDistance(long point1, long point2, long distance);
+
+    public static PointFloat imaqGetIntersection(PointFloat start1, PointFloat end1, PointFloat start2, PointFloat end2) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetIntersection(start1.getAddress(), end1.getAddress(), start2.getAddress(), end2.getAddress(), rv_addr+0);
+        PointFloat intersection;
+        intersection = new PointFloat(rv_buf, 0);
+        intersection.read();
+        return intersection;
+    }
+    private static native long _imaqGetIntersection(long start1, long end1, long start2, long end2, long intersection);
+
+    public static class GetMidLineResult {
+        public PointFloat midLineStart;
+        public PointFloat midLineEnd;
+        private GetMidLineResult(ByteBuffer rv_buf) {
+            midLineStart = new PointFloat(rv_buf, 0);
+            midLineStart.read();
+            midLineEnd = new PointFloat(rv_buf, 8);
+            midLineEnd.read();
+        }
+    }
+
+    public static GetMidLineResult imaqGetMidLine(PointFloat refLineStart, PointFloat refLineEnd, PointFloat point) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqGetMidLine(refLineStart.getAddress(), refLineEnd.getAddress(), point.getAddress(), rv_addr+0, rv_addr+8);
+        GetMidLineResult rv = new GetMidLineResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqGetMidLine(long refLineStart, long refLineEnd, long point, long midLineStart, long midLineEnd);
+
+    public static class GetPerpendicularLineResult {
+        public PointFloat perpLineStart;
+        public PointFloat perpLineEnd;
+        public double distance;
+        private GetPerpendicularLineResult(ByteBuffer rv_buf) {
+            perpLineStart = new PointFloat(rv_buf, 0);
+            perpLineStart.read();
+            perpLineEnd = new PointFloat(rv_buf, 8);
+            perpLineEnd.read();
+            distance = rv_buf.getDouble(16);
+        }
+    }
+
+    public static GetPerpendicularLineResult imaqGetPerpendicularLine(PointFloat refLineStart, PointFloat refLineEnd, PointFloat point) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(32);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqGetPerpendicularLine(refLineStart.getAddress(), refLineEnd.getAddress(), point.getAddress(), rv_addr+0, rv_addr+8, rv_addr+16);
+        GetPerpendicularLineResult rv = new GetPerpendicularLineResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqGetPerpendicularLine(long refLineStart, long refLineEnd, long point, long perpLineStart, long perpLineEnd, long distance);
+
+    public static class GetPointsOnContourResult {
+        public SegmentInfo[] array;
+        private long array_addr;
+        private GetPointsOnContourResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numSegments;
+            array_numSegments = rv_buf.getInt(0);
+            array = new SegmentInfo[array_numSegments];
+            if (array_numSegments > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numSegments*24);
+                for (int i=0, off=0; i<array_numSegments; i++, off += 24) {
+                    array[i] = new SegmentInfo(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static GetPointsOnContourResult imaqGetPointsOnContour(Image image) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetPointsOnContour(image.getAddress(), rv_addr+0);
+        GetPointsOnContourResult rv = new GetPointsOnContourResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqGetPointsOnContour(long image, long numSegments);
+
+    public static class GetPointsOnLineResult {
+        public Point[] array;
+        private long array_addr;
+        private GetPointsOnLineResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numPoints;
+            array_numPoints = rv_buf.getInt(0);
+            array = new Point[array_numPoints];
+            if (array_numPoints > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numPoints*8);
+                for (int i=0, off=0; i<array_numPoints; i++, off += 8) {
+                    array[i] = new Point(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static GetPointsOnLineResult imaqGetPointsOnLine(Point start, Point end) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetPointsOnLine(start.getAddress(), end.getAddress(), rv_addr+0);
+        GetPointsOnLineResult rv = new GetPointsOnLineResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqGetPointsOnLine(long start, long end, long numPoints);
+
+    public static float imaqGetPolygonArea(PointFloat points, int numPoints) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        float jn_rv = _imaqGetPolygonArea(points.getAddress(), numPoints, rv_addr+0);
+        float area;
+        area = rv_buf.getFloat(0);
+        return area;
+    }
+    private static native float _imaqGetPolygonArea(long points, int numPoints, long area);
+
+    /**
+     * Clipboard functions
+     */
+
+    public static RGBValue imaqClipboardToImage(Image dest) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqClipboardToImage(dest.getAddress(), rv_addr+0);
+        RGBValue palette;
+        palette = new RGBValue(rv_buf, 0);
+        palette.read();
+        return palette;
+    }
+    private static native long _imaqClipboardToImage(long dest, long palette);
+
+    public static void imaqImageToClipboard(Image image, RGBValue palette) {
+        
+        _imaqImageToClipboard(image.getAddress(), palette == null ? 0 : palette.getAddress());
+        
+    }
+    private static native void _imaqImageToClipboard(long image, long palette);
+
+    /**
+     * Border functions
+     */
+
+    public static void imaqFillBorder(Image image, BorderMethod method) {
+        
+        _imaqFillBorder(image.getAddress(), method.getValue());
+        
+    }
+    private static native void _imaqFillBorder(long image, int method);
+
+    public static int imaqGetBorderSize(Image image) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqGetBorderSize(image.getAddress(), rv_addr+0);
+        int borderSize;
+        borderSize = rv_buf.getInt(0);
+        return borderSize;
+    }
+    private static native int _imaqGetBorderSize(long image, long borderSize);
+
+    public static void imaqSetBorderSize(Image image, int size) {
+        
+        _imaqSetBorderSize(image.getAddress(), size);
+        
+    }
+    private static native void _imaqSetBorderSize(long image, int size);
+
+    /**
+     * Image Management functions
+     */
+
+    public static Image imaqCreateImage(ImageType type, int borderSize) {
+        
+        long jn_rv = _imaqCreateImage(type.getValue(), borderSize);
+        
+        return new Image(jn_rv, true);
+    }
+    private static native long _imaqCreateImage(int type, int borderSize);
+
+    /**
+     * Color Processing functions
+     */
+
+    public static void imaqColorBCGTransform(Image dest, Image source, BCGOptions redOptions, BCGOptions greenOptions, BCGOptions blueOptions, Image mask) {
+        
+        _imaqColorBCGTransform(dest.getAddress(), source.getAddress(), redOptions == null ? 0 : redOptions.getAddress(), greenOptions == null ? 0 : greenOptions.getAddress(), blueOptions == null ? 0 : blueOptions.getAddress(), mask == null ? 0 : mask.getAddress());
+        
+    }
+    private static native void _imaqColorBCGTransform(long dest, long source, long redOptions, long greenOptions, long blueOptions, long mask);
+
+    public static void imaqColorEqualize(Image dest, Image source, int colorEqualization) {
+        
+        _imaqColorEqualize(dest.getAddress(), source.getAddress(), colorEqualization);
+        
+    }
+    private static native void _imaqColorEqualize(long dest, long source, int colorEqualization);
+
+    public static ColorHistogramReport imaqColorHistogram2(Image image, int numClasses, ColorMode mode, CIEXYZValue whiteReference, Image mask) {
+        
+        long jn_rv = _imaqColorHistogram2(image.getAddress(), numClasses, mode.getValue(), whiteReference.getAddress(), mask == null ? 0 : mask.getAddress());
+        
+        return new ColorHistogramReport(jn_rv, true);
+    }
+    private static native long _imaqColorHistogram2(long image, int numClasses, int mode, long whiteReference, long mask);
+
+    public static void imaqColorThreshold(Image dest, Image source, int replaceValue, ColorMode mode, Range plane1Range, Range plane2Range, Range plane3Range) {
+        
+        _imaqColorThreshold(dest.getAddress(), source.getAddress(), replaceValue, mode.getValue(), plane1Range == null ? 0 : plane1Range.getAddress(), plane2Range == null ? 0 : plane2Range.getAddress(), plane3Range == null ? 0 : plane3Range.getAddress());
+        
+    }
+    private static native void _imaqColorThreshold(long dest, long source, int replaceValue, int mode, long plane1Range, long plane2Range, long plane3Range);
+
+    public static SupervisedColorSegmentationReport imaqSupervisedColorSegmentation(ClassifierSession session, Image labelImage, Image srcImage, ROI roi, ROILabel labelIn, int numLabelIn, int maxDistance, int minIdentificationScore, ColorSegmenationOptions segmentOptions) {
+        
+        long jn_rv = _imaqSupervisedColorSegmentation(session.getAddress(), labelImage.getAddress(), srcImage.getAddress(), roi.getAddress(), labelIn.getAddress(), numLabelIn, maxDistance, minIdentificationScore, segmentOptions.getAddress());
+        
+        return new SupervisedColorSegmentationReport(jn_rv, true);
+    }
+    private static native long _imaqSupervisedColorSegmentation(long session, long labelImage, long srcImage, long roi, long labelIn, int numLabelIn, int maxDistance, int minIdentificationScore, long segmentOptions);
+
+    public static int imaqGetColorSegmentationMaxDistance(ClassifierSession session, ColorSegmenationOptions segmentOptions, SegmentationDistanceLevel distLevel) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqGetColorSegmentationMaxDistance(session.getAddress(), segmentOptions.getAddress(), distLevel.getValue(), rv_addr+0);
+        int maxDistance;
+        maxDistance = rv_buf.getInt(0);
+        return maxDistance;
+    }
+    private static native int _imaqGetColorSegmentationMaxDistance(long session, long segmentOptions, int distLevel, long maxDistance);
+
+    /**
+     * Transform functions
+     */
+
+    public static void imaqBCGTransform(Image dest, Image source, BCGOptions options, Image mask) {
+        
+        _imaqBCGTransform(dest.getAddress(), source.getAddress(), options.getAddress(), mask == null ? 0 : mask.getAddress());
+        
+    }
+    private static native void _imaqBCGTransform(long dest, long source, long options, long mask);
+
+    public static void imaqEqualize(Image dest, Image source, float min, float max, Image mask) {
+        
+        _imaqEqualize(dest.getAddress(), source.getAddress(), min, max, mask == null ? 0 : mask.getAddress());
+        
+    }
+    private static native void _imaqEqualize(long dest, long source, float min, float max, long mask);
+
+    public static void imaqInverse(Image dest, Image source, Image mask) {
+        
+        _imaqInverse(dest.getAddress(), source.getAddress(), mask == null ? 0 : mask.getAddress());
+        
+    }
+    private static native void _imaqInverse(long dest, long source, long mask);
+
+    public static void imaqMathTransform(Image dest, Image source, MathTransformMethod method, float rangeMin, float rangeMax, float power, Image mask) {
+        
+        _imaqMathTransform(dest.getAddress(), source.getAddress(), method.getValue(), rangeMin, rangeMax, power, mask == null ? 0 : mask.getAddress());
+        
+    }
+    private static native void _imaqMathTransform(long dest, long source, int method, float rangeMin, float rangeMax, float power, long mask);
+
+    public static int imaqWatershedTransform(Image dest, Image source, int connectivity8) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqWatershedTransform(dest.getAddress(), source.getAddress(), connectivity8, rv_addr+0);
+        int zoneCount;
+        zoneCount = rv_buf.getInt(0);
+        return zoneCount;
+    }
+    private static native int _imaqWatershedTransform(long dest, long source, int connectivity8, long zoneCount);
+
+    /**
+     * Window Management functions
+     */
+
+    public static int imaqAreScrollbarsVisible(int windowNumber) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqAreScrollbarsVisible(windowNumber, rv_addr+0);
+        int visible;
+        visible = rv_buf.getInt(0);
+        return visible;
+    }
+    private static native int _imaqAreScrollbarsVisible(int windowNumber, long visible);
+
+    public static void imaqBringWindowToTop(int windowNumber) {
+        
+        _imaqBringWindowToTop(windowNumber);
+        
+    }
+    private static native void _imaqBringWindowToTop(int windowNumber);
+
+    public static class GetMousePosResult {
+        public Point position;
+        public int windowNumber;
+        private GetMousePosResult(ByteBuffer rv_buf) {
+            position = new Point(rv_buf, 0);
+            position.read();
+            windowNumber = rv_buf.getInt(8);
+        }
+    }
+
+    public static GetMousePosResult imaqGetMousePos() {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqGetMousePos(rv_addr+0, rv_addr+8);
+        GetMousePosResult rv = new GetMousePosResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqGetMousePos(long position, long windowNumber);
+
+    public static class GetWindowBackgroundResult {
+        public WindowBackgroundFillStyle fillStyle;
+        public WindowBackgroundHatchStyle hatchStyle;
+        public RGBValue fillColor;
+        public RGBValue backgroundColor;
+        private GetWindowBackgroundResult(ByteBuffer rv_buf) {
+            fillStyle = WindowBackgroundFillStyle.fromValue(rv_buf.getInt(0));
+            hatchStyle = WindowBackgroundHatchStyle.fromValue(rv_buf.getInt(8));
+            fillColor = new RGBValue(rv_buf, 16);
+            fillColor.read();
+            backgroundColor = new RGBValue(rv_buf, 24);
+            backgroundColor.read();
+        }
+    }
+
+    public static GetWindowBackgroundResult imaqGetWindowBackground(int windowNumber) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(40);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqGetWindowBackground(windowNumber, rv_addr+0, rv_addr+8, rv_addr+16, rv_addr+24);
+        GetWindowBackgroundResult rv = new GetWindowBackgroundResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqGetWindowBackground(int windowNumber, long fillStyle, long hatchStyle, long fillColor, long backgroundColor);
+
+    public static DisplayMapping imaqGetWindowDisplayMapping(int windowNum) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetWindowDisplayMapping(windowNum, rv_addr+0);
+        DisplayMapping mapping;
+        mapping = new DisplayMapping(rv_buf, 0);
+        mapping.read();
+        return mapping;
+    }
+    private static native long _imaqGetWindowDisplayMapping(int windowNum, long mapping);
+
+    public static class GetWindowGridResult {
+        public int xResolution;
+        public int yResolution;
+        private GetWindowGridResult(ByteBuffer rv_buf) {
+            xResolution = rv_buf.getInt(0);
+            yResolution = rv_buf.getInt(8);
+        }
+    }
+
+    public static GetWindowGridResult imaqGetWindowGrid(int windowNumber) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqGetWindowGrid(windowNumber, rv_addr+0, rv_addr+8);
+        GetWindowGridResult rv = new GetWindowGridResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqGetWindowGrid(int windowNumber, long xResolution, long yResolution);
+
+    public static int imaqGetWindowHandle() {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqGetWindowHandle(rv_addr+0);
+        int handle;
+        handle = rv_buf.getInt(0);
+        return handle;
+    }
+    private static native int _imaqGetWindowHandle(long handle);
+
+    public static Point imaqGetWindowPos(int windowNumber) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetWindowPos(windowNumber, rv_addr+0);
+        Point position;
+        position = new Point(rv_buf, 0);
+        position.read();
+        return position;
+    }
+    private static native long _imaqGetWindowPos(int windowNumber, long position);
+
+    public static class GetWindowSizeResult {
+        public int width;
+        public int height;
+        private GetWindowSizeResult(ByteBuffer rv_buf) {
+            width = rv_buf.getInt(0);
+            height = rv_buf.getInt(8);
+        }
+    }
+
+    public static GetWindowSizeResult imaqGetWindowSize(int windowNumber) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqGetWindowSize(windowNumber, rv_addr+0, rv_addr+8);
+        GetWindowSizeResult rv = new GetWindowSizeResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqGetWindowSize(int windowNumber, long width, long height);
+
+    public static String imaqGetWindowTitle(int windowNumber) {
+        
+        String jn_rv = _imaqGetWindowTitle(windowNumber);
+        
+        return jn_rv;
+    }
+    private static native String _imaqGetWindowTitle(int windowNumber);
+
+    public static class GetWindowZoom2Result {
+        public float xZoom;
+        public float yZoom;
+        private GetWindowZoom2Result(ByteBuffer rv_buf) {
+            xZoom = rv_buf.getFloat(0);
+            yZoom = rv_buf.getFloat(8);
+        }
+    }
+
+    public static GetWindowZoom2Result imaqGetWindowZoom2(int windowNumber) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqGetWindowZoom2(windowNumber, rv_addr+0, rv_addr+8);
+        GetWindowZoom2Result rv = new GetWindowZoom2Result(rv_buf);
+        return rv;
+    }
+    private static native void _imaqGetWindowZoom2(int windowNumber, long xZoom, long yZoom);
+
+    public static int imaqIsWindowNonTearing(int windowNumber) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqIsWindowNonTearing(windowNumber, rv_addr+0);
+        int nonTearing;
+        nonTearing = rv_buf.getInt(0);
+        return nonTearing;
+    }
+    private static native int _imaqIsWindowNonTearing(int windowNumber, long nonTearing);
+
+    public static int imaqIsWindowVisible(int windowNumber) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqIsWindowVisible(windowNumber, rv_addr+0);
+        int visible;
+        visible = rv_buf.getInt(0);
+        return visible;
+    }
+    private static native int _imaqIsWindowVisible(int windowNumber, long visible);
+
+    public static void imaqMoveWindow(int windowNumber, Point position) {
+        
+        _imaqMoveWindow(windowNumber, position.getAddress());
+        
+    }
+    private static native void _imaqMoveWindow(int windowNumber, long position);
+
+    public static void imaqSetupWindow(int windowNumber, int configuration) {
+        
+        _imaqSetupWindow(windowNumber, configuration);
+        
+    }
+    private static native void _imaqSetupWindow(int windowNumber, int configuration);
+
+    public static void imaqSetWindowBackground(int windowNumber, WindowBackgroundFillStyle fillStyle, WindowBackgroundHatchStyle hatchStyle, RGBValue fillColor, RGBValue backgroundColor) {
+        
+        _imaqSetWindowBackground(windowNumber, fillStyle.getValue(), hatchStyle.getValue(), fillColor.getAddress(), backgroundColor.getAddress());
+        
+    }
+    private static native void _imaqSetWindowBackground(int windowNumber, int fillStyle, int hatchStyle, long fillColor, long backgroundColor);
+
+    public static void imaqSetWindowDisplayMapping(int windowNumber, DisplayMapping mapping) {
+        
+        _imaqSetWindowDisplayMapping(windowNumber, mapping.getAddress());
+        
+    }
+    private static native void _imaqSetWindowDisplayMapping(int windowNumber, long mapping);
+
+    public static void imaqSetWindowGrid(int windowNumber, int xResolution, int yResolution) {
+        
+        _imaqSetWindowGrid(windowNumber, xResolution, yResolution);
+        
+    }
+    private static native void _imaqSetWindowGrid(int windowNumber, int xResolution, int yResolution);
+
+    public static void imaqSetWindowMaxContourCount(int windowNumber, int maxContourCount) {
+        
+        _imaqSetWindowMaxContourCount(windowNumber, maxContourCount);
+        
+    }
+    private static native void _imaqSetWindowMaxContourCount(int windowNumber, int maxContourCount);
+
+    public static void imaqSetWindowNonTearing(int windowNumber, int nonTearing) {
+        
+        _imaqSetWindowNonTearing(windowNumber, nonTearing);
+        
+    }
+    private static native void _imaqSetWindowNonTearing(int windowNumber, int nonTearing);
+
+    public static void imaqSetWindowPalette(int windowNumber, PaletteType type, RGBValue[] palette) {
+        int numColors = palette.length;
+        ByteBuffer palette_buf = null;
+        palette_buf = ByteBuffer.allocateDirect(palette.length*4);
+        for (int i=0, off=0; i<palette.length; i++, off += 4) {
+            palette[i].setBuffer(palette_buf, off);
+            palette[i].write();
+        }
+        _imaqSetWindowPalette(windowNumber, type.getValue(), getByteBufferAddress(palette_buf), numColors);
+        
+    }
+    private static native void _imaqSetWindowPalette(int windowNumber, int type, long palette, int numColors);
+
+    public static void imaqSetWindowSize(int windowNumber, int width, int height) {
+        
+        _imaqSetWindowSize(windowNumber, width, height);
+        
+    }
+    private static native void _imaqSetWindowSize(int windowNumber, int width, int height);
+
+    public static void imaqSetWindowThreadPolicy(WindowThreadPolicy policy) {
+        
+        _imaqSetWindowThreadPolicy(policy.getValue());
+        
+    }
+    private static native void _imaqSetWindowThreadPolicy(int policy);
+
+    public static void imaqSetWindowTitle(int windowNumber, String title) {
+        ByteBuffer title_buf = null;
+        if (title != null) {
+            byte[] title_bytes;
+            try {
+                title_bytes = title.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                title_bytes = new byte[0];
+            }
+            title_buf = ByteBuffer.allocateDirect(title_bytes.length+1);
+            putBytes(title_buf, title_bytes, 0, title_bytes.length).put(title_bytes.length, (byte)0);
+        }
+        _imaqSetWindowTitle(windowNumber, title == null ? 0 : getByteBufferAddress(title_buf));
+        
+    }
+    private static native void _imaqSetWindowTitle(int windowNumber, long title);
+
+    public static void imaqSetWindowZoomToFit(int windowNumber, int zoomToFit) {
+        
+        _imaqSetWindowZoomToFit(windowNumber, zoomToFit);
+        
+    }
+    private static native void _imaqSetWindowZoomToFit(int windowNumber, int zoomToFit);
+
+    public static void imaqShowScrollbars(int windowNumber, int visible) {
+        
+        _imaqShowScrollbars(windowNumber, visible);
+        
+    }
+    private static native void _imaqShowScrollbars(int windowNumber, int visible);
+
+    public static void imaqZoomWindow2(int windowNumber, float xZoom, float yZoom, Point center) {
+        
+        _imaqZoomWindow2(windowNumber, xZoom, yZoom, center.getAddress());
+        
+    }
+    private static native void _imaqZoomWindow2(int windowNumber, float xZoom, float yZoom, long center);
+
+    /**
+     * Utilities functions
+     */
+
+    public static int imaqMulticoreOptions(MulticoreOperation operation) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqMulticoreOptions(operation.getValue(), rv_addr+0);
+        int customNumCores;
+        customNumCores = rv_buf.getInt(0);
+        return customNumCores;
+    }
+    private static native int _imaqMulticoreOptions(int operation, long customNumCores);
+
+    /**
+     * Tool Window functions
+     */
+
+    public static void imaqCloseToolWindow() {
+        
+        _imaqCloseToolWindow();
+        
+    }
+    private static native void _imaqCloseToolWindow();
+
+    public static Tool imaqGetCurrentTool() {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqGetCurrentTool(rv_addr+0);
+        Tool currentTool;
+        currentTool = Tool.fromValue(rv_buf.getInt(0));
+        return currentTool;
+    }
+    private static native int _imaqGetCurrentTool(long currentTool);
+
+    public static class GetLastEventResult {
+        public WindowEventType type;
+        public int windowNumber;
+        public Tool tool;
+        public Rect rect;
+        private GetLastEventResult(ByteBuffer rv_buf) {
+            type = WindowEventType.fromValue(rv_buf.getInt(0));
+            windowNumber = rv_buf.getInt(8);
+            tool = Tool.fromValue(rv_buf.getInt(16));
+            rect = new Rect(rv_buf, 24);
+            rect.read();
+        }
+    }
+
+    public static GetLastEventResult imaqGetLastEvent() {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(40);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqGetLastEvent(rv_addr+0, rv_addr+8, rv_addr+16, rv_addr+24);
+        GetLastEventResult rv = new GetLastEventResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqGetLastEvent(long type, long windowNumber, long tool, long rect);
+
+    public static Point imaqGetToolWindowPos() {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetToolWindowPos(rv_addr+0);
+        Point position;
+        position = new Point(rv_buf, 0);
+        position.read();
+        return position;
+    }
+    private static native long _imaqGetToolWindowPos(long position);
+
+    public static int imaqIsToolWindowVisible() {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqIsToolWindowVisible(rv_addr+0);
+        int visible;
+        visible = rv_buf.getInt(0);
+        return visible;
+    }
+    private static native int _imaqIsToolWindowVisible(long visible);
+
+    public static void imaqMoveToolWindow(Point position) {
+        
+        _imaqMoveToolWindow(position.getAddress());
+        
+    }
+    private static native void _imaqMoveToolWindow(long position);
+
+    public static void imaqSetCurrentTool(Tool currentTool) {
+        
+        _imaqSetCurrentTool(currentTool.getValue());
+        
+    }
+    private static native void _imaqSetCurrentTool(int currentTool);
+
+    public static void imaqSetToolColor(RGBValue color) {
+        
+        _imaqSetToolColor(color.getAddress());
+        
+    }
+    private static native void _imaqSetToolColor(long color);
+
+    public static void imaqSetupToolWindow(int showCoordinates, int maxIconsPerLine, ToolWindowOptions options) {
+        
+        _imaqSetupToolWindow(showCoordinates, maxIconsPerLine, options == null ? 0 : options.getAddress());
+        
+    }
+    private static native void _imaqSetupToolWindow(int showCoordinates, int maxIconsPerLine, long options);
+
+    public static void imaqShowToolWindow(int visible) {
+        
+        _imaqShowToolWindow(visible);
+        
+    }
+    private static native void _imaqShowToolWindow(int visible);
+
+    /**
+     * Meter functions
+     */
+
+    public static MeterArc imaqGetMeterArc(int lightNeedle, MeterArcMode mode, ROI roi, PointFloat base, PointFloat start, PointFloat end) {
+        
+        long jn_rv = _imaqGetMeterArc(lightNeedle, mode.getValue(), roi.getAddress(), base.getAddress(), start.getAddress(), end.getAddress());
+        
+        return new MeterArc(jn_rv, true);
+    }
+    private static native long _imaqGetMeterArc(int lightNeedle, int mode, long roi, long base, long start, long end);
+
+    public static class ReadMeterResult {
+        public double percentage;
+        public PointFloat endOfNeedle;
+        private ReadMeterResult(ByteBuffer rv_buf) {
+            percentage = rv_buf.getDouble(0);
+            endOfNeedle = new PointFloat(rv_buf, 8);
+            endOfNeedle.read();
+        }
+    }
+
+    public static ReadMeterResult imaqReadMeter(Image image, MeterArc arcInfo) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqReadMeter(image.getAddress(), arcInfo.getAddress(), rv_addr+0, rv_addr+8);
+        ReadMeterResult rv = new ReadMeterResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqReadMeter(long image, long arcInfo, long percentage, long endOfNeedle);
+
+    /**
+     * Calibration functions
+     */
+
+    public static void imaqCopyCalibrationInfo2(Image dest, Image source, Point offset) {
+        
+        _imaqCopyCalibrationInfo2(dest.getAddress(), source.getAddress(), offset.getAddress());
+        
+    }
+    private static native void _imaqCopyCalibrationInfo2(long dest, long source, long offset);
+
+    public static CalibrationInfo imaqGetCalibrationInfo2(Image image) {
+        
+        long jn_rv = _imaqGetCalibrationInfo2(image.getAddress());
+        
+        return new CalibrationInfo(jn_rv, true);
+    }
+    private static native long _imaqGetCalibrationInfo2(long image);
+
+    public static CalibrationInfo imaqGetCalibrationInfo3(Image image, int isGetErrorMap) {
+        
+        long jn_rv = _imaqGetCalibrationInfo3(image.getAddress(), isGetErrorMap);
+        
+        return new CalibrationInfo(jn_rv, true);
+    }
+    private static native long _imaqGetCalibrationInfo3(long image, int isGetErrorMap);
+
+    public static float imaqLearnCalibrationGrid(Image image, ROI roi, LearnCalibrationOptions options, GridDescriptor grid, CoordinateSystem system, RangeFloat range) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        float jn_rv = _imaqLearnCalibrationGrid(image.getAddress(), roi.getAddress(), options.getAddress(), grid.getAddress(), system.getAddress(), range.getAddress(), rv_addr+0);
+        float quality;
+        quality = rv_buf.getFloat(0);
+        return quality;
+    }
+    private static native float _imaqLearnCalibrationGrid(long image, long roi, long options, long grid, long system, long range, long quality);
+
+    public static float imaqLearnCalibrationPoints(Image image, CalibrationPoints points, ROI roi, LearnCalibrationOptions options, GridDescriptor grid, CoordinateSystem system) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        float jn_rv = _imaqLearnCalibrationPoints(image.getAddress(), points.getAddress(), roi.getAddress(), options.getAddress(), grid.getAddress(), system.getAddress(), rv_addr+0);
+        float quality;
+        quality = rv_buf.getFloat(0);
+        return quality;
+    }
+    private static native float _imaqLearnCalibrationPoints(long image, long points, long roi, long options, long grid, long system, long quality);
+
+    public static void imaqSetCoordinateSystem(Image image, CoordinateSystem system) {
+        
+        _imaqSetCoordinateSystem(image.getAddress(), system.getAddress());
+        
+    }
+    private static native void _imaqSetCoordinateSystem(long image, long system);
+
+    public static void imaqSetSimpleCalibration(Image image, ScalingMethod method, int learnTable, GridDescriptor grid, CoordinateSystem system) {
+        
+        _imaqSetSimpleCalibration(image.getAddress(), method.getValue(), learnTable, grid.getAddress(), system.getAddress());
+        
+    }
+    private static native void _imaqSetSimpleCalibration(long image, int method, int learnTable, long grid, long system);
+
+    public static TransformReport imaqTransformPixelToRealWorld(Image image, PointFloat[] pixelCoordinates) {
+        int numCoordinates = pixelCoordinates.length;
+        ByteBuffer pixelCoordinates_buf = null;
+        pixelCoordinates_buf = ByteBuffer.allocateDirect(pixelCoordinates.length*8);
+        for (int i=0, off=0; i<pixelCoordinates.length; i++, off += 8) {
+            pixelCoordinates[i].setBuffer(pixelCoordinates_buf, off);
+            pixelCoordinates[i].write();
+        }
+        long jn_rv = _imaqTransformPixelToRealWorld(image.getAddress(), getByteBufferAddress(pixelCoordinates_buf), numCoordinates);
+        
+        return new TransformReport(jn_rv, true);
+    }
+    private static native long _imaqTransformPixelToRealWorld(long image, long pixelCoordinates, int numCoordinates);
+
+    public static TransformReport imaqTransformRealWorldToPixel(Image image, PointFloat[] realWorldCoordinates) {
+        int numCoordinates = realWorldCoordinates.length;
+        ByteBuffer realWorldCoordinates_buf = null;
+        realWorldCoordinates_buf = ByteBuffer.allocateDirect(realWorldCoordinates.length*8);
+        for (int i=0, off=0; i<realWorldCoordinates.length; i++, off += 8) {
+            realWorldCoordinates[i].setBuffer(realWorldCoordinates_buf, off);
+            realWorldCoordinates[i].write();
+        }
+        long jn_rv = _imaqTransformRealWorldToPixel(image.getAddress(), getByteBufferAddress(realWorldCoordinates_buf), numCoordinates);
+        
+        return new TransformReport(jn_rv, true);
+    }
+    private static native long _imaqTransformRealWorldToPixel(long image, long realWorldCoordinates, int numCoordinates);
+
+    public static void imaqSetSimpleCalibration2(Image image, GridDescriptor gridDescriptor) {
+        
+        _imaqSetSimpleCalibration2(image.getAddress(), gridDescriptor.getAddress());
+        
+    }
+    private static native void _imaqSetSimpleCalibration2(long image, long gridDescriptor);
+
+    public static CoordinateSystem imaqCalibrationSetAxisInfo(Image image) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqCalibrationSetAxisInfo(image.getAddress(), rv_addr+0);
+        CoordinateSystem axisInfo;
+        axisInfo = new CoordinateSystem(rv_buf, 0);
+        axisInfo.read();
+        return axisInfo;
+    }
+    private static native long _imaqCalibrationSetAxisInfo(long image, long axisInfo);
+
+    public static void imaqCalibrationGetThumbnailImage(Image templateImage, Image image, CalibrationThumbnailType type, int index) {
+        
+        _imaqCalibrationGetThumbnailImage(templateImage.getAddress(), image.getAddress(), type.getValue(), index);
+        
+    }
+    private static native void _imaqCalibrationGetThumbnailImage(long templateImage, long image, int type, int index);
+
+    public static GetCalibrationInfoReport imaqCalibrationGetCalibrationInfo(Image image, int isGetErrorMap) {
+        
+        long jn_rv = _imaqCalibrationGetCalibrationInfo(image.getAddress(), isGetErrorMap);
+        
+        return new GetCalibrationInfoReport(jn_rv, true);
+    }
+    private static native long _imaqCalibrationGetCalibrationInfo(long image, int isGetErrorMap);
+
+    public static GetCameraParametersReport imaqCalibrationGetCameraParameters(Image templateImage) {
+        
+        long jn_rv = _imaqCalibrationGetCameraParameters(templateImage.getAddress());
+        
+        return new GetCameraParametersReport(jn_rv, true);
+    }
+    private static native long _imaqCalibrationGetCameraParameters(long templateImage);
+
+    public static void imaqCalibrationCompactInformation(Image image) {
+        
+        _imaqCalibrationCompactInformation(image.getAddress());
+        
+    }
+    private static native void _imaqCalibrationCompactInformation(long image);
+
+    /**
+     * Pixel Manipulation functions
+     */
+
+    public static void imaqExtractColorPlanes(Image image, ColorMode mode, Image plane1, Image plane2, Image plane3) {
+        
+        _imaqExtractColorPlanes(image.getAddress(), mode.getValue(), plane1 == null ? 0 : plane1.getAddress(), plane2 == null ? 0 : plane2.getAddress(), plane3 == null ? 0 : plane3.getAddress());
+        
+    }
+    private static native void _imaqExtractColorPlanes(long image, int mode, long plane1, long plane2, long plane3);
+
+    public static void imaqExtractComplexPlane(Image dest, Image source, ComplexPlane plane) {
+        
+        _imaqExtractComplexPlane(dest.getAddress(), source.getAddress(), plane.getValue());
+        
+    }
+    private static native void _imaqExtractComplexPlane(long dest, long source, int plane);
+
+    public static void imaqReplaceColorPlanes(Image dest, Image source, ColorMode mode, Image plane1, Image plane2, Image plane3) {
+        
+        _imaqReplaceColorPlanes(dest.getAddress(), source.getAddress(), mode.getValue(), plane1 == null ? 0 : plane1.getAddress(), plane2 == null ? 0 : plane2.getAddress(), plane3 == null ? 0 : plane3.getAddress());
+        
+    }
+    private static native void _imaqReplaceColorPlanes(long dest, long source, int mode, long plane1, long plane2, long plane3);
+
+    public static void imaqReplaceComplexPlane(Image dest, Image source, Image newValues, ComplexPlane plane) {
+        
+        _imaqReplaceComplexPlane(dest.getAddress(), source.getAddress(), newValues.getAddress(), plane.getValue());
+        
+    }
+    private static native void _imaqReplaceComplexPlane(long dest, long source, long newValues, int plane);
+
+    /**
+     * Color Matching functions
+     */
+
+    public static ColorInformation imaqLearnColor(Image image, ROI roi, ColorSensitivity sensitivity, int saturation) {
+        
+        long jn_rv = _imaqLearnColor(image.getAddress(), roi == null ? 0 : roi.getAddress(), sensitivity.getValue(), saturation);
+        
+        return new ColorInformation(jn_rv, true);
+    }
+    private static native long _imaqLearnColor(long image, long roi, int sensitivity, int saturation);
+
+    /**
+     * Frequency Domain Analysis functions
+     */
+
+    public static void imaqAttenuate(Image dest, Image source, AttenuateMode highlow) {
+        
+        _imaqAttenuate(dest.getAddress(), source.getAddress(), highlow.getValue());
+        
+    }
+    private static native void _imaqAttenuate(long dest, long source, int highlow);
+
+    public static void imaqConjugate(Image dest, Image source) {
+        
+        _imaqConjugate(dest.getAddress(), source.getAddress());
+        
+    }
+    private static native void _imaqConjugate(long dest, long source);
+
+    public static void imaqFFT(Image dest, Image source) {
+        
+        _imaqFFT(dest.getAddress(), source.getAddress());
+        
+    }
+    private static native void _imaqFFT(long dest, long source);
+
+    public static void imaqFlipFrequencies(Image dest, Image source) {
+        
+        _imaqFlipFrequencies(dest.getAddress(), source.getAddress());
+        
+    }
+    private static native void _imaqFlipFrequencies(long dest, long source);
+
+    public static void imaqInverseFFT(Image dest, Image source) {
+        
+        _imaqInverseFFT(dest.getAddress(), source.getAddress());
+        
+    }
+    private static native void _imaqInverseFFT(long dest, long source);
+
+    public static void imaqTruncate(Image dest, Image source, TruncateMode highlow, float ratioToKeep) {
+        
+        _imaqTruncate(dest.getAddress(), source.getAddress(), highlow.getValue(), ratioToKeep);
+        
+    }
+    private static native void _imaqTruncate(long dest, long source, int highlow, float ratioToKeep);
+
+    /**
+     * Barcode I/O functions
+     */
+
+    public static AIMGradeReport imaqGradeDataMatrixBarcodeAIM(Image image) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGradeDataMatrixBarcodeAIM(image.getAddress(), rv_addr+0);
+        AIMGradeReport report;
+        report = new AIMGradeReport(rv_buf, 0);
+        report.read();
+        return report;
+    }
+    private static native long _imaqGradeDataMatrixBarcodeAIM(long image, long report);
+
+    public static BarcodeInfo imaqReadBarcode(Image image, BarcodeType type, ROI roi, int validate) {
+        
+        long jn_rv = _imaqReadBarcode(image.getAddress(), type.getValue(), roi == null ? 0 : roi.getAddress(), validate);
+        
+        return new BarcodeInfo(jn_rv, true);
+    }
+    private static native long _imaqReadBarcode(long image, int type, long roi, int validate);
+
+    public static DataMatrixReport imaqReadDataMatrixBarcode2(Image image, ROI roi, DataMatrixGradingMode prepareForGrading, DataMatrixDescriptionOptions descriptionOptions, DataMatrixSizeOptions sizeOptions, DataMatrixSearchOptions searchOptions) {
+        
+        long jn_rv = _imaqReadDataMatrixBarcode2(image.getAddress(), roi.getAddress(), prepareForGrading.getValue(), descriptionOptions.getAddress(), sizeOptions.getAddress(), searchOptions.getAddress());
+        
+        return new DataMatrixReport(jn_rv, true);
+    }
+    private static native long _imaqReadDataMatrixBarcode2(long image, long roi, int prepareForGrading, long descriptionOptions, long sizeOptions, long searchOptions);
+
+    public static class ReadPDF417BarcodeResult {
+        public Barcode2DInfo[] array;
+        private long array_addr;
+        private ReadPDF417BarcodeResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numBarcodes;
+            array_numBarcodes = rv_buf.getInt(0);
+            array = new Barcode2DInfo[array_numBarcodes];
+            if (array_numBarcodes > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numBarcodes*64);
+                for (int i=0, off=0; i<array_numBarcodes; i++, off += 64) {
+                    array[i] = new Barcode2DInfo(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static ReadPDF417BarcodeResult imaqReadPDF417Barcode(Image image, ROI roi, Barcode2DSearchMode searchMode) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqReadPDF417Barcode(image.getAddress(), roi.getAddress(), searchMode.getValue(), rv_addr+0);
+        ReadPDF417BarcodeResult rv = new ReadPDF417BarcodeResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqReadPDF417Barcode(long image, long roi, int searchMode, long numBarcodes);
+
+    public static QRCodeReport imaqReadQRCode(Image image, ROI roi, QRGradingMode reserved, QRCodeDescriptionOptions descriptionOptions, QRCodeSizeOptions sizeOptions, QRCodeSearchOptions searchOptions) {
+        
+        long jn_rv = _imaqReadQRCode(image.getAddress(), roi.getAddress(), reserved.getValue(), descriptionOptions.getAddress(), sizeOptions.getAddress(), searchOptions.getAddress());
+        
+        return new QRCodeReport(jn_rv, true);
+    }
+    private static native long _imaqReadQRCode(long image, long roi, int reserved, long descriptionOptions, long sizeOptions, long searchOptions);
+
+    /**
+     * LCD functions
+     */
+
+    public static void imaqFindLCDSegments(ROI roi, Image image, LCDOptions options) {
+        
+        _imaqFindLCDSegments(roi.getAddress(), image.getAddress(), options == null ? 0 : options.getAddress());
+        
+    }
+    private static native void _imaqFindLCDSegments(long roi, long image, long options);
+
+    public static LCDReport imaqReadLCD(Image image, ROI roi, LCDOptions options) {
+        
+        long jn_rv = _imaqReadLCD(image.getAddress(), roi.getAddress(), options == null ? 0 : options.getAddress());
+        
+        return new LCDReport(jn_rv, true);
+    }
+    private static native long _imaqReadLCD(long image, long roi, long options);
+
+    /**
+     * Shape Matching functions
+     */
+
+    public static class MatchShapeResult {
+        public ShapeReport[] array;
+        private long array_addr;
+        private MatchShapeResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numMatches;
+            array_numMatches = rv_buf.getInt(0);
+            array = new ShapeReport[array_numMatches];
+            if (array_numMatches > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatches*40);
+                for (int i=0, off=0; i<array_numMatches; i++, off += 40) {
+                    array[i] = new ShapeReport(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static MatchShapeResult imaqMatchShape(Image dest, Image source, Image templateImage, int scaleInvariant, int connectivity8, double tolerance) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqMatchShape(dest.getAddress(), source.getAddress(), templateImage.getAddress(), scaleInvariant, connectivity8, tolerance, rv_addr+0);
+        MatchShapeResult rv = new MatchShapeResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqMatchShape(long dest, long source, long templateImage, int scaleInvariant, int connectivity8, double tolerance, long numMatches);
+
+    /**
+     * Contours functions
+     */
+
+    public static int imaqAddAnnulusContour(ROI roi, Annulus annulus) {
+        
+        int jn_rv = _imaqAddAnnulusContour(roi.getAddress(), annulus.getAddress());
+        
+        return jn_rv;
+    }
+    private static native int _imaqAddAnnulusContour(long roi, long annulus);
+
+    public static int imaqAddClosedContour(ROI roi, Point[] points) {
+        int numPoints = points.length;
+        ByteBuffer points_buf = null;
+        points_buf = ByteBuffer.allocateDirect(points.length*8);
+        for (int i=0, off=0; i<points.length; i++, off += 8) {
+            points[i].setBuffer(points_buf, off);
+            points[i].write();
+        }
+        int jn_rv = _imaqAddClosedContour(roi.getAddress(), getByteBufferAddress(points_buf), numPoints);
+        
+        return jn_rv;
+    }
+    private static native int _imaqAddClosedContour(long roi, long points, int numPoints);
+
+    public static int imaqAddLineContour(ROI roi, Point start, Point end) {
+        
+        int jn_rv = _imaqAddLineContour(roi.getAddress(), start.getAddress(), end.getAddress());
+        
+        return jn_rv;
+    }
+    private static native int _imaqAddLineContour(long roi, long start, long end);
+
+    public static int imaqAddOpenContour(ROI roi, Point[] points) {
+        int numPoints = points.length;
+        ByteBuffer points_buf = null;
+        points_buf = ByteBuffer.allocateDirect(points.length*8);
+        for (int i=0, off=0; i<points.length; i++, off += 8) {
+            points[i].setBuffer(points_buf, off);
+            points[i].write();
+        }
+        int jn_rv = _imaqAddOpenContour(roi.getAddress(), getByteBufferAddress(points_buf), numPoints);
+        
+        return jn_rv;
+    }
+    private static native int _imaqAddOpenContour(long roi, long points, int numPoints);
+
+    public static int imaqAddOvalContour(ROI roi, Rect boundingBox) {
+        
+        int jn_rv = _imaqAddOvalContour(roi.getAddress(), boundingBox.getAddress());
+        
+        return jn_rv;
+    }
+    private static native int _imaqAddOvalContour(long roi, long boundingBox);
+
+    public static int imaqAddPointContour(ROI roi, Point point) {
+        
+        int jn_rv = _imaqAddPointContour(roi.getAddress(), point.getAddress());
+        
+        return jn_rv;
+    }
+    private static native int _imaqAddPointContour(long roi, long point);
+
+    public static int imaqAddRectContour(ROI roi, Rect rect) {
+        
+        int jn_rv = _imaqAddRectContour(roi.getAddress(), rect.getAddress());
+        
+        return jn_rv;
+    }
+    private static native int _imaqAddRectContour(long roi, long rect);
+
+    public static int imaqAddRotatedRectContour2(ROI roi, RotatedRect rect) {
+        
+        int jn_rv = _imaqAddRotatedRectContour2(roi.getAddress(), rect.getAddress());
+        
+        return jn_rv;
+    }
+    private static native int _imaqAddRotatedRectContour2(long roi, long rect);
+
+    public static int imaqCopyContour(ROI destRoi, ROI sourceRoi, int id) {
+        
+        int jn_rv = _imaqCopyContour(destRoi.getAddress(), sourceRoi.getAddress(), id);
+        
+        return jn_rv;
+    }
+    private static native int _imaqCopyContour(long destRoi, long sourceRoi, int id);
+
+    public static int imaqGetContour(ROI roi, int index) {
+        
+        int jn_rv = _imaqGetContour(roi.getAddress(), index);
+        
+        return jn_rv;
+    }
+    private static native int _imaqGetContour(long roi, int index);
+
+    public static RGBValue imaqGetContourColor(ROI roi, int id) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetContourColor(roi.getAddress(), id, rv_addr+0);
+        RGBValue contourColor;
+        contourColor = new RGBValue(rv_buf, 0);
+        contourColor.read();
+        return contourColor;
+    }
+    private static native long _imaqGetContourColor(long roi, int id, long contourColor);
+
+    public static void imaqGetContourCount(ROI roi) {
+        
+        _imaqGetContourCount(roi.getAddress());
+        
+    }
+    private static native void _imaqGetContourCount(long roi);
+
+    public static ContourInfo2 imaqGetContourInfo2(ROI roi, int id) {
+        
+        long jn_rv = _imaqGetContourInfo2(roi.getAddress(), id);
+        
+        return new ContourInfo2(jn_rv, true);
+    }
+    private static native long _imaqGetContourInfo2(long roi, int id);
+
+    public static void imaqMoveContour(ROI roi, int id, int deltaX, int deltaY) {
+        
+        _imaqMoveContour(roi.getAddress(), id, deltaX, deltaY);
+        
+    }
+    private static native void _imaqMoveContour(long roi, int id, int deltaX, int deltaY);
+
+    public static void imaqRemoveContour(ROI roi, int id) {
+        
+        _imaqRemoveContour(roi.getAddress(), id);
+        
+    }
+    private static native void _imaqRemoveContour(long roi, int id);
+
+    public static void imaqSetContourColor(ROI roi, int id, RGBValue color) {
+        
+        _imaqSetContourColor(roi.getAddress(), id, color.getAddress());
+        
+    }
+    private static native void _imaqSetContourColor(long roi, int id, long color);
+
+    /**
+     * Regions of Interest functions
+     */
+
+    public static int imaqConstructROI2(Image image, ROI roi, Tool initialTool, ToolWindowOptions tools, ConstructROIOptions2 options) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqConstructROI2(image.getAddress(), roi.getAddress(), initialTool.getValue(), tools.getAddress(), options.getAddress(), rv_addr+0);
+        int okay;
+        okay = rv_buf.getInt(0);
+        return okay;
+    }
+    private static native int _imaqConstructROI2(long image, long roi, int initialTool, long tools, long options, long okay);
+
+    public static ROI imaqCreateROI() {
+        
+        long jn_rv = _imaqCreateROI();
+        
+        return new ROI(jn_rv, true);
+    }
+    private static native long _imaqCreateROI();
+
+    public static Rect imaqGetROIBoundingBox(ROI roi) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetROIBoundingBox(roi.getAddress(), rv_addr+0);
+        Rect boundingBox;
+        boundingBox = new Rect(rv_buf, 0);
+        boundingBox.read();
+        return boundingBox;
+    }
+    private static native long _imaqGetROIBoundingBox(long roi, long boundingBox);
+
+    public static RGBValue imaqGetROIColor(ROI roi) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetROIColor(roi.getAddress(), rv_addr+0);
+        RGBValue roiColor;
+        roiColor = new RGBValue(rv_buf, 0);
+        roiColor.read();
+        return roiColor;
+    }
+    private static native long _imaqGetROIColor(long roi, long roiColor);
+
+    public static ROI imaqGetWindowROI(int windowNumber) {
+        
+        long jn_rv = _imaqGetWindowROI(windowNumber);
+        
+        return new ROI(jn_rv, true);
+    }
+    private static native long _imaqGetWindowROI(int windowNumber);
+
+    public static void imaqSetROIColor(ROI roi, RGBValue color) {
+        
+        _imaqSetROIColor(roi.getAddress(), color.getAddress());
+        
+    }
+    private static native void _imaqSetROIColor(long roi, long color);
+
+    public static void imaqSetWindowROI(int windowNumber, ROI roi) {
+        
+        _imaqSetWindowROI(windowNumber, roi == null ? 0 : roi.getAddress());
+        
+    }
+    private static native void _imaqSetWindowROI(int windowNumber, long roi);
+
+    /**
+     * Image Analysis functions
+     */
+
+    public static PointFloat imaqCentroid(Image image, Image mask) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqCentroid(image.getAddress(), rv_addr+0, mask.getAddress());
+        PointFloat centroid;
+        centroid = new PointFloat(rv_buf, 0);
+        centroid.read();
+        return centroid;
+    }
+    private static native long _imaqCentroid(long image, long centroid, long mask);
+
+    public static class ExtractCurvesResult {
+        public Curve[] array;
+        private long array_addr;
+        private ExtractCurvesResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numCurves;
+            array_numCurves = rv_buf.getInt(0);
+            array = new Curve[array_numCurves];
+            if (array_numCurves > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numCurves*48);
+                for (int i=0, off=0; i<array_numCurves; i++, off += 48) {
+                    array[i] = new Curve(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static ExtractCurvesResult imaqExtractCurves(Image image, ROI roi, CurveOptions curveOptions) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqExtractCurves(image.getAddress(), roi.getAddress(), curveOptions.getAddress(), rv_addr+0);
+        ExtractCurvesResult rv = new ExtractCurvesResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqExtractCurves(long image, long roi, long curveOptions, long numCurves);
+
+    public static HistogramReport imaqHistogram(Image image, int numClasses, float min, float max, Image mask) {
+        
+        long jn_rv = _imaqHistogram(image.getAddress(), numClasses, min, max, mask == null ? 0 : mask.getAddress());
+        
+        return new HistogramReport(jn_rv, true);
+    }
+    private static native long _imaqHistogram(long image, int numClasses, float min, float max, long mask);
+
+    public static LinearAverages imaqLinearAverages2(Image image, LinearAveragesMode mode, Rect rect) {
+        
+        long jn_rv = _imaqLinearAverages2(image.getAddress(), mode.getValue(), rect.getAddress());
+        
+        return new LinearAverages(jn_rv, true);
+    }
+    private static native long _imaqLinearAverages2(long image, int mode, long rect);
+
+    public static LineProfile imaqLineProfile(Image image, Point start, Point end) {
+        
+        long jn_rv = _imaqLineProfile(image.getAddress(), start.getAddress(), end.getAddress());
+        
+        return new LineProfile(jn_rv, true);
+    }
+    private static native long _imaqLineProfile(long image, long start, long end);
+
+    public static QuantifyReport imaqQuantify(Image image, Image mask) {
+        
+        long jn_rv = _imaqQuantify(image.getAddress(), mask == null ? 0 : mask.getAddress());
+        
+        return new QuantifyReport(jn_rv, true);
+    }
+    private static native long _imaqQuantify(long image, long mask);
+
+    /**
+     * Threshold functions
+     */
+
+    public static ThresholdData imaqAutoThreshold2(Image dest, Image source, int numClasses, ThresholdMethod method, Image mask) {
+        
+        long jn_rv = _imaqAutoThreshold2(dest.getAddress(), source.getAddress(), numClasses, method.getValue(), mask.getAddress());
+        
+        return new ThresholdData(jn_rv, true);
+    }
+    private static native long _imaqAutoThreshold2(long dest, long source, int numClasses, int method, long mask);
+
+    public static void imaqLocalThreshold(Image dest, Image source, int windowWidth, int windowHeight, LocalThresholdMethod method, double deviationWeight, ObjectType type, float replaceValue) {
+        
+        _imaqLocalThreshold(dest.getAddress(), source.getAddress(), windowWidth, windowHeight, method.getValue(), deviationWeight, type.getValue(), replaceValue);
+        
+    }
+    private static native void _imaqLocalThreshold(long dest, long source, int windowWidth, int windowHeight, int method, double deviationWeight, int type, float replaceValue);
+
+    public static void imaqMagicWand(Image dest, Image source, Point coord, float tolerance, int connectivity8, float replaceValue) {
+        
+        _imaqMagicWand(dest.getAddress(), source.getAddress(), coord.getAddress(), tolerance, connectivity8, replaceValue);
+        
+    }
+    private static native void _imaqMagicWand(long dest, long source, long coord, float tolerance, int connectivity8, float replaceValue);
+
+    public static void imaqMultithreshold(Image dest, Image source, ThresholdData[] ranges) {
+        int numRanges = ranges.length;
+        ByteBuffer ranges_buf = null;
+        ranges_buf = ByteBuffer.allocateDirect(ranges.length*16);
+        for (int i=0, off=0; i<ranges.length; i++, off += 16) {
+            ranges[i].setBuffer(ranges_buf, off);
+            ranges[i].write();
+        }
+        _imaqMultithreshold(dest.getAddress(), source.getAddress(), getByteBufferAddress(ranges_buf), numRanges);
+        
+    }
+    private static native void _imaqMultithreshold(long dest, long source, long ranges, int numRanges);
+
+    public static void imaqThreshold(Image dest, Image source, float rangeMin, float rangeMax, int useNewValue, float newValue) {
+        
+        _imaqThreshold(dest.getAddress(), source.getAddress(), rangeMin, rangeMax, useNewValue, newValue);
+        
+    }
+    private static native void _imaqThreshold(long dest, long source, float rangeMin, float rangeMax, int useNewValue, float newValue);
+
+    /**
+     * Memory Management functions
+     */
+
+    /**
+     * Pattern Matching functions
+     */
+
+    public static class DetectCirclesResult {
+        public CircleMatch[] array;
+        private long array_addr;
+        private DetectCirclesResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numMatchesReturned;
+            array_numMatchesReturned = rv_buf.getInt(0);
+            array = new CircleMatch[array_numMatchesReturned];
+            if (array_numMatchesReturned > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatchesReturned*24);
+                for (int i=0, off=0; i<array_numMatchesReturned; i++, off += 24) {
+                    array[i] = new CircleMatch(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static DetectCirclesResult imaqDetectCircles(Image image, CircleDescriptor circleDescriptor, CurveOptions curveOptions, ShapeDetectionOptions shapeDetectionOptions, ROI roi) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqDetectCircles(image.getAddress(), circleDescriptor.getAddress(), curveOptions.getAddress(), shapeDetectionOptions.getAddress(), roi.getAddress(), rv_addr+0);
+        DetectCirclesResult rv = new DetectCirclesResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqDetectCircles(long image, long circleDescriptor, long curveOptions, long shapeDetectionOptions, long roi, long numMatchesReturned);
+
+    public static class DetectEllipsesResult {
+        public EllipseMatch[] array;
+        private long array_addr;
+        private DetectEllipsesResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numMatchesReturned;
+            array_numMatchesReturned = rv_buf.getInt(0);
+            array = new EllipseMatch[array_numMatchesReturned];
+            if (array_numMatchesReturned > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatchesReturned*40);
+                for (int i=0, off=0; i<array_numMatchesReturned; i++, off += 40) {
+                    array[i] = new EllipseMatch(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static DetectEllipsesResult imaqDetectEllipses(Image image, EllipseDescriptor ellipseDescriptor, CurveOptions curveOptions, ShapeDetectionOptions shapeDetectionOptions, ROI roi) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqDetectEllipses(image.getAddress(), ellipseDescriptor.getAddress(), curveOptions.getAddress(), shapeDetectionOptions.getAddress(), roi.getAddress(), rv_addr+0);
+        DetectEllipsesResult rv = new DetectEllipsesResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqDetectEllipses(long image, long ellipseDescriptor, long curveOptions, long shapeDetectionOptions, long roi, long numMatchesReturned);
+
+    public static class DetectLinesResult {
+        public LineMatch[] array;
+        private long array_addr;
+        private DetectLinesResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numMatchesReturned;
+            array_numMatchesReturned = rv_buf.getInt(0);
+            array = new LineMatch[array_numMatchesReturned];
+            if (array_numMatchesReturned > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatchesReturned*40);
+                for (int i=0, off=0; i<array_numMatchesReturned; i++, off += 40) {
+                    array[i] = new LineMatch(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static DetectLinesResult imaqDetectLines(Image image, LineDescriptor lineDescriptor, CurveOptions curveOptions, ShapeDetectionOptions shapeDetectionOptions, ROI roi) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqDetectLines(image.getAddress(), lineDescriptor.getAddress(), curveOptions.getAddress(), shapeDetectionOptions.getAddress(), roi.getAddress(), rv_addr+0);
+        DetectLinesResult rv = new DetectLinesResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqDetectLines(long image, long lineDescriptor, long curveOptions, long shapeDetectionOptions, long roi, long numMatchesReturned);
+
+    public static class DetectRectanglesResult {
+        public RectangleMatch[] array;
+        private long array_addr;
+        private DetectRectanglesResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numMatchesReturned;
+            array_numMatchesReturned = rv_buf.getInt(0);
+            array = new RectangleMatch[array_numMatchesReturned];
+            if (array_numMatchesReturned > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatchesReturned*64);
+                for (int i=0, off=0; i<array_numMatchesReturned; i++, off += 64) {
+                    array[i] = new RectangleMatch(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static DetectRectanglesResult imaqDetectRectangles(Image image, RectangleDescriptor rectangleDescriptor, CurveOptions curveOptions, ShapeDetectionOptions shapeDetectionOptions, ROI roi) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqDetectRectangles(image.getAddress(), rectangleDescriptor.getAddress(), curveOptions.getAddress(), shapeDetectionOptions.getAddress(), roi.getAddress(), rv_addr+0);
+        DetectRectanglesResult rv = new DetectRectanglesResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqDetectRectangles(long image, long rectangleDescriptor, long curveOptions, long shapeDetectionOptions, long roi, long numMatchesReturned);
+
+    public static class GetGeometricFeaturesFromCurvesResult {
+        public FeatureData[] array;
+        private long array_addr;
+        private GetGeometricFeaturesFromCurvesResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numFeatures;
+            array_numFeatures = rv_buf.getInt(0);
+            array = new FeatureData[array_numFeatures];
+            if (array_numFeatures > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numFeatures*16);
+                for (int i=0, off=0; i<array_numFeatures; i++, off += 16) {
+                    array[i] = new FeatureData(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static GetGeometricFeaturesFromCurvesResult imaqGetGeometricFeaturesFromCurves(Curve[] curves, FeatureType[] featureTypes) {
+        int numCurves = curves.length;
+        ByteBuffer curves_buf = null;
+        curves_buf = ByteBuffer.allocateDirect(curves.length*48);
+        for (int i=0, off=0; i<curves.length; i++, off += 48) {
+            curves[i].setBuffer(curves_buf, off);
+            curves[i].write();
+        }
+        int numFeatureTypes = featureTypes.length;
+        ByteBuffer featureTypes_buf = null;
+        featureTypes_buf = ByteBuffer.allocateDirect(featureTypes.length*4);
+        for (int i=0, off=0; i<featureTypes.length; i++, off += 4) {
+            if (featureTypes != null)
+                featureTypes_buf.putInt(off, featureTypes[i].getValue());
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetGeometricFeaturesFromCurves(getByteBufferAddress(curves_buf), numCurves, getByteBufferAddress(featureTypes_buf), numFeatureTypes, rv_addr+0);
+        GetGeometricFeaturesFromCurvesResult rv = new GetGeometricFeaturesFromCurvesResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqGetGeometricFeaturesFromCurves(long curves, int numCurves, long featureTypes, int numFeatureTypes, long numFeatures);
+
+    public static class GetGeometricTemplateFeatureInfoResult {
+        public FeatureData[] array;
+        private long array_addr;
+        private GetGeometricTemplateFeatureInfoResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numFeatures;
+            array_numFeatures = rv_buf.getInt(0);
+            array = new FeatureData[array_numFeatures];
+            if (array_numFeatures > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numFeatures*16);
+                for (int i=0, off=0; i<array_numFeatures; i++, off += 16) {
+                    array[i] = new FeatureData(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static GetGeometricTemplateFeatureInfoResult imaqGetGeometricTemplateFeatureInfo(Image pattern) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetGeometricTemplateFeatureInfo(pattern.getAddress(), rv_addr+0);
+        GetGeometricTemplateFeatureInfoResult rv = new GetGeometricTemplateFeatureInfoResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqGetGeometricTemplateFeatureInfo(long pattern, long numFeatures);
+
+    public static void imaqLearnColorPattern(Image image, LearnColorPatternOptions options) {
+        
+        _imaqLearnColorPattern(image.getAddress(), options.getAddress());
+        
+    }
+    private static native void _imaqLearnColorPattern(long image, long options);
+
+    public static void imaqLearnGeometricPattern(Image image, PointFloat originOffset, CurveOptions curveOptions, LearnGeometricPatternAdvancedOptions advancedLearnOptions, Image mask) {
+        
+        _imaqLearnGeometricPattern(image.getAddress(), originOffset.getAddress(), curveOptions.getAddress(), advancedLearnOptions.getAddress(), mask.getAddress());
+        
+    }
+    private static native void _imaqLearnGeometricPattern(long image, long originOffset, long curveOptions, long advancedLearnOptions, long mask);
+
+    public static LearnPatternAdvancedOptions imaqLearnPattern3(Image image, LearningMode learningMode, Image mask) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqLearnPattern3(image.getAddress(), learningMode.getValue(), rv_addr+0, mask.getAddress());
+        LearnPatternAdvancedOptions advancedOptions;
+        advancedOptions = new LearnPatternAdvancedOptions(rv_buf, 0);
+        advancedOptions.read();
+        return advancedOptions;
+    }
+    private static native long _imaqLearnPattern3(long image, int learningMode, long advancedOptions, long mask);
+
+    public static class MatchColorPatternResult {
+        public PatternMatch[] array;
+        private long array_addr;
+        private MatchColorPatternResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numMatches;
+            array_numMatches = rv_buf.getInt(0);
+            array = new PatternMatch[array_numMatches];
+            if (array_numMatches > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatches*52);
+                for (int i=0, off=0; i<array_numMatches; i++, off += 52) {
+                    array[i] = new PatternMatch(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static MatchColorPatternResult imaqMatchColorPattern(Image image, Image pattern, MatchColorPatternOptions options, Rect searchRect) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqMatchColorPattern(image.getAddress(), pattern.getAddress(), options.getAddress(), searchRect.getAddress(), rv_addr+0);
+        MatchColorPatternResult rv = new MatchColorPatternResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqMatchColorPattern(long image, long pattern, long options, long searchRect, long numMatches);
+
+    public static class MatchGeometricPattern2Result {
+        public GeometricPatternMatch2[] array;
+        private long array_addr;
+        private MatchGeometricPattern2Result(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numMatches;
+            array_numMatches = rv_buf.getInt(0);
+            array = new GeometricPatternMatch2[array_numMatches];
+            if (array_numMatches > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatches*380);
+                for (int i=0, off=0; i<array_numMatches; i++, off += 380) {
+                    array[i] = new GeometricPatternMatch2(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static MatchGeometricPattern2Result imaqMatchGeometricPattern2(Image image, Image pattern, CurveOptions curveOptions, MatchGeometricPatternOptions matchOptions, MatchGeometricPatternAdvancedOptions2 advancedMatchOptions, ROI roi) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqMatchGeometricPattern2(image.getAddress(), pattern.getAddress(), curveOptions.getAddress(), matchOptions.getAddress(), advancedMatchOptions.getAddress(), roi.getAddress(), rv_addr+0);
+        MatchGeometricPattern2Result rv = new MatchGeometricPattern2Result(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqMatchGeometricPattern2(long image, long pattern, long curveOptions, long matchOptions, long advancedMatchOptions, long roi, long numMatches);
+
+    public static class MatchMultipleGeometricPatternsResult {
+        public GeometricPatternMatch2[] array;
+        private long array_addr;
+        private MatchMultipleGeometricPatternsResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numMatches;
+            array_numMatches = rv_buf.getInt(0);
+            array = new GeometricPatternMatch2[array_numMatches];
+            if (array_numMatches > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatches*380);
+                for (int i=0, off=0; i<array_numMatches; i++, off += 380) {
+                    array[i] = new GeometricPatternMatch2(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static MatchMultipleGeometricPatternsResult imaqMatchMultipleGeometricPatterns(Image image, MultipleGeometricPattern multiplePattern, ROI roi) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqMatchMultipleGeometricPatterns(image.getAddress(), multiplePattern.getAddress(), roi.getAddress(), rv_addr+0);
+        MatchMultipleGeometricPatternsResult rv = new MatchMultipleGeometricPatternsResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqMatchMultipleGeometricPatterns(long image, long multiplePattern, long roi, long numMatches);
+
+    public static MultipleGeometricPattern imaqReadMultipleGeometricPatternFile(String fileName, String description) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        ByteBuffer description_buf = ByteBuffer.allocateDirect(256);
+        if (description != null) {
+            byte[] bytes;
+            try {
+                bytes = description.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                bytes = new byte[0];
+            }
+            putBytes(description_buf, bytes, 0, bytes.length);
+            for (int i=bytes.length; i<256; i++)
+                description_buf.put(i, (byte)0); // fill with zero
+        }
+        long jn_rv = _imaqReadMultipleGeometricPatternFile(fileName == null ? 0 : getByteBufferAddress(fileName_buf), description == null ? 0 : getByteBufferAddress(description_buf));
+        
+        return new MultipleGeometricPattern(jn_rv, true);
+    }
+    private static native long _imaqReadMultipleGeometricPatternFile(long fileName, long description);
+
+    public static class RefineMatchesResult {
+        public MatchPatternOptions options;
+        public MatchPatternAdvancedOptions advancedOptions;
+        public PatternMatch[] array;
+        private long array_addr;
+        private RefineMatchesResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            options = new MatchPatternOptions(rv_buf, 0);
+            options.read();
+            advancedOptions = new MatchPatternAdvancedOptions(rv_buf, 8);
+            advancedOptions.read();
+            int array_numCandidatesOut;
+            array_numCandidatesOut = rv_buf.getInt(16);
+            array = new PatternMatch[array_numCandidatesOut];
+            if (array_numCandidatesOut > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numCandidatesOut*52);
+                for (int i=0, off=0; i<array_numCandidatesOut; i++, off += 52) {
+                    array[i] = new PatternMatch(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static RefineMatchesResult imaqRefineMatches(Image image, Image pattern, PatternMatch[] candidatesIn) {
+        int numCandidatesIn = candidatesIn.length;
+        ByteBuffer candidatesIn_buf = null;
+        candidatesIn_buf = ByteBuffer.allocateDirect(candidatesIn.length*52);
+        for (int i=0, off=0; i<candidatesIn.length; i++, off += 52) {
+            candidatesIn[i].setBuffer(candidatesIn_buf, off);
+            candidatesIn[i].write();
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(32);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqRefineMatches(image.getAddress(), pattern.getAddress(), getByteBufferAddress(candidatesIn_buf), numCandidatesIn, rv_addr+0, rv_addr+8, rv_addr+16);
+        RefineMatchesResult rv = new RefineMatchesResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqRefineMatches(long image, long pattern, long candidatesIn, int numCandidatesIn, long options, long advancedOptions, long numCandidatesOut);
+
+    public static void imaqSetMultipleGeometricPatternsOptions(MultipleGeometricPattern multiplePattern, String label, CurveOptions curveOptions, MatchGeometricPatternOptions matchOptions, MatchGeometricPatternAdvancedOptions2 advancedMatchOptions) {
+        ByteBuffer label_buf = null;
+        if (label != null) {
+            byte[] label_bytes;
+            try {
+                label_bytes = label.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                label_bytes = new byte[0];
+            }
+            label_buf = ByteBuffer.allocateDirect(label_bytes.length+1);
+            putBytes(label_buf, label_bytes, 0, label_bytes.length).put(label_bytes.length, (byte)0);
+        }
+        _imaqSetMultipleGeometricPatternsOptions(multiplePattern.getAddress(), label == null ? 0 : getByteBufferAddress(label_buf), curveOptions.getAddress(), matchOptions.getAddress(), advancedMatchOptions.getAddress());
+        
+    }
+    private static native void _imaqSetMultipleGeometricPatternsOptions(long multiplePattern, long label, long curveOptions, long matchOptions, long advancedMatchOptions);
+
+    public static void imaqWriteMultipleGeometricPatternFile(MultipleGeometricPattern multiplePattern, String fileName, String description) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        ByteBuffer description_buf = null;
+        if (description != null) {
+            byte[] description_bytes;
+            try {
+                description_bytes = description.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                description_bytes = new byte[0];
+            }
+            description_buf = ByteBuffer.allocateDirect(description_bytes.length+1);
+            putBytes(description_buf, description_bytes, 0, description_bytes.length).put(description_bytes.length, (byte)0);
+        }
+        _imaqWriteMultipleGeometricPatternFile(multiplePattern.getAddress(), fileName == null ? 0 : getByteBufferAddress(fileName_buf), description == null ? 0 : getByteBufferAddress(description_buf));
+        
+    }
+    private static native void _imaqWriteMultipleGeometricPatternFile(long multiplePattern, long fileName, long description);
+
+    public static class MatchGeometricPattern3Result {
+        public GeometricPatternMatch3[] array;
+        private long array_addr;
+        private MatchGeometricPattern3Result(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numMatches;
+            array_numMatches = rv_buf.getInt(0);
+            array = new GeometricPatternMatch3[array_numMatches];
+            if (array_numMatches > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatches*116);
+                for (int i=0, off=0; i<array_numMatches; i++, off += 116) {
+                    array[i] = new GeometricPatternMatch3(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static MatchGeometricPattern3Result imaqMatchGeometricPattern3(Image image, Image pattern, CurveOptions curveOptions, MatchGeometricPatternOptions matchOptions, MatchGeometricPatternAdvancedOptions3 advancedMatchOptions, ROI roi) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqMatchGeometricPattern3(image.getAddress(), pattern.getAddress(), curveOptions.getAddress(), matchOptions.getAddress(), advancedMatchOptions.getAddress(), roi.getAddress(), rv_addr+0);
+        MatchGeometricPattern3Result rv = new MatchGeometricPattern3Result(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqMatchGeometricPattern3(long image, long pattern, long curveOptions, long matchOptions, long advancedMatchOptions, long roi, long numMatches);
+
+    public static void imaqLearnGeometricPattern2(Image image, PointFloat originOffset, double angleOffset, CurveOptions curveOptions, LearnGeometricPatternAdvancedOptions2 advancedLearnOptions, Image mask) {
+        
+        _imaqLearnGeometricPattern2(image.getAddress(), originOffset.getAddress(), angleOffset, curveOptions.getAddress(), advancedLearnOptions.getAddress(), mask.getAddress());
+        
+    }
+    private static native void _imaqLearnGeometricPattern2(long image, long originOffset, double angleOffset, long curveOptions, long advancedLearnOptions, long mask);
+
+    public static class MatchPattern3Result {
+        public PatternMatch[] array;
+        private long array_addr;
+        private MatchPattern3Result(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numMatches;
+            array_numMatches = rv_buf.getInt(0);
+            array = new PatternMatch[array_numMatches];
+            if (array_numMatches > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatches*52);
+                for (int i=0, off=0; i<array_numMatches; i++, off += 52) {
+                    array[i] = new PatternMatch(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static MatchPattern3Result imaqMatchPattern3(Image image, Image pattern, MatchPatternOptions options, MatchPatternAdvancedOptions advancedOptions, ROI roi) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqMatchPattern3(image.getAddress(), pattern.getAddress(), options == null ? 0 : options.getAddress(), advancedOptions.getAddress(), roi.getAddress(), rv_addr+0);
+        MatchPattern3Result rv = new MatchPattern3Result(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqMatchPattern3(long image, long pattern, long options, long advancedOptions, long roi, long numMatches);
+
+    /**
+     * Overlay functions
+     */
+
+    public static void imaqClearOverlay(Image image, String group) {
+        ByteBuffer group_buf = null;
+        if (group != null) {
+            byte[] group_bytes;
+            try {
+                group_bytes = group.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                group_bytes = new byte[0];
+            }
+            group_buf = ByteBuffer.allocateDirect(group_bytes.length+1);
+            putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte)0);
+        }
+        _imaqClearOverlay(image.getAddress(), group == null ? 0 : getByteBufferAddress(group_buf));
+        
+    }
+    private static native void _imaqClearOverlay(long image, long group);
+
+    public static void imaqCopyOverlay(Image dest, Image source, String group) {
+        ByteBuffer group_buf = null;
+        if (group != null) {
+            byte[] group_bytes;
+            try {
+                group_bytes = group.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                group_bytes = new byte[0];
+            }
+            group_buf = ByteBuffer.allocateDirect(group_bytes.length+1);
+            putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte)0);
+        }
+        _imaqCopyOverlay(dest.getAddress(), source.getAddress(), group == null ? 0 : getByteBufferAddress(group_buf));
+        
+    }
+    private static native void _imaqCopyOverlay(long dest, long source, long group);
+
+    public static TransformBehaviors imaqGetOverlayProperties(Image image, String group) {
+        ByteBuffer group_buf = null;
+        if (group != null) {
+            byte[] group_bytes;
+            try {
+                group_bytes = group.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                group_bytes = new byte[0];
+            }
+            group_buf = ByteBuffer.allocateDirect(group_bytes.length+1);
+            putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte)0);
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetOverlayProperties(image.getAddress(), group == null ? 0 : getByteBufferAddress(group_buf), rv_addr+0);
+        TransformBehaviors transformBehaviors;
+        transformBehaviors = new TransformBehaviors(rv_buf, 0);
+        transformBehaviors.read();
+        return transformBehaviors;
+    }
+    private static native long _imaqGetOverlayProperties(long image, long group, long transformBehaviors);
+
+    public static void imaqMergeOverlay(Image dest, Image source, RGBValue[] palette, String group) {
+        int numColors = palette.length;
+        ByteBuffer palette_buf = null;
+        palette_buf = ByteBuffer.allocateDirect(palette.length*4);
+        for (int i=0, off=0; i<palette.length; i++, off += 4) {
+            palette[i].setBuffer(palette_buf, off);
+            palette[i].write();
+        }
+        ByteBuffer group_buf = null;
+        if (group != null) {
+            byte[] group_bytes;
+            try {
+                group_bytes = group.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                group_bytes = new byte[0];
+            }
+            group_buf = ByteBuffer.allocateDirect(group_bytes.length+1);
+            putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte)0);
+        }
+        _imaqMergeOverlay(dest.getAddress(), source.getAddress(), getByteBufferAddress(palette_buf), numColors, group == null ? 0 : getByteBufferAddress(group_buf));
+        
+    }
+    private static native void _imaqMergeOverlay(long dest, long source, long palette, int numColors, long group);
+
+    public static void imaqOverlayArc(Image image, ArcInfo arc, RGBValue color, DrawMode drawMode, String group) {
+        ByteBuffer group_buf = null;
+        if (group != null) {
+            byte[] group_bytes;
+            try {
+                group_bytes = group.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                group_bytes = new byte[0];
+            }
+            group_buf = ByteBuffer.allocateDirect(group_bytes.length+1);
+            putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte)0);
+        }
+        _imaqOverlayArc(image.getAddress(), arc.getAddress(), color.getAddress(), drawMode.getValue(), group == null ? 0 : getByteBufferAddress(group_buf));
+        
+    }
+    private static native void _imaqOverlayArc(long image, long arc, long color, int drawMode, long group);
+
+    public static void imaqOverlayBitmap(Image image, Point destLoc, RGBValue bitmap, int numCols, int numRows, String group) {
+        ByteBuffer group_buf = null;
+        if (group != null) {
+            byte[] group_bytes;
+            try {
+                group_bytes = group.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                group_bytes = new byte[0];
+            }
+            group_buf = ByteBuffer.allocateDirect(group_bytes.length+1);
+            putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte)0);
+        }
+        _imaqOverlayBitmap(image.getAddress(), destLoc.getAddress(), bitmap.getAddress(), numCols, numRows, group == null ? 0 : getByteBufferAddress(group_buf));
+        
+    }
+    private static native void _imaqOverlayBitmap(long image, long destLoc, long bitmap, int numCols, int numRows, long group);
+
+    public static void imaqOverlayClosedContour(Image image, Point[] points, RGBValue color, DrawMode drawMode, String group) {
+        int numPoints = points.length;
+        ByteBuffer points_buf = null;
+        points_buf = ByteBuffer.allocateDirect(points.length*8);
+        for (int i=0, off=0; i<points.length; i++, off += 8) {
+            points[i].setBuffer(points_buf, off);
+            points[i].write();
+        }
+        ByteBuffer group_buf = null;
+        if (group != null) {
+            byte[] group_bytes;
+            try {
+                group_bytes = group.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                group_bytes = new byte[0];
+            }
+            group_buf = ByteBuffer.allocateDirect(group_bytes.length+1);
+            putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte)0);
+        }
+        _imaqOverlayClosedContour(image.getAddress(), getByteBufferAddress(points_buf), numPoints, color.getAddress(), drawMode.getValue(), group == null ? 0 : getByteBufferAddress(group_buf));
+        
+    }
+    private static native void _imaqOverlayClosedContour(long image, long points, int numPoints, long color, int drawMode, long group);
+
+    public static void imaqOverlayLine(Image image, Point start, Point end, RGBValue color, String group) {
+        ByteBuffer group_buf = null;
+        if (group != null) {
+            byte[] group_bytes;
+            try {
+                group_bytes = group.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                group_bytes = new byte[0];
+            }
+            group_buf = ByteBuffer.allocateDirect(group_bytes.length+1);
+            putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte)0);
+        }
+        _imaqOverlayLine(image.getAddress(), start.getAddress(), end.getAddress(), color.getAddress(), group == null ? 0 : getByteBufferAddress(group_buf));
+        
+    }
+    private static native void _imaqOverlayLine(long image, long start, long end, long color, long group);
+
+    public static void imaqOverlayOpenContour(Image image, Point[] points, RGBValue color, String group) {
+        int numPoints = points.length;
+        ByteBuffer points_buf = null;
+        points_buf = ByteBuffer.allocateDirect(points.length*8);
+        for (int i=0, off=0; i<points.length; i++, off += 8) {
+            points[i].setBuffer(points_buf, off);
+            points[i].write();
+        }
+        ByteBuffer group_buf = null;
+        if (group != null) {
+            byte[] group_bytes;
+            try {
+                group_bytes = group.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                group_bytes = new byte[0];
+            }
+            group_buf = ByteBuffer.allocateDirect(group_bytes.length+1);
+            putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte)0);
+        }
+        _imaqOverlayOpenContour(image.getAddress(), getByteBufferAddress(points_buf), numPoints, color.getAddress(), group == null ? 0 : getByteBufferAddress(group_buf));
+        
+    }
+    private static native void _imaqOverlayOpenContour(long image, long points, int numPoints, long color, long group);
+
+    public static byte imaqOverlayOval(Image image, Rect boundingBox, RGBValue color, DrawMode drawMode) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        byte jn_rv = _imaqOverlayOval(image.getAddress(), boundingBox.getAddress(), color.getAddress(), drawMode.getValue(), rv_addr+0);
+        byte group;
+        group = rv_buf.get(0);
+        return group;
+    }
+    private static native byte _imaqOverlayOval(long image, long boundingBox, long color, int drawMode, long group);
+
+    public static void imaqOverlayPoints(Image image, Point[] points, RGBValue[] colors, PointSymbol symbol, UserPointSymbol userSymbol, String group) {
+        int numPoints = points.length;
+        ByteBuffer points_buf = null;
+        points_buf = ByteBuffer.allocateDirect(points.length*8);
+        for (int i=0, off=0; i<points.length; i++, off += 8) {
+            points[i].setBuffer(points_buf, off);
+            points[i].write();
+        }
+        int numColors = colors.length;
+        ByteBuffer colors_buf = null;
+        colors_buf = ByteBuffer.allocateDirect(colors.length*4);
+        for (int i=0, off=0; i<colors.length; i++, off += 4) {
+            colors[i].setBuffer(colors_buf, off);
+            colors[i].write();
+        }
+        ByteBuffer group_buf = null;
+        if (group != null) {
+            byte[] group_bytes;
+            try {
+                group_bytes = group.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                group_bytes = new byte[0];
+            }
+            group_buf = ByteBuffer.allocateDirect(group_bytes.length+1);
+            putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte)0);
+        }
+        _imaqOverlayPoints(image.getAddress(), getByteBufferAddress(points_buf), numPoints, getByteBufferAddress(colors_buf), numColors, symbol.getValue(), userSymbol.getAddress(), group == null ? 0 : getByteBufferAddress(group_buf));
+        
+    }
+    private static native void _imaqOverlayPoints(long image, long points, int numPoints, long colors, int numColors, int symbol, long userSymbol, long group);
+
+    public static void imaqOverlayRect(Image image, Rect rect, RGBValue color, DrawMode drawMode, String group) {
+        ByteBuffer group_buf = null;
+        if (group != null) {
+            byte[] group_bytes;
+            try {
+                group_bytes = group.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                group_bytes = new byte[0];
+            }
+            group_buf = ByteBuffer.allocateDirect(group_bytes.length+1);
+            putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte)0);
+        }
+        _imaqOverlayRect(image.getAddress(), rect.getAddress(), color.getAddress(), drawMode.getValue(), group == null ? 0 : getByteBufferAddress(group_buf));
+        
+    }
+    private static native void _imaqOverlayRect(long image, long rect, long color, int drawMode, long group);
+
+    public static void imaqOverlayROI(Image image, ROI roi, PointSymbol symbol, UserPointSymbol userSymbol, String group) {
+        ByteBuffer group_buf = null;
+        if (group != null) {
+            byte[] group_bytes;
+            try {
+                group_bytes = group.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                group_bytes = new byte[0];
+            }
+            group_buf = ByteBuffer.allocateDirect(group_bytes.length+1);
+            putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte)0);
+        }
+        _imaqOverlayROI(image.getAddress(), roi.getAddress(), symbol.getValue(), userSymbol.getAddress(), group == null ? 0 : getByteBufferAddress(group_buf));
+        
+    }
+    private static native void _imaqOverlayROI(long image, long roi, int symbol, long userSymbol, long group);
+
+    public static void imaqOverlayText(Image image, Point origin, String text, RGBValue color, OverlayTextOptions options, String group) {
+        ByteBuffer text_buf = null;
+        if (text != null) {
+            byte[] text_bytes;
+            try {
+                text_bytes = text.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                text_bytes = new byte[0];
+            }
+            text_buf = ByteBuffer.allocateDirect(text_bytes.length+1);
+            putBytes(text_buf, text_bytes, 0, text_bytes.length).put(text_bytes.length, (byte)0);
+        }
+        ByteBuffer group_buf = null;
+        if (group != null) {
+            byte[] group_bytes;
+            try {
+                group_bytes = group.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                group_bytes = new byte[0];
+            }
+            group_buf = ByteBuffer.allocateDirect(group_bytes.length+1);
+            putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte)0);
+        }
+        _imaqOverlayText(image.getAddress(), origin.getAddress(), text == null ? 0 : getByteBufferAddress(text_buf), color.getAddress(), options.getAddress(), group == null ? 0 : getByteBufferAddress(group_buf));
+        
+    }
+    private static native void _imaqOverlayText(long image, long origin, long text, long color, long options, long group);
+
+    public static TransformBehaviors imaqSetOverlayProperties(Image image, String group) {
+        ByteBuffer group_buf = null;
+        if (group != null) {
+            byte[] group_bytes;
+            try {
+                group_bytes = group.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                group_bytes = new byte[0];
+            }
+            group_buf = ByteBuffer.allocateDirect(group_bytes.length+1);
+            putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte)0);
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqSetOverlayProperties(image.getAddress(), group == null ? 0 : getByteBufferAddress(group_buf), rv_addr+0);
+        TransformBehaviors transformBehaviors;
+        transformBehaviors = new TransformBehaviors(rv_buf, 0);
+        transformBehaviors.read();
+        return transformBehaviors;
+    }
+    private static native long _imaqSetOverlayProperties(long image, long group, long transformBehaviors);
+
+    /**
+     * OCR functions
+     */
+
+    public static CharSet imaqCreateCharSet() {
+        
+        long jn_rv = _imaqCreateCharSet();
+        
+        return new CharSet(jn_rv, true);
+    }
+    private static native long _imaqCreateCharSet();
+
+    public static void imaqDeleteChar(CharSet set, int index) {
+        
+        _imaqDeleteChar(set.getAddress(), index);
+        
+    }
+    private static native void _imaqDeleteChar(long set, int index);
+
+    public static void imaqGetCharCount(CharSet set) {
+        
+        _imaqGetCharCount(set.getAddress());
+        
+    }
+    private static native void _imaqGetCharCount(long set);
+
+    public static CharInfo2 imaqGetCharInfo2(CharSet set, int index) {
+        
+        long jn_rv = _imaqGetCharInfo2(set.getAddress(), index);
+        
+        return new CharInfo2(jn_rv, true);
+    }
+    private static native long _imaqGetCharInfo2(long set, int index);
+
+    public static class ReadOCRFileResult {
+        public ReadTextOptions readOptions;
+        public OCRProcessingOptions processingOptions;
+        public OCRSpacingOptions spacingOptions;
+        private ReadOCRFileResult(ByteBuffer rv_buf) {
+            readOptions = new ReadTextOptions(rv_buf, 0);
+            readOptions.read();
+            processingOptions = new OCRProcessingOptions(rv_buf, 8);
+            processingOptions.read();
+            spacingOptions = new OCRSpacingOptions(rv_buf, 16);
+            spacingOptions.read();
+        }
+    }
+
+    public static ReadOCRFileResult imaqReadOCRFile(String fileName, CharSet set, String setDescription) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        ByteBuffer setDescription_buf = ByteBuffer.allocateDirect(256);
+        if (setDescription != null) {
+            byte[] bytes;
+            try {
+                bytes = setDescription.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                bytes = new byte[0];
+            }
+            putBytes(setDescription_buf, bytes, 0, bytes.length);
+            for (int i=bytes.length; i<256; i++)
+                setDescription_buf.put(i, (byte)0); // fill with zero
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(32);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqReadOCRFile(fileName == null ? 0 : getByteBufferAddress(fileName_buf), set.getAddress(), setDescription == null ? 0 : getByteBufferAddress(setDescription_buf), rv_addr+0, rv_addr+8, rv_addr+16);
+        ReadOCRFileResult rv = new ReadOCRFileResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqReadOCRFile(long fileName, long set, long setDescription, long readOptions, long processingOptions, long spacingOptions);
+
+    public static ReadTextReport3 imaqReadText3(Image image, CharSet set, ROI roi, ReadTextOptions readOptions, OCRProcessingOptions processingOptions, OCRSpacingOptions spacingOptions) {
+        
+        long jn_rv = _imaqReadText3(image.getAddress(), set.getAddress(), roi.getAddress(), readOptions.getAddress(), processingOptions.getAddress(), spacingOptions.getAddress());
+        
+        return new ReadTextReport3(jn_rv, true);
+    }
+    private static native long _imaqReadText3(long image, long set, long roi, long readOptions, long processingOptions, long spacingOptions);
+
+    public static void imaqRenameChar(CharSet set, int index, String newCharValue) {
+        ByteBuffer newCharValue_buf = null;
+        if (newCharValue != null) {
+            byte[] newCharValue_bytes;
+            try {
+                newCharValue_bytes = newCharValue.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                newCharValue_bytes = new byte[0];
+            }
+            newCharValue_buf = ByteBuffer.allocateDirect(newCharValue_bytes.length+1);
+            putBytes(newCharValue_buf, newCharValue_bytes, 0, newCharValue_bytes.length).put(newCharValue_bytes.length, (byte)0);
+        }
+        _imaqRenameChar(set.getAddress(), index, newCharValue == null ? 0 : getByteBufferAddress(newCharValue_buf));
+        
+    }
+    private static native void _imaqRenameChar(long set, int index, long newCharValue);
+
+    public static void imaqSetReferenceChar(CharSet set, int index, int isReferenceChar) {
+        
+        _imaqSetReferenceChar(set.getAddress(), index, isReferenceChar);
+        
+    }
+    private static native void _imaqSetReferenceChar(long set, int index, int isReferenceChar);
+
+    public static void imaqTrainChars(Image image, CharSet set, int index, String charValue, ROI roi, OCRProcessingOptions processingOptions, OCRSpacingOptions spacingOptions) {
+        ByteBuffer charValue_buf = null;
+        if (charValue != null) {
+            byte[] charValue_bytes;
+            try {
+                charValue_bytes = charValue.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                charValue_bytes = new byte[0];
+            }
+            charValue_buf = ByteBuffer.allocateDirect(charValue_bytes.length+1);
+            putBytes(charValue_buf, charValue_bytes, 0, charValue_bytes.length).put(charValue_bytes.length, (byte)0);
+        }
+        _imaqTrainChars(image.getAddress(), set.getAddress(), index, charValue == null ? 0 : getByteBufferAddress(charValue_buf), roi.getAddress(), processingOptions.getAddress(), spacingOptions.getAddress());
+        
+    }
+    private static native void _imaqTrainChars(long image, long set, int index, long charValue, long roi, long processingOptions, long spacingOptions);
+
+    public static void imaqWriteOCRFile(String fileName, CharSet set, String setDescription, ReadTextOptions readOptions, OCRProcessingOptions processingOptions, OCRSpacingOptions spacingOptions) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        ByteBuffer setDescription_buf = null;
+        if (setDescription != null) {
+            byte[] setDescription_bytes;
+            try {
+                setDescription_bytes = setDescription.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                setDescription_bytes = new byte[0];
+            }
+            setDescription_buf = ByteBuffer.allocateDirect(setDescription_bytes.length+1);
+            putBytes(setDescription_buf, setDescription_bytes, 0, setDescription_bytes.length).put(setDescription_bytes.length, (byte)0);
+        }
+        _imaqWriteOCRFile(fileName == null ? 0 : getByteBufferAddress(fileName_buf), set.getAddress(), setDescription == null ? 0 : getByteBufferAddress(setDescription_buf), readOptions.getAddress(), processingOptions.getAddress(), spacingOptions.getAddress());
+        
+    }
+    private static native void _imaqWriteOCRFile(long fileName, long set, long setDescription, long readOptions, long processingOptions, long spacingOptions);
+
+    /**
+     * Geometric Matching functions
+     */
+
+    public static class ExtractContourResult {
+        public CurveParameters curveParams;
+        public ExtractContourReport val;
+        private ExtractContourResult(ByteBuffer rv_buf) {
+            curveParams = new CurveParameters(rv_buf, 0);
+            curveParams.read();
+        }
+    }
+
+    public static ExtractContourResult imaqExtractContour(Image image, ROI roi, ExtractContourDirection direction, ConnectionConstraint connectionConstraintParams, int numOfConstraints, ExtractContourSelection selection, Image contourImage) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqExtractContour(image.getAddress(), roi.getAddress(), direction.getValue(), rv_addr+0, connectionConstraintParams.getAddress(), numOfConstraints, selection.getValue(), contourImage.getAddress());
+        ExtractContourResult rv = new ExtractContourResult(rv_buf);
+        rv.val = new ExtractContourReport(jn_rv, true);
+        return rv;
+    }
+    private static native long _imaqExtractContour(long image, long roi, int direction, long curveParams, long connectionConstraintParams, int numOfConstraints, int selection, long contourImage);
+
+    public static void imaqContourOverlay(Image image, Image contourImage, ContourOverlaySettings pointsSettings, ContourOverlaySettings eqnSettings, String groupName) {
+        ByteBuffer groupName_buf = null;
+        if (groupName != null) {
+            byte[] groupName_bytes;
+            try {
+                groupName_bytes = groupName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                groupName_bytes = new byte[0];
+            }
+            groupName_buf = ByteBuffer.allocateDirect(groupName_bytes.length+1);
+            putBytes(groupName_buf, groupName_bytes, 0, groupName_bytes.length).put(groupName_bytes.length, (byte)0);
+        }
+        _imaqContourOverlay(image.getAddress(), contourImage.getAddress(), pointsSettings.getAddress(), eqnSettings.getAddress(), groupName == null ? 0 : getByteBufferAddress(groupName_buf));
+        
+    }
+    private static native void _imaqContourOverlay(long image, long contourImage, long pointsSettings, long eqnSettings, long groupName);
+
+    public static ContourComputeCurvatureReport imaqContourComputeCurvature(Image contourImage, int kernel) {
+        
+        long jn_rv = _imaqContourComputeCurvature(contourImage.getAddress(), kernel);
+        
+        return new ContourComputeCurvatureReport(jn_rv, true);
+    }
+    private static native long _imaqContourComputeCurvature(long contourImage, int kernel);
+
+    public static CurvatureAnalysisReport imaqContourClassifyCurvature(Image contourImage, int kernel, RangeLabel[] curvatureClasses) {
+        int numCurvatureClasses = curvatureClasses.length;
+        ByteBuffer curvatureClasses_buf = null;
+        curvatureClasses_buf = ByteBuffer.allocateDirect(curvatureClasses.length*24);
+        for (int i=0, off=0; i<curvatureClasses.length; i++, off += 24) {
+            curvatureClasses[i].setBuffer(curvatureClasses_buf, off);
+            curvatureClasses[i].write();
+        }
+        long jn_rv = _imaqContourClassifyCurvature(contourImage.getAddress(), kernel, getByteBufferAddress(curvatureClasses_buf), numCurvatureClasses);
+        
+        return new CurvatureAnalysisReport(jn_rv, true);
+    }
+    private static native long _imaqContourClassifyCurvature(long contourImage, int kernel, long curvatureClasses, int numCurvatureClasses);
+
+    public static ComputeDistancesReport imaqContourComputeDistances(Image targetImage, Image templateImage, SetupMatchPatternData matchSetupData, int smoothingKernel) {
+        
+        long jn_rv = _imaqContourComputeDistances(targetImage.getAddress(), templateImage.getAddress(), matchSetupData.getAddress(), smoothingKernel);
+        
+        return new ComputeDistancesReport(jn_rv, true);
+    }
+    private static native long _imaqContourComputeDistances(long targetImage, long templateImage, long matchSetupData, int smoothingKernel);
+
+    public static ClassifyDistancesReport imaqContourClassifyDistances(Image targetImage, Image templateImage, SetupMatchPatternData matchSetupData, int smoothingKernel, RangeLabel[] distanceRanges) {
+        int numDistanceRanges = distanceRanges.length;
+        ByteBuffer distanceRanges_buf = null;
+        distanceRanges_buf = ByteBuffer.allocateDirect(distanceRanges.length*24);
+        for (int i=0, off=0; i<distanceRanges.length; i++, off += 24) {
+            distanceRanges[i].setBuffer(distanceRanges_buf, off);
+            distanceRanges[i].write();
+        }
+        long jn_rv = _imaqContourClassifyDistances(targetImage.getAddress(), templateImage.getAddress(), matchSetupData.getAddress(), smoothingKernel, getByteBufferAddress(distanceRanges_buf), numDistanceRanges);
+        
+        return new ClassifyDistancesReport(jn_rv, true);
+    }
+    private static native long _imaqContourClassifyDistances(long targetImage, long templateImage, long matchSetupData, int smoothingKernel, long distanceRanges, int numDistanceRanges);
+
+    public static ContourInfoReport imaqContourInfo(Image contourImage) {
+        
+        long jn_rv = _imaqContourInfo(contourImage.getAddress());
+        
+        return new ContourInfoReport(jn_rv, true);
+    }
+    private static native long _imaqContourInfo(long contourImage);
+
+    public static class ContourSetupMatchPatternResult {
+        public MatchMode matchMode;
+        public CurveParameters curveParams;
+        public SetupMatchPatternData val;
+        private ContourSetupMatchPatternResult(ByteBuffer rv_buf) {
+            matchMode = new MatchMode(rv_buf, 0);
+            matchMode.read();
+            curveParams = new CurveParameters(rv_buf, 8);
+            curveParams.read();
+        }
+    }
+
+    public static ContourSetupMatchPatternResult imaqContourSetupMatchPattern(int enableSubPixelAccuracy, int useLearnCurveParameters, RangeSettingDouble[] rangeSettings) {
+        int numRangeSettings = rangeSettings.length;
+        ByteBuffer rangeSettings_buf = null;
+        rangeSettings_buf = ByteBuffer.allocateDirect(rangeSettings.length*24);
+        for (int i=0, off=0; i<rangeSettings.length; i++, off += 24) {
+            rangeSettings[i].setBuffer(rangeSettings_buf, off);
+            rangeSettings[i].write();
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqContourSetupMatchPattern(rv_addr+0, enableSubPixelAccuracy, rv_addr+8, useLearnCurveParameters, getByteBufferAddress(rangeSettings_buf), numRangeSettings);
+        ContourSetupMatchPatternResult rv = new ContourSetupMatchPatternResult(rv_buf);
+        rv.val = new SetupMatchPatternData(jn_rv, true);
+        return rv;
+    }
+    private static native long _imaqContourSetupMatchPattern(long matchMode, int enableSubPixelAccuracy, long curveParams, int useLearnCurveParameters, long rangeSettings, int numRangeSettings);
+
+    public static SetupMatchPatternData imaqContourAdvancedSetupMatchPattern(GeometricAdvancedSetupDataOption[] geometricOptions) {
+        int numGeometricOptions = geometricOptions.length;
+        ByteBuffer geometricOptions_buf = null;
+        geometricOptions_buf = ByteBuffer.allocateDirect(geometricOptions.length*16);
+        for (int i=0, off=0; i<geometricOptions.length; i++, off += 16) {
+            geometricOptions[i].setBuffer(geometricOptions_buf, off);
+            geometricOptions[i].write();
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqContourAdvancedSetupMatchPattern(rv_addr+0, getByteBufferAddress(geometricOptions_buf), numGeometricOptions);
+        SetupMatchPatternData matchSetupData;
+        matchSetupData = new SetupMatchPatternData(rv_buf, 0);
+        matchSetupData.read();
+        return matchSetupData;
+    }
+    private static native long _imaqContourAdvancedSetupMatchPattern(long matchSetupData, long geometricOptions, int numGeometricOptions);
+
+    public static ContourFitLineReport imaqContourFitLine(Image image, double pixelRadius) {
+        
+        long jn_rv = _imaqContourFitLine(image.getAddress(), pixelRadius);
+        
+        return new ContourFitLineReport(jn_rv, true);
+    }
+    private static native long _imaqContourFitLine(long image, double pixelRadius);
+
+    public static PartialCircle imaqContourFitCircle(Image image, double pixelRadius, int rejectOutliers) {
+        
+        long jn_rv = _imaqContourFitCircle(image.getAddress(), pixelRadius, rejectOutliers);
+        
+        return new PartialCircle(jn_rv, true);
+    }
+    private static native long _imaqContourFitCircle(long image, double pixelRadius, int rejectOutliers);
+
+    public static PartialEllipse imaqContourFitEllipse(Image image, double pixelRadius, int rejectOutliers) {
+        
+        long jn_rv = _imaqContourFitEllipse(image.getAddress(), pixelRadius, rejectOutliers);
+        
+        return new PartialEllipse(jn_rv, true);
+    }
+    private static native long _imaqContourFitEllipse(long image, double pixelRadius, int rejectOutliers);
+
+    public static ContourFitSplineReport imaqContourFitSpline(Image image, int degree, int numberOfControlPoints) {
+        
+        long jn_rv = _imaqContourFitSpline(image.getAddress(), degree, numberOfControlPoints);
+        
+        return new ContourFitSplineReport(jn_rv, true);
+    }
+    private static native long _imaqContourFitSpline(long image, int degree, int numberOfControlPoints);
+
+    public static ContourFitPolynomialReport imaqContourFitPolynomial(Image image, int order) {
+        
+        long jn_rv = _imaqContourFitPolynomial(image.getAddress(), order);
+        
+        return new ContourFitPolynomialReport(jn_rv, true);
+    }
+    private static native long _imaqContourFitPolynomial(long image, int order);
+
+    /**
+     * Edge Detection functions
+     */
+
+    public static FindCircularEdgeReport imaqFindCircularEdge2(Image image, ROI roi, CoordinateSystem baseSystem, CoordinateSystem newSystem, FindCircularEdgeOptions edgeOptions, CircleFitOptions circleFitOptions) {
+        
+        long jn_rv = _imaqFindCircularEdge2(image.getAddress(), roi.getAddress(), baseSystem.getAddress(), newSystem.getAddress(), edgeOptions.getAddress(), circleFitOptions.getAddress());
+        
+        return new FindCircularEdgeReport(jn_rv, true);
+    }
+    private static native long _imaqFindCircularEdge2(long image, long roi, long baseSystem, long newSystem, long edgeOptions, long circleFitOptions);
+
+    public static FindConcentricEdgeReport imaqFindConcentricEdge2(Image image, ROI roi, CoordinateSystem baseSystem, CoordinateSystem newSystem, FindConcentricEdgeOptions edgeOptions, ConcentricEdgeFitOptions concentricEdgeFitOptions) {
+        
+        long jn_rv = _imaqFindConcentricEdge2(image.getAddress(), roi.getAddress(), baseSystem.getAddress(), newSystem.getAddress(), edgeOptions.getAddress(), concentricEdgeFitOptions.getAddress());
+        
+        return new FindConcentricEdgeReport(jn_rv, true);
+    }
+    private static native long _imaqFindConcentricEdge2(long image, long roi, long baseSystem, long newSystem, long edgeOptions, long concentricEdgeFitOptions);
+
+    /**
+     * Morphology Reconstruction functions
+     */
+
+    public static void imaqGrayMorphologyReconstruct(Image dstImage, Image srcImage, Image markerImage, PointFloat[] points, MorphologyReconstructOperation operation, StructuringElement structuringElement, ROI roi) {
+        int numOfPoints = points.length;
+        ByteBuffer points_buf = null;
+        points_buf = ByteBuffer.allocateDirect(points.length*8);
+        for (int i=0, off=0; i<points.length; i++, off += 8) {
+            points[i].setBuffer(points_buf, off);
+            points[i].write();
+        }
+        _imaqGrayMorphologyReconstruct(dstImage.getAddress(), srcImage.getAddress(), markerImage.getAddress(), getByteBufferAddress(points_buf), numOfPoints, operation.getValue(), structuringElement.getAddress(), roi.getAddress());
+        
+    }
+    private static native void _imaqGrayMorphologyReconstruct(long dstImage, long srcImage, long markerImage, long points, int numOfPoints, int operation, long structuringElement, long roi);
+
+    public static void imaqMorphologyReconstruct(Image dstImage, Image srcImage, Image markerImage, PointFloat[] points, MorphologyReconstructOperation operation, Connectivity connectivity, ROI roi) {
+        int numOfPoints = points.length;
+        ByteBuffer points_buf = null;
+        points_buf = ByteBuffer.allocateDirect(points.length*8);
+        for (int i=0, off=0; i<points.length; i++, off += 8) {
+            points[i].setBuffer(points_buf, off);
+            points[i].write();
+        }
+        _imaqMorphologyReconstruct(dstImage.getAddress(), srcImage.getAddress(), markerImage.getAddress(), getByteBufferAddress(points_buf), numOfPoints, operation.getValue(), connectivity.getValue(), roi.getAddress());
+        
+    }
+    private static native void _imaqMorphologyReconstruct(long dstImage, long srcImage, long markerImage, long points, int numOfPoints, int operation, int connectivity, long roi);
+
+    /**
+     * Texture functions
+     */
+
+    public static void imaqDetectTextureDefect(ClassifierSession session, Image destImage, Image srcImage, ROI roi, int initialStepSize, int finalStepSize, short defectPixelValue, double minClassificationScore) {
+        
+        _imaqDetectTextureDefect(session.getAddress(), destImage.getAddress(), srcImage.getAddress(), roi.getAddress(), initialStepSize, finalStepSize, defectPixelValue, minClassificationScore);
+        
+    }
+    private static native void _imaqDetectTextureDefect(long session, long destImage, long srcImage, long roi, int initialStepSize, int finalStepSize, short defectPixelValue, double minClassificationScore);
+
+    /**
+     * Regions of Interest Manipulation functions
+     */
+
+    public static class MaskToROIResult {
+        public int withinLimit;
+        public ROI val;
+        private MaskToROIResult(ByteBuffer rv_buf) {
+            withinLimit = rv_buf.getInt(0);
+        }
+    }
+
+    public static MaskToROIResult imaqMaskToROI(Image mask) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqMaskToROI(mask.getAddress(), rv_addr+0);
+        MaskToROIResult rv = new MaskToROIResult(rv_buf);
+        rv.val = new ROI(jn_rv, true);
+        return rv;
+    }
+    private static native long _imaqMaskToROI(long mask, long withinLimit);
+
+    public static ROIProfile imaqROIProfile(Image image, ROI roi) {
+        
+        long jn_rv = _imaqROIProfile(image.getAddress(), roi.getAddress());
+        
+        return new ROIProfile(jn_rv, true);
+    }
+    private static native long _imaqROIProfile(long image, long roi);
+
+    public static int imaqROIToMask(Image mask, ROI roi, int fillValue, Image imageModel) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqROIToMask(mask.getAddress(), roi.getAddress(), fillValue, imageModel == null ? 0 : imageModel.getAddress(), rv_addr+0);
+        int inSpace;
+        inSpace = rv_buf.getInt(0);
+        return inSpace;
+    }
+    private static native int _imaqROIToMask(long mask, long roi, int fillValue, long imageModel, long inSpace);
+
+    public static void imaqTransformROI2(ROI roi, CoordinateSystem baseSystem, CoordinateSystem newSystem) {
+        
+        _imaqTransformROI2(roi.getAddress(), baseSystem.getAddress(), newSystem.getAddress());
+        
+    }
+    private static native void _imaqTransformROI2(long roi, long baseSystem, long newSystem);
+
+    public static LabelToROIReport imaqLabelToROI(Image image, int[] labelsIn, int maxNumVectors, int isExternelEdges) {
+        int numLabelsIn = labelsIn.length;
+        ByteBuffer labelsIn_buf = null;
+        labelsIn_buf = ByteBuffer.allocateDirect(labelsIn.length*4);
+        labelsIn_buf.asIntBuffer().put(labelsIn).rewind();
+        long jn_rv = _imaqLabelToROI(image.getAddress(), getByteBufferAddress(labelsIn_buf), numLabelsIn, maxNumVectors, isExternelEdges);
+        
+        return new LabelToROIReport(jn_rv, true);
+    }
+    private static native long _imaqLabelToROI(long image, long labelsIn, int numLabelsIn, int maxNumVectors, int isExternelEdges);
+
+    /**
+     * Morphology functions
+     */
+
+    public static void imaqGrayMorphology(Image dest, Image source, MorphologyMethod method, StructuringElement structuringElement) {
+        
+        _imaqGrayMorphology(dest.getAddress(), source.getAddress(), method.getValue(), structuringElement == null ? 0 : structuringElement.getAddress());
+        
+    }
+    private static native void _imaqGrayMorphology(long dest, long source, int method, long structuringElement);
+
+    /**
+     * Classification functions
+     */
+
+    public static void imaqAddClassifierSample(Image image, ClassifierSession session, ROI roi, String sampleClass, double[] featureVector) {
+        ByteBuffer sampleClass_buf = null;
+        if (sampleClass != null) {
+            byte[] sampleClass_bytes;
+            try {
+                sampleClass_bytes = sampleClass.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                sampleClass_bytes = new byte[0];
+            }
+            sampleClass_buf = ByteBuffer.allocateDirect(sampleClass_bytes.length+1);
+            putBytes(sampleClass_buf, sampleClass_bytes, 0, sampleClass_bytes.length).put(sampleClass_bytes.length, (byte)0);
+        }
+        int vectorSize = featureVector.length;
+        ByteBuffer featureVector_buf = null;
+        featureVector_buf = ByteBuffer.allocateDirect(featureVector.length*8);
+        featureVector_buf.asDoubleBuffer().put(featureVector).rewind();
+        _imaqAddClassifierSample(image.getAddress(), session.getAddress(), roi.getAddress(), sampleClass == null ? 0 : getByteBufferAddress(sampleClass_buf), getByteBufferAddress(featureVector_buf), vectorSize);
+        
+    }
+    private static native void _imaqAddClassifierSample(long image, long session, long roi, long sampleClass, long featureVector, int vectorSize);
+
+    public static ClassifierReportAdvanced imaqAdvanceClassify(Image image, ClassifierSession session, ROI roi, double[] featureVector) {
+        int vectorSize = featureVector.length;
+        ByteBuffer featureVector_buf = null;
+        featureVector_buf = ByteBuffer.allocateDirect(featureVector.length*8);
+        featureVector_buf.asDoubleBuffer().put(featureVector).rewind();
+        long jn_rv = _imaqAdvanceClassify(image.getAddress(), session.getAddress(), roi.getAddress(), getByteBufferAddress(featureVector_buf), vectorSize);
+        
+        return new ClassifierReportAdvanced(jn_rv, true);
+    }
+    private static native long _imaqAdvanceClassify(long image, long session, long roi, long featureVector, int vectorSize);
+
+    public static ClassifierReport imaqClassify(Image image, ClassifierSession session, ROI roi, double[] featureVector) {
+        int vectorSize = featureVector.length;
+        ByteBuffer featureVector_buf = null;
+        featureVector_buf = ByteBuffer.allocateDirect(featureVector.length*8);
+        featureVector_buf.asDoubleBuffer().put(featureVector).rewind();
+        long jn_rv = _imaqClassify(image.getAddress(), session.getAddress(), roi.getAddress(), getByteBufferAddress(featureVector_buf), vectorSize);
+        
+        return new ClassifierReport(jn_rv, true);
+    }
+    private static native long _imaqClassify(long image, long session, long roi, long featureVector, int vectorSize);
+
+    public static ClassifierSession imaqCreateClassifier(ClassifierType type) {
+        
+        long jn_rv = _imaqCreateClassifier(type.getValue());
+        
+        return new ClassifierSession(jn_rv, true);
+    }
+    private static native long _imaqCreateClassifier(int type);
+
+    public static void imaqDeleteClassifierSample(ClassifierSession session, int index) {
+        
+        _imaqDeleteClassifierSample(session.getAddress(), index);
+        
+    }
+    private static native void _imaqDeleteClassifierSample(long session, int index);
+
+    public static ClassifierAccuracyReport imaqGetClassifierAccuracy(ClassifierSession session) {
+        
+        long jn_rv = _imaqGetClassifierAccuracy(session.getAddress());
+        
+        return new ClassifierAccuracyReport(jn_rv, true);
+    }
+    private static native long _imaqGetClassifierAccuracy(long session);
+
+    public static class GetClassifierSampleInfoResult {
+        public int numSamples;
+        public ClassifierSampleInfo val;
+        private GetClassifierSampleInfoResult(ByteBuffer rv_buf) {
+            numSamples = rv_buf.getInt(0);
+        }
+    }
+
+    public static GetClassifierSampleInfoResult imaqGetClassifierSampleInfo(ClassifierSession session, int index) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetClassifierSampleInfo(session.getAddress(), index, rv_addr+0);
+        GetClassifierSampleInfoResult rv = new GetClassifierSampleInfoResult(rv_buf);
+        rv.val = new ClassifierSampleInfo(jn_rv, true);
+        return rv;
+    }
+    private static native long _imaqGetClassifierSampleInfo(long session, int index, long numSamples);
+
+    public static ColorOptions imaqGetColorClassifierOptions(ClassifierSession session) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetColorClassifierOptions(session.getAddress(), rv_addr+0);
+        ColorOptions options;
+        options = new ColorOptions(rv_buf, 0);
+        options.read();
+        return options;
+    }
+    private static native long _imaqGetColorClassifierOptions(long session, long options);
+
+    public static NearestNeighborOptions imaqGetNearestNeighborOptions(ClassifierSession session) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetNearestNeighborOptions(session.getAddress(), rv_addr+0);
+        NearestNeighborOptions options;
+        options = new NearestNeighborOptions(rv_buf, 0);
+        options.read();
+        return options;
+    }
+    private static native long _imaqGetNearestNeighborOptions(long session, long options);
+
+    public static class GetParticleClassifierOptions2Result {
+        public ParticleClassifierPreprocessingOptions2 preprocessingOptions;
+        public ParticleClassifierOptions options;
+        private GetParticleClassifierOptions2Result(ByteBuffer rv_buf) {
+            preprocessingOptions = new ParticleClassifierPreprocessingOptions2(rv_buf, 0);
+            preprocessingOptions.read();
+            options = new ParticleClassifierOptions(rv_buf, 8);
+            options.read();
+        }
+    }
+
+    public static GetParticleClassifierOptions2Result imaqGetParticleClassifierOptions2(ClassifierSession session) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqGetParticleClassifierOptions2(session.getAddress(), rv_addr+0, rv_addr+8);
+        GetParticleClassifierOptions2Result rv = new GetParticleClassifierOptions2Result(rv_buf);
+        return rv;
+    }
+    private static native void _imaqGetParticleClassifierOptions2(long session, long preprocessingOptions, long options);
+
+    public static class ReadClassifierFileResult {
+        public ClassifierType type;
+        public ClassifierEngineType engine;
+        public ClassifierSession val;
+        private ReadClassifierFileResult(ByteBuffer rv_buf) {
+            type = ClassifierType.fromValue(rv_buf.getInt(0));
+            engine = ClassifierEngineType.fromValue(rv_buf.getInt(8));
+        }
+    }
+
+    public static ReadClassifierFileResult imaqReadClassifierFile(ClassifierSession session, String fileName, ReadClassifierFileMode mode, String description) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        ByteBuffer description_buf = ByteBuffer.allocateDirect(256);
+        if (description != null) {
+            byte[] bytes;
+            try {
+                bytes = description.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                bytes = new byte[0];
+            }
+            putBytes(description_buf, bytes, 0, bytes.length);
+            for (int i=bytes.length; i<256; i++)
+                description_buf.put(i, (byte)0); // fill with zero
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqReadClassifierFile(session.getAddress(), fileName == null ? 0 : getByteBufferAddress(fileName_buf), mode.getValue(), rv_addr+0, rv_addr+8, description == null ? 0 : getByteBufferAddress(description_buf));
+        ReadClassifierFileResult rv = new ReadClassifierFileResult(rv_buf);
+        rv.val = new ClassifierSession(jn_rv, true);
+        return rv;
+    }
+    private static native long _imaqReadClassifierFile(long session, long fileName, int mode, long type, long engine, long description);
+
+    public static void imaqRelabelClassifierSample(ClassifierSession session, int index, String newClass) {
+        ByteBuffer newClass_buf = null;
+        if (newClass != null) {
+            byte[] newClass_bytes;
+            try {
+                newClass_bytes = newClass.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                newClass_bytes = new byte[0];
+            }
+            newClass_buf = ByteBuffer.allocateDirect(newClass_bytes.length+1);
+            putBytes(newClass_buf, newClass_bytes, 0, newClass_bytes.length).put(newClass_bytes.length, (byte)0);
+        }
+        _imaqRelabelClassifierSample(session.getAddress(), index, newClass == null ? 0 : getByteBufferAddress(newClass_buf));
+        
+    }
+    private static native void _imaqRelabelClassifierSample(long session, int index, long newClass);
+
+    public static void imaqSetParticleClassifierOptions2(ClassifierSession session, ParticleClassifierPreprocessingOptions2 preprocessingOptions, ParticleClassifierOptions options) {
+        
+        _imaqSetParticleClassifierOptions2(session.getAddress(), preprocessingOptions.getAddress(), options.getAddress());
+        
+    }
+    private static native void _imaqSetParticleClassifierOptions2(long session, long preprocessingOptions, long options);
+
+    public static void imaqSetColorClassifierOptions(ClassifierSession session, ColorOptions options) {
+        
+        _imaqSetColorClassifierOptions(session.getAddress(), options.getAddress());
+        
+    }
+    private static native void _imaqSetColorClassifierOptions(long session, long options);
+
+    public static NearestNeighborTrainingReport imaqTrainNearestNeighborClassifier(ClassifierSession session, NearestNeighborOptions options) {
+        
+        long jn_rv = _imaqTrainNearestNeighborClassifier(session.getAddress(), options.getAddress());
+        
+        return new NearestNeighborTrainingReport(jn_rv, true);
+    }
+    private static native long _imaqTrainNearestNeighborClassifier(long session, long options);
+
+    public static void imaqWriteClassifierFile(ClassifierSession session, String fileName, WriteClassifierFileMode mode, String description) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        ByteBuffer description_buf = ByteBuffer.allocateDirect(256);
+        if (description != null) {
+            byte[] bytes;
+            try {
+                bytes = description.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                bytes = new byte[0];
+            }
+            putBytes(description_buf, bytes, 0, bytes.length);
+            for (int i=bytes.length; i<256; i++)
+                description_buf.put(i, (byte)0); // fill with zero
+        }
+        _imaqWriteClassifierFile(session.getAddress(), fileName == null ? 0 : getByteBufferAddress(fileName_buf), mode.getValue(), description == null ? 0 : getByteBufferAddress(description_buf));
+        
+    }
+    private static native void _imaqWriteClassifierFile(long session, long fileName, int mode, long description);
+
+    /**
+     * Measure Distances functions
+     */
+
+    public static ClampMax2Report imaqClampMax2(Image image, ROI roi, CoordinateSystem baseSystem, CoordinateSystem newSystem, CurveOptions curveSettings, ClampSettings clampSettings, ClampOverlaySettings clampOverlaySettings) {
+        
+        long jn_rv = _imaqClampMax2(image.getAddress(), roi.getAddress(), baseSystem.getAddress(), newSystem.getAddress(), curveSettings.getAddress(), clampSettings.getAddress(), clampOverlaySettings.getAddress());
+        
+        return new ClampMax2Report(jn_rv, true);
+    }
+    private static native long _imaqClampMax2(long image, long roi, long baseSystem, long newSystem, long curveSettings, long clampSettings, long clampOverlaySettings);
+
+    /**
+     * Inspection functions
+     */
+
+    public static void imaqCompareGoldenTemplate(Image image, Image goldenTemplate, Image brightDefects, Image darkDefects, InspectionAlignment alignment, InspectionOptions options) {
+        
+        _imaqCompareGoldenTemplate(image.getAddress(), goldenTemplate.getAddress(), brightDefects.getAddress(), darkDefects.getAddress(), alignment.getAddress(), options.getAddress());
+        
+    }
+    private static native void _imaqCompareGoldenTemplate(long image, long goldenTemplate, long brightDefects, long darkDefects, long alignment, long options);
+
+    public static void imaqLearnGoldenTemplate(Image goldenTemplate, PointFloat originOffset, Image mask) {
+        
+        _imaqLearnGoldenTemplate(goldenTemplate.getAddress(), originOffset.getAddress(), mask.getAddress());
+        
+    }
+    private static native void _imaqLearnGoldenTemplate(long goldenTemplate, long originOffset, long mask);
+
+    /**
+     * Obsolete functions
+     */
+
+    public static void imaqWritePNGFile(Image image, String fileName, int compressionSpeed, RGBValue colorTable) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        _imaqWritePNGFile(image.getAddress(), fileName == null ? 0 : getByteBufferAddress(fileName_buf), compressionSpeed, colorTable == null ? 0 : colorTable.getAddress());
+        
+    }
+    private static native void _imaqWritePNGFile(long image, long fileName, int compressionSpeed, long colorTable);
+
+    public static class SelectParticlesResult {
+        public ParticleReport[] array;
+        private long array_addr;
+        private SelectParticlesResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_selectedCount;
+            array_selectedCount = rv_buf.getInt(0);
+            array = new ParticleReport[array_selectedCount];
+            if (array_selectedCount > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_selectedCount*84);
+                for (int i=0, off=0; i<array_selectedCount; i++, off += 84) {
+                    array[i] = new ParticleReport(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static SelectParticlesResult imaqSelectParticles(Image image, ParticleReport reports, int reportCount, int rejectBorder, SelectParticleCriteria criteria, int criteriaCount) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqSelectParticles(image.getAddress(), reports.getAddress(), reportCount, rejectBorder, criteria.getAddress(), criteriaCount, rv_addr+0);
+        SelectParticlesResult rv = new SelectParticlesResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqSelectParticles(long image, long reports, int reportCount, int rejectBorder, long criteria, int criteriaCount, long selectedCount);
+
+    public static void imaqParticleFilter(Image dest, Image source, ParticleFilterCriteria criteria, int criteriaCount, int rejectMatches, int connectivity8) {
+        
+        _imaqParticleFilter(dest.getAddress(), source.getAddress(), criteria.getAddress(), criteriaCount, rejectMatches, connectivity8);
+        
+    }
+    private static native void _imaqParticleFilter(long dest, long source, long criteria, int criteriaCount, int rejectMatches, int connectivity8);
+
+    public static class GetParticleInfoResult {
+        public ParticleReport[] array;
+        private long array_addr;
+        private GetParticleInfoResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_reportCount;
+            array_reportCount = rv_buf.getInt(0);
+            array = new ParticleReport[array_reportCount];
+            if (array_reportCount > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_reportCount*84);
+                for (int i=0, off=0; i<array_reportCount; i++, off += 84) {
+                    array[i] = new ParticleReport(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static GetParticleInfoResult imaqGetParticleInfo(Image image, int connectivity8, ParticleInfoMode mode) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqGetParticleInfo(image.getAddress(), connectivity8, mode.getValue(), rv_addr+0);
+        GetParticleInfoResult rv = new GetParticleInfoResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqGetParticleInfo(long image, int connectivity8, int mode, long reportCount);
+
+    public static float imaqCalcCoeff(Image image, ParticleReport report, MeasurementValue parameter) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        float jn_rv = _imaqCalcCoeff(image.getAddress(), report.getAddress(), parameter.getValue(), rv_addr+0);
+        float coefficient;
+        coefficient = rv_buf.getFloat(0);
+        return coefficient;
+    }
+    private static native float _imaqCalcCoeff(long image, long report, int parameter, long coefficient);
+
+    public static class EdgeToolResult {
+        public EdgeReport[] array;
+        private long array_addr;
+        private EdgeToolResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numEdges;
+            array_numEdges = rv_buf.getInt(0);
+            array = new EdgeReport[array_numEdges];
+            if (array_numEdges > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numEdges*32);
+                for (int i=0, off=0; i<array_numEdges; i++, off += 32) {
+                    array[i] = new EdgeReport(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static EdgeToolResult imaqEdgeTool(Image image, Point points, int numPoints, EdgeOptions options) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqEdgeTool(image.getAddress(), points.getAddress(), numPoints, options.getAddress(), rv_addr+0);
+        EdgeToolResult rv = new EdgeToolResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqEdgeTool(long image, long points, int numPoints, long options, long numEdges);
+
+    public static class CirclesResult {
+        public CircleReport[] array;
+        private long array_addr;
+        private CirclesResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numCircles;
+            array_numCircles = rv_buf.getInt(0);
+            array = new CircleReport[array_numCircles];
+            if (array_numCircles > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numCircles*16);
+                for (int i=0, off=0; i<array_numCircles; i++, off += 16) {
+                    array[i] = new CircleReport(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static CirclesResult imaqCircles(Image dest, Image source, float minRadius, float maxRadius) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqCircles(dest.getAddress(), source.getAddress(), minRadius, maxRadius, rv_addr+0);
+        CirclesResult rv = new CirclesResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqCircles(long dest, long source, float minRadius, float maxRadius, long numCircles);
+
+    public static int imaqLabel(Image dest, Image source, int connectivity8) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqLabel(dest.getAddress(), source.getAddress(), connectivity8, rv_addr+0);
+        int particleCount;
+        particleCount = rv_buf.getInt(0);
+        return particleCount;
+    }
+    private static native int _imaqLabel(long dest, long source, int connectivity8, long particleCount);
+
+    public static BestEllipse imaqFitEllipse(PointFloat[] points) {
+        int numPoints = points.length;
+        ByteBuffer points_buf = null;
+        points_buf = ByteBuffer.allocateDirect(points.length*8);
+        for (int i=0, off=0; i<points.length; i++, off += 8) {
+            points[i].setBuffer(points_buf, off);
+            points[i].write();
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqFitEllipse(getByteBufferAddress(points_buf), numPoints, rv_addr+0);
+        BestEllipse ellipse;
+        ellipse = new BestEllipse(rv_buf, 0);
+        ellipse.read();
+        return ellipse;
+    }
+    private static native long _imaqFitEllipse(long points, int numPoints, long ellipse);
+
+    public static BestCircle imaqFitCircle(PointFloat[] points) {
+        int numPoints = points.length;
+        ByteBuffer points_buf = null;
+        points_buf = ByteBuffer.allocateDirect(points.length*8);
+        for (int i=0, off=0; i<points.length; i++, off += 8) {
+            points[i].setBuffer(points_buf, off);
+            points[i].write();
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqFitCircle(getByteBufferAddress(points_buf), numPoints, rv_addr+0);
+        BestCircle circle;
+        circle = new BestCircle(rv_buf, 0);
+        circle.read();
+        return circle;
+    }
+    private static native long _imaqFitCircle(long points, int numPoints, long circle);
+
+    public static class MatchPatternResult {
+        public PatternMatch[] array;
+        private long array_addr;
+        private MatchPatternResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numMatches;
+            array_numMatches = rv_buf.getInt(0);
+            array = new PatternMatch[array_numMatches];
+            if (array_numMatches > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatches*52);
+                for (int i=0, off=0; i<array_numMatches; i++, off += 52) {
+                    array[i] = new PatternMatch(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static MatchPatternResult imaqMatchPattern(Image image, Image pattern, MatchPatternOptions options, Rect searchRect) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqMatchPattern(image.getAddress(), pattern.getAddress(), options == null ? 0 : options.getAddress(), searchRect.getAddress(), rv_addr+0);
+        MatchPatternResult rv = new MatchPatternResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqMatchPattern(long image, long pattern, long options, long searchRect, long numMatches);
+
+    public static void imaqConvex(Image dest, Image source) {
+        
+        _imaqConvex(dest.getAddress(), source.getAddress());
+        
+    }
+    private static native void _imaqConvex(long dest, long source);
+
+    public static int imaqIsVisionInfoPresent(Image image, VisionInfoType type) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqIsVisionInfoPresent(image.getAddress(), type.getValue(), rv_addr+0);
+        int present;
+        present = rv_buf.getInt(0);
+        return present;
+    }
+    private static native int _imaqIsVisionInfoPresent(long image, int type, long present);
+
+    public static float imaqLineGaugeTool(Image image, Point start, Point end, LineGaugeMethod method, EdgeOptions edgeOptions, CoordinateTransform reference) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        float jn_rv = _imaqLineGaugeTool(image.getAddress(), start.getAddress(), end.getAddress(), method.getValue(), edgeOptions.getAddress(), reference == null ? 0 : reference.getAddress(), rv_addr+0);
+        float distance;
+        distance = rv_buf.getFloat(0);
+        return distance;
+    }
+    private static native float _imaqLineGaugeTool(long image, long start, long end, int method, long edgeOptions, long reference, long distance);
+
+    public static class BestCircleResult {
+        public PointFloat center;
+        public double radius;
+        private BestCircleResult(ByteBuffer rv_buf) {
+            center = new PointFloat(rv_buf, 0);
+            center.read();
+            radius = rv_buf.getDouble(8);
+        }
+    }
+
+    public static BestCircleResult imaqBestCircle(PointFloat[] points) {
+        int numPoints = points.length;
+        ByteBuffer points_buf = null;
+        points_buf = ByteBuffer.allocateDirect(points.length*8);
+        for (int i=0, off=0; i<points.length; i++, off += 8) {
+            points[i].setBuffer(points_buf, off);
+            points[i].write();
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqBestCircle(getByteBufferAddress(points_buf), numPoints, rv_addr+0, rv_addr+8);
+        BestCircleResult rv = new BestCircleResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqBestCircle(long points, int numPoints, long center, long radius);
+
+    public static void imaqSavePattern(Image pattern, String fileName) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        _imaqSavePattern(pattern.getAddress(), fileName == null ? 0 : getByteBufferAddress(fileName_buf));
+        
+    }
+    private static native void _imaqSavePattern(long pattern, long fileName);
+
+    public static void imaqLoadPattern(Image pattern, String fileName) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        _imaqLoadPattern(pattern.getAddress(), fileName == null ? 0 : getByteBufferAddress(fileName_buf));
+        
+    }
+    private static native void _imaqLoadPattern(long pattern, long fileName);
+
+    public static void imaqTransformROI(ROI roi, Point originStart, float angleStart, Point originFinal, float angleFinal) {
+        
+        _imaqTransformROI(roi.getAddress(), originStart.getAddress(), angleStart, originFinal.getAddress(), angleFinal);
+        
+    }
+    private static native void _imaqTransformROI(long roi, long originStart, float angleStart, long originFinal, float angleFinal);
+
+    public static class CoordinateReferenceResult {
+        public Point origin;
+        public float angle;
+        private CoordinateReferenceResult(ByteBuffer rv_buf) {
+            origin = new Point(rv_buf, 0);
+            origin.read();
+            angle = rv_buf.getFloat(8);
+        }
+    }
+
+    public static CoordinateReferenceResult imaqCoordinateReference(Point points, ReferenceMode mode) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqCoordinateReference(points.getAddress(), mode.getValue(), rv_addr+0, rv_addr+8);
+        CoordinateReferenceResult rv = new CoordinateReferenceResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqCoordinateReference(long points, int mode, long origin, long angle);
+
+    public static ContourInfo imaqGetContourInfo(ROI roi, int id) {
+        
+        long jn_rv = _imaqGetContourInfo(roi.getAddress(), id);
+        
+        return new ContourInfo(jn_rv, true);
+    }
+    private static native long _imaqGetContourInfo(long roi, int id);
+
+    public static void imaqSetWindowOverlay(int windowNumber, Overlay overlay) {
+        
+        _imaqSetWindowOverlay(windowNumber, overlay == null ? 0 : overlay.getAddress());
+        
+    }
+    private static native void _imaqSetWindowOverlay(int windowNumber, long overlay);
+
+    public static Overlay imaqCreateOverlayFromROI(ROI roi) {
+        
+        long jn_rv = _imaqCreateOverlayFromROI(roi.getAddress());
+        
+        return new Overlay(jn_rv, true);
+    }
+    private static native long _imaqCreateOverlayFromROI(long roi);
+
+    public static void imaqSetCalibrationInfo(Image image, CalibrationUnit unit, float xDistance, float yDistance) {
+        
+        _imaqSetCalibrationInfo(image.getAddress(), unit.getValue(), xDistance, yDistance);
+        
+    }
+    private static native void _imaqSetCalibrationInfo(long image, int unit, float xDistance, float yDistance);
+
+    public static class GetCalibrationInfoResult {
+        public CalibrationUnit unit;
+        public float xDistance;
+        public float yDistance;
+        private GetCalibrationInfoResult(ByteBuffer rv_buf) {
+            unit = CalibrationUnit.fromValue(rv_buf.getInt(0));
+            xDistance = rv_buf.getFloat(8);
+            yDistance = rv_buf.getFloat(16);
+        }
+    }
+
+    public static GetCalibrationInfoResult imaqGetCalibrationInfo(Image image) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(32);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqGetCalibrationInfo(image.getAddress(), rv_addr+0, rv_addr+8, rv_addr+16);
+        GetCalibrationInfoResult rv = new GetCalibrationInfoResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqGetCalibrationInfo(long image, long unit, long xDistance, long yDistance);
+
+    public static int imaqConstructROI(Image image, ROI roi, Tool initialTool, ToolWindowOptions tools, ConstructROIOptions options) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqConstructROI(image.getAddress(), roi.getAddress(), initialTool.getValue(), tools.getAddress(), options.getAddress(), rv_addr+0);
+        int okay;
+        okay = rv_buf.getInt(0);
+        return okay;
+    }
+    private static native int _imaqConstructROI(long image, long roi, int initialTool, long tools, long options, long okay);
+
+    public static class GetParticleClassifierOptionsResult {
+        public ParticleClassifierPreprocessingOptions preprocessingOptions;
+        public ParticleClassifierOptions options;
+        private GetParticleClassifierOptionsResult(ByteBuffer rv_buf) {
+            preprocessingOptions = new ParticleClassifierPreprocessingOptions(rv_buf, 0);
+            preprocessingOptions.read();
+            options = new ParticleClassifierOptions(rv_buf, 8);
+            options.read();
+        }
+    }
+
+    public static GetParticleClassifierOptionsResult imaqGetParticleClassifierOptions(ClassifierSession session) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqGetParticleClassifierOptions(session.getAddress(), rv_addr+0, rv_addr+8);
+        GetParticleClassifierOptionsResult rv = new GetParticleClassifierOptionsResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqGetParticleClassifierOptions(long session, long preprocessingOptions, long options);
+
+    public static void imaqZoomWindow(int windowNumber, int xZoom, int yZoom, Point center) {
+        
+        _imaqZoomWindow(windowNumber, xZoom, yZoom, center.getAddress());
+        
+    }
+    private static native void _imaqZoomWindow(int windowNumber, int xZoom, int yZoom, long center);
+
+    public static class GetWindowZoomResult {
+        public int xZoom;
+        public int yZoom;
+        private GetWindowZoomResult(ByteBuffer rv_buf) {
+            xZoom = rv_buf.getInt(0);
+            yZoom = rv_buf.getInt(8);
+        }
+    }
+
+    public static GetWindowZoomResult imaqGetWindowZoom(int windowNumber) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        _imaqGetWindowZoom(windowNumber, rv_addr+0, rv_addr+8);
+        GetWindowZoomResult rv = new GetWindowZoomResult(rv_buf);
+        return rv;
+    }
+    private static native void _imaqGetWindowZoom(int windowNumber, long xZoom, long yZoom);
+
+    public static int imaqParticleFilter3(Image dest, Image source, ParticleFilterCriteria2 criteria, int criteriaCount, ParticleFilterOptions options, ROI roi) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqParticleFilter3(dest.getAddress(), source.getAddress(), criteria.getAddress(), criteriaCount, options.getAddress(), roi.getAddress(), rv_addr+0);
+        int numParticles;
+        numParticles = rv_buf.getInt(0);
+        return numParticles;
+    }
+    private static native int _imaqParticleFilter3(long dest, long source, long criteria, int criteriaCount, long options, long roi, long numParticles);
+
+    public static ReadTextReport2 imaqReadText2(Image image, CharSet set, ROI roi, ReadTextOptions readOptions, OCRProcessingOptions processingOptions, OCRSpacingOptions spacingOptions) {
+        
+        long jn_rv = _imaqReadText2(image.getAddress(), set.getAddress(), roi.getAddress(), readOptions.getAddress(), processingOptions.getAddress(), spacingOptions.getAddress());
+        
+        return new ReadTextReport2(jn_rv, true);
+    }
+    private static native long _imaqReadText2(long image, long set, long roi, long readOptions, long processingOptions, long spacingOptions);
+
+    public static LearnPatternAdvancedOptions imaqLearnPattern2(Image image, LearningMode learningMode) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqLearnPattern2(image.getAddress(), learningMode.getValue(), rv_addr+0);
+        LearnPatternAdvancedOptions advancedOptions;
+        advancedOptions = new LearnPatternAdvancedOptions(rv_buf, 0);
+        advancedOptions.read();
+        return advancedOptions;
+    }
+    private static native long _imaqLearnPattern2(long image, int learningMode, long advancedOptions);
+
+    public static void imaqDivide(Image dest, Image sourceA, Image sourceB) {
+        
+        _imaqDivide(dest.getAddress(), sourceA.getAddress(), sourceB.getAddress());
+        
+    }
+    private static native void _imaqDivide(long dest, long sourceA, long sourceB);
+
+    public static EdgeReport2 imaqEdgeTool3(Image image, ROI roi, EdgeProcess processType, EdgeOptions2 edgeOptions) {
+        
+        long jn_rv = _imaqEdgeTool3(image.getAddress(), roi.getAddress(), processType.getValue(), edgeOptions.getAddress());
+        
+        return new EdgeReport2(jn_rv, true);
+    }
+    private static native long _imaqEdgeTool3(long image, long roi, int processType, long edgeOptions);
+
+    public static ConcentricRakeReport imaqConcentricRake(Image image, ROI roi, ConcentricRakeDirection direction, EdgeProcess process, RakeOptions options) {
+        
+        long jn_rv = _imaqConcentricRake(image.getAddress(), roi.getAddress(), direction.getValue(), process.getValue(), options.getAddress());
+        
+        return new ConcentricRakeReport(jn_rv, true);
+    }
+    private static native long _imaqConcentricRake(long image, long roi, int direction, int process, long options);
+
+    public static SpokeReport imaqSpoke(Image image, ROI roi, SpokeDirection direction, EdgeProcess process, SpokeOptions options) {
+        
+        long jn_rv = _imaqSpoke(image.getAddress(), roi.getAddress(), direction.getValue(), process.getValue(), options.getAddress());
+        
+        return new SpokeReport(jn_rv, true);
+    }
+    private static native long _imaqSpoke(long image, long roi, int direction, int process, long options);
+
+    public static void imaqLearnPattern(Image image, LearningMode learningMode) {
+        
+        _imaqLearnPattern(image.getAddress(), learningMode.getValue());
+        
+    }
+    private static native void _imaqLearnPattern(long image, int learningMode);
+
+    public static class MatchPattern2Result {
+        public PatternMatch[] array;
+        private long array_addr;
+        private MatchPattern2Result(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numMatches;
+            array_numMatches = rv_buf.getInt(0);
+            array = new PatternMatch[array_numMatches];
+            if (array_numMatches > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatches*52);
+                for (int i=0, off=0; i<array_numMatches; i++, off += 52) {
+                    array[i] = new PatternMatch(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static MatchPattern2Result imaqMatchPattern2(Image image, Image pattern, MatchPatternOptions options, MatchPatternAdvancedOptions advancedOptions, Rect searchRect) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqMatchPattern2(image.getAddress(), pattern.getAddress(), options == null ? 0 : options.getAddress(), advancedOptions.getAddress(), searchRect.getAddress(), rv_addr+0);
+        MatchPattern2Result rv = new MatchPattern2Result(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqMatchPattern2(long image, long pattern, long options, long advancedOptions, long searchRect, long numMatches);
+
+    public static void imaqSetParticleClassifierOptions(ClassifierSession session, ParticleClassifierPreprocessingOptions preprocessingOptions, ParticleClassifierOptions options) {
+        
+        _imaqSetParticleClassifierOptions(session.getAddress(), preprocessingOptions.getAddress(), options.getAddress());
+        
+    }
+    private static native void _imaqSetParticleClassifierOptions(long session, long preprocessingOptions, long options);
+
+    public static void imaqCopyCalibrationInfo(Image dest, Image source) {
+        
+        _imaqCopyCalibrationInfo(dest.getAddress(), source.getAddress());
+        
+    }
+    private static native void _imaqCopyCalibrationInfo(long dest, long source);
+
+    public static int imaqParticleFilter2(Image dest, Image source, ParticleFilterCriteria2[] criteria, int rejectMatches, int connectivity8) {
+        int criteriaCount = criteria.length;
+        ByteBuffer criteria_buf = null;
+        criteria_buf = ByteBuffer.allocateDirect(criteria.length*20);
+        for (int i=0, off=0; i<criteria.length; i++, off += 20) {
+            criteria[i].setBuffer(criteria_buf, off);
+            criteria[i].write();
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _imaqParticleFilter2(dest.getAddress(), source.getAddress(), getByteBufferAddress(criteria_buf), criteriaCount, rejectMatches, connectivity8, rv_addr+0);
+        int numParticles;
+        numParticles = rv_buf.getInt(0);
+        return numParticles;
+    }
+    private static native int _imaqParticleFilter2(long dest, long source, long criteria, int criteriaCount, int rejectMatches, int connectivity8, long numParticles);
+
+    public static class EdgeTool2Result {
+        public EdgeReport[] array;
+        private long array_addr;
+        private EdgeTool2Result(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numEdges;
+            array_numEdges = rv_buf.getInt(0);
+            array = new EdgeReport[array_numEdges];
+            if (array_numEdges > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numEdges*32);
+                for (int i=0, off=0; i<array_numEdges; i++, off += 32) {
+                    array[i] = new EdgeReport(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static EdgeTool2Result imaqEdgeTool2(Image image, Point points, int numPoints, EdgeProcess process, EdgeOptions options) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqEdgeTool2(image.getAddress(), points.getAddress(), numPoints, process.getValue(), options.getAddress(), rv_addr+0);
+        EdgeTool2Result rv = new EdgeTool2Result(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqEdgeTool2(long image, long points, int numPoints, int process, long options, long numEdges);
+
+    public static int imaqAddRotatedRectContour(ROI roi, RotatedRect rect) {
+        
+        int jn_rv = _imaqAddRotatedRectContour(roi.getAddress(), rect.getAddress());
+        
+        return jn_rv;
+    }
+    private static native int _imaqAddRotatedRectContour(long roi, long rect);
+
+    public static class ReadDataMatrixBarcodeResult {
+        public Barcode2DInfo[] array;
+        private long array_addr;
+        private ReadDataMatrixBarcodeResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numBarcodes;
+            array_numBarcodes = rv_buf.getInt(0);
+            array = new Barcode2DInfo[array_numBarcodes];
+            if (array_numBarcodes > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numBarcodes*64);
+                for (int i=0, off=0; i<array_numBarcodes; i++, off += 64) {
+                    array[i] = new Barcode2DInfo(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static ReadDataMatrixBarcodeResult imaqReadDataMatrixBarcode(Image image, ROI roi, DataMatrixOptions options) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqReadDataMatrixBarcode(image.getAddress(), roi.getAddress(), options.getAddress(), rv_addr+0);
+        ReadDataMatrixBarcodeResult rv = new ReadDataMatrixBarcodeResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqReadDataMatrixBarcode(long image, long roi, long options, long numBarcodes);
+
+    public static LinearAverages imaqLinearAverages(Image image, Rect rect) {
+        
+        long jn_rv = _imaqLinearAverages(image.getAddress(), rect.getAddress());
+        
+        return new LinearAverages(jn_rv, true);
+    }
+    private static native long _imaqLinearAverages(long image, long rect);
+
+    public static class MatchGeometricPatternResult {
+        public GeometricPatternMatch[] array;
+        private long array_addr;
+        private MatchGeometricPatternResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numMatches;
+            array_numMatches = rv_buf.getInt(0);
+            array = new GeometricPatternMatch[array_numMatches];
+            if (array_numMatches > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numMatches*72);
+                for (int i=0, off=0; i<array_numMatches; i++, off += 72) {
+                    array[i] = new GeometricPatternMatch(bb, off);
+                    array[i].read();
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static MatchGeometricPatternResult imaqMatchGeometricPattern(Image image, Image pattern, CurveOptions curveOptions, MatchGeometricPatternOptions matchOptions, MatchGeometricPatternAdvancedOptions advancedMatchOptions, ROI roi) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqMatchGeometricPattern(image.getAddress(), pattern.getAddress(), curveOptions.getAddress(), matchOptions.getAddress(), advancedMatchOptions.getAddress(), roi.getAddress(), rv_addr+0);
+        MatchGeometricPatternResult rv = new MatchGeometricPatternResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqMatchGeometricPattern(long image, long pattern, long curveOptions, long matchOptions, long advancedMatchOptions, long roi, long numMatches);
+
+    public static CharInfo imaqGetCharInfo(CharSet set, int index) {
+        
+        long jn_rv = _imaqGetCharInfo(set.getAddress(), index);
+        
+        return new CharInfo(jn_rv, true);
+    }
+    private static native long _imaqGetCharInfo(long set, int index);
+
+    public static ReadTextReport imaqReadText(Image image, CharSet set, ROI roi, ReadTextOptions readOptions, OCRProcessingOptions processingOptions, OCRSpacingOptions spacingOptions) {
+        
+        long jn_rv = _imaqReadText(image.getAddress(), set.getAddress(), roi.getAddress(), readOptions.getAddress(), processingOptions.getAddress(), spacingOptions.getAddress());
+        
+        return new ReadTextReport(jn_rv, true);
+    }
+    private static native long _imaqReadText(long image, long set, long roi, long readOptions, long processingOptions, long spacingOptions);
+
+    public static ThresholdData imaqAutoThreshold(Image dest, Image source, int numClasses, ThresholdMethod method) {
+        
+        long jn_rv = _imaqAutoThreshold(dest.getAddress(), source.getAddress(), numClasses, method.getValue());
+        
+        return new ThresholdData(jn_rv, true);
+    }
+    private static native long _imaqAutoThreshold(long dest, long source, int numClasses, int method);
+
+    public static ColorHistogramReport imaqColorHistogram(Image image, int numClasses, ColorMode mode, Image mask) {
+        
+        long jn_rv = _imaqColorHistogram(image.getAddress(), numClasses, mode.getValue(), mask == null ? 0 : mask.getAddress());
+        
+        return new ColorHistogramReport(jn_rv, true);
+    }
+    private static native long _imaqColorHistogram(long image, int numClasses, int mode, long mask);
+
+    public static RakeReport imaqRake(Image image, ROI roi, RakeDirection direction, EdgeProcess process, RakeOptions options) {
+        
+        long jn_rv = _imaqRake(image.getAddress(), roi.getAddress(), direction.getValue(), process.getValue(), options.getAddress());
+        
+        return new RakeReport(jn_rv, true);
+    }
+    private static native long _imaqRake(long image, long roi, int direction, int process, long options);
+}
diff --git a/wpilibj/wpilibJavaDevices/src/main/java/com/ni/vision/VisionException.java b/wpilibj/wpilibJavaDevices/src/main/java/com/ni/vision/VisionException.java
new file mode 100644
index 0000000000000000000000000000000000000000..a58806251d2e7654d4ea1c472da3c0dcad2ffc40
--- /dev/null
+++ b/wpilibj/wpilibJavaDevices/src/main/java/com/ni/vision/VisionException.java
@@ -0,0 +1,20 @@
+//
+// This file is auto-generated by wpilibj/wpilibJavaJNI/nivision/gen_java.py
+// Please do not edit!
+//
+
+package com.ni.vision;
+
+public class VisionException extends RuntimeException {
+
+    private static final long serialVersionUID = 1L;
+
+    public VisionException(String msg) {
+        super(msg);
+    }
+
+    @Override
+    public String toString() {
+        return "VisionException [" + super.toString() + "]";
+    }
+}
diff --git a/wpilibj/wpilibJavaJNI/lib/NIVisionJNI.cpp b/wpilibj/wpilibJavaJNI/lib/NIVisionJNI.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..55846f9e2811c5b23d966775cbd9ca3408350973
--- /dev/null
+++ b/wpilibj/wpilibJavaJNI/lib/NIVisionJNI.cpp
@@ -0,0 +1,4717 @@
+//
+// This file is auto-generated by wpilibj/wpilibJavaJNI/nivision/gen_java.py
+// Please do not edit!
+//
+
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <jni.h>
+#include <nivision.h>
+
+// throw java exception
+static void throwJavaException(JNIEnv *env) {
+    jclass je = env->FindClass("com/ni/vision/VisionException");
+    int err = imaqGetLastError();
+    char* err_text = imaqGetErrorText(err);
+    char* full_err_msg = (char*)malloc(30+strlen(err_text));
+    sprintf(full_err_msg, "imaqError: %d: %s", err, err_text);
+    imaqDispose(err_text);
+    env->ThrowNew(je, full_err_msg);
+    free(full_err_msg);
+}
+
+extern "C" {
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDispose(JNIEnv* , jclass , jlong addr)
+{
+    imaqDispose((void*)addr);
+}
+
+/*
+ * Opaque Structures
+ */
+
+/*
+ * Manifest Constants
+ */
+
+/*
+ * Predefined Valid Characters
+ */
+
+/*
+ * Enumerated Types
+ */
+
+/*
+ * Forward Declare Data Structures
+ */
+
+/*
+ * Data Structures
+ */
+
+/*
+ * Globals
+ */
+
+/*
+ * Logical functions
+ */
+
+/* J: void imaqAnd(Image dest, Image sourceA, Image sourceB)
+ * JN: void imaqAnd(long dest, long sourceA, long sourceB)
+ * C: int imaqAnd(Image* dest, const Image* sourceA, const Image* sourceB)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqAnd(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
+{
+    int rv = imaqAnd((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqCompare(Image dest, Image source, Image compareImage, ComparisonFunction compare)
+ * JN: void imaqCompare(long dest, long source, long compareImage, int compare)
+ * C: int imaqCompare(Image* dest, const Image* source, const Image* compareImage, ComparisonFunction compare)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCompare(JNIEnv* env, jclass , jlong dest, jlong source, jlong compareImage, jint compare)
+{
+    int rv = imaqCompare((Image*)dest, (const Image*)source, (const Image*)compareImage, (ComparisonFunction)compare);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqLogicalDifference(Image dest, Image sourceA, Image sourceB)
+ * JN: void imaqLogicalDifference(long dest, long sourceA, long sourceB)
+ * C: int imaqLogicalDifference(Image* dest, const Image* sourceA, const Image* sourceB)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLogicalDifference(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
+{
+    int rv = imaqLogicalDifference((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqNand(Image dest, Image sourceA, Image sourceB)
+ * JN: void imaqNand(long dest, long sourceA, long sourceB)
+ * C: int imaqNand(Image* dest, const Image* sourceA, const Image* sourceB)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqNand(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
+{
+    int rv = imaqNand((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqNor(Image dest, Image sourceA, Image sourceB)
+ * JN: void imaqNor(long dest, long sourceA, long sourceB)
+ * C: int imaqNor(Image* dest, const Image* sourceA, const Image* sourceB)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqNor(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
+{
+    int rv = imaqNor((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqOr(Image dest, Image sourceA, Image sourceB)
+ * JN: void imaqOr(long dest, long sourceA, long sourceB)
+ * C: int imaqOr(Image* dest, const Image* sourceA, const Image* sourceB)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOr(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
+{
+    int rv = imaqOr((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqXnor(Image dest, Image sourceA, Image sourceB)
+ * JN: void imaqXnor(long dest, long sourceA, long sourceB)
+ * C: int imaqXnor(Image* dest, const Image* sourceA, const Image* sourceB)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqXnor(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
+{
+    int rv = imaqXnor((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqXor(Image dest, Image sourceA, Image sourceB)
+ * JN: void imaqXor(long dest, long sourceA, long sourceB)
+ * C: int imaqXor(Image* dest, const Image* sourceA, const Image* sourceB)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqXor(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
+{
+    int rv = imaqXor((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Particle Analysis functions
+ */
+
+/* J: int imaqCountParticles(Image image, int connectivity8)
+ * JN: int imaqCountParticles(long image, int connectivity8, long numParticles)
+ * C: int imaqCountParticles(Image* image, int connectivity8, int* numParticles)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqCountParticles(JNIEnv* env, jclass , jlong image, jint connectivity8, jlong numParticles)
+{
+    int rv = imaqCountParticles((Image*)image, (int)connectivity8, (int*)numParticles);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: double imaqMeasureParticle(Image image, int particleNumber, int calibrated, MeasurementType measurement)
+ * JN: double imaqMeasureParticle(long image, int particleNumber, int calibrated, int measurement, long value)
+ * C: int imaqMeasureParticle(Image* image, int particleNumber, int calibrated, MeasurementType measurement, double* value)
+ */
+
+JNIEXPORT jdouble JNICALL Java_com_ni_vision_NIVision__1imaqMeasureParticle(JNIEnv* env, jclass , jlong image, jint particleNumber, jint calibrated, jint measurement, jlong value)
+{
+    int rv = imaqMeasureParticle((Image*)image, (int)particleNumber, (int)calibrated, (MeasurementType)measurement, (double*)value);
+    if (rv == 0) throwJavaException(env);
+    return (jdouble)rv;
+}
+
+/* J: MeasureParticlesReport imaqMeasureParticles(Image image, MeasureParticlesCalibrationMode calibrationMode, MeasurementType[] measurements)
+ * JN: long imaqMeasureParticles(long image, int calibrationMode, long measurements, int numMeasurements)
+ * C: MeasureParticlesReport* imaqMeasureParticles(Image* image, MeasureParticlesCalibrationMode calibrationMode, const MeasurementType* measurements, size_t numMeasurements)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMeasureParticles(JNIEnv* env, jclass , jlong image, jint calibrationMode, jlong measurements, jint numMeasurements)
+{
+    MeasureParticlesReport* rv = imaqMeasureParticles((Image*)image, (MeasureParticlesCalibrationMode)calibrationMode, (const MeasurementType*)measurements, (size_t)numMeasurements);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: int imaqParticleFilter4(Image dest, Image source, ParticleFilterCriteria2[] criteria, ParticleFilterOptions2 options, ROI roi)
+ * JN: int imaqParticleFilter4(long dest, long source, long criteria, int criteriaCount, long options, long roi, long numParticles)
+ * C: int imaqParticleFilter4(Image* dest, Image* source, const ParticleFilterCriteria2* criteria, int criteriaCount, const ParticleFilterOptions2* options, const ROI* roi, int* numParticles)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqParticleFilter4(JNIEnv* env, jclass , jlong dest, jlong source, jlong criteria, jint criteriaCount, jlong options, jlong roi, jlong numParticles)
+{
+    int rv = imaqParticleFilter4((Image*)dest, (Image*)source, (const ParticleFilterCriteria2*)criteria, (int)criteriaCount, (const ParticleFilterOptions2*)options, (const ROI*)roi, (int*)numParticles);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/*
+ * Morphology functions
+ */
+
+/* J: void imaqConvexHull(Image dest, Image source, int connectivity8)
+ * JN: void imaqConvexHull(long dest, long source, int connectivity8)
+ * C: int imaqConvexHull(Image* dest, Image* source, int connectivity8)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqConvexHull(JNIEnv* env, jclass , jlong dest, jlong source, jint connectivity8)
+{
+    int rv = imaqConvexHull((Image*)dest, (Image*)source, (int)connectivity8);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqDanielssonDistance(Image dest, Image source)
+ * JN: void imaqDanielssonDistance(long dest, long source)
+ * C: int imaqDanielssonDistance(Image* dest, Image* source)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDanielssonDistance(JNIEnv* env, jclass , jlong dest, jlong source)
+{
+    int rv = imaqDanielssonDistance((Image*)dest, (Image*)source);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqFillHoles(Image dest, Image source, int connectivity8)
+ * JN: void imaqFillHoles(long dest, long source, int connectivity8)
+ * C: int imaqFillHoles(Image* dest, const Image* source, int connectivity8)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqFillHoles(JNIEnv* env, jclass , jlong dest, jlong source, jint connectivity8)
+{
+    int rv = imaqFillHoles((Image*)dest, (const Image*)source, (int)connectivity8);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: FindCirclesResult imaqFindCircles(Image dest, Image source, float minRadius, float maxRadius)
+ * JN: long imaqFindCircles(long dest, long source, float minRadius, float maxRadius, long numCircles)
+ * C: CircleReport* imaqFindCircles(Image* dest, Image* source, float minRadius, float maxRadius, int* numCircles)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFindCircles(JNIEnv* env, jclass , jlong dest, jlong source, jfloat minRadius, jfloat maxRadius, jlong numCircles)
+{
+    CircleReport* rv = imaqFindCircles((Image*)dest, (Image*)source, (float)minRadius, (float)maxRadius, (int*)numCircles);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: int imaqLabel2(Image dest, Image source, int connectivity8)
+ * JN: int imaqLabel2(long dest, long source, int connectivity8, long particleCount)
+ * C: int imaqLabel2(Image* dest, Image* source, int connectivity8, int* particleCount)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqLabel2(JNIEnv* env, jclass , jlong dest, jlong source, jint connectivity8, jlong particleCount)
+{
+    int rv = imaqLabel2((Image*)dest, (Image*)source, (int)connectivity8, (int*)particleCount);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: void imaqMorphology(Image dest, Image source, MorphologyMethod method, StructuringElement structuringElement)
+ * JN: void imaqMorphology(long dest, long source, int method, long structuringElement)
+ * C: int imaqMorphology(Image* dest, Image* source, MorphologyMethod method, const StructuringElement* structuringElement)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMorphology(JNIEnv* env, jclass , jlong dest, jlong source, jint method, jlong structuringElement)
+{
+    int rv = imaqMorphology((Image*)dest, (Image*)source, (MorphologyMethod)method, (const StructuringElement*)structuringElement);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqRejectBorder(Image dest, Image source, int connectivity8)
+ * JN: void imaqRejectBorder(long dest, long source, int connectivity8)
+ * C: int imaqRejectBorder(Image* dest, Image* source, int connectivity8)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqRejectBorder(JNIEnv* env, jclass , jlong dest, jlong source, jint connectivity8)
+{
+    int rv = imaqRejectBorder((Image*)dest, (Image*)source, (int)connectivity8);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSegmentation(Image dest, Image source)
+ * JN: void imaqSegmentation(long dest, long source)
+ * C: int imaqSegmentation(Image* dest, Image* source)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSegmentation(JNIEnv* env, jclass , jlong dest, jlong source)
+{
+    int rv = imaqSegmentation((Image*)dest, (Image*)source);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSeparation(Image dest, Image source, int erosions, StructuringElement structuringElement)
+ * JN: void imaqSeparation(long dest, long source, int erosions, long structuringElement)
+ * C: int imaqSeparation(Image* dest, Image* source, int erosions, const StructuringElement* structuringElement)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSeparation(JNIEnv* env, jclass , jlong dest, jlong source, jint erosions, jlong structuringElement)
+{
+    int rv = imaqSeparation((Image*)dest, (Image*)source, (int)erosions, (const StructuringElement*)structuringElement);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSimpleDistance(Image dest, Image source, StructuringElement structuringElement)
+ * JN: void imaqSimpleDistance(long dest, long source, long structuringElement)
+ * C: int imaqSimpleDistance(Image* dest, Image* source, const StructuringElement* structuringElement)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSimpleDistance(JNIEnv* env, jclass , jlong dest, jlong source, jlong structuringElement)
+{
+    int rv = imaqSimpleDistance((Image*)dest, (Image*)source, (const StructuringElement*)structuringElement);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSizeFilter(Image dest, Image source, int connectivity8, int erosions, SizeType keepSize, StructuringElement structuringElement)
+ * JN: void imaqSizeFilter(long dest, long source, int connectivity8, int erosions, int keepSize, long structuringElement)
+ * C: int imaqSizeFilter(Image* dest, Image* source, int connectivity8, int erosions, SizeType keepSize, const StructuringElement* structuringElement)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSizeFilter(JNIEnv* env, jclass , jlong dest, jlong source, jint connectivity8, jint erosions, jint keepSize, jlong structuringElement)
+{
+    int rv = imaqSizeFilter((Image*)dest, (Image*)source, (int)connectivity8, (int)erosions, (SizeType)keepSize, (const StructuringElement*)structuringElement);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSkeleton(Image dest, Image source, SkeletonMethod method)
+ * JN: void imaqSkeleton(long dest, long source, int method)
+ * C: int imaqSkeleton(Image* dest, Image* source, SkeletonMethod method)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSkeleton(JNIEnv* env, jclass , jlong dest, jlong source, jint method)
+{
+    int rv = imaqSkeleton((Image*)dest, (Image*)source, (SkeletonMethod)method);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Acquisition functions
+ */
+
+/* J: Image imaqCopyFromRing(long sessionID, Image image, int imageToCopy, Rect rect)
+ * JN: long imaqCopyFromRing(long sessionID, long image, int imageToCopy, long imageNumber, long rect)
+ * C: Image* imaqCopyFromRing(SESSION_ID sessionID, Image* image, int imageToCopy, int* imageNumber, Rect rect)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCopyFromRing(JNIEnv* env, jclass , jlong sessionID, jlong image, jint imageToCopy, jlong imageNumber, jlong rect)
+{
+    Image* rv = imaqCopyFromRing((SESSION_ID)sessionID, (Image*)image, (int)imageToCopy, (int*)imageNumber, *((Rect*)rect));
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: Image imaqEasyAcquire(String interfaceName)
+ * JN: long imaqEasyAcquire(long interfaceName)
+ * C: Image* imaqEasyAcquire(const char* interfaceName)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqEasyAcquire(JNIEnv* env, jclass , jlong interfaceName)
+{
+    Image* rv = imaqEasyAcquire((const char*)interfaceName);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: Image imaqExtractFromRing(long sessionID, int imageToExtract)
+ * JN: long imaqExtractFromRing(long sessionID, int imageToExtract, long imageNumber)
+ * C: Image* imaqExtractFromRing(SESSION_ID sessionID, int imageToExtract, int* imageNumber)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqExtractFromRing(JNIEnv* env, jclass , jlong sessionID, jint imageToExtract, jlong imageNumber)
+{
+    Image* rv = imaqExtractFromRing((SESSION_ID)sessionID, (int)imageToExtract, (int*)imageNumber);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: Image imaqGrab(long sessionID, Image image, int immediate)
+ * JN: long imaqGrab(long sessionID, long image, int immediate)
+ * C: Image* imaqGrab(SESSION_ID sessionID, Image* image, int immediate)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGrab(JNIEnv* env, jclass , jlong sessionID, jlong image, jint immediate)
+{
+    Image* rv = imaqGrab((SESSION_ID)sessionID, (Image*)image, (int)immediate);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqReleaseImage(long sessionID)
+ * JN: void imaqReleaseImage(long sessionID)
+ * C: int imaqReleaseImage(SESSION_ID sessionID)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqReleaseImage(JNIEnv* env, jclass , jlong sessionID)
+{
+    int rv = imaqReleaseImage((SESSION_ID)sessionID);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetupGrab(long sessionID, Rect rect)
+ * JN: void imaqSetupGrab(long sessionID, long rect)
+ * C: int imaqSetupGrab(SESSION_ID sessionID, Rect rect)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetupGrab(JNIEnv* env, jclass , jlong sessionID, jlong rect)
+{
+    int rv = imaqSetupGrab((SESSION_ID)sessionID, *((Rect*)rect));
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetupRing(long sessionID, Image[] images, int skipCount, Rect rect)
+ * JN: void imaqSetupRing(long sessionID, long images, int numImages, int skipCount, long rect)
+ * C: int imaqSetupRing(SESSION_ID sessionID, Image** images, int numImages, int skipCount, Rect rect)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetupRing(JNIEnv* env, jclass , jlong sessionID, jlong images, jint numImages, jint skipCount, jlong rect)
+{
+    int rv = imaqSetupRing((SESSION_ID)sessionID, (Image**)images, (int)numImages, (int)skipCount, *((Rect*)rect));
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetupSequence(long sessionID, Image[] images, int skipCount, Rect rect)
+ * JN: void imaqSetupSequence(long sessionID, long images, int numImages, int skipCount, long rect)
+ * C: int imaqSetupSequence(SESSION_ID sessionID, Image** images, int numImages, int skipCount, Rect rect)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetupSequence(JNIEnv* env, jclass , jlong sessionID, jlong images, jint numImages, jint skipCount, jlong rect)
+{
+    int rv = imaqSetupSequence((SESSION_ID)sessionID, (Image**)images, (int)numImages, (int)skipCount, *((Rect*)rect));
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: Image imaqSnap(long sessionID, Image image, Rect rect)
+ * JN: long imaqSnap(long sessionID, long image, long rect)
+ * C: Image* imaqSnap(SESSION_ID sessionID, Image* image, Rect rect)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqSnap(JNIEnv* env, jclass , jlong sessionID, jlong image, jlong rect)
+{
+    Image* rv = imaqSnap((SESSION_ID)sessionID, (Image*)image, *((Rect*)rect));
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqStartAcquisition(long sessionID)
+ * JN: void imaqStartAcquisition(long sessionID)
+ * C: int imaqStartAcquisition(SESSION_ID sessionID)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqStartAcquisition(JNIEnv* env, jclass , jlong sessionID)
+{
+    int rv = imaqStartAcquisition((SESSION_ID)sessionID);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqStopAcquisition(long sessionID)
+ * JN: void imaqStopAcquisition(long sessionID)
+ * C: int imaqStopAcquisition(SESSION_ID sessionID)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqStopAcquisition(JNIEnv* env, jclass , jlong sessionID)
+{
+    int rv = imaqStopAcquisition((SESSION_ID)sessionID);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Arithmetic functions
+ */
+
+/* J: void imaqAbsoluteDifference(Image dest, Image sourceA, Image sourceB)
+ * JN: void imaqAbsoluteDifference(long dest, long sourceA, long sourceB)
+ * C: int imaqAbsoluteDifference(Image* dest, const Image* sourceA, const Image* sourceB)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqAbsoluteDifference(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
+{
+    int rv = imaqAbsoluteDifference((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqAdd(Image dest, Image sourceA, Image sourceB)
+ * JN: void imaqAdd(long dest, long sourceA, long sourceB)
+ * C: int imaqAdd(Image* dest, const Image* sourceA, const Image* sourceB)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqAdd(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
+{
+    int rv = imaqAdd((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqAverage(Image dest, Image sourceA, Image sourceB)
+ * JN: void imaqAverage(long dest, long sourceA, long sourceB)
+ * C: int imaqAverage(Image* dest, const Image* sourceA, const Image* sourceB)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqAverage(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
+{
+    int rv = imaqAverage((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqDivide2(Image dest, Image sourceA, Image sourceB, RoundingMode roundingMode)
+ * JN: void imaqDivide2(long dest, long sourceA, long sourceB, int roundingMode)
+ * C: int imaqDivide2(Image* dest, const Image* sourceA, const Image* sourceB, RoundingMode roundingMode)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDivide2(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB, jint roundingMode)
+{
+    int rv = imaqDivide2((Image*)dest, (const Image*)sourceA, (const Image*)sourceB, (RoundingMode)roundingMode);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqMax(Image dest, Image sourceA, Image sourceB)
+ * JN: void imaqMax(long dest, long sourceA, long sourceB)
+ * C: int imaqMax(Image* dest, const Image* sourceA, const Image* sourceB)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMax(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
+{
+    int rv = imaqMax((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqMin(Image dest, Image sourceA, Image sourceB)
+ * JN: void imaqMin(long dest, long sourceA, long sourceB)
+ * C: int imaqMin(Image* dest, const Image* sourceA, const Image* sourceB)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMin(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
+{
+    int rv = imaqMin((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqModulo(Image dest, Image sourceA, Image sourceB)
+ * JN: void imaqModulo(long dest, long sourceA, long sourceB)
+ * C: int imaqModulo(Image* dest, const Image* sourceA, const Image* sourceB)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqModulo(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
+{
+    int rv = imaqModulo((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqMulDiv(Image dest, Image sourceA, Image sourceB, float value)
+ * JN: void imaqMulDiv(long dest, long sourceA, long sourceB, float value)
+ * C: int imaqMulDiv(Image* dest, const Image* sourceA, const Image* sourceB, float value)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMulDiv(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB, jfloat value)
+{
+    int rv = imaqMulDiv((Image*)dest, (const Image*)sourceA, (const Image*)sourceB, (float)value);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqMultiply(Image dest, Image sourceA, Image sourceB)
+ * JN: void imaqMultiply(long dest, long sourceA, long sourceB)
+ * C: int imaqMultiply(Image* dest, const Image* sourceA, const Image* sourceB)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMultiply(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
+{
+    int rv = imaqMultiply((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSubtract(Image dest, Image sourceA, Image sourceB)
+ * JN: void imaqSubtract(long dest, long sourceA, long sourceB)
+ * C: int imaqSubtract(Image* dest, const Image* sourceA, const Image* sourceB)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSubtract(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
+{
+    int rv = imaqSubtract((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Caliper functions
+ */
+
+/* J: CaliperToolResult imaqCaliperTool(Image image, Point[] points, EdgeOptions edgeOptions, CaliperOptions caliperOptions)
+ * JN: long imaqCaliperTool(long image, long points, int numPoints, long edgeOptions, long caliperOptions, long numEdgePairs)
+ * C: CaliperReport* imaqCaliperTool(const Image* image, const Point* points, int numPoints, const EdgeOptions* edgeOptions, const CaliperOptions* caliperOptions, int* numEdgePairs)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCaliperTool(JNIEnv* env, jclass , jlong image, jlong points, jint numPoints, jlong edgeOptions, jlong caliperOptions, jlong numEdgePairs)
+{
+    CaliperReport* rv = imaqCaliperTool((const Image*)image, (const Point*)points, (int)numPoints, (const EdgeOptions*)edgeOptions, (const CaliperOptions*)caliperOptions, (int*)numEdgePairs);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ConcentricRakeReport2 imaqConcentricRake2(Image image, ROI roi, ConcentricRakeDirection direction, EdgeProcess process, int stepSize)
+ * JN: long imaqConcentricRake2(long image, long roi, int direction, int process, int stepSize, long edgeOptions)
+ * C: ConcentricRakeReport2* imaqConcentricRake2(Image* image, ROI* roi, ConcentricRakeDirection direction, EdgeProcess process, int stepSize, EdgeOptions2* edgeOptions)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqConcentricRake2(JNIEnv* env, jclass , jlong image, jlong roi, jint direction, jint process, jint stepSize, jlong edgeOptions)
+{
+    ConcentricRakeReport2* rv = imaqConcentricRake2((Image*)image, (ROI*)roi, (ConcentricRakeDirection)direction, (EdgeProcess)process, (int)stepSize, (EdgeOptions2*)edgeOptions);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: DetectExtremesResult imaqDetectExtremes(double[] pixels, DetectionMode mode, DetectExtremesOptions options)
+ * JN: long imaqDetectExtremes(long pixels, int numPixels, int mode, long options, long numExtremes)
+ * C: ExtremeReport* imaqDetectExtremes(const double* pixels, int numPixels, DetectionMode mode, const DetectExtremesOptions* options, int* numExtremes)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqDetectExtremes(JNIEnv* env, jclass , jlong pixels, jint numPixels, jint mode, jlong options, jlong numExtremes)
+{
+    ExtremeReport* rv = imaqDetectExtremes((const double*)pixels, (int)numPixels, (DetectionMode)mode, (const DetectExtremesOptions*)options, (int*)numExtremes);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: double imaqDetectRotation(Image referenceImage, Image testImage, PointFloat referenceCenter, PointFloat testCenter, int radius, float precision)
+ * JN: double imaqDetectRotation(long referenceImage, long testImage, long referenceCenter, long testCenter, int radius, float precision, long angle)
+ * C: int imaqDetectRotation(const Image* referenceImage, const Image* testImage, PointFloat referenceCenter, PointFloat testCenter, int radius, float precision, double* angle)
+ */
+
+JNIEXPORT jdouble JNICALL Java_com_ni_vision_NIVision__1imaqDetectRotation(JNIEnv* env, jclass , jlong referenceImage, jlong testImage, jlong referenceCenter, jlong testCenter, jint radius, jfloat precision, jlong angle)
+{
+    int rv = imaqDetectRotation((const Image*)referenceImage, (const Image*)testImage, *((PointFloat*)referenceCenter), *((PointFloat*)testCenter), (int)radius, (float)precision, (double*)angle);
+    if (rv == 0) throwJavaException(env);
+    return (jdouble)rv;
+}
+
+/* J: EdgeReport2 imaqEdgeTool4(Image image, ROI roi, EdgeProcess processType, int reverseDirection)
+ * JN: long imaqEdgeTool4(long image, long roi, int processType, long edgeOptions, int reverseDirection)
+ * C: EdgeReport2* imaqEdgeTool4(Image* image, ROI* roi, EdgeProcess processType, EdgeOptions2* edgeOptions, const unsigned int reverseDirection)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqEdgeTool4(JNIEnv* env, jclass , jlong image, jlong roi, jint processType, jlong edgeOptions, jint reverseDirection)
+{
+    EdgeReport2* rv = imaqEdgeTool4((Image*)image, (ROI*)roi, (EdgeProcess)processType, (EdgeOptions2*)edgeOptions, (const unsigned int)reverseDirection);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: FindEdgeReport imaqFindEdge2(Image image, ROI roi, CoordinateSystem baseSystem, CoordinateSystem newSystem, FindEdgeOptions2 findEdgeOptions, StraightEdgeOptions straightEdgeOptions)
+ * JN: long imaqFindEdge2(long image, long roi, long baseSystem, long newSystem, long findEdgeOptions, long straightEdgeOptions)
+ * C: FindEdgeReport* imaqFindEdge2(Image* image, const ROI* roi, const CoordinateSystem* baseSystem, const CoordinateSystem* newSystem, const FindEdgeOptions2* findEdgeOptions, const StraightEdgeOptions* straightEdgeOptions)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFindEdge2(JNIEnv* env, jclass , jlong image, jlong roi, jlong baseSystem, jlong newSystem, jlong findEdgeOptions, jlong straightEdgeOptions)
+{
+    FindEdgeReport* rv = imaqFindEdge2((Image*)image, (const ROI*)roi, (const CoordinateSystem*)baseSystem, (const CoordinateSystem*)newSystem, (const FindEdgeOptions2*)findEdgeOptions, (const StraightEdgeOptions*)straightEdgeOptions);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqFindTransformRect2(Image image, ROI roi, FindTransformMode mode, FindTransformRectOptions2 findTransformOptions, StraightEdgeOptions straightEdgeOptions)
+ * JN: void imaqFindTransformRect2(long image, long roi, int mode, long baseSystem, long newSystem, long findTransformOptions, long straightEdgeOptions, long axisReport)
+ * C: int imaqFindTransformRect2(Image* image, const ROI* roi, FindTransformMode mode, CoordinateSystem* baseSystem, CoordinateSystem* newSystem, const FindTransformRectOptions2* findTransformOptions, const StraightEdgeOptions* straightEdgeOptions, AxisReport* axisReport)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqFindTransformRect2(JNIEnv* env, jclass , jlong image, jlong roi, jint mode, jlong baseSystem, jlong newSystem, jlong findTransformOptions, jlong straightEdgeOptions, jlong axisReport)
+{
+    int rv = imaqFindTransformRect2((Image*)image, (const ROI*)roi, (FindTransformMode)mode, (CoordinateSystem*)baseSystem, (CoordinateSystem*)newSystem, (const FindTransformRectOptions2*)findTransformOptions, (const StraightEdgeOptions*)straightEdgeOptions, (AxisReport*)axisReport);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqFindTransformRects2(Image image, ROI primaryROI, ROI secondaryROI, FindTransformMode mode, FindTransformRectsOptions2 findTransformOptions, StraightEdgeOptions primaryStraightEdgeOptions, StraightEdgeOptions secondaryStraightEdgeOptions)
+ * JN: void imaqFindTransformRects2(long image, long primaryROI, long secondaryROI, int mode, long baseSystem, long newSystem, long findTransformOptions, long primaryStraightEdgeOptions, long secondaryStraightEdgeOptions, long axisReport)
+ * C: int imaqFindTransformRects2(Image* image, const ROI* primaryROI, const ROI* secondaryROI, FindTransformMode mode, CoordinateSystem* baseSystem, CoordinateSystem* newSystem, const FindTransformRectsOptions2* findTransformOptions, const StraightEdgeOptions* primaryStraightEdgeOptions, const StraightEdgeOptions* secondaryStraightEdgeOptions, AxisReport* axisReport)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqFindTransformRects2(JNIEnv* env, jclass , jlong image, jlong primaryROI, jlong secondaryROI, jint mode, jlong baseSystem, jlong newSystem, jlong findTransformOptions, jlong primaryStraightEdgeOptions, jlong secondaryStraightEdgeOptions, jlong axisReport)
+{
+    int rv = imaqFindTransformRects2((Image*)image, (const ROI*)primaryROI, (const ROI*)secondaryROI, (FindTransformMode)mode, (CoordinateSystem*)baseSystem, (CoordinateSystem*)newSystem, (const FindTransformRectsOptions2*)findTransformOptions, (const StraightEdgeOptions*)primaryStraightEdgeOptions, (const StraightEdgeOptions*)secondaryStraightEdgeOptions, (AxisReport*)axisReport);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: float imaqLineGaugeTool2(Image image, Point start, Point end, LineGaugeMethod method, EdgeOptions edgeOptions, CoordinateTransform2 transform)
+ * JN: float imaqLineGaugeTool2(long image, long start, long end, int method, long edgeOptions, long transform, long distance)
+ * C: int imaqLineGaugeTool2(const Image* image, Point start, Point end, LineGaugeMethod method, const EdgeOptions* edgeOptions, const CoordinateTransform2* transform, float* distance)
+ */
+
+JNIEXPORT jfloat JNICALL Java_com_ni_vision_NIVision__1imaqLineGaugeTool2(JNIEnv* env, jclass , jlong image, jlong start, jlong end, jint method, jlong edgeOptions, jlong transform, jlong distance)
+{
+    int rv = imaqLineGaugeTool2((const Image*)image, *((Point*)start), *((Point*)end), (LineGaugeMethod)method, (const EdgeOptions*)edgeOptions, (const CoordinateTransform2*)transform, (float*)distance);
+    if (rv == 0) throwJavaException(env);
+    return (jfloat)rv;
+}
+
+/* J: RakeReport2 imaqRake2(Image image, ROI roi, RakeDirection direction, EdgeProcess process, int stepSize)
+ * JN: long imaqRake2(long image, long roi, int direction, int process, int stepSize, long edgeOptions)
+ * C: RakeReport2* imaqRake2(Image* image, ROI* roi, RakeDirection direction, EdgeProcess process, int stepSize, EdgeOptions2* edgeOptions)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqRake2(JNIEnv* env, jclass , jlong image, jlong roi, jint direction, jint process, jint stepSize, jlong edgeOptions)
+{
+    RakeReport2* rv = imaqRake2((Image*)image, (ROI*)roi, (RakeDirection)direction, (EdgeProcess)process, (int)stepSize, (EdgeOptions2*)edgeOptions);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: SimpleEdgeResult imaqSimpleEdge(Image image, Point[] points, SimpleEdgeOptions options)
+ * JN: long imaqSimpleEdge(long image, long points, int numPoints, long options, long numEdges)
+ * C: PointFloat* imaqSimpleEdge(const Image* image, const Point* points, int numPoints, const SimpleEdgeOptions* options, int* numEdges)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqSimpleEdge(JNIEnv* env, jclass , jlong image, jlong points, jint numPoints, jlong options, jlong numEdges)
+{
+    PointFloat* rv = imaqSimpleEdge((const Image*)image, (const Point*)points, (int)numPoints, (const SimpleEdgeOptions*)options, (int*)numEdges);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: SpokeReport2 imaqSpoke2(Image image, ROI roi, SpokeDirection direction, EdgeProcess process, int stepSize)
+ * JN: long imaqSpoke2(long image, long roi, int direction, int process, int stepSize, long edgeOptions)
+ * C: SpokeReport2* imaqSpoke2(Image* image, ROI* roi, SpokeDirection direction, EdgeProcess process, int stepSize, EdgeOptions2* edgeOptions)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqSpoke2(JNIEnv* env, jclass , jlong image, jlong roi, jint direction, jint process, jint stepSize, jlong edgeOptions)
+{
+    SpokeReport2* rv = imaqSpoke2((Image*)image, (ROI*)roi, (SpokeDirection)direction, (EdgeProcess)process, (int)stepSize, (EdgeOptions2*)edgeOptions);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: StraightEdgeReport2 imaqStraightEdge(Image image, ROI roi, SearchDirection searchDirection, EdgeOptions2 edgeOptions, StraightEdgeOptions straightEdgeOptions)
+ * JN: long imaqStraightEdge(long image, long roi, int searchDirection, long edgeOptions, long straightEdgeOptions)
+ * C: StraightEdgeReport2* imaqStraightEdge(const Image* image, const ROI* roi, SearchDirection searchDirection, const EdgeOptions2* edgeOptions, const StraightEdgeOptions* straightEdgeOptions)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqStraightEdge(JNIEnv* env, jclass , jlong image, jlong roi, jint searchDirection, jlong edgeOptions, jlong straightEdgeOptions)
+{
+    StraightEdgeReport2* rv = imaqStraightEdge((const Image*)image, (const ROI*)roi, (SearchDirection)searchDirection, (const EdgeOptions2*)edgeOptions, (const StraightEdgeOptions*)straightEdgeOptions);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: StraightEdgeReport2 imaqStraightEdge2(Image image, ROI roi, SearchDirection searchDirection, EdgeOptions2 edgeOptions, StraightEdgeOptions straightEdgeOptions, int optimizedMode)
+ * JN: long imaqStraightEdge2(long image, long roi, int searchDirection, long edgeOptions, long straightEdgeOptions, int optimizedMode)
+ * C: StraightEdgeReport2* imaqStraightEdge2(const Image* image, const ROI* roi, SearchDirection searchDirection, const EdgeOptions2* edgeOptions, const StraightEdgeOptions* straightEdgeOptions, unsigned int optimizedMode)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqStraightEdge2(JNIEnv* env, jclass , jlong image, jlong roi, jint searchDirection, jlong edgeOptions, jlong straightEdgeOptions, jint optimizedMode)
+{
+    StraightEdgeReport2* rv = imaqStraightEdge2((const Image*)image, (const ROI*)roi, (SearchDirection)searchDirection, (const EdgeOptions2*)edgeOptions, (const StraightEdgeOptions*)straightEdgeOptions, (unsigned int)optimizedMode);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/*
+ * Spatial Filters functions
+ */
+
+/* J: void imaqCannyEdgeFilter(Image dest, Image source, CannyOptions options)
+ * JN: void imaqCannyEdgeFilter(long dest, long source, long options)
+ * C: int imaqCannyEdgeFilter(Image* dest, const Image* source, const CannyOptions* options)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCannyEdgeFilter(JNIEnv* env, jclass , jlong dest, jlong source, jlong options)
+{
+    int rv = imaqCannyEdgeFilter((Image*)dest, (const Image*)source, (const CannyOptions*)options);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqCorrelate(Image dest, Image source, Image templateImage, Rect rect)
+ * JN: void imaqCorrelate(long dest, long source, long templateImage, long rect)
+ * C: int imaqCorrelate(Image* dest, Image* source, const Image* templateImage, Rect rect)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCorrelate(JNIEnv* env, jclass , jlong dest, jlong source, jlong templateImage, jlong rect)
+{
+    int rv = imaqCorrelate((Image*)dest, (Image*)source, (const Image*)templateImage, *((Rect*)rect));
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqEdgeFilter(Image dest, Image source, OutlineMethod method, Image mask)
+ * JN: void imaqEdgeFilter(long dest, long source, int method, long mask)
+ * C: int imaqEdgeFilter(Image* dest, Image* source, OutlineMethod method, const Image* mask)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqEdgeFilter(JNIEnv* env, jclass , jlong dest, jlong source, jint method, jlong mask)
+{
+    int rv = imaqEdgeFilter((Image*)dest, (Image*)source, (OutlineMethod)method, (const Image*)mask);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqLowPass(Image dest, Image source, int width, int height, float tolerance, Image mask)
+ * JN: void imaqLowPass(long dest, long source, int width, int height, float tolerance, long mask)
+ * C: int imaqLowPass(Image* dest, Image* source, int width, int height, float tolerance, const Image* mask)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLowPass(JNIEnv* env, jclass , jlong dest, jlong source, jint width, jint height, jfloat tolerance, jlong mask)
+{
+    int rv = imaqLowPass((Image*)dest, (Image*)source, (int)width, (int)height, (float)tolerance, (const Image*)mask);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqMedianFilter(Image dest, Image source, int width, int height, Image mask)
+ * JN: void imaqMedianFilter(long dest, long source, int width, int height, long mask)
+ * C: int imaqMedianFilter(Image* dest, Image* source, int width, int height, const Image* mask)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMedianFilter(JNIEnv* env, jclass , jlong dest, jlong source, jint width, jint height, jlong mask)
+{
+    int rv = imaqMedianFilter((Image*)dest, (Image*)source, (int)width, (int)height, (const Image*)mask);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqNthOrderFilter(Image dest, Image source, int width, int height, int n, Image mask)
+ * JN: void imaqNthOrderFilter(long dest, long source, int width, int height, int n, long mask)
+ * C: int imaqNthOrderFilter(Image* dest, Image* source, int width, int height, int n, const Image* mask)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqNthOrderFilter(JNIEnv* env, jclass , jlong dest, jlong source, jint width, jint height, jint n, jlong mask)
+{
+    int rv = imaqNthOrderFilter((Image*)dest, (Image*)source, (int)width, (int)height, (int)n, (const Image*)mask);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Drawing functions
+ */
+
+/* J: void imaqDrawLineOnImage(Image dest, Image source, DrawMode mode, Point start, Point end, float newPixelValue)
+ * JN: void imaqDrawLineOnImage(long dest, long source, int mode, long start, long end, float newPixelValue)
+ * C: int imaqDrawLineOnImage(Image* dest, const Image* source, DrawMode mode, Point start, Point end, float newPixelValue)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDrawLineOnImage(JNIEnv* env, jclass , jlong dest, jlong source, jint mode, jlong start, jlong end, jfloat newPixelValue)
+{
+    int rv = imaqDrawLineOnImage((Image*)dest, (const Image*)source, (DrawMode)mode, *((Point*)start), *((Point*)end), (float)newPixelValue);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqDrawShapeOnImage(Image dest, Image source, Rect rect, DrawMode mode, ShapeMode shape, float newPixelValue)
+ * JN: void imaqDrawShapeOnImage(long dest, long source, long rect, int mode, int shape, float newPixelValue)
+ * C: int imaqDrawShapeOnImage(Image* dest, const Image* source, Rect rect, DrawMode mode, ShapeMode shape, float newPixelValue)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDrawShapeOnImage(JNIEnv* env, jclass , jlong dest, jlong source, jlong rect, jint mode, jint shape, jfloat newPixelValue)
+{
+    int rv = imaqDrawShapeOnImage((Image*)dest, (const Image*)source, *((Rect*)rect), (DrawMode)mode, (ShapeMode)shape, (float)newPixelValue);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: int imaqDrawTextOnImage(Image dest, Image source, Point coord, String text, DrawTextOptions options)
+ * JN: int imaqDrawTextOnImage(long dest, long source, long coord, long text, long options, long fontNameUsed)
+ * C: int imaqDrawTextOnImage(Image* dest, const Image* source, Point coord, const char* text, const DrawTextOptions* options, int* fontNameUsed)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqDrawTextOnImage(JNIEnv* env, jclass , jlong dest, jlong source, jlong coord, jlong text, jlong options, jlong fontNameUsed)
+{
+    int rv = imaqDrawTextOnImage((Image*)dest, (const Image*)source, *((Point*)coord), (const char*)text, (const DrawTextOptions*)options, (int*)fontNameUsed);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/*
+ * Interlacing functions
+ */
+
+/* J: void imaqInterlaceCombine(Image frame, Image odd, Image even)
+ * JN: void imaqInterlaceCombine(long frame, long odd, long even)
+ * C: int imaqInterlaceCombine(Image* frame, const Image* odd, const Image* even)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqInterlaceCombine(JNIEnv* env, jclass , jlong frame, jlong odd, jlong even)
+{
+    int rv = imaqInterlaceCombine((Image*)frame, (const Image*)odd, (const Image*)even);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqInterlaceSeparate(Image frame, Image odd, Image even)
+ * JN: void imaqInterlaceSeparate(long frame, long odd, long even)
+ * C: int imaqInterlaceSeparate(const Image* frame, Image* odd, Image* even)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqInterlaceSeparate(JNIEnv* env, jclass , jlong frame, jlong odd, jlong even)
+{
+    int rv = imaqInterlaceSeparate((const Image*)frame, (Image*)odd, (Image*)even);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Image Information functions
+ */
+
+/* J: int imaqGetBitDepth(Image image)
+ * JN: int imaqGetBitDepth(long image, long bitDepth)
+ * C: int imaqGetBitDepth(const Image* image, unsigned int* bitDepth)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqGetBitDepth(JNIEnv* env, jclass , jlong image, jlong bitDepth)
+{
+    int rv = imaqGetBitDepth((const Image*)image, (unsigned int*)bitDepth);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: int imaqGetBytesPerPixel(Image image)
+ * JN: int imaqGetBytesPerPixel(long image, long byteCount)
+ * C: int imaqGetBytesPerPixel(const Image* image, int* byteCount)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqGetBytesPerPixel(JNIEnv* env, jclass , jlong image, jlong byteCount)
+{
+    int rv = imaqGetBytesPerPixel((const Image*)image, (int*)byteCount);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: ImageInfo imaqGetImageInfo(Image image)
+ * JN: long imaqGetImageInfo(long image, long info)
+ * C: int imaqGetImageInfo(const Image* image, ImageInfo* info)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetImageInfo(JNIEnv* env, jclass , jlong image, jlong info)
+{
+    int rv = imaqGetImageInfo((const Image*)image, (ImageInfo*)info);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqGetImageSize(Image image)
+ * JN: void imaqGetImageSize(long image, long width, long height)
+ * C: int imaqGetImageSize(const Image* image, int* width, int* height)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetImageSize(JNIEnv* env, jclass , jlong image, jlong width, jlong height)
+{
+    int rv = imaqGetImageSize((const Image*)image, (int*)width, (int*)height);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: ImageType imaqGetImageType(Image image)
+ * JN: int imaqGetImageType(long image, long type)
+ * C: int imaqGetImageType(const Image* image, ImageType* type)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqGetImageType(JNIEnv* env, jclass , jlong image, jlong type)
+{
+    int rv = imaqGetImageType((const Image*)image, (ImageType*)type);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: Point imaqGetMaskOffset(Image image)
+ * JN: long imaqGetMaskOffset(long image, long offset)
+ * C: int imaqGetMaskOffset(const Image* image, Point* offset)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetMaskOffset(JNIEnv* env, jclass , jlong image, jlong offset)
+{
+    int rv = imaqGetMaskOffset((const Image*)image, (Point*)offset);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: int imaqGetVisionInfoTypes(Image image)
+ * JN: int imaqGetVisionInfoTypes(long image, long present)
+ * C: int imaqGetVisionInfoTypes(const Image* image, unsigned int* present)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqGetVisionInfoTypes(JNIEnv* env, jclass , jlong image, jlong present)
+{
+    int rv = imaqGetVisionInfoTypes((const Image*)image, (unsigned int*)present);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: int imaqIsImageEmpty(Image image)
+ * JN: int imaqIsImageEmpty(long image, long empty)
+ * C: int imaqIsImageEmpty(const Image* image, int* empty)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqIsImageEmpty(JNIEnv* env, jclass , jlong image, jlong empty)
+{
+    int rv = imaqIsImageEmpty((const Image*)image, (int*)empty);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: void imaqRemoveCustomData(Image image, String key)
+ * JN: void imaqRemoveCustomData(long image, long key)
+ * C: int imaqRemoveCustomData(Image* image, const char* key)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqRemoveCustomData(JNIEnv* env, jclass , jlong image, jlong key)
+{
+    int rv = imaqRemoveCustomData((Image*)image, (const char*)key);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqRemoveVisionInfo2(Image image, int info)
+ * JN: void imaqRemoveVisionInfo2(long image, int info)
+ * C: int imaqRemoveVisionInfo2(const Image* image, unsigned int info)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqRemoveVisionInfo2(JNIEnv* env, jclass , jlong image, jint info)
+{
+    int rv = imaqRemoveVisionInfo2((const Image*)image, (unsigned int)info);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetBitDepth(Image image, int bitDepth)
+ * JN: void imaqSetBitDepth(long image, int bitDepth)
+ * C: int imaqSetBitDepth(Image* image, unsigned int bitDepth)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetBitDepth(JNIEnv* env, jclass , jlong image, jint bitDepth)
+{
+    int rv = imaqSetBitDepth((Image*)image, (unsigned int)bitDepth);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetImageSize(Image image, int width, int height)
+ * JN: void imaqSetImageSize(long image, int width, int height)
+ * C: int imaqSetImageSize(Image* image, int width, int height)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetImageSize(JNIEnv* env, jclass , jlong image, jint width, jint height)
+{
+    int rv = imaqSetImageSize((Image*)image, (int)width, (int)height);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetMaskOffset(Image image, Point offset)
+ * JN: void imaqSetMaskOffset(long image, long offset)
+ * C: int imaqSetMaskOffset(Image* image, Point offset)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetMaskOffset(JNIEnv* env, jclass , jlong image, jlong offset)
+{
+    int rv = imaqSetMaskOffset((Image*)image, *((Point*)offset));
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Display functions
+ */
+
+/* J: int imaqAreToolsContextSensitive()
+ * JN: int imaqAreToolsContextSensitive(long sensitive)
+ * C: int imaqAreToolsContextSensitive(int* sensitive)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAreToolsContextSensitive(JNIEnv* env, jclass , jlong sensitive)
+{
+    int rv = imaqAreToolsContextSensitive((int*)sensitive);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: void imaqCloseWindow(int windowNumber)
+ * JN: void imaqCloseWindow(int windowNumber)
+ * C: int imaqCloseWindow(int windowNumber)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCloseWindow(JNIEnv* env, jclass , jint windowNumber)
+{
+    int rv = imaqCloseWindow((int)windowNumber);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqDisplayImage(Image image, int windowNumber, int resize)
+ * JN: void imaqDisplayImage(long image, int windowNumber, int resize)
+ * C: int imaqDisplayImage(const Image* image, int windowNumber, int resize)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDisplayImage(JNIEnv* env, jclass , jlong image, jint windowNumber, jint resize)
+{
+    int rv = imaqDisplayImage((const Image*)image, (int)windowNumber, (int)resize);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqGetLastKey()
+ * JN: void imaqGetLastKey(long keyPressed, long windowNumber, long modifiers)
+ * C: int imaqGetLastKey(char* keyPressed, int* windowNumber, int* modifiers)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetLastKey(JNIEnv* env, jclass , jlong keyPressed, jlong windowNumber, jlong modifiers)
+{
+    int rv = imaqGetLastKey((char*)keyPressed, (int*)windowNumber, (int*)modifiers);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: Point imaqGetWindowCenterPos(int windowNumber)
+ * JN: long imaqGetWindowCenterPos(int windowNumber, long centerPosition)
+ * C: int imaqGetWindowCenterPos(int windowNumber, Point* centerPosition)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetWindowCenterPos(JNIEnv* env, jclass , jint windowNumber, jlong centerPosition)
+{
+    int rv = imaqGetWindowCenterPos((int)windowNumber, (Point*)centerPosition);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqSetToolContextSensitivity(int sensitive)
+ * JN: void imaqSetToolContextSensitivity(int sensitive)
+ * C: int imaqSetToolContextSensitivity(int sensitive)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetToolContextSensitivity(JNIEnv* env, jclass , jint sensitive)
+{
+    int rv = imaqSetToolContextSensitivity((int)sensitive);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqShowWindow(int windowNumber, int visible)
+ * JN: void imaqShowWindow(int windowNumber, int visible)
+ * C: int imaqShowWindow(int windowNumber, int visible)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqShowWindow(JNIEnv* env, jclass , jint windowNumber, jint visible)
+{
+    int rv = imaqShowWindow((int)windowNumber, (int)visible);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Image Manipulation functions
+ */
+
+/* J: void imaqCopyRect(Image dest, Image source, Rect rect, Point destLoc)
+ * JN: void imaqCopyRect(long dest, long source, long rect, long destLoc)
+ * C: int imaqCopyRect(Image* dest, const Image* source, Rect rect, Point destLoc)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCopyRect(JNIEnv* env, jclass , jlong dest, jlong source, jlong rect, jlong destLoc)
+{
+    int rv = imaqCopyRect((Image*)dest, (const Image*)source, *((Rect*)rect), *((Point*)destLoc));
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqDuplicate(Image dest, Image source)
+ * JN: void imaqDuplicate(long dest, long source)
+ * C: int imaqDuplicate(Image* dest, const Image* source)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDuplicate(JNIEnv* env, jclass , jlong dest, jlong source)
+{
+    int rv = imaqDuplicate((Image*)dest, (const Image*)source);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqFlip(Image dest, Image source, FlipAxis axis)
+ * JN: void imaqFlip(long dest, long source, int axis)
+ * C: int imaqFlip(Image* dest, const Image* source, FlipAxis axis)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqFlip(JNIEnv* env, jclass , jlong dest, jlong source, jint axis)
+{
+    int rv = imaqFlip((Image*)dest, (const Image*)source, (FlipAxis)axis);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqMask(Image dest, Image source, Image mask)
+ * JN: void imaqMask(long dest, long source, long mask)
+ * C: int imaqMask(Image* dest, const Image* source, const Image* mask)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMask(JNIEnv* env, jclass , jlong dest, jlong source, jlong mask)
+{
+    int rv = imaqMask((Image*)dest, (const Image*)source, (const Image*)mask);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqResample(Image dest, Image source, int newWidth, int newHeight, InterpolationMethod method, Rect rect)
+ * JN: void imaqResample(long dest, long source, int newWidth, int newHeight, int method, long rect)
+ * C: int imaqResample(Image* dest, const Image* source, int newWidth, int newHeight, InterpolationMethod method, Rect rect)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqResample(JNIEnv* env, jclass , jlong dest, jlong source, jint newWidth, jint newHeight, jint method, jlong rect)
+{
+    int rv = imaqResample((Image*)dest, (const Image*)source, (int)newWidth, (int)newHeight, (InterpolationMethod)method, *((Rect*)rect));
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqScale(Image dest, Image source, int xScale, int yScale, ScalingMode scaleMode, Rect rect)
+ * JN: void imaqScale(long dest, long source, int xScale, int yScale, int scaleMode, long rect)
+ * C: int imaqScale(Image* dest, const Image* source, int xScale, int yScale, ScalingMode scaleMode, Rect rect)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqScale(JNIEnv* env, jclass , jlong dest, jlong source, jint xScale, jint yScale, jint scaleMode, jlong rect)
+{
+    int rv = imaqScale((Image*)dest, (const Image*)source, (int)xScale, (int)yScale, (ScalingMode)scaleMode, *((Rect*)rect));
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqTranspose(Image dest, Image source)
+ * JN: void imaqTranspose(long dest, long source)
+ * C: int imaqTranspose(Image* dest, const Image* source)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqTranspose(JNIEnv* env, jclass , jlong dest, jlong source)
+{
+    int rv = imaqTranspose((Image*)dest, (const Image*)source);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqUnwrapImage(Image dest, Image source, Annulus annulus, RectOrientation orientation, InterpolationMethod method)
+ * JN: void imaqUnwrapImage(long dest, long source, long annulus, int orientation, int method)
+ * C: int imaqUnwrapImage(Image* dest, const Image* source, Annulus annulus, RectOrientation orientation, InterpolationMethod method)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqUnwrapImage(JNIEnv* env, jclass , jlong dest, jlong source, jlong annulus, jint orientation, jint method)
+{
+    int rv = imaqUnwrapImage((Image*)dest, (const Image*)source, *((Annulus*)annulus), (RectOrientation)orientation, (InterpolationMethod)method);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqView3D(Image dest, Image source, View3DOptions options)
+ * JN: void imaqView3D(long dest, long source, long options)
+ * C: int imaqView3D(Image* dest, Image* source, const View3DOptions* options)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqView3D(JNIEnv* env, jclass , jlong dest, jlong source, jlong options)
+{
+    int rv = imaqView3D((Image*)dest, (Image*)source, (const View3DOptions*)options);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * File I/O functions
+ */
+
+/* J: void imaqCloseAVI(int session)
+ * JN: void imaqCloseAVI(int session)
+ * C: int imaqCloseAVI(AVISession session)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCloseAVI(JNIEnv* env, jclass , jint session)
+{
+    int rv = imaqCloseAVI((AVISession)session);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: int imaqCreateAVI(String fileName, String compressionFilter, int quality, int framesPerSecond, int maxDataSize)
+ * JN: int imaqCreateAVI(long fileName, long compressionFilter, int quality, int framesPerSecond, int maxDataSize)
+ * C: AVISession imaqCreateAVI(const char* fileName, const char* compressionFilter, int quality, unsigned int framesPerSecond, unsigned int maxDataSize)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqCreateAVI(JNIEnv* env, jclass , jlong fileName, jlong compressionFilter, jint quality, jint framesPerSecond, jint maxDataSize)
+{
+    AVISession rv = imaqCreateAVI((const char*)fileName, (const char*)compressionFilter, (int)quality, (unsigned int)framesPerSecond, (unsigned int)maxDataSize);
+    
+    return (jint)rv;
+}
+
+/* J: AVIInfo imaqGetAVIInfo(int session)
+ * JN: long imaqGetAVIInfo(int session, long info)
+ * C: int imaqGetAVIInfo(AVISession session, AVIInfo* info)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetAVIInfo(JNIEnv* env, jclass , jint session, jlong info)
+{
+    int rv = imaqGetAVIInfo((AVISession)session, (AVIInfo*)info);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqGetFileInfo(String fileName)
+ * JN: void imaqGetFileInfo(long fileName, long calibrationUnit, long calibrationX, long calibrationY, long width, long height, long imageType)
+ * C: int imaqGetFileInfo(const char* fileName, CalibrationUnit* calibrationUnit, float* calibrationX, float* calibrationY, int* width, int* height, ImageType* imageType)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetFileInfo(JNIEnv* env, jclass , jlong fileName, jlong calibrationUnit, jlong calibrationX, jlong calibrationY, jlong width, jlong height, jlong imageType)
+{
+    int rv = imaqGetFileInfo((const char*)fileName, (CalibrationUnit*)calibrationUnit, (float*)calibrationX, (float*)calibrationY, (int*)width, (int*)height, (ImageType*)imageType);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: GetFilterNamesResult imaqGetFilterNames()
+ * JN: long imaqGetFilterNames(long numFilters)
+ * C: FilterName* imaqGetFilterNames(int* numFilters)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetFilterNames(JNIEnv* env, jclass , jlong numFilters)
+{
+    FilterName* rv = imaqGetFilterNames((int*)numFilters);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: int imaqOpenAVI(String fileName)
+ * JN: int imaqOpenAVI(long fileName)
+ * C: AVISession imaqOpenAVI(const char* fileName)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqOpenAVI(JNIEnv* env, jclass , jlong fileName)
+{
+    AVISession rv = imaqOpenAVI((const char*)fileName);
+    
+    return (jint)rv;
+}
+
+/* J: void imaqReadFile(Image image, String fileName)
+ * JN: void imaqReadFile(long image, long fileName, long colorTable, long numColors)
+ * C: int imaqReadFile(Image* image, const char* fileName, RGBValue* colorTable, int* numColors)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqReadFile(JNIEnv* env, jclass , jlong image, jlong fileName, jlong colorTable, jlong numColors)
+{
+    int rv = imaqReadFile((Image*)image, (const char*)fileName, (RGBValue*)colorTable, (int*)numColors);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqReadVisionFile(Image image, String fileName)
+ * JN: void imaqReadVisionFile(long image, long fileName, long colorTable, long numColors)
+ * C: int imaqReadVisionFile(Image* image, const char* fileName, RGBValue* colorTable, int* numColors)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqReadVisionFile(JNIEnv* env, jclass , jlong image, jlong fileName, jlong colorTable, jlong numColors)
+{
+    int rv = imaqReadVisionFile((Image*)image, (const char*)fileName, (RGBValue*)colorTable, (int*)numColors);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqWriteBMPFile(Image image, String fileName, int compress, RGBValue colorTable)
+ * JN: void imaqWriteBMPFile(long image, long fileName, int compress, long colorTable)
+ * C: int imaqWriteBMPFile(const Image* image, const char* fileName, int compress, const RGBValue* colorTable)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteBMPFile(JNIEnv* env, jclass , jlong image, jlong fileName, jint compress, jlong colorTable)
+{
+    int rv = imaqWriteBMPFile((const Image*)image, (const char*)fileName, (int)compress, (const RGBValue*)colorTable);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqWriteFile(Image image, String fileName, RGBValue colorTable)
+ * JN: void imaqWriteFile(long image, long fileName, long colorTable)
+ * C: int imaqWriteFile(const Image* image, const char* fileName, const RGBValue* colorTable)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteFile(JNIEnv* env, jclass , jlong image, jlong fileName, jlong colorTable)
+{
+    int rv = imaqWriteFile((const Image*)image, (const char*)fileName, (const RGBValue*)colorTable);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqWriteJPEG2000File(Image image, String fileName, int lossless, float compressionRatio, JPEG2000FileAdvancedOptions advancedOptions, RGBValue colorTable)
+ * JN: void imaqWriteJPEG2000File(long image, long fileName, int lossless, float compressionRatio, long advancedOptions, long colorTable)
+ * C: int imaqWriteJPEG2000File(const Image* image, const char* fileName, int lossless, float compressionRatio, const JPEG2000FileAdvancedOptions* advancedOptions, const RGBValue* colorTable)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteJPEG2000File(JNIEnv* env, jclass , jlong image, jlong fileName, jint lossless, jfloat compressionRatio, jlong advancedOptions, jlong colorTable)
+{
+    int rv = imaqWriteJPEG2000File((const Image*)image, (const char*)fileName, (int)lossless, (float)compressionRatio, (const JPEG2000FileAdvancedOptions*)advancedOptions, (const RGBValue*)colorTable);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqWritePNGFile2(Image image, String fileName, int compressionSpeed, RGBValue colorTable, int useBitDepth)
+ * JN: void imaqWritePNGFile2(long image, long fileName, int compressionSpeed, long colorTable, int useBitDepth)
+ * C: int imaqWritePNGFile2(const Image* image, const char* fileName, unsigned int compressionSpeed, const RGBValue* colorTable, int useBitDepth)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWritePNGFile2(JNIEnv* env, jclass , jlong image, jlong fileName, jint compressionSpeed, jlong colorTable, jint useBitDepth)
+{
+    int rv = imaqWritePNGFile2((const Image*)image, (const char*)fileName, (unsigned int)compressionSpeed, (const RGBValue*)colorTable, (int)useBitDepth);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqWriteTIFFFile(Image image, String fileName, TIFFFileOptions options, RGBValue colorTable)
+ * JN: void imaqWriteTIFFFile(long image, long fileName, long options, long colorTable)
+ * C: int imaqWriteTIFFFile(const Image* image, const char* fileName, const TIFFFileOptions* options, const RGBValue* colorTable)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteTIFFFile(JNIEnv* env, jclass , jlong image, jlong fileName, jlong options, jlong colorTable)
+{
+    int rv = imaqWriteTIFFFile((const Image*)image, (const char*)fileName, (const TIFFFileOptions*)options, (const RGBValue*)colorTable);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqWriteVisionFile(Image image, String fileName, RGBValue colorTable)
+ * JN: void imaqWriteVisionFile(long image, long fileName, long colorTable)
+ * C: int imaqWriteVisionFile(const Image* image, const char* fileName, const RGBValue* colorTable)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteVisionFile(JNIEnv* env, jclass , jlong image, jlong fileName, jlong colorTable)
+{
+    int rv = imaqWriteVisionFile((const Image*)image, (const char*)fileName, (const RGBValue*)colorTable);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Analytic Geometry functions
+ */
+
+/* J: CoordinateSystem imaqBuildCoordinateSystem(Point points, ReferenceMode mode, AxisOrientation orientation)
+ * JN: long imaqBuildCoordinateSystem(long points, int mode, int orientation, long system)
+ * C: int imaqBuildCoordinateSystem(const Point* points, ReferenceMode mode, AxisOrientation orientation, CoordinateSystem* system)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqBuildCoordinateSystem(JNIEnv* env, jclass , jlong points, jint mode, jint orientation, jlong system)
+{
+    int rv = imaqBuildCoordinateSystem((const Point*)points, (ReferenceMode)mode, (AxisOrientation)orientation, (CoordinateSystem*)system);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: BestCircle2 imaqFitCircle2(PointFloat[] points, FitCircleOptions options)
+ * JN: long imaqFitCircle2(long points, int numPoints, long options)
+ * C: BestCircle2* imaqFitCircle2(const PointFloat* points, int numPoints, const FitCircleOptions* options)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFitCircle2(JNIEnv* env, jclass , jlong points, jint numPoints, jlong options)
+{
+    BestCircle2* rv = imaqFitCircle2((const PointFloat*)points, (int)numPoints, (const FitCircleOptions*)options);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: BestEllipse2 imaqFitEllipse2(PointFloat[] points, FitEllipseOptions options)
+ * JN: long imaqFitEllipse2(long points, int numPoints, long options)
+ * C: BestEllipse2* imaqFitEllipse2(const PointFloat* points, int numPoints, const FitEllipseOptions* options)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFitEllipse2(JNIEnv* env, jclass , jlong points, jint numPoints, jlong options)
+{
+    BestEllipse2* rv = imaqFitEllipse2((const PointFloat*)points, (int)numPoints, (const FitEllipseOptions*)options);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: BestLine imaqFitLine(PointFloat[] points, FitLineOptions options)
+ * JN: long imaqFitLine(long points, int numPoints, long options)
+ * C: BestLine* imaqFitLine(const PointFloat* points, int numPoints, const FitLineOptions* options)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFitLine(JNIEnv* env, jclass , jlong points, jint numPoints, jlong options)
+{
+    BestLine* rv = imaqFitLine((const PointFloat*)points, (int)numPoints, (const FitLineOptions*)options);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: float imaqGetAngle(PointFloat start1, PointFloat end1, PointFloat start2, PointFloat end2)
+ * JN: float imaqGetAngle(long start1, long end1, long start2, long end2, long angle)
+ * C: int imaqGetAngle(PointFloat start1, PointFloat end1, PointFloat start2, PointFloat end2, float* angle)
+ */
+
+JNIEXPORT jfloat JNICALL Java_com_ni_vision_NIVision__1imaqGetAngle(JNIEnv* env, jclass , jlong start1, jlong end1, jlong start2, jlong end2, jlong angle)
+{
+    int rv = imaqGetAngle(*((PointFloat*)start1), *((PointFloat*)end1), *((PointFloat*)start2), *((PointFloat*)end2), (float*)angle);
+    if (rv == 0) throwJavaException(env);
+    return (jfloat)rv;
+}
+
+/* J: void imaqGetBisectingLine(PointFloat start1, PointFloat end1, PointFloat start2, PointFloat end2)
+ * JN: void imaqGetBisectingLine(long start1, long end1, long start2, long end2, long bisectStart, long bisectEnd)
+ * C: int imaqGetBisectingLine(PointFloat start1, PointFloat end1, PointFloat start2, PointFloat end2, PointFloat* bisectStart, PointFloat* bisectEnd)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetBisectingLine(JNIEnv* env, jclass , jlong start1, jlong end1, jlong start2, jlong end2, jlong bisectStart, jlong bisectEnd)
+{
+    int rv = imaqGetBisectingLine(*((PointFloat*)start1), *((PointFloat*)end1), *((PointFloat*)start2), *((PointFloat*)end2), (PointFloat*)bisectStart, (PointFloat*)bisectEnd);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: float imaqGetDistance(PointFloat point1, PointFloat point2)
+ * JN: float imaqGetDistance(long point1, long point2, long distance)
+ * C: int imaqGetDistance(PointFloat point1, PointFloat point2, float* distance)
+ */
+
+JNIEXPORT jfloat JNICALL Java_com_ni_vision_NIVision__1imaqGetDistance(JNIEnv* env, jclass , jlong point1, jlong point2, jlong distance)
+{
+    int rv = imaqGetDistance(*((PointFloat*)point1), *((PointFloat*)point2), (float*)distance);
+    if (rv == 0) throwJavaException(env);
+    return (jfloat)rv;
+}
+
+/* J: PointFloat imaqGetIntersection(PointFloat start1, PointFloat end1, PointFloat start2, PointFloat end2)
+ * JN: long imaqGetIntersection(long start1, long end1, long start2, long end2, long intersection)
+ * C: int imaqGetIntersection(PointFloat start1, PointFloat end1, PointFloat start2, PointFloat end2, PointFloat* intersection)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetIntersection(JNIEnv* env, jclass , jlong start1, jlong end1, jlong start2, jlong end2, jlong intersection)
+{
+    int rv = imaqGetIntersection(*((PointFloat*)start1), *((PointFloat*)end1), *((PointFloat*)start2), *((PointFloat*)end2), (PointFloat*)intersection);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqGetMidLine(PointFloat refLineStart, PointFloat refLineEnd, PointFloat point)
+ * JN: void imaqGetMidLine(long refLineStart, long refLineEnd, long point, long midLineStart, long midLineEnd)
+ * C: int imaqGetMidLine(PointFloat refLineStart, PointFloat refLineEnd, PointFloat point, PointFloat* midLineStart, PointFloat* midLineEnd)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetMidLine(JNIEnv* env, jclass , jlong refLineStart, jlong refLineEnd, jlong point, jlong midLineStart, jlong midLineEnd)
+{
+    int rv = imaqGetMidLine(*((PointFloat*)refLineStart), *((PointFloat*)refLineEnd), *((PointFloat*)point), (PointFloat*)midLineStart, (PointFloat*)midLineEnd);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqGetPerpendicularLine(PointFloat refLineStart, PointFloat refLineEnd, PointFloat point)
+ * JN: void imaqGetPerpendicularLine(long refLineStart, long refLineEnd, long point, long perpLineStart, long perpLineEnd, long distance)
+ * C: int imaqGetPerpendicularLine(PointFloat refLineStart, PointFloat refLineEnd, PointFloat point, PointFloat* perpLineStart, PointFloat* perpLineEnd, double* distance)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetPerpendicularLine(JNIEnv* env, jclass , jlong refLineStart, jlong refLineEnd, jlong point, jlong perpLineStart, jlong perpLineEnd, jlong distance)
+{
+    int rv = imaqGetPerpendicularLine(*((PointFloat*)refLineStart), *((PointFloat*)refLineEnd), *((PointFloat*)point), (PointFloat*)perpLineStart, (PointFloat*)perpLineEnd, (double*)distance);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: GetPointsOnContourResult imaqGetPointsOnContour(Image image)
+ * JN: long imaqGetPointsOnContour(long image, long numSegments)
+ * C: SegmentInfo* imaqGetPointsOnContour(const Image* image, int* numSegments)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetPointsOnContour(JNIEnv* env, jclass , jlong image, jlong numSegments)
+{
+    SegmentInfo* rv = imaqGetPointsOnContour((const Image*)image, (int*)numSegments);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: GetPointsOnLineResult imaqGetPointsOnLine(Point start, Point end)
+ * JN: long imaqGetPointsOnLine(long start, long end, long numPoints)
+ * C: Point* imaqGetPointsOnLine(Point start, Point end, int* numPoints)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetPointsOnLine(JNIEnv* env, jclass , jlong start, jlong end, jlong numPoints)
+{
+    Point* rv = imaqGetPointsOnLine(*((Point*)start), *((Point*)end), (int*)numPoints);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: float imaqGetPolygonArea(PointFloat points, int numPoints)
+ * JN: float imaqGetPolygonArea(long points, int numPoints, long area)
+ * C: int imaqGetPolygonArea(const PointFloat* points, int numPoints, float* area)
+ */
+
+JNIEXPORT jfloat JNICALL Java_com_ni_vision_NIVision__1imaqGetPolygonArea(JNIEnv* env, jclass , jlong points, jint numPoints, jlong area)
+{
+    int rv = imaqGetPolygonArea((const PointFloat*)points, (int)numPoints, (float*)area);
+    if (rv == 0) throwJavaException(env);
+    return (jfloat)rv;
+}
+
+/*
+ * Clipboard functions
+ */
+
+/* J: RGBValue imaqClipboardToImage(Image dest)
+ * JN: long imaqClipboardToImage(long dest, long palette)
+ * C: int imaqClipboardToImage(Image* dest, RGBValue* palette)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqClipboardToImage(JNIEnv* env, jclass , jlong dest, jlong palette)
+{
+    int rv = imaqClipboardToImage((Image*)dest, (RGBValue*)palette);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqImageToClipboard(Image image, RGBValue palette)
+ * JN: void imaqImageToClipboard(long image, long palette)
+ * C: int imaqImageToClipboard(const Image* image, const RGBValue* palette)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqImageToClipboard(JNIEnv* env, jclass , jlong image, jlong palette)
+{
+    int rv = imaqImageToClipboard((const Image*)image, (const RGBValue*)palette);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Border functions
+ */
+
+/* J: void imaqFillBorder(Image image, BorderMethod method)
+ * JN: void imaqFillBorder(long image, int method)
+ * C: int imaqFillBorder(Image* image, BorderMethod method)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqFillBorder(JNIEnv* env, jclass , jlong image, jint method)
+{
+    int rv = imaqFillBorder((Image*)image, (BorderMethod)method);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: int imaqGetBorderSize(Image image)
+ * JN: int imaqGetBorderSize(long image, long borderSize)
+ * C: int imaqGetBorderSize(const Image* image, int* borderSize)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqGetBorderSize(JNIEnv* env, jclass , jlong image, jlong borderSize)
+{
+    int rv = imaqGetBorderSize((const Image*)image, (int*)borderSize);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: void imaqSetBorderSize(Image image, int size)
+ * JN: void imaqSetBorderSize(long image, int size)
+ * C: int imaqSetBorderSize(Image* image, int size)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetBorderSize(JNIEnv* env, jclass , jlong image, jint size)
+{
+    int rv = imaqSetBorderSize((Image*)image, (int)size);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Image Management functions
+ */
+
+/* J: Image imaqCreateImage(ImageType type, int borderSize)
+ * JN: long imaqCreateImage(int type, int borderSize)
+ * C: Image* imaqCreateImage(ImageType type, int borderSize)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCreateImage(JNIEnv* env, jclass , jint type, jint borderSize)
+{
+    Image* rv = imaqCreateImage((ImageType)type, (int)borderSize);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/*
+ * Color Processing functions
+ */
+
+/* J: void imaqColorBCGTransform(Image dest, Image source, BCGOptions redOptions, BCGOptions greenOptions, BCGOptions blueOptions, Image mask)
+ * JN: void imaqColorBCGTransform(long dest, long source, long redOptions, long greenOptions, long blueOptions, long mask)
+ * C: int imaqColorBCGTransform(Image* dest, const Image* source, const BCGOptions* redOptions, const BCGOptions* greenOptions, const BCGOptions* blueOptions, const Image* mask)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqColorBCGTransform(JNIEnv* env, jclass , jlong dest, jlong source, jlong redOptions, jlong greenOptions, jlong blueOptions, jlong mask)
+{
+    int rv = imaqColorBCGTransform((Image*)dest, (const Image*)source, (const BCGOptions*)redOptions, (const BCGOptions*)greenOptions, (const BCGOptions*)blueOptions, (const Image*)mask);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqColorEqualize(Image dest, Image source, int colorEqualization)
+ * JN: void imaqColorEqualize(long dest, long source, int colorEqualization)
+ * C: int imaqColorEqualize(Image* dest, const Image* source, int colorEqualization)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqColorEqualize(JNIEnv* env, jclass , jlong dest, jlong source, jint colorEqualization)
+{
+    int rv = imaqColorEqualize((Image*)dest, (const Image*)source, (int)colorEqualization);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: ColorHistogramReport imaqColorHistogram2(Image image, int numClasses, ColorMode mode, CIEXYZValue whiteReference, Image mask)
+ * JN: long imaqColorHistogram2(long image, int numClasses, int mode, long whiteReference, long mask)
+ * C: ColorHistogramReport* imaqColorHistogram2(Image* image, int numClasses, ColorMode mode, const CIEXYZValue* whiteReference, Image* mask)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqColorHistogram2(JNIEnv* env, jclass , jlong image, jint numClasses, jint mode, jlong whiteReference, jlong mask)
+{
+    ColorHistogramReport* rv = imaqColorHistogram2((Image*)image, (int)numClasses, (ColorMode)mode, (const CIEXYZValue*)whiteReference, (Image*)mask);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqColorThreshold(Image dest, Image source, int replaceValue, ColorMode mode, Range plane1Range, Range plane2Range, Range plane3Range)
+ * JN: void imaqColorThreshold(long dest, long source, int replaceValue, int mode, long plane1Range, long plane2Range, long plane3Range)
+ * C: int imaqColorThreshold(Image* dest, const Image* source, int replaceValue, ColorMode mode, const Range* plane1Range, const Range* plane2Range, const Range* plane3Range)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqColorThreshold(JNIEnv* env, jclass , jlong dest, jlong source, jint replaceValue, jint mode, jlong plane1Range, jlong plane2Range, jlong plane3Range)
+{
+    int rv = imaqColorThreshold((Image*)dest, (const Image*)source, (int)replaceValue, (ColorMode)mode, (const Range*)plane1Range, (const Range*)plane2Range, (const Range*)plane3Range);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: SupervisedColorSegmentationReport imaqSupervisedColorSegmentation(ClassifierSession session, Image labelImage, Image srcImage, ROI roi, ROILabel labelIn, int numLabelIn, int maxDistance, int minIdentificationScore, ColorSegmenationOptions segmentOptions)
+ * JN: long imaqSupervisedColorSegmentation(long session, long labelImage, long srcImage, long roi, long labelIn, int numLabelIn, int maxDistance, int minIdentificationScore, long segmentOptions)
+ * C: SupervisedColorSegmentationReport* imaqSupervisedColorSegmentation(ClassifierSession* session, Image* labelImage, const Image* srcImage, const ROI* roi, const ROILabel* labelIn, unsigned int numLabelIn, int maxDistance, int minIdentificationScore, const ColorSegmenationOptions* segmentOptions)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqSupervisedColorSegmentation(JNIEnv* env, jclass , jlong session, jlong labelImage, jlong srcImage, jlong roi, jlong labelIn, jint numLabelIn, jint maxDistance, jint minIdentificationScore, jlong segmentOptions)
+{
+    SupervisedColorSegmentationReport* rv = imaqSupervisedColorSegmentation((ClassifierSession*)session, (Image*)labelImage, (const Image*)srcImage, (const ROI*)roi, (const ROILabel*)labelIn, (unsigned int)numLabelIn, (int)maxDistance, (int)minIdentificationScore, (const ColorSegmenationOptions*)segmentOptions);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: int imaqGetColorSegmentationMaxDistance(ClassifierSession session, ColorSegmenationOptions segmentOptions, SegmentationDistanceLevel distLevel)
+ * JN: int imaqGetColorSegmentationMaxDistance(long session, long segmentOptions, int distLevel, long maxDistance)
+ * C: int imaqGetColorSegmentationMaxDistance(ClassifierSession* session, const ColorSegmenationOptions* segmentOptions, SegmentationDistanceLevel distLevel, int* maxDistance)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqGetColorSegmentationMaxDistance(JNIEnv* env, jclass , jlong session, jlong segmentOptions, jint distLevel, jlong maxDistance)
+{
+    int rv = imaqGetColorSegmentationMaxDistance((ClassifierSession*)session, (const ColorSegmenationOptions*)segmentOptions, (SegmentationDistanceLevel)distLevel, (int*)maxDistance);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/*
+ * Transform functions
+ */
+
+/* J: void imaqBCGTransform(Image dest, Image source, BCGOptions options, Image mask)
+ * JN: void imaqBCGTransform(long dest, long source, long options, long mask)
+ * C: int imaqBCGTransform(Image* dest, const Image* source, const BCGOptions* options, const Image* mask)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqBCGTransform(JNIEnv* env, jclass , jlong dest, jlong source, jlong options, jlong mask)
+{
+    int rv = imaqBCGTransform((Image*)dest, (const Image*)source, (const BCGOptions*)options, (const Image*)mask);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqEqualize(Image dest, Image source, float min, float max, Image mask)
+ * JN: void imaqEqualize(long dest, long source, float min, float max, long mask)
+ * C: int imaqEqualize(Image* dest, const Image* source, float min, float max, const Image* mask)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqEqualize(JNIEnv* env, jclass , jlong dest, jlong source, jfloat min, jfloat max, jlong mask)
+{
+    int rv = imaqEqualize((Image*)dest, (const Image*)source, (float)min, (float)max, (const Image*)mask);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqInverse(Image dest, Image source, Image mask)
+ * JN: void imaqInverse(long dest, long source, long mask)
+ * C: int imaqInverse(Image* dest, const Image* source, const Image* mask)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqInverse(JNIEnv* env, jclass , jlong dest, jlong source, jlong mask)
+{
+    int rv = imaqInverse((Image*)dest, (const Image*)source, (const Image*)mask);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqMathTransform(Image dest, Image source, MathTransformMethod method, float rangeMin, float rangeMax, float power, Image mask)
+ * JN: void imaqMathTransform(long dest, long source, int method, float rangeMin, float rangeMax, float power, long mask)
+ * C: int imaqMathTransform(Image* dest, const Image* source, MathTransformMethod method, float rangeMin, float rangeMax, float power, const Image* mask)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMathTransform(JNIEnv* env, jclass , jlong dest, jlong source, jint method, jfloat rangeMin, jfloat rangeMax, jfloat power, jlong mask)
+{
+    int rv = imaqMathTransform((Image*)dest, (const Image*)source, (MathTransformMethod)method, (float)rangeMin, (float)rangeMax, (float)power, (const Image*)mask);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: int imaqWatershedTransform(Image dest, Image source, int connectivity8)
+ * JN: int imaqWatershedTransform(long dest, long source, int connectivity8, long zoneCount)
+ * C: int imaqWatershedTransform(Image* dest, const Image* source, int connectivity8, int* zoneCount)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqWatershedTransform(JNIEnv* env, jclass , jlong dest, jlong source, jint connectivity8, jlong zoneCount)
+{
+    int rv = imaqWatershedTransform((Image*)dest, (const Image*)source, (int)connectivity8, (int*)zoneCount);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/*
+ * Window Management functions
+ */
+
+/* J: int imaqAreScrollbarsVisible(int windowNumber)
+ * JN: int imaqAreScrollbarsVisible(int windowNumber, long visible)
+ * C: int imaqAreScrollbarsVisible(int windowNumber, int* visible)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAreScrollbarsVisible(JNIEnv* env, jclass , jint windowNumber, jlong visible)
+{
+    int rv = imaqAreScrollbarsVisible((int)windowNumber, (int*)visible);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: void imaqBringWindowToTop(int windowNumber)
+ * JN: void imaqBringWindowToTop(int windowNumber)
+ * C: int imaqBringWindowToTop(int windowNumber)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqBringWindowToTop(JNIEnv* env, jclass , jint windowNumber)
+{
+    int rv = imaqBringWindowToTop((int)windowNumber);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqGetMousePos()
+ * JN: void imaqGetMousePos(long position, long windowNumber)
+ * C: int imaqGetMousePos(Point* position, int* windowNumber)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetMousePos(JNIEnv* env, jclass , jlong position, jlong windowNumber)
+{
+    int rv = imaqGetMousePos((Point*)position, (int*)windowNumber);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqGetWindowBackground(int windowNumber)
+ * JN: void imaqGetWindowBackground(int windowNumber, long fillStyle, long hatchStyle, long fillColor, long backgroundColor)
+ * C: int imaqGetWindowBackground(int windowNumber, WindowBackgroundFillStyle* fillStyle, WindowBackgroundHatchStyle* hatchStyle, RGBValue* fillColor, RGBValue* backgroundColor)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetWindowBackground(JNIEnv* env, jclass , jint windowNumber, jlong fillStyle, jlong hatchStyle, jlong fillColor, jlong backgroundColor)
+{
+    int rv = imaqGetWindowBackground((int)windowNumber, (WindowBackgroundFillStyle*)fillStyle, (WindowBackgroundHatchStyle*)hatchStyle, (RGBValue*)fillColor, (RGBValue*)backgroundColor);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: DisplayMapping imaqGetWindowDisplayMapping(int windowNum)
+ * JN: long imaqGetWindowDisplayMapping(int windowNum, long mapping)
+ * C: int imaqGetWindowDisplayMapping(int windowNum, DisplayMapping* mapping)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetWindowDisplayMapping(JNIEnv* env, jclass , jint windowNum, jlong mapping)
+{
+    int rv = imaqGetWindowDisplayMapping((int)windowNum, (DisplayMapping*)mapping);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqGetWindowGrid(int windowNumber)
+ * JN: void imaqGetWindowGrid(int windowNumber, long xResolution, long yResolution)
+ * C: int imaqGetWindowGrid(int windowNumber, int* xResolution, int* yResolution)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetWindowGrid(JNIEnv* env, jclass , jint windowNumber, jlong xResolution, jlong yResolution)
+{
+    int rv = imaqGetWindowGrid((int)windowNumber, (int*)xResolution, (int*)yResolution);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: int imaqGetWindowHandle()
+ * JN: int imaqGetWindowHandle(long handle)
+ * C: int imaqGetWindowHandle(int* handle)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqGetWindowHandle(JNIEnv* env, jclass , jlong handle)
+{
+    int rv = imaqGetWindowHandle((int*)handle);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: Point imaqGetWindowPos(int windowNumber)
+ * JN: long imaqGetWindowPos(int windowNumber, long position)
+ * C: int imaqGetWindowPos(int windowNumber, Point* position)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetWindowPos(JNIEnv* env, jclass , jint windowNumber, jlong position)
+{
+    int rv = imaqGetWindowPos((int)windowNumber, (Point*)position);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqGetWindowSize(int windowNumber)
+ * JN: void imaqGetWindowSize(int windowNumber, long width, long height)
+ * C: int imaqGetWindowSize(int windowNumber, int* width, int* height)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetWindowSize(JNIEnv* env, jclass , jint windowNumber, jlong width, jlong height)
+{
+    int rv = imaqGetWindowSize((int)windowNumber, (int*)width, (int*)height);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: String imaqGetWindowTitle(int windowNumber)
+ * JN: String imaqGetWindowTitle(int windowNumber)
+ * C: char* imaqGetWindowTitle(int windowNumber)
+ */
+
+JNIEXPORT jstring JNICALL Java_com_ni_vision_NIVision__1imaqGetWindowTitle(JNIEnv* env, jclass , jint windowNumber)
+{
+    char* rv = imaqGetWindowTitle((int)windowNumber);
+    if (!rv) throwJavaException(env);
+    return (jstring)rv;
+}
+
+/* J: void imaqGetWindowZoom2(int windowNumber)
+ * JN: void imaqGetWindowZoom2(int windowNumber, long xZoom, long yZoom)
+ * C: int imaqGetWindowZoom2(int windowNumber, float* xZoom, float* yZoom)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetWindowZoom2(JNIEnv* env, jclass , jint windowNumber, jlong xZoom, jlong yZoom)
+{
+    int rv = imaqGetWindowZoom2((int)windowNumber, (float*)xZoom, (float*)yZoom);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: int imaqIsWindowNonTearing(int windowNumber)
+ * JN: int imaqIsWindowNonTearing(int windowNumber, long nonTearing)
+ * C: int imaqIsWindowNonTearing(int windowNumber, int* nonTearing)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqIsWindowNonTearing(JNIEnv* env, jclass , jint windowNumber, jlong nonTearing)
+{
+    int rv = imaqIsWindowNonTearing((int)windowNumber, (int*)nonTearing);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: int imaqIsWindowVisible(int windowNumber)
+ * JN: int imaqIsWindowVisible(int windowNumber, long visible)
+ * C: int imaqIsWindowVisible(int windowNumber, int* visible)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqIsWindowVisible(JNIEnv* env, jclass , jint windowNumber, jlong visible)
+{
+    int rv = imaqIsWindowVisible((int)windowNumber, (int*)visible);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: void imaqMoveWindow(int windowNumber, Point position)
+ * JN: void imaqMoveWindow(int windowNumber, long position)
+ * C: int imaqMoveWindow(int windowNumber, Point position)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMoveWindow(JNIEnv* env, jclass , jint windowNumber, jlong position)
+{
+    int rv = imaqMoveWindow((int)windowNumber, *((Point*)position));
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetupWindow(int windowNumber, int configuration)
+ * JN: void imaqSetupWindow(int windowNumber, int configuration)
+ * C: int imaqSetupWindow(int windowNumber, int configuration)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetupWindow(JNIEnv* env, jclass , jint windowNumber, jint configuration)
+{
+    int rv = imaqSetupWindow((int)windowNumber, (int)configuration);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetWindowBackground(int windowNumber, WindowBackgroundFillStyle fillStyle, WindowBackgroundHatchStyle hatchStyle, RGBValue fillColor, RGBValue backgroundColor)
+ * JN: void imaqSetWindowBackground(int windowNumber, int fillStyle, int hatchStyle, long fillColor, long backgroundColor)
+ * C: int imaqSetWindowBackground(int windowNumber, WindowBackgroundFillStyle fillStyle, WindowBackgroundHatchStyle hatchStyle, const RGBValue* fillColor, const RGBValue* backgroundColor)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetWindowBackground(JNIEnv* env, jclass , jint windowNumber, jint fillStyle, jint hatchStyle, jlong fillColor, jlong backgroundColor)
+{
+    int rv = imaqSetWindowBackground((int)windowNumber, (WindowBackgroundFillStyle)fillStyle, (WindowBackgroundHatchStyle)hatchStyle, (const RGBValue*)fillColor, (const RGBValue*)backgroundColor);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetWindowDisplayMapping(int windowNumber, DisplayMapping mapping)
+ * JN: void imaqSetWindowDisplayMapping(int windowNumber, long mapping)
+ * C: int imaqSetWindowDisplayMapping(int windowNumber, const DisplayMapping* mapping)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetWindowDisplayMapping(JNIEnv* env, jclass , jint windowNumber, jlong mapping)
+{
+    int rv = imaqSetWindowDisplayMapping((int)windowNumber, (const DisplayMapping*)mapping);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetWindowGrid(int windowNumber, int xResolution, int yResolution)
+ * JN: void imaqSetWindowGrid(int windowNumber, int xResolution, int yResolution)
+ * C: int imaqSetWindowGrid(int windowNumber, int xResolution, int yResolution)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetWindowGrid(JNIEnv* env, jclass , jint windowNumber, jint xResolution, jint yResolution)
+{
+    int rv = imaqSetWindowGrid((int)windowNumber, (int)xResolution, (int)yResolution);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetWindowMaxContourCount(int windowNumber, int maxContourCount)
+ * JN: void imaqSetWindowMaxContourCount(int windowNumber, int maxContourCount)
+ * C: int imaqSetWindowMaxContourCount(int windowNumber, unsigned int maxContourCount)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetWindowMaxContourCount(JNIEnv* env, jclass , jint windowNumber, jint maxContourCount)
+{
+    int rv = imaqSetWindowMaxContourCount((int)windowNumber, (unsigned int)maxContourCount);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetWindowNonTearing(int windowNumber, int nonTearing)
+ * JN: void imaqSetWindowNonTearing(int windowNumber, int nonTearing)
+ * C: int imaqSetWindowNonTearing(int windowNumber, int nonTearing)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetWindowNonTearing(JNIEnv* env, jclass , jint windowNumber, jint nonTearing)
+{
+    int rv = imaqSetWindowNonTearing((int)windowNumber, (int)nonTearing);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetWindowPalette(int windowNumber, PaletteType type, RGBValue[] palette)
+ * JN: void imaqSetWindowPalette(int windowNumber, int type, long palette, int numColors)
+ * C: int imaqSetWindowPalette(int windowNumber, PaletteType type, const RGBValue* palette, int numColors)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetWindowPalette(JNIEnv* env, jclass , jint windowNumber, jint type, jlong palette, jint numColors)
+{
+    int rv = imaqSetWindowPalette((int)windowNumber, (PaletteType)type, (const RGBValue*)palette, (int)numColors);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetWindowSize(int windowNumber, int width, int height)
+ * JN: void imaqSetWindowSize(int windowNumber, int width, int height)
+ * C: int imaqSetWindowSize(int windowNumber, int width, int height)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetWindowSize(JNIEnv* env, jclass , jint windowNumber, jint width, jint height)
+{
+    int rv = imaqSetWindowSize((int)windowNumber, (int)width, (int)height);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetWindowThreadPolicy(WindowThreadPolicy policy)
+ * JN: void imaqSetWindowThreadPolicy(int policy)
+ * C: int imaqSetWindowThreadPolicy(WindowThreadPolicy policy)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetWindowThreadPolicy(JNIEnv* env, jclass , jint policy)
+{
+    int rv = imaqSetWindowThreadPolicy((WindowThreadPolicy)policy);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetWindowTitle(int windowNumber, String title)
+ * JN: void imaqSetWindowTitle(int windowNumber, long title)
+ * C: int imaqSetWindowTitle(int windowNumber, const char* title)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetWindowTitle(JNIEnv* env, jclass , jint windowNumber, jlong title)
+{
+    int rv = imaqSetWindowTitle((int)windowNumber, (const char*)title);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetWindowZoomToFit(int windowNumber, int zoomToFit)
+ * JN: void imaqSetWindowZoomToFit(int windowNumber, int zoomToFit)
+ * C: int imaqSetWindowZoomToFit(int windowNumber, int zoomToFit)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetWindowZoomToFit(JNIEnv* env, jclass , jint windowNumber, jint zoomToFit)
+{
+    int rv = imaqSetWindowZoomToFit((int)windowNumber, (int)zoomToFit);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqShowScrollbars(int windowNumber, int visible)
+ * JN: void imaqShowScrollbars(int windowNumber, int visible)
+ * C: int imaqShowScrollbars(int windowNumber, int visible)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqShowScrollbars(JNIEnv* env, jclass , jint windowNumber, jint visible)
+{
+    int rv = imaqShowScrollbars((int)windowNumber, (int)visible);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqZoomWindow2(int windowNumber, float xZoom, float yZoom, Point center)
+ * JN: void imaqZoomWindow2(int windowNumber, float xZoom, float yZoom, long center)
+ * C: int imaqZoomWindow2(int windowNumber, float xZoom, float yZoom, Point center)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqZoomWindow2(JNIEnv* env, jclass , jint windowNumber, jfloat xZoom, jfloat yZoom, jlong center)
+{
+    int rv = imaqZoomWindow2((int)windowNumber, (float)xZoom, (float)yZoom, *((Point*)center));
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Utilities functions
+ */
+
+/* J: int imaqMulticoreOptions(MulticoreOperation operation)
+ * JN: int imaqMulticoreOptions(int operation, long customNumCores)
+ * C: int imaqMulticoreOptions(MulticoreOperation operation, unsigned int* customNumCores)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqMulticoreOptions(JNIEnv* env, jclass , jint operation, jlong customNumCores)
+{
+    int rv = imaqMulticoreOptions((MulticoreOperation)operation, (unsigned int*)customNumCores);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/*
+ * Tool Window functions
+ */
+
+/* J: void imaqCloseToolWindow()
+ * JN: void imaqCloseToolWindow()
+ * C: int imaqCloseToolWindow( void)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCloseToolWindow(JNIEnv* env, jclass )
+{
+    int rv = imaqCloseToolWindow();
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: Tool imaqGetCurrentTool()
+ * JN: int imaqGetCurrentTool(long currentTool)
+ * C: int imaqGetCurrentTool(Tool* currentTool)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqGetCurrentTool(JNIEnv* env, jclass , jlong currentTool)
+{
+    int rv = imaqGetCurrentTool((Tool*)currentTool);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: void imaqGetLastEvent()
+ * JN: void imaqGetLastEvent(long type, long windowNumber, long tool, long rect)
+ * C: int imaqGetLastEvent(WindowEventType* type, int* windowNumber, Tool* tool, Rect* rect)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetLastEvent(JNIEnv* env, jclass , jlong type, jlong windowNumber, jlong tool, jlong rect)
+{
+    int rv = imaqGetLastEvent((WindowEventType*)type, (int*)windowNumber, (Tool*)tool, (Rect*)rect);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: Point imaqGetToolWindowPos()
+ * JN: long imaqGetToolWindowPos(long position)
+ * C: int imaqGetToolWindowPos(Point* position)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetToolWindowPos(JNIEnv* env, jclass , jlong position)
+{
+    int rv = imaqGetToolWindowPos((Point*)position);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: int imaqIsToolWindowVisible()
+ * JN: int imaqIsToolWindowVisible(long visible)
+ * C: int imaqIsToolWindowVisible(int* visible)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqIsToolWindowVisible(JNIEnv* env, jclass , jlong visible)
+{
+    int rv = imaqIsToolWindowVisible((int*)visible);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: void imaqMoveToolWindow(Point position)
+ * JN: void imaqMoveToolWindow(long position)
+ * C: int imaqMoveToolWindow(Point position)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMoveToolWindow(JNIEnv* env, jclass , jlong position)
+{
+    int rv = imaqMoveToolWindow(*((Point*)position));
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetCurrentTool(Tool currentTool)
+ * JN: void imaqSetCurrentTool(int currentTool)
+ * C: int imaqSetCurrentTool(Tool currentTool)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetCurrentTool(JNIEnv* env, jclass , jint currentTool)
+{
+    int rv = imaqSetCurrentTool((Tool)currentTool);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetToolColor(RGBValue color)
+ * JN: void imaqSetToolColor(long color)
+ * C: int imaqSetToolColor(const RGBValue* color)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetToolColor(JNIEnv* env, jclass , jlong color)
+{
+    int rv = imaqSetToolColor((const RGBValue*)color);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetupToolWindow(int showCoordinates, int maxIconsPerLine, ToolWindowOptions options)
+ * JN: void imaqSetupToolWindow(int showCoordinates, int maxIconsPerLine, long options)
+ * C: int imaqSetupToolWindow(int showCoordinates, int maxIconsPerLine, const ToolWindowOptions* options)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetupToolWindow(JNIEnv* env, jclass , jint showCoordinates, jint maxIconsPerLine, jlong options)
+{
+    int rv = imaqSetupToolWindow((int)showCoordinates, (int)maxIconsPerLine, (const ToolWindowOptions*)options);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqShowToolWindow(int visible)
+ * JN: void imaqShowToolWindow(int visible)
+ * C: int imaqShowToolWindow(int visible)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqShowToolWindow(JNIEnv* env, jclass , jint visible)
+{
+    int rv = imaqShowToolWindow((int)visible);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Meter functions
+ */
+
+/* J: MeterArc imaqGetMeterArc(int lightNeedle, MeterArcMode mode, ROI roi, PointFloat base, PointFloat start, PointFloat end)
+ * JN: long imaqGetMeterArc(int lightNeedle, int mode, long roi, long base, long start, long end)
+ * C: MeterArc* imaqGetMeterArc(int lightNeedle, MeterArcMode mode, const ROI* roi, PointFloat base, PointFloat start, PointFloat end)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetMeterArc(JNIEnv* env, jclass , jint lightNeedle, jint mode, jlong roi, jlong base, jlong start, jlong end)
+{
+    MeterArc* rv = imaqGetMeterArc((int)lightNeedle, (MeterArcMode)mode, (const ROI*)roi, *((PointFloat*)base), *((PointFloat*)start), *((PointFloat*)end));
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqReadMeter(Image image, MeterArc arcInfo)
+ * JN: void imaqReadMeter(long image, long arcInfo, long percentage, long endOfNeedle)
+ * C: int imaqReadMeter(const Image* image, const MeterArc* arcInfo, double* percentage, PointFloat* endOfNeedle)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqReadMeter(JNIEnv* env, jclass , jlong image, jlong arcInfo, jlong percentage, jlong endOfNeedle)
+{
+    int rv = imaqReadMeter((const Image*)image, (const MeterArc*)arcInfo, (double*)percentage, (PointFloat*)endOfNeedle);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Calibration functions
+ */
+
+/* J: void imaqCopyCalibrationInfo2(Image dest, Image source, Point offset)
+ * JN: void imaqCopyCalibrationInfo2(long dest, long source, long offset)
+ * C: int imaqCopyCalibrationInfo2(Image* dest, Image* source, Point offset)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCopyCalibrationInfo2(JNIEnv* env, jclass , jlong dest, jlong source, jlong offset)
+{
+    int rv = imaqCopyCalibrationInfo2((Image*)dest, (Image*)source, *((Point*)offset));
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: CalibrationInfo imaqGetCalibrationInfo2(Image image)
+ * JN: long imaqGetCalibrationInfo2(long image)
+ * C: CalibrationInfo* imaqGetCalibrationInfo2(const Image* image)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetCalibrationInfo2(JNIEnv* env, jclass , jlong image)
+{
+    CalibrationInfo* rv = imaqGetCalibrationInfo2((const Image*)image);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: CalibrationInfo imaqGetCalibrationInfo3(Image image, int isGetErrorMap)
+ * JN: long imaqGetCalibrationInfo3(long image, int isGetErrorMap)
+ * C: CalibrationInfo* imaqGetCalibrationInfo3(Image* image, unsigned int isGetErrorMap)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetCalibrationInfo3(JNIEnv* env, jclass , jlong image, jint isGetErrorMap)
+{
+    CalibrationInfo* rv = imaqGetCalibrationInfo3((Image*)image, (unsigned int)isGetErrorMap);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: float imaqLearnCalibrationGrid(Image image, ROI roi, LearnCalibrationOptions options, GridDescriptor grid, CoordinateSystem system, RangeFloat range)
+ * JN: float imaqLearnCalibrationGrid(long image, long roi, long options, long grid, long system, long range, long quality)
+ * C: int imaqLearnCalibrationGrid(Image* image, const ROI* roi, const LearnCalibrationOptions* options, const GridDescriptor* grid, const CoordinateSystem* system, const RangeFloat* range, float* quality)
+ */
+
+JNIEXPORT jfloat JNICALL Java_com_ni_vision_NIVision__1imaqLearnCalibrationGrid(JNIEnv* env, jclass , jlong image, jlong roi, jlong options, jlong grid, jlong system, jlong range, jlong quality)
+{
+    int rv = imaqLearnCalibrationGrid((Image*)image, (const ROI*)roi, (const LearnCalibrationOptions*)options, (const GridDescriptor*)grid, (const CoordinateSystem*)system, (const RangeFloat*)range, (float*)quality);
+    if (rv == 0) throwJavaException(env);
+    return (jfloat)rv;
+}
+
+/* J: float imaqLearnCalibrationPoints(Image image, CalibrationPoints points, ROI roi, LearnCalibrationOptions options, GridDescriptor grid, CoordinateSystem system)
+ * JN: float imaqLearnCalibrationPoints(long image, long points, long roi, long options, long grid, long system, long quality)
+ * C: int imaqLearnCalibrationPoints(Image* image, const CalibrationPoints* points, const ROI* roi, const LearnCalibrationOptions* options, const GridDescriptor* grid, const CoordinateSystem* system, float* quality)
+ */
+
+JNIEXPORT jfloat JNICALL Java_com_ni_vision_NIVision__1imaqLearnCalibrationPoints(JNIEnv* env, jclass , jlong image, jlong points, jlong roi, jlong options, jlong grid, jlong system, jlong quality)
+{
+    int rv = imaqLearnCalibrationPoints((Image*)image, (const CalibrationPoints*)points, (const ROI*)roi, (const LearnCalibrationOptions*)options, (const GridDescriptor*)grid, (const CoordinateSystem*)system, (float*)quality);
+    if (rv == 0) throwJavaException(env);
+    return (jfloat)rv;
+}
+
+/* J: void imaqSetCoordinateSystem(Image image, CoordinateSystem system)
+ * JN: void imaqSetCoordinateSystem(long image, long system)
+ * C: int imaqSetCoordinateSystem(Image* image, const CoordinateSystem* system)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetCoordinateSystem(JNIEnv* env, jclass , jlong image, jlong system)
+{
+    int rv = imaqSetCoordinateSystem((Image*)image, (const CoordinateSystem*)system);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetSimpleCalibration(Image image, ScalingMethod method, int learnTable, GridDescriptor grid, CoordinateSystem system)
+ * JN: void imaqSetSimpleCalibration(long image, int method, int learnTable, long grid, long system)
+ * C: int imaqSetSimpleCalibration(Image* image, ScalingMethod method, int learnTable, const GridDescriptor* grid, const CoordinateSystem* system)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetSimpleCalibration(JNIEnv* env, jclass , jlong image, jint method, jint learnTable, jlong grid, jlong system)
+{
+    int rv = imaqSetSimpleCalibration((Image*)image, (ScalingMethod)method, (int)learnTable, (const GridDescriptor*)grid, (const CoordinateSystem*)system);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: TransformReport imaqTransformPixelToRealWorld(Image image, PointFloat[] pixelCoordinates)
+ * JN: long imaqTransformPixelToRealWorld(long image, long pixelCoordinates, int numCoordinates)
+ * C: TransformReport* imaqTransformPixelToRealWorld(const Image* image, const PointFloat* pixelCoordinates, int numCoordinates)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqTransformPixelToRealWorld(JNIEnv* env, jclass , jlong image, jlong pixelCoordinates, jint numCoordinates)
+{
+    TransformReport* rv = imaqTransformPixelToRealWorld((const Image*)image, (const PointFloat*)pixelCoordinates, (int)numCoordinates);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: TransformReport imaqTransformRealWorldToPixel(Image image, PointFloat[] realWorldCoordinates)
+ * JN: long imaqTransformRealWorldToPixel(long image, long realWorldCoordinates, int numCoordinates)
+ * C: TransformReport* imaqTransformRealWorldToPixel(const Image* image, const PointFloat* realWorldCoordinates, int numCoordinates)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqTransformRealWorldToPixel(JNIEnv* env, jclass , jlong image, jlong realWorldCoordinates, jint numCoordinates)
+{
+    TransformReport* rv = imaqTransformRealWorldToPixel((const Image*)image, (const PointFloat*)realWorldCoordinates, (int)numCoordinates);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqSetSimpleCalibration2(Image image, GridDescriptor gridDescriptor)
+ * JN: void imaqSetSimpleCalibration2(long image, long gridDescriptor)
+ * C: int imaqSetSimpleCalibration2(Image* image, const GridDescriptor* gridDescriptor)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetSimpleCalibration2(JNIEnv* env, jclass , jlong image, jlong gridDescriptor)
+{
+    int rv = imaqSetSimpleCalibration2((Image*)image, (const GridDescriptor*)gridDescriptor);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: CoordinateSystem imaqCalibrationSetAxisInfo(Image image)
+ * JN: long imaqCalibrationSetAxisInfo(long image, long axisInfo)
+ * C: int imaqCalibrationSetAxisInfo(Image* image, CoordinateSystem* axisInfo)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCalibrationSetAxisInfo(JNIEnv* env, jclass , jlong image, jlong axisInfo)
+{
+    int rv = imaqCalibrationSetAxisInfo((Image*)image, (CoordinateSystem*)axisInfo);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqCalibrationGetThumbnailImage(Image templateImage, Image image, CalibrationThumbnailType type, int index)
+ * JN: void imaqCalibrationGetThumbnailImage(long templateImage, long image, int type, int index)
+ * C: int imaqCalibrationGetThumbnailImage(Image* templateImage, Image* image, CalibrationThumbnailType type, unsigned int index)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCalibrationGetThumbnailImage(JNIEnv* env, jclass , jlong templateImage, jlong image, jint type, jint index)
+{
+    int rv = imaqCalibrationGetThumbnailImage((Image*)templateImage, (Image*)image, (CalibrationThumbnailType)type, (unsigned int)index);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: GetCalibrationInfoReport imaqCalibrationGetCalibrationInfo(Image image, int isGetErrorMap)
+ * JN: long imaqCalibrationGetCalibrationInfo(long image, int isGetErrorMap)
+ * C: GetCalibrationInfoReport* imaqCalibrationGetCalibrationInfo(Image* image, unsigned int isGetErrorMap)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCalibrationGetCalibrationInfo(JNIEnv* env, jclass , jlong image, jint isGetErrorMap)
+{
+    GetCalibrationInfoReport* rv = imaqCalibrationGetCalibrationInfo((Image*)image, (unsigned int)isGetErrorMap);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: GetCameraParametersReport imaqCalibrationGetCameraParameters(Image templateImage)
+ * JN: long imaqCalibrationGetCameraParameters(long templateImage)
+ * C: GetCameraParametersReport* imaqCalibrationGetCameraParameters(Image* templateImage)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCalibrationGetCameraParameters(JNIEnv* env, jclass , jlong templateImage)
+{
+    GetCameraParametersReport* rv = imaqCalibrationGetCameraParameters((Image*)templateImage);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqCalibrationCompactInformation(Image image)
+ * JN: void imaqCalibrationCompactInformation(long image)
+ * C: int imaqCalibrationCompactInformation(Image* image)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCalibrationCompactInformation(JNIEnv* env, jclass , jlong image)
+{
+    int rv = imaqCalibrationCompactInformation((Image*)image);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Pixel Manipulation functions
+ */
+
+/* J: void imaqExtractColorPlanes(Image image, ColorMode mode, Image plane1, Image plane2, Image plane3)
+ * JN: void imaqExtractColorPlanes(long image, int mode, long plane1, long plane2, long plane3)
+ * C: int imaqExtractColorPlanes(const Image* image, ColorMode mode, Image* plane1, Image* plane2, Image* plane3)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqExtractColorPlanes(JNIEnv* env, jclass , jlong image, jint mode, jlong plane1, jlong plane2, jlong plane3)
+{
+    int rv = imaqExtractColorPlanes((const Image*)image, (ColorMode)mode, (Image*)plane1, (Image*)plane2, (Image*)plane3);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqExtractComplexPlane(Image dest, Image source, ComplexPlane plane)
+ * JN: void imaqExtractComplexPlane(long dest, long source, int plane)
+ * C: int imaqExtractComplexPlane(Image* dest, const Image* source, ComplexPlane plane)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqExtractComplexPlane(JNIEnv* env, jclass , jlong dest, jlong source, jint plane)
+{
+    int rv = imaqExtractComplexPlane((Image*)dest, (const Image*)source, (ComplexPlane)plane);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqReplaceColorPlanes(Image dest, Image source, ColorMode mode, Image plane1, Image plane2, Image plane3)
+ * JN: void imaqReplaceColorPlanes(long dest, long source, int mode, long plane1, long plane2, long plane3)
+ * C: int imaqReplaceColorPlanes(Image* dest, const Image* source, ColorMode mode, const Image* plane1, const Image* plane2, const Image* plane3)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqReplaceColorPlanes(JNIEnv* env, jclass , jlong dest, jlong source, jint mode, jlong plane1, jlong plane2, jlong plane3)
+{
+    int rv = imaqReplaceColorPlanes((Image*)dest, (const Image*)source, (ColorMode)mode, (const Image*)plane1, (const Image*)plane2, (const Image*)plane3);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqReplaceComplexPlane(Image dest, Image source, Image newValues, ComplexPlane plane)
+ * JN: void imaqReplaceComplexPlane(long dest, long source, long newValues, int plane)
+ * C: int imaqReplaceComplexPlane(Image* dest, const Image* source, const Image* newValues, ComplexPlane plane)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqReplaceComplexPlane(JNIEnv* env, jclass , jlong dest, jlong source, jlong newValues, jint plane)
+{
+    int rv = imaqReplaceComplexPlane((Image*)dest, (const Image*)source, (const Image*)newValues, (ComplexPlane)plane);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Color Matching functions
+ */
+
+/* J: ColorInformation imaqLearnColor(Image image, ROI roi, ColorSensitivity sensitivity, int saturation)
+ * JN: long imaqLearnColor(long image, long roi, int sensitivity, int saturation)
+ * C: ColorInformation* imaqLearnColor(const Image* image, const ROI* roi, ColorSensitivity sensitivity, int saturation)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqLearnColor(JNIEnv* env, jclass , jlong image, jlong roi, jint sensitivity, jint saturation)
+{
+    ColorInformation* rv = imaqLearnColor((const Image*)image, (const ROI*)roi, (ColorSensitivity)sensitivity, (int)saturation);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/*
+ * Frequency Domain Analysis functions
+ */
+
+/* J: void imaqAttenuate(Image dest, Image source, AttenuateMode highlow)
+ * JN: void imaqAttenuate(long dest, long source, int highlow)
+ * C: int imaqAttenuate(Image* dest, const Image* source, AttenuateMode highlow)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqAttenuate(JNIEnv* env, jclass , jlong dest, jlong source, jint highlow)
+{
+    int rv = imaqAttenuate((Image*)dest, (const Image*)source, (AttenuateMode)highlow);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqConjugate(Image dest, Image source)
+ * JN: void imaqConjugate(long dest, long source)
+ * C: int imaqConjugate(Image* dest, const Image* source)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqConjugate(JNIEnv* env, jclass , jlong dest, jlong source)
+{
+    int rv = imaqConjugate((Image*)dest, (const Image*)source);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqFFT(Image dest, Image source)
+ * JN: void imaqFFT(long dest, long source)
+ * C: int imaqFFT(Image* dest, const Image* source)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqFFT(JNIEnv* env, jclass , jlong dest, jlong source)
+{
+    int rv = imaqFFT((Image*)dest, (const Image*)source);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqFlipFrequencies(Image dest, Image source)
+ * JN: void imaqFlipFrequencies(long dest, long source)
+ * C: int imaqFlipFrequencies(Image* dest, const Image* source)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqFlipFrequencies(JNIEnv* env, jclass , jlong dest, jlong source)
+{
+    int rv = imaqFlipFrequencies((Image*)dest, (const Image*)source);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqInverseFFT(Image dest, Image source)
+ * JN: void imaqInverseFFT(long dest, long source)
+ * C: int imaqInverseFFT(Image* dest, const Image* source)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqInverseFFT(JNIEnv* env, jclass , jlong dest, jlong source)
+{
+    int rv = imaqInverseFFT((Image*)dest, (const Image*)source);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqTruncate(Image dest, Image source, TruncateMode highlow, float ratioToKeep)
+ * JN: void imaqTruncate(long dest, long source, int highlow, float ratioToKeep)
+ * C: int imaqTruncate(Image* dest, const Image* source, TruncateMode highlow, float ratioToKeep)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqTruncate(JNIEnv* env, jclass , jlong dest, jlong source, jint highlow, jfloat ratioToKeep)
+{
+    int rv = imaqTruncate((Image*)dest, (const Image*)source, (TruncateMode)highlow, (float)ratioToKeep);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Barcode I/O functions
+ */
+
+/* J: AIMGradeReport imaqGradeDataMatrixBarcodeAIM(Image image)
+ * JN: long imaqGradeDataMatrixBarcodeAIM(long image, long report)
+ * C: int imaqGradeDataMatrixBarcodeAIM(const Image* image, AIMGradeReport* report)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGradeDataMatrixBarcodeAIM(JNIEnv* env, jclass , jlong image, jlong report)
+{
+    int rv = imaqGradeDataMatrixBarcodeAIM((const Image*)image, (AIMGradeReport*)report);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: BarcodeInfo imaqReadBarcode(Image image, BarcodeType type, ROI roi, int validate)
+ * JN: long imaqReadBarcode(long image, int type, long roi, int validate)
+ * C: BarcodeInfo* imaqReadBarcode(const Image* image, BarcodeType type, const ROI* roi, int validate)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadBarcode(JNIEnv* env, jclass , jlong image, jint type, jlong roi, jint validate)
+{
+    BarcodeInfo* rv = imaqReadBarcode((const Image*)image, (BarcodeType)type, (const ROI*)roi, (int)validate);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: DataMatrixReport imaqReadDataMatrixBarcode2(Image image, ROI roi, DataMatrixGradingMode prepareForGrading, DataMatrixDescriptionOptions descriptionOptions, DataMatrixSizeOptions sizeOptions, DataMatrixSearchOptions searchOptions)
+ * JN: long imaqReadDataMatrixBarcode2(long image, long roi, int prepareForGrading, long descriptionOptions, long sizeOptions, long searchOptions)
+ * C: DataMatrixReport* imaqReadDataMatrixBarcode2(Image* image, const ROI* roi, DataMatrixGradingMode prepareForGrading, const DataMatrixDescriptionOptions* descriptionOptions, const DataMatrixSizeOptions* sizeOptions, const DataMatrixSearchOptions* searchOptions)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadDataMatrixBarcode2(JNIEnv* env, jclass , jlong image, jlong roi, jint prepareForGrading, jlong descriptionOptions, jlong sizeOptions, jlong searchOptions)
+{
+    DataMatrixReport* rv = imaqReadDataMatrixBarcode2((Image*)image, (const ROI*)roi, (DataMatrixGradingMode)prepareForGrading, (const DataMatrixDescriptionOptions*)descriptionOptions, (const DataMatrixSizeOptions*)sizeOptions, (const DataMatrixSearchOptions*)searchOptions);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ReadPDF417BarcodeResult imaqReadPDF417Barcode(Image image, ROI roi, Barcode2DSearchMode searchMode)
+ * JN: long imaqReadPDF417Barcode(long image, long roi, int searchMode, long numBarcodes)
+ * C: Barcode2DInfo* imaqReadPDF417Barcode(const Image* image, const ROI* roi, Barcode2DSearchMode searchMode, unsigned int* numBarcodes)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadPDF417Barcode(JNIEnv* env, jclass , jlong image, jlong roi, jint searchMode, jlong numBarcodes)
+{
+    Barcode2DInfo* rv = imaqReadPDF417Barcode((const Image*)image, (const ROI*)roi, (Barcode2DSearchMode)searchMode, (unsigned int*)numBarcodes);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: QRCodeReport imaqReadQRCode(Image image, ROI roi, QRGradingMode reserved, QRCodeDescriptionOptions descriptionOptions, QRCodeSizeOptions sizeOptions, QRCodeSearchOptions searchOptions)
+ * JN: long imaqReadQRCode(long image, long roi, int reserved, long descriptionOptions, long sizeOptions, long searchOptions)
+ * C: QRCodeReport* imaqReadQRCode(Image* image, const ROI* roi, QRGradingMode reserved, const QRCodeDescriptionOptions* descriptionOptions, const QRCodeSizeOptions* sizeOptions, const QRCodeSearchOptions* searchOptions)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadQRCode(JNIEnv* env, jclass , jlong image, jlong roi, jint reserved, jlong descriptionOptions, jlong sizeOptions, jlong searchOptions)
+{
+    QRCodeReport* rv = imaqReadQRCode((Image*)image, (const ROI*)roi, (QRGradingMode)reserved, (const QRCodeDescriptionOptions*)descriptionOptions, (const QRCodeSizeOptions*)sizeOptions, (const QRCodeSearchOptions*)searchOptions);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/*
+ * LCD functions
+ */
+
+/* J: void imaqFindLCDSegments(ROI roi, Image image, LCDOptions options)
+ * JN: void imaqFindLCDSegments(long roi, long image, long options)
+ * C: int imaqFindLCDSegments(ROI* roi, const Image* image, const LCDOptions* options)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqFindLCDSegments(JNIEnv* env, jclass , jlong roi, jlong image, jlong options)
+{
+    int rv = imaqFindLCDSegments((ROI*)roi, (const Image*)image, (const LCDOptions*)options);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: LCDReport imaqReadLCD(Image image, ROI roi, LCDOptions options)
+ * JN: long imaqReadLCD(long image, long roi, long options)
+ * C: LCDReport* imaqReadLCD(const Image* image, const ROI* roi, const LCDOptions* options)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadLCD(JNIEnv* env, jclass , jlong image, jlong roi, jlong options)
+{
+    LCDReport* rv = imaqReadLCD((const Image*)image, (const ROI*)roi, (const LCDOptions*)options);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/*
+ * Shape Matching functions
+ */
+
+/* J: MatchShapeResult imaqMatchShape(Image dest, Image source, Image templateImage, int scaleInvariant, int connectivity8, double tolerance)
+ * JN: long imaqMatchShape(long dest, long source, long templateImage, int scaleInvariant, int connectivity8, double tolerance, long numMatches)
+ * C: ShapeReport* imaqMatchShape(Image* dest, Image* source, const Image* templateImage, int scaleInvariant, int connectivity8, double tolerance, int* numMatches)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchShape(JNIEnv* env, jclass , jlong dest, jlong source, jlong templateImage, jint scaleInvariant, jint connectivity8, jdouble tolerance, jlong numMatches)
+{
+    ShapeReport* rv = imaqMatchShape((Image*)dest, (Image*)source, (const Image*)templateImage, (int)scaleInvariant, (int)connectivity8, (double)tolerance, (int*)numMatches);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/*
+ * Contours functions
+ */
+
+/* J: int imaqAddAnnulusContour(ROI roi, Annulus annulus)
+ * JN: int imaqAddAnnulusContour(long roi, long annulus)
+ * C: ContourID imaqAddAnnulusContour(ROI* roi, Annulus annulus)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddAnnulusContour(JNIEnv* env, jclass , jlong roi, jlong annulus)
+{
+    ContourID rv = imaqAddAnnulusContour((ROI*)roi, *((Annulus*)annulus));
+    
+    return (jint)rv;
+}
+
+/* J: int imaqAddClosedContour(ROI roi, Point[] points)
+ * JN: int imaqAddClosedContour(long roi, long points, int numPoints)
+ * C: ContourID imaqAddClosedContour(ROI* roi, const Point* points, int numPoints)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddClosedContour(JNIEnv* env, jclass , jlong roi, jlong points, jint numPoints)
+{
+    ContourID rv = imaqAddClosedContour((ROI*)roi, (const Point*)points, (int)numPoints);
+    
+    return (jint)rv;
+}
+
+/* J: int imaqAddLineContour(ROI roi, Point start, Point end)
+ * JN: int imaqAddLineContour(long roi, long start, long end)
+ * C: ContourID imaqAddLineContour(ROI* roi, Point start, Point end)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddLineContour(JNIEnv* env, jclass , jlong roi, jlong start, jlong end)
+{
+    ContourID rv = imaqAddLineContour((ROI*)roi, *((Point*)start), *((Point*)end));
+    
+    return (jint)rv;
+}
+
+/* J: int imaqAddOpenContour(ROI roi, Point[] points)
+ * JN: int imaqAddOpenContour(long roi, long points, int numPoints)
+ * C: ContourID imaqAddOpenContour(ROI* roi, const Point* points, int numPoints)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddOpenContour(JNIEnv* env, jclass , jlong roi, jlong points, jint numPoints)
+{
+    ContourID rv = imaqAddOpenContour((ROI*)roi, (const Point*)points, (int)numPoints);
+    
+    return (jint)rv;
+}
+
+/* J: int imaqAddOvalContour(ROI roi, Rect boundingBox)
+ * JN: int imaqAddOvalContour(long roi, long boundingBox)
+ * C: ContourID imaqAddOvalContour(ROI* roi, Rect boundingBox)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddOvalContour(JNIEnv* env, jclass , jlong roi, jlong boundingBox)
+{
+    ContourID rv = imaqAddOvalContour((ROI*)roi, *((Rect*)boundingBox));
+    
+    return (jint)rv;
+}
+
+/* J: int imaqAddPointContour(ROI roi, Point point)
+ * JN: int imaqAddPointContour(long roi, long point)
+ * C: ContourID imaqAddPointContour(ROI* roi, Point point)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddPointContour(JNIEnv* env, jclass , jlong roi, jlong point)
+{
+    ContourID rv = imaqAddPointContour((ROI*)roi, *((Point*)point));
+    
+    return (jint)rv;
+}
+
+/* J: int imaqAddRectContour(ROI roi, Rect rect)
+ * JN: int imaqAddRectContour(long roi, long rect)
+ * C: ContourID imaqAddRectContour(ROI* roi, Rect rect)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddRectContour(JNIEnv* env, jclass , jlong roi, jlong rect)
+{
+    ContourID rv = imaqAddRectContour((ROI*)roi, *((Rect*)rect));
+    
+    return (jint)rv;
+}
+
+/* J: int imaqAddRotatedRectContour2(ROI roi, RotatedRect rect)
+ * JN: int imaqAddRotatedRectContour2(long roi, long rect)
+ * C: ContourID imaqAddRotatedRectContour2(ROI* roi, RotatedRect rect)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddRotatedRectContour2(JNIEnv* env, jclass , jlong roi, jlong rect)
+{
+    ContourID rv = imaqAddRotatedRectContour2((ROI*)roi, *((RotatedRect*)rect));
+    
+    return (jint)rv;
+}
+
+/* J: int imaqCopyContour(ROI destRoi, ROI sourceRoi, int id)
+ * JN: int imaqCopyContour(long destRoi, long sourceRoi, int id)
+ * C: ContourID imaqCopyContour(ROI* destRoi, const ROI* sourceRoi, ContourID id)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqCopyContour(JNIEnv* env, jclass , jlong destRoi, jlong sourceRoi, jint id)
+{
+    ContourID rv = imaqCopyContour((ROI*)destRoi, (const ROI*)sourceRoi, (ContourID)id);
+    
+    return (jint)rv;
+}
+
+/* J: int imaqGetContour(ROI roi, int index)
+ * JN: int imaqGetContour(long roi, int index)
+ * C: ContourID imaqGetContour(const ROI* roi, unsigned int index)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqGetContour(JNIEnv* env, jclass , jlong roi, jint index)
+{
+    ContourID rv = imaqGetContour((const ROI*)roi, (unsigned int)index);
+    
+    return (jint)rv;
+}
+
+/* J: RGBValue imaqGetContourColor(ROI roi, int id)
+ * JN: long imaqGetContourColor(long roi, int id, long contourColor)
+ * C: int imaqGetContourColor(const ROI* roi, ContourID id, RGBValue* contourColor)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetContourColor(JNIEnv* env, jclass , jlong roi, jint id, jlong contourColor)
+{
+    int rv = imaqGetContourColor((const ROI*)roi, (ContourID)id, (RGBValue*)contourColor);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqGetContourCount(ROI roi)
+ * JN: void imaqGetContourCount(long roi)
+ * C: int imaqGetContourCount(const ROI* roi)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetContourCount(JNIEnv* env, jclass , jlong roi)
+{
+    int rv = imaqGetContourCount((const ROI*)roi);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: ContourInfo2 imaqGetContourInfo2(ROI roi, int id)
+ * JN: long imaqGetContourInfo2(long roi, int id)
+ * C: ContourInfo2* imaqGetContourInfo2(const ROI* roi, ContourID id)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetContourInfo2(JNIEnv* env, jclass , jlong roi, jint id)
+{
+    ContourInfo2* rv = imaqGetContourInfo2((const ROI*)roi, (ContourID)id);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqMoveContour(ROI roi, int id, int deltaX, int deltaY)
+ * JN: void imaqMoveContour(long roi, int id, int deltaX, int deltaY)
+ * C: int imaqMoveContour(ROI* roi, ContourID id, int deltaX, int deltaY)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMoveContour(JNIEnv* env, jclass , jlong roi, jint id, jint deltaX, jint deltaY)
+{
+    int rv = imaqMoveContour((ROI*)roi, (ContourID)id, (int)deltaX, (int)deltaY);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqRemoveContour(ROI roi, int id)
+ * JN: void imaqRemoveContour(long roi, int id)
+ * C: int imaqRemoveContour(ROI* roi, ContourID id)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqRemoveContour(JNIEnv* env, jclass , jlong roi, jint id)
+{
+    int rv = imaqRemoveContour((ROI*)roi, (ContourID)id);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetContourColor(ROI roi, int id, RGBValue color)
+ * JN: void imaqSetContourColor(long roi, int id, long color)
+ * C: int imaqSetContourColor(ROI* roi, ContourID id, const RGBValue* color)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetContourColor(JNIEnv* env, jclass , jlong roi, jint id, jlong color)
+{
+    int rv = imaqSetContourColor((ROI*)roi, (ContourID)id, (const RGBValue*)color);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Regions of Interest functions
+ */
+
+/* J: int imaqConstructROI2(Image image, ROI roi, Tool initialTool, ToolWindowOptions tools, ConstructROIOptions2 options)
+ * JN: int imaqConstructROI2(long image, long roi, int initialTool, long tools, long options, long okay)
+ * C: int imaqConstructROI2(const Image* image, ROI* roi, Tool initialTool, const ToolWindowOptions* tools, const ConstructROIOptions2* options, int* okay)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqConstructROI2(JNIEnv* env, jclass , jlong image, jlong roi, jint initialTool, jlong tools, jlong options, jlong okay)
+{
+    int rv = imaqConstructROI2((const Image*)image, (ROI*)roi, (Tool)initialTool, (const ToolWindowOptions*)tools, (const ConstructROIOptions2*)options, (int*)okay);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: ROI imaqCreateROI()
+ * JN: long imaqCreateROI()
+ * C: ROI* imaqCreateROI( void)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCreateROI(JNIEnv* env, jclass )
+{
+    ROI* rv = imaqCreateROI();
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: Rect imaqGetROIBoundingBox(ROI roi)
+ * JN: long imaqGetROIBoundingBox(long roi, long boundingBox)
+ * C: int imaqGetROIBoundingBox(const ROI* roi, Rect* boundingBox)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetROIBoundingBox(JNIEnv* env, jclass , jlong roi, jlong boundingBox)
+{
+    int rv = imaqGetROIBoundingBox((const ROI*)roi, (Rect*)boundingBox);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: RGBValue imaqGetROIColor(ROI roi)
+ * JN: long imaqGetROIColor(long roi, long roiColor)
+ * C: int imaqGetROIColor(const ROI* roi, RGBValue* roiColor)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetROIColor(JNIEnv* env, jclass , jlong roi, jlong roiColor)
+{
+    int rv = imaqGetROIColor((const ROI*)roi, (RGBValue*)roiColor);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ROI imaqGetWindowROI(int windowNumber)
+ * JN: long imaqGetWindowROI(int windowNumber)
+ * C: ROI* imaqGetWindowROI(int windowNumber)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetWindowROI(JNIEnv* env, jclass , jint windowNumber)
+{
+    ROI* rv = imaqGetWindowROI((int)windowNumber);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqSetROIColor(ROI roi, RGBValue color)
+ * JN: void imaqSetROIColor(long roi, long color)
+ * C: int imaqSetROIColor(ROI* roi, const RGBValue* color)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetROIColor(JNIEnv* env, jclass , jlong roi, jlong color)
+{
+    int rv = imaqSetROIColor((ROI*)roi, (const RGBValue*)color);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetWindowROI(int windowNumber, ROI roi)
+ * JN: void imaqSetWindowROI(int windowNumber, long roi)
+ * C: int imaqSetWindowROI(int windowNumber, const ROI* roi)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetWindowROI(JNIEnv* env, jclass , jint windowNumber, jlong roi)
+{
+    int rv = imaqSetWindowROI((int)windowNumber, (const ROI*)roi);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Image Analysis functions
+ */
+
+/* J: PointFloat imaqCentroid(Image image, Image mask)
+ * JN: long imaqCentroid(long image, long centroid, long mask)
+ * C: int imaqCentroid(const Image* image, PointFloat* centroid, const Image* mask)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCentroid(JNIEnv* env, jclass , jlong image, jlong centroid, jlong mask)
+{
+    int rv = imaqCentroid((const Image*)image, (PointFloat*)centroid, (const Image*)mask);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ExtractCurvesResult imaqExtractCurves(Image image, ROI roi, CurveOptions curveOptions)
+ * JN: long imaqExtractCurves(long image, long roi, long curveOptions, long numCurves)
+ * C: Curve* imaqExtractCurves(const Image* image, const ROI* roi, const CurveOptions* curveOptions, unsigned int* numCurves)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqExtractCurves(JNIEnv* env, jclass , jlong image, jlong roi, jlong curveOptions, jlong numCurves)
+{
+    Curve* rv = imaqExtractCurves((const Image*)image, (const ROI*)roi, (const CurveOptions*)curveOptions, (unsigned int*)numCurves);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: HistogramReport imaqHistogram(Image image, int numClasses, float min, float max, Image mask)
+ * JN: long imaqHistogram(long image, int numClasses, float min, float max, long mask)
+ * C: HistogramReport* imaqHistogram(const Image* image, int numClasses, float min, float max, const Image* mask)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqHistogram(JNIEnv* env, jclass , jlong image, jint numClasses, jfloat min, jfloat max, jlong mask)
+{
+    HistogramReport* rv = imaqHistogram((const Image*)image, (int)numClasses, (float)min, (float)max, (const Image*)mask);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: LinearAverages imaqLinearAverages2(Image image, LinearAveragesMode mode, Rect rect)
+ * JN: long imaqLinearAverages2(long image, int mode, long rect)
+ * C: LinearAverages* imaqLinearAverages2(Image* image, LinearAveragesMode mode, Rect rect)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqLinearAverages2(JNIEnv* env, jclass , jlong image, jint mode, jlong rect)
+{
+    LinearAverages* rv = imaqLinearAverages2((Image*)image, (LinearAveragesMode)mode, *((Rect*)rect));
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: LineProfile imaqLineProfile(Image image, Point start, Point end)
+ * JN: long imaqLineProfile(long image, long start, long end)
+ * C: LineProfile* imaqLineProfile(const Image* image, Point start, Point end)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqLineProfile(JNIEnv* env, jclass , jlong image, jlong start, jlong end)
+{
+    LineProfile* rv = imaqLineProfile((const Image*)image, *((Point*)start), *((Point*)end));
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: QuantifyReport imaqQuantify(Image image, Image mask)
+ * JN: long imaqQuantify(long image, long mask)
+ * C: QuantifyReport* imaqQuantify(const Image* image, const Image* mask)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqQuantify(JNIEnv* env, jclass , jlong image, jlong mask)
+{
+    QuantifyReport* rv = imaqQuantify((const Image*)image, (const Image*)mask);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/*
+ * Threshold functions
+ */
+
+/* J: ThresholdData imaqAutoThreshold2(Image dest, Image source, int numClasses, ThresholdMethod method, Image mask)
+ * JN: long imaqAutoThreshold2(long dest, long source, int numClasses, int method, long mask)
+ * C: ThresholdData* imaqAutoThreshold2(Image* dest, const Image* source, int numClasses, ThresholdMethod method, const Image* mask)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqAutoThreshold2(JNIEnv* env, jclass , jlong dest, jlong source, jint numClasses, jint method, jlong mask)
+{
+    ThresholdData* rv = imaqAutoThreshold2((Image*)dest, (const Image*)source, (int)numClasses, (ThresholdMethod)method, (const Image*)mask);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqLocalThreshold(Image dest, Image source, int windowWidth, int windowHeight, LocalThresholdMethod method, double deviationWeight, ObjectType type, float replaceValue)
+ * JN: void imaqLocalThreshold(long dest, long source, int windowWidth, int windowHeight, int method, double deviationWeight, int type, float replaceValue)
+ * C: int imaqLocalThreshold(Image* dest, const Image* source, unsigned int windowWidth, unsigned int windowHeight, LocalThresholdMethod method, double deviationWeight, ObjectType type, float replaceValue)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLocalThreshold(JNIEnv* env, jclass , jlong dest, jlong source, jint windowWidth, jint windowHeight, jint method, jdouble deviationWeight, jint type, jfloat replaceValue)
+{
+    int rv = imaqLocalThreshold((Image*)dest, (const Image*)source, (unsigned int)windowWidth, (unsigned int)windowHeight, (LocalThresholdMethod)method, (double)deviationWeight, (ObjectType)type, (float)replaceValue);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqMagicWand(Image dest, Image source, Point coord, float tolerance, int connectivity8, float replaceValue)
+ * JN: void imaqMagicWand(long dest, long source, long coord, float tolerance, int connectivity8, float replaceValue)
+ * C: int imaqMagicWand(Image* dest, const Image* source, Point coord, float tolerance, int connectivity8, float replaceValue)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMagicWand(JNIEnv* env, jclass , jlong dest, jlong source, jlong coord, jfloat tolerance, jint connectivity8, jfloat replaceValue)
+{
+    int rv = imaqMagicWand((Image*)dest, (const Image*)source, *((Point*)coord), (float)tolerance, (int)connectivity8, (float)replaceValue);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqMultithreshold(Image dest, Image source, ThresholdData[] ranges)
+ * JN: void imaqMultithreshold(long dest, long source, long ranges, int numRanges)
+ * C: int imaqMultithreshold(Image* dest, const Image* source, const ThresholdData* ranges, int numRanges)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMultithreshold(JNIEnv* env, jclass , jlong dest, jlong source, jlong ranges, jint numRanges)
+{
+    int rv = imaqMultithreshold((Image*)dest, (const Image*)source, (const ThresholdData*)ranges, (int)numRanges);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqThreshold(Image dest, Image source, float rangeMin, float rangeMax, int useNewValue, float newValue)
+ * JN: void imaqThreshold(long dest, long source, float rangeMin, float rangeMax, int useNewValue, float newValue)
+ * C: int imaqThreshold(Image* dest, const Image* source, float rangeMin, float rangeMax, int useNewValue, float newValue)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqThreshold(JNIEnv* env, jclass , jlong dest, jlong source, jfloat rangeMin, jfloat rangeMax, jint useNewValue, jfloat newValue)
+{
+    int rv = imaqThreshold((Image*)dest, (const Image*)source, (float)rangeMin, (float)rangeMax, (int)useNewValue, (float)newValue);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Memory Management functions
+ */
+
+/*
+ * Pattern Matching functions
+ */
+
+/* J: DetectCirclesResult imaqDetectCircles(Image image, CircleDescriptor circleDescriptor, CurveOptions curveOptions, ShapeDetectionOptions shapeDetectionOptions, ROI roi)
+ * JN: long imaqDetectCircles(long image, long circleDescriptor, long curveOptions, long shapeDetectionOptions, long roi, long numMatchesReturned)
+ * C: CircleMatch* imaqDetectCircles(const Image* image, const CircleDescriptor* circleDescriptor, const CurveOptions* curveOptions, const ShapeDetectionOptions* shapeDetectionOptions, const ROI* roi, int* numMatchesReturned)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqDetectCircles(JNIEnv* env, jclass , jlong image, jlong circleDescriptor, jlong curveOptions, jlong shapeDetectionOptions, jlong roi, jlong numMatchesReturned)
+{
+    CircleMatch* rv = imaqDetectCircles((const Image*)image, (const CircleDescriptor*)circleDescriptor, (const CurveOptions*)curveOptions, (const ShapeDetectionOptions*)shapeDetectionOptions, (const ROI*)roi, (int*)numMatchesReturned);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: DetectEllipsesResult imaqDetectEllipses(Image image, EllipseDescriptor ellipseDescriptor, CurveOptions curveOptions, ShapeDetectionOptions shapeDetectionOptions, ROI roi)
+ * JN: long imaqDetectEllipses(long image, long ellipseDescriptor, long curveOptions, long shapeDetectionOptions, long roi, long numMatchesReturned)
+ * C: EllipseMatch* imaqDetectEllipses(const Image* image, const EllipseDescriptor* ellipseDescriptor, const CurveOptions* curveOptions, const ShapeDetectionOptions* shapeDetectionOptions, const ROI* roi, int* numMatchesReturned)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqDetectEllipses(JNIEnv* env, jclass , jlong image, jlong ellipseDescriptor, jlong curveOptions, jlong shapeDetectionOptions, jlong roi, jlong numMatchesReturned)
+{
+    EllipseMatch* rv = imaqDetectEllipses((const Image*)image, (const EllipseDescriptor*)ellipseDescriptor, (const CurveOptions*)curveOptions, (const ShapeDetectionOptions*)shapeDetectionOptions, (const ROI*)roi, (int*)numMatchesReturned);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: DetectLinesResult imaqDetectLines(Image image, LineDescriptor lineDescriptor, CurveOptions curveOptions, ShapeDetectionOptions shapeDetectionOptions, ROI roi)
+ * JN: long imaqDetectLines(long image, long lineDescriptor, long curveOptions, long shapeDetectionOptions, long roi, long numMatchesReturned)
+ * C: LineMatch* imaqDetectLines(const Image* image, const LineDescriptor* lineDescriptor, const CurveOptions* curveOptions, const ShapeDetectionOptions* shapeDetectionOptions, const ROI* roi, int* numMatchesReturned)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqDetectLines(JNIEnv* env, jclass , jlong image, jlong lineDescriptor, jlong curveOptions, jlong shapeDetectionOptions, jlong roi, jlong numMatchesReturned)
+{
+    LineMatch* rv = imaqDetectLines((const Image*)image, (const LineDescriptor*)lineDescriptor, (const CurveOptions*)curveOptions, (const ShapeDetectionOptions*)shapeDetectionOptions, (const ROI*)roi, (int*)numMatchesReturned);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: DetectRectanglesResult imaqDetectRectangles(Image image, RectangleDescriptor rectangleDescriptor, CurveOptions curveOptions, ShapeDetectionOptions shapeDetectionOptions, ROI roi)
+ * JN: long imaqDetectRectangles(long image, long rectangleDescriptor, long curveOptions, long shapeDetectionOptions, long roi, long numMatchesReturned)
+ * C: RectangleMatch* imaqDetectRectangles(const Image* image, const RectangleDescriptor* rectangleDescriptor, const CurveOptions* curveOptions, const ShapeDetectionOptions* shapeDetectionOptions, const ROI* roi, int* numMatchesReturned)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqDetectRectangles(JNIEnv* env, jclass , jlong image, jlong rectangleDescriptor, jlong curveOptions, jlong shapeDetectionOptions, jlong roi, jlong numMatchesReturned)
+{
+    RectangleMatch* rv = imaqDetectRectangles((const Image*)image, (const RectangleDescriptor*)rectangleDescriptor, (const CurveOptions*)curveOptions, (const ShapeDetectionOptions*)shapeDetectionOptions, (const ROI*)roi, (int*)numMatchesReturned);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: GetGeometricFeaturesFromCurvesResult imaqGetGeometricFeaturesFromCurves(Curve[] curves, FeatureType[] featureTypes)
+ * JN: long imaqGetGeometricFeaturesFromCurves(long curves, int numCurves, long featureTypes, int numFeatureTypes, long numFeatures)
+ * C: FeatureData* imaqGetGeometricFeaturesFromCurves(const Curve* curves, unsigned int numCurves, const FeatureType* featureTypes, unsigned int numFeatureTypes, unsigned int* numFeatures)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetGeometricFeaturesFromCurves(JNIEnv* env, jclass , jlong curves, jint numCurves, jlong featureTypes, jint numFeatureTypes, jlong numFeatures)
+{
+    FeatureData* rv = imaqGetGeometricFeaturesFromCurves((const Curve*)curves, (unsigned int)numCurves, (const FeatureType*)featureTypes, (unsigned int)numFeatureTypes, (unsigned int*)numFeatures);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: GetGeometricTemplateFeatureInfoResult imaqGetGeometricTemplateFeatureInfo(Image pattern)
+ * JN: long imaqGetGeometricTemplateFeatureInfo(long pattern, long numFeatures)
+ * C: FeatureData* imaqGetGeometricTemplateFeatureInfo(const Image* pattern, unsigned int* numFeatures)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetGeometricTemplateFeatureInfo(JNIEnv* env, jclass , jlong pattern, jlong numFeatures)
+{
+    FeatureData* rv = imaqGetGeometricTemplateFeatureInfo((const Image*)pattern, (unsigned int*)numFeatures);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqLearnColorPattern(Image image, LearnColorPatternOptions options)
+ * JN: void imaqLearnColorPattern(long image, long options)
+ * C: int imaqLearnColorPattern(Image* image, const LearnColorPatternOptions* options)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLearnColorPattern(JNIEnv* env, jclass , jlong image, jlong options)
+{
+    int rv = imaqLearnColorPattern((Image*)image, (const LearnColorPatternOptions*)options);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqLearnGeometricPattern(Image image, PointFloat originOffset, CurveOptions curveOptions, LearnGeometricPatternAdvancedOptions advancedLearnOptions, Image mask)
+ * JN: void imaqLearnGeometricPattern(long image, long originOffset, long curveOptions, long advancedLearnOptions, long mask)
+ * C: int imaqLearnGeometricPattern(Image* image, PointFloat originOffset, const CurveOptions* curveOptions, const LearnGeometricPatternAdvancedOptions* advancedLearnOptions, const Image* mask)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLearnGeometricPattern(JNIEnv* env, jclass , jlong image, jlong originOffset, jlong curveOptions, jlong advancedLearnOptions, jlong mask)
+{
+    int rv = imaqLearnGeometricPattern((Image*)image, *((PointFloat*)originOffset), (const CurveOptions*)curveOptions, (const LearnGeometricPatternAdvancedOptions*)advancedLearnOptions, (const Image*)mask);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: LearnPatternAdvancedOptions imaqLearnPattern3(Image image, LearningMode learningMode, Image mask)
+ * JN: long imaqLearnPattern3(long image, int learningMode, long advancedOptions, long mask)
+ * C: int imaqLearnPattern3(Image* image, LearningMode learningMode, LearnPatternAdvancedOptions* advancedOptions, const Image* mask)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqLearnPattern3(JNIEnv* env, jclass , jlong image, jint learningMode, jlong advancedOptions, jlong mask)
+{
+    int rv = imaqLearnPattern3((Image*)image, (LearningMode)learningMode, (LearnPatternAdvancedOptions*)advancedOptions, (const Image*)mask);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: MatchColorPatternResult imaqMatchColorPattern(Image image, Image pattern, MatchColorPatternOptions options, Rect searchRect)
+ * JN: long imaqMatchColorPattern(long image, long pattern, long options, long searchRect, long numMatches)
+ * C: PatternMatch* imaqMatchColorPattern(const Image* image, Image* pattern, const MatchColorPatternOptions* options, Rect searchRect, int* numMatches)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchColorPattern(JNIEnv* env, jclass , jlong image, jlong pattern, jlong options, jlong searchRect, jlong numMatches)
+{
+    PatternMatch* rv = imaqMatchColorPattern((const Image*)image, (Image*)pattern, (const MatchColorPatternOptions*)options, *((Rect*)searchRect), (int*)numMatches);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: MatchGeometricPattern2Result imaqMatchGeometricPattern2(Image image, Image pattern, CurveOptions curveOptions, MatchGeometricPatternOptions matchOptions, MatchGeometricPatternAdvancedOptions2 advancedMatchOptions, ROI roi)
+ * JN: long imaqMatchGeometricPattern2(long image, long pattern, long curveOptions, long matchOptions, long advancedMatchOptions, long roi, long numMatches)
+ * C: GeometricPatternMatch2* imaqMatchGeometricPattern2(const Image* image, const Image* pattern, const CurveOptions* curveOptions, const MatchGeometricPatternOptions* matchOptions, const MatchGeometricPatternAdvancedOptions2* advancedMatchOptions, const ROI* roi, int* numMatches)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchGeometricPattern2(JNIEnv* env, jclass , jlong image, jlong pattern, jlong curveOptions, jlong matchOptions, jlong advancedMatchOptions, jlong roi, jlong numMatches)
+{
+    GeometricPatternMatch2* rv = imaqMatchGeometricPattern2((const Image*)image, (const Image*)pattern, (const CurveOptions*)curveOptions, (const MatchGeometricPatternOptions*)matchOptions, (const MatchGeometricPatternAdvancedOptions2*)advancedMatchOptions, (const ROI*)roi, (int*)numMatches);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: MatchMultipleGeometricPatternsResult imaqMatchMultipleGeometricPatterns(Image image, MultipleGeometricPattern multiplePattern, ROI roi)
+ * JN: long imaqMatchMultipleGeometricPatterns(long image, long multiplePattern, long roi, long numMatches)
+ * C: GeometricPatternMatch2* imaqMatchMultipleGeometricPatterns(const Image* image, const MultipleGeometricPattern* multiplePattern, const ROI* roi, int* numMatches)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchMultipleGeometricPatterns(JNIEnv* env, jclass , jlong image, jlong multiplePattern, jlong roi, jlong numMatches)
+{
+    GeometricPatternMatch2* rv = imaqMatchMultipleGeometricPatterns((const Image*)image, (const MultipleGeometricPattern*)multiplePattern, (const ROI*)roi, (int*)numMatches);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: MultipleGeometricPattern imaqReadMultipleGeometricPatternFile(String fileName, String description)
+ * JN: long imaqReadMultipleGeometricPatternFile(long fileName, long description)
+ * C: MultipleGeometricPattern* imaqReadMultipleGeometricPatternFile(const char* fileName, String255 description)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadMultipleGeometricPatternFile(JNIEnv* env, jclass , jlong fileName, jlong description)
+{
+    MultipleGeometricPattern* rv = imaqReadMultipleGeometricPatternFile((const char*)fileName, (char *)description);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: RefineMatchesResult imaqRefineMatches(Image image, Image pattern, PatternMatch[] candidatesIn)
+ * JN: long imaqRefineMatches(long image, long pattern, long candidatesIn, int numCandidatesIn, long options, long advancedOptions, long numCandidatesOut)
+ * C: PatternMatch* imaqRefineMatches(const Image* image, const Image* pattern, const PatternMatch* candidatesIn, int numCandidatesIn, MatchPatternOptions* options, MatchPatternAdvancedOptions* advancedOptions, int* numCandidatesOut)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqRefineMatches(JNIEnv* env, jclass , jlong image, jlong pattern, jlong candidatesIn, jint numCandidatesIn, jlong options, jlong advancedOptions, jlong numCandidatesOut)
+{
+    PatternMatch* rv = imaqRefineMatches((const Image*)image, (const Image*)pattern, (const PatternMatch*)candidatesIn, (int)numCandidatesIn, (MatchPatternOptions*)options, (MatchPatternAdvancedOptions*)advancedOptions, (int*)numCandidatesOut);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqSetMultipleGeometricPatternsOptions(MultipleGeometricPattern multiplePattern, String label, CurveOptions curveOptions, MatchGeometricPatternOptions matchOptions, MatchGeometricPatternAdvancedOptions2 advancedMatchOptions)
+ * JN: void imaqSetMultipleGeometricPatternsOptions(long multiplePattern, long label, long curveOptions, long matchOptions, long advancedMatchOptions)
+ * C: int imaqSetMultipleGeometricPatternsOptions(MultipleGeometricPattern* multiplePattern, const char* label, const CurveOptions* curveOptions, const MatchGeometricPatternOptions* matchOptions, const MatchGeometricPatternAdvancedOptions2* advancedMatchOptions)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetMultipleGeometricPatternsOptions(JNIEnv* env, jclass , jlong multiplePattern, jlong label, jlong curveOptions, jlong matchOptions, jlong advancedMatchOptions)
+{
+    int rv = imaqSetMultipleGeometricPatternsOptions((MultipleGeometricPattern*)multiplePattern, (const char*)label, (const CurveOptions*)curveOptions, (const MatchGeometricPatternOptions*)matchOptions, (const MatchGeometricPatternAdvancedOptions2*)advancedMatchOptions);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqWriteMultipleGeometricPatternFile(MultipleGeometricPattern multiplePattern, String fileName, String description)
+ * JN: void imaqWriteMultipleGeometricPatternFile(long multiplePattern, long fileName, long description)
+ * C: int imaqWriteMultipleGeometricPatternFile(const MultipleGeometricPattern* multiplePattern, const char* fileName, const char* description)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteMultipleGeometricPatternFile(JNIEnv* env, jclass , jlong multiplePattern, jlong fileName, jlong description)
+{
+    int rv = imaqWriteMultipleGeometricPatternFile((const MultipleGeometricPattern*)multiplePattern, (const char*)fileName, (const char*)description);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: MatchGeometricPattern3Result imaqMatchGeometricPattern3(Image image, Image pattern, CurveOptions curveOptions, MatchGeometricPatternOptions matchOptions, MatchGeometricPatternAdvancedOptions3 advancedMatchOptions, ROI roi)
+ * JN: long imaqMatchGeometricPattern3(long image, long pattern, long curveOptions, long matchOptions, long advancedMatchOptions, long roi, long numMatches)
+ * C: GeometricPatternMatch3* imaqMatchGeometricPattern3(const Image* image, const Image* pattern, const CurveOptions* curveOptions, const MatchGeometricPatternOptions* matchOptions, const MatchGeometricPatternAdvancedOptions3* advancedMatchOptions, const ROI* roi, size_t* numMatches)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchGeometricPattern3(JNIEnv* env, jclass , jlong image, jlong pattern, jlong curveOptions, jlong matchOptions, jlong advancedMatchOptions, jlong roi, jlong numMatches)
+{
+    GeometricPatternMatch3* rv = imaqMatchGeometricPattern3((const Image*)image, (const Image*)pattern, (const CurveOptions*)curveOptions, (const MatchGeometricPatternOptions*)matchOptions, (const MatchGeometricPatternAdvancedOptions3*)advancedMatchOptions, (const ROI*)roi, (size_t*)numMatches);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqLearnGeometricPattern2(Image image, PointFloat originOffset, double angleOffset, CurveOptions curveOptions, LearnGeometricPatternAdvancedOptions2 advancedLearnOptions, Image mask)
+ * JN: void imaqLearnGeometricPattern2(long image, long originOffset, double angleOffset, long curveOptions, long advancedLearnOptions, long mask)
+ * C: int imaqLearnGeometricPattern2(Image* image, PointFloat originOffset, double angleOffset, const CurveOptions* curveOptions, const LearnGeometricPatternAdvancedOptions2* advancedLearnOptions, const Image* mask)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLearnGeometricPattern2(JNIEnv* env, jclass , jlong image, jlong originOffset, jdouble angleOffset, jlong curveOptions, jlong advancedLearnOptions, jlong mask)
+{
+    int rv = imaqLearnGeometricPattern2((Image*)image, *((PointFloat*)originOffset), (double)angleOffset, (const CurveOptions*)curveOptions, (const LearnGeometricPatternAdvancedOptions2*)advancedLearnOptions, (const Image*)mask);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: MatchPattern3Result imaqMatchPattern3(Image image, Image pattern, MatchPatternOptions options, MatchPatternAdvancedOptions advancedOptions, ROI roi)
+ * JN: long imaqMatchPattern3(long image, long pattern, long options, long advancedOptions, long roi, long numMatches)
+ * C: PatternMatch* imaqMatchPattern3(const Image* image, const Image* pattern, const MatchPatternOptions* options, const MatchPatternAdvancedOptions* advancedOptions, const ROI* roi, int* numMatches)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchPattern3(JNIEnv* env, jclass , jlong image, jlong pattern, jlong options, jlong advancedOptions, jlong roi, jlong numMatches)
+{
+    PatternMatch* rv = imaqMatchPattern3((const Image*)image, (const Image*)pattern, (const MatchPatternOptions*)options, (const MatchPatternAdvancedOptions*)advancedOptions, (const ROI*)roi, (int*)numMatches);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/*
+ * Overlay functions
+ */
+
+/* J: void imaqClearOverlay(Image image, String group)
+ * JN: void imaqClearOverlay(long image, long group)
+ * C: int imaqClearOverlay(Image* image, const char* group)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqClearOverlay(JNIEnv* env, jclass , jlong image, jlong group)
+{
+    int rv = imaqClearOverlay((Image*)image, (const char*)group);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqCopyOverlay(Image dest, Image source, String group)
+ * JN: void imaqCopyOverlay(long dest, long source, long group)
+ * C: int imaqCopyOverlay(Image* dest, const Image* source, const char* group)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCopyOverlay(JNIEnv* env, jclass , jlong dest, jlong source, jlong group)
+{
+    int rv = imaqCopyOverlay((Image*)dest, (const Image*)source, (const char*)group);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: TransformBehaviors imaqGetOverlayProperties(Image image, String group)
+ * JN: long imaqGetOverlayProperties(long image, long group, long transformBehaviors)
+ * C: int imaqGetOverlayProperties(const Image* image, const char* group, TransformBehaviors* transformBehaviors)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetOverlayProperties(JNIEnv* env, jclass , jlong image, jlong group, jlong transformBehaviors)
+{
+    int rv = imaqGetOverlayProperties((const Image*)image, (const char*)group, (TransformBehaviors*)transformBehaviors);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqMergeOverlay(Image dest, Image source, RGBValue[] palette, String group)
+ * JN: void imaqMergeOverlay(long dest, long source, long palette, int numColors, long group)
+ * C: int imaqMergeOverlay(Image* dest, const Image* source, const RGBValue* palette, unsigned int numColors, const char* group)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMergeOverlay(JNIEnv* env, jclass , jlong dest, jlong source, jlong palette, jint numColors, jlong group)
+{
+    int rv = imaqMergeOverlay((Image*)dest, (const Image*)source, (const RGBValue*)palette, (unsigned int)numColors, (const char*)group);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqOverlayArc(Image image, ArcInfo arc, RGBValue color, DrawMode drawMode, String group)
+ * JN: void imaqOverlayArc(long image, long arc, long color, int drawMode, long group)
+ * C: int imaqOverlayArc(Image* image, const ArcInfo* arc, const RGBValue* color, DrawMode drawMode, const char* group)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayArc(JNIEnv* env, jclass , jlong image, jlong arc, jlong color, jint drawMode, jlong group)
+{
+    int rv = imaqOverlayArc((Image*)image, (const ArcInfo*)arc, (const RGBValue*)color, (DrawMode)drawMode, (const char*)group);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqOverlayBitmap(Image image, Point destLoc, RGBValue bitmap, int numCols, int numRows, String group)
+ * JN: void imaqOverlayBitmap(long image, long destLoc, long bitmap, int numCols, int numRows, long group)
+ * C: int imaqOverlayBitmap(Image* image, Point destLoc, const RGBValue* bitmap, unsigned int numCols, unsigned int numRows, const char* group)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayBitmap(JNIEnv* env, jclass , jlong image, jlong destLoc, jlong bitmap, jint numCols, jint numRows, jlong group)
+{
+    int rv = imaqOverlayBitmap((Image*)image, *((Point*)destLoc), (const RGBValue*)bitmap, (unsigned int)numCols, (unsigned int)numRows, (const char*)group);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqOverlayClosedContour(Image image, Point[] points, RGBValue color, DrawMode drawMode, String group)
+ * JN: void imaqOverlayClosedContour(long image, long points, int numPoints, long color, int drawMode, long group)
+ * C: int imaqOverlayClosedContour(Image* image, const Point* points, int numPoints, const RGBValue* color, DrawMode drawMode, const char* group)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayClosedContour(JNIEnv* env, jclass , jlong image, jlong points, jint numPoints, jlong color, jint drawMode, jlong group)
+{
+    int rv = imaqOverlayClosedContour((Image*)image, (const Point*)points, (int)numPoints, (const RGBValue*)color, (DrawMode)drawMode, (const char*)group);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqOverlayLine(Image image, Point start, Point end, RGBValue color, String group)
+ * JN: void imaqOverlayLine(long image, long start, long end, long color, long group)
+ * C: int imaqOverlayLine(Image* image, Point start, Point end, const RGBValue* color, const char* group)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayLine(JNIEnv* env, jclass , jlong image, jlong start, jlong end, jlong color, jlong group)
+{
+    int rv = imaqOverlayLine((Image*)image, *((Point*)start), *((Point*)end), (const RGBValue*)color, (const char*)group);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqOverlayOpenContour(Image image, Point[] points, RGBValue color, String group)
+ * JN: void imaqOverlayOpenContour(long image, long points, int numPoints, long color, long group)
+ * C: int imaqOverlayOpenContour(Image* image, const Point* points, int numPoints, const RGBValue* color, const char* group)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayOpenContour(JNIEnv* env, jclass , jlong image, jlong points, jint numPoints, jlong color, jlong group)
+{
+    int rv = imaqOverlayOpenContour((Image*)image, (const Point*)points, (int)numPoints, (const RGBValue*)color, (const char*)group);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: byte imaqOverlayOval(Image image, Rect boundingBox, RGBValue color, DrawMode drawMode)
+ * JN: byte imaqOverlayOval(long image, long boundingBox, long color, int drawMode, long group)
+ * C: int imaqOverlayOval(Image* image, Rect boundingBox, const RGBValue* color, DrawMode drawMode, char* group)
+ */
+
+JNIEXPORT jbyte JNICALL Java_com_ni_vision_NIVision__1imaqOverlayOval(JNIEnv* env, jclass , jlong image, jlong boundingBox, jlong color, jint drawMode, jlong group)
+{
+    int rv = imaqOverlayOval((Image*)image, *((Rect*)boundingBox), (const RGBValue*)color, (DrawMode)drawMode, (char*)group);
+    if (rv == 0) throwJavaException(env);
+    return (jbyte)rv;
+}
+
+/* J: void imaqOverlayPoints(Image image, Point[] points, RGBValue[] colors, PointSymbol symbol, UserPointSymbol userSymbol, String group)
+ * JN: void imaqOverlayPoints(long image, long points, int numPoints, long colors, int numColors, int symbol, long userSymbol, long group)
+ * C: int imaqOverlayPoints(Image* image, const Point* points, int numPoints, const RGBValue* colors, int numColors, PointSymbol symbol, const UserPointSymbol* userSymbol, const char* group)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayPoints(JNIEnv* env, jclass , jlong image, jlong points, jint numPoints, jlong colors, jint numColors, jint symbol, jlong userSymbol, jlong group)
+{
+    int rv = imaqOverlayPoints((Image*)image, (const Point*)points, (int)numPoints, (const RGBValue*)colors, (int)numColors, (PointSymbol)symbol, (const UserPointSymbol*)userSymbol, (const char*)group);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqOverlayRect(Image image, Rect rect, RGBValue color, DrawMode drawMode, String group)
+ * JN: void imaqOverlayRect(long image, long rect, long color, int drawMode, long group)
+ * C: int imaqOverlayRect(Image* image, Rect rect, const RGBValue* color, DrawMode drawMode, const char* group)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayRect(JNIEnv* env, jclass , jlong image, jlong rect, jlong color, jint drawMode, jlong group)
+{
+    int rv = imaqOverlayRect((Image*)image, *((Rect*)rect), (const RGBValue*)color, (DrawMode)drawMode, (const char*)group);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqOverlayROI(Image image, ROI roi, PointSymbol symbol, UserPointSymbol userSymbol, String group)
+ * JN: void imaqOverlayROI(long image, long roi, int symbol, long userSymbol, long group)
+ * C: int imaqOverlayROI(Image* image, const ROI* roi, PointSymbol symbol, const UserPointSymbol* userSymbol, const char* group)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayROI(JNIEnv* env, jclass , jlong image, jlong roi, jint symbol, jlong userSymbol, jlong group)
+{
+    int rv = imaqOverlayROI((Image*)image, (const ROI*)roi, (PointSymbol)symbol, (const UserPointSymbol*)userSymbol, (const char*)group);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqOverlayText(Image image, Point origin, String text, RGBValue color, OverlayTextOptions options, String group)
+ * JN: void imaqOverlayText(long image, long origin, long text, long color, long options, long group)
+ * C: int imaqOverlayText(Image* image, Point origin, const char* text, const RGBValue* color, const OverlayTextOptions* options, const char* group)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayText(JNIEnv* env, jclass , jlong image, jlong origin, jlong text, jlong color, jlong options, jlong group)
+{
+    int rv = imaqOverlayText((Image*)image, *((Point*)origin), (const char*)text, (const RGBValue*)color, (const OverlayTextOptions*)options, (const char*)group);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: TransformBehaviors imaqSetOverlayProperties(Image image, String group)
+ * JN: long imaqSetOverlayProperties(long image, long group, long transformBehaviors)
+ * C: int imaqSetOverlayProperties(Image* image, const char* group, TransformBehaviors* transformBehaviors)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqSetOverlayProperties(JNIEnv* env, jclass , jlong image, jlong group, jlong transformBehaviors)
+{
+    int rv = imaqSetOverlayProperties((Image*)image, (const char*)group, (TransformBehaviors*)transformBehaviors);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/*
+ * OCR functions
+ */
+
+/* J: CharSet imaqCreateCharSet()
+ * JN: long imaqCreateCharSet()
+ * C: CharSet* imaqCreateCharSet( void)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCreateCharSet(JNIEnv* env, jclass )
+{
+    CharSet* rv = imaqCreateCharSet();
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqDeleteChar(CharSet set, int index)
+ * JN: void imaqDeleteChar(long set, int index)
+ * C: int imaqDeleteChar(CharSet* set, int index)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDeleteChar(JNIEnv* env, jclass , jlong set, jint index)
+{
+    int rv = imaqDeleteChar((CharSet*)set, (int)index);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqGetCharCount(CharSet set)
+ * JN: void imaqGetCharCount(long set)
+ * C: int imaqGetCharCount(const CharSet* set)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetCharCount(JNIEnv* env, jclass , jlong set)
+{
+    int rv = imaqGetCharCount((const CharSet*)set);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: CharInfo2 imaqGetCharInfo2(CharSet set, int index)
+ * JN: long imaqGetCharInfo2(long set, int index)
+ * C: CharInfo2* imaqGetCharInfo2(const CharSet* set, int index)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetCharInfo2(JNIEnv* env, jclass , jlong set, jint index)
+{
+    CharInfo2* rv = imaqGetCharInfo2((const CharSet*)set, (int)index);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqReadOCRFile(String fileName, CharSet set, String setDescription)
+ * JN: void imaqReadOCRFile(long fileName, long set, long setDescription, long readOptions, long processingOptions, long spacingOptions)
+ * C: int imaqReadOCRFile(const char* fileName, CharSet* set, String255 setDescription, ReadTextOptions* readOptions, OCRProcessingOptions* processingOptions, OCRSpacingOptions* spacingOptions)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqReadOCRFile(JNIEnv* env, jclass , jlong fileName, jlong set, jlong setDescription, jlong readOptions, jlong processingOptions, jlong spacingOptions)
+{
+    int rv = imaqReadOCRFile((const char*)fileName, (CharSet*)set, (char *)setDescription, (ReadTextOptions*)readOptions, (OCRProcessingOptions*)processingOptions, (OCRSpacingOptions*)spacingOptions);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: ReadTextReport3 imaqReadText3(Image image, CharSet set, ROI roi, ReadTextOptions readOptions, OCRProcessingOptions processingOptions, OCRSpacingOptions spacingOptions)
+ * JN: long imaqReadText3(long image, long set, long roi, long readOptions, long processingOptions, long spacingOptions)
+ * C: ReadTextReport3* imaqReadText3(const Image* image, const CharSet* set, const ROI* roi, const ReadTextOptions* readOptions, const OCRProcessingOptions* processingOptions, const OCRSpacingOptions* spacingOptions)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadText3(JNIEnv* env, jclass , jlong image, jlong set, jlong roi, jlong readOptions, jlong processingOptions, jlong spacingOptions)
+{
+    ReadTextReport3* rv = imaqReadText3((const Image*)image, (const CharSet*)set, (const ROI*)roi, (const ReadTextOptions*)readOptions, (const OCRProcessingOptions*)processingOptions, (const OCRSpacingOptions*)spacingOptions);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqRenameChar(CharSet set, int index, String newCharValue)
+ * JN: void imaqRenameChar(long set, int index, long newCharValue)
+ * C: int imaqRenameChar(CharSet* set, int index, const char* newCharValue)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqRenameChar(JNIEnv* env, jclass , jlong set, jint index, jlong newCharValue)
+{
+    int rv = imaqRenameChar((CharSet*)set, (int)index, (const char*)newCharValue);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetReferenceChar(CharSet set, int index, int isReferenceChar)
+ * JN: void imaqSetReferenceChar(long set, int index, int isReferenceChar)
+ * C: int imaqSetReferenceChar(const CharSet* set, int index, int isReferenceChar)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetReferenceChar(JNIEnv* env, jclass , jlong set, jint index, jint isReferenceChar)
+{
+    int rv = imaqSetReferenceChar((const CharSet*)set, (int)index, (int)isReferenceChar);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqTrainChars(Image image, CharSet set, int index, String charValue, ROI roi, OCRProcessingOptions processingOptions, OCRSpacingOptions spacingOptions)
+ * JN: void imaqTrainChars(long image, long set, int index, long charValue, long roi, long processingOptions, long spacingOptions)
+ * C: int imaqTrainChars(const Image* image, CharSet* set, int index, const char* charValue, const ROI* roi, const OCRProcessingOptions* processingOptions, const OCRSpacingOptions* spacingOptions)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqTrainChars(JNIEnv* env, jclass , jlong image, jlong set, jint index, jlong charValue, jlong roi, jlong processingOptions, jlong spacingOptions)
+{
+    int rv = imaqTrainChars((const Image*)image, (CharSet*)set, (int)index, (const char*)charValue, (const ROI*)roi, (const OCRProcessingOptions*)processingOptions, (const OCRSpacingOptions*)spacingOptions);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqWriteOCRFile(String fileName, CharSet set, String setDescription, ReadTextOptions readOptions, OCRProcessingOptions processingOptions, OCRSpacingOptions spacingOptions)
+ * JN: void imaqWriteOCRFile(long fileName, long set, long setDescription, long readOptions, long processingOptions, long spacingOptions)
+ * C: int imaqWriteOCRFile(const char* fileName, const CharSet* set, const char* setDescription, const ReadTextOptions* readOptions, const OCRProcessingOptions* processingOptions, const OCRSpacingOptions* spacingOptions)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteOCRFile(JNIEnv* env, jclass , jlong fileName, jlong set, jlong setDescription, jlong readOptions, jlong processingOptions, jlong spacingOptions)
+{
+    int rv = imaqWriteOCRFile((const char*)fileName, (const CharSet*)set, (const char*)setDescription, (const ReadTextOptions*)readOptions, (const OCRProcessingOptions*)processingOptions, (const OCRSpacingOptions*)spacingOptions);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Geometric Matching functions
+ */
+
+/* J: ExtractContourReport imaqExtractContour(Image image, ROI roi, ExtractContourDirection direction, ConnectionConstraint connectionConstraintParams, int numOfConstraints, ExtractContourSelection selection, Image contourImage)
+ * JN: long imaqExtractContour(long image, long roi, int direction, long curveParams, long connectionConstraintParams, int numOfConstraints, int selection, long contourImage)
+ * C: ExtractContourReport* imaqExtractContour(Image* image, const ROI* roi, ExtractContourDirection direction, CurveParameters* curveParams, const ConnectionConstraint* connectionConstraintParams, unsigned int numOfConstraints, ExtractContourSelection selection, Image* contourImage)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqExtractContour(JNIEnv* env, jclass , jlong image, jlong roi, jint direction, jlong curveParams, jlong connectionConstraintParams, jint numOfConstraints, jint selection, jlong contourImage)
+{
+    ExtractContourReport* rv = imaqExtractContour((Image*)image, (const ROI*)roi, (ExtractContourDirection)direction, (CurveParameters*)curveParams, (const ConnectionConstraint*)connectionConstraintParams, (unsigned int)numOfConstraints, (ExtractContourSelection)selection, (Image*)contourImage);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqContourOverlay(Image image, Image contourImage, ContourOverlaySettings pointsSettings, ContourOverlaySettings eqnSettings, String groupName)
+ * JN: void imaqContourOverlay(long image, long contourImage, long pointsSettings, long eqnSettings, long groupName)
+ * C: int imaqContourOverlay(Image* image, const Image* contourImage, const ContourOverlaySettings* pointsSettings, const ContourOverlaySettings* eqnSettings, const char* groupName)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqContourOverlay(JNIEnv* env, jclass , jlong image, jlong contourImage, jlong pointsSettings, jlong eqnSettings, jlong groupName)
+{
+    int rv = imaqContourOverlay((Image*)image, (const Image*)contourImage, (const ContourOverlaySettings*)pointsSettings, (const ContourOverlaySettings*)eqnSettings, (const char*)groupName);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: ContourComputeCurvatureReport imaqContourComputeCurvature(Image contourImage, int kernel)
+ * JN: long imaqContourComputeCurvature(long contourImage, int kernel)
+ * C: ContourComputeCurvatureReport* imaqContourComputeCurvature(const Image* contourImage, unsigned int kernel)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourComputeCurvature(JNIEnv* env, jclass , jlong contourImage, jint kernel)
+{
+    ContourComputeCurvatureReport* rv = imaqContourComputeCurvature((const Image*)contourImage, (unsigned int)kernel);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: CurvatureAnalysisReport imaqContourClassifyCurvature(Image contourImage, int kernel, RangeLabel[] curvatureClasses)
+ * JN: long imaqContourClassifyCurvature(long contourImage, int kernel, long curvatureClasses, int numCurvatureClasses)
+ * C: CurvatureAnalysisReport* imaqContourClassifyCurvature(const Image* contourImage, unsigned int kernel, RangeLabel* curvatureClasses, unsigned int numCurvatureClasses)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourClassifyCurvature(JNIEnv* env, jclass , jlong contourImage, jint kernel, jlong curvatureClasses, jint numCurvatureClasses)
+{
+    CurvatureAnalysisReport* rv = imaqContourClassifyCurvature((const Image*)contourImage, (unsigned int)kernel, (RangeLabel*)curvatureClasses, (unsigned int)numCurvatureClasses);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ComputeDistancesReport imaqContourComputeDistances(Image targetImage, Image templateImage, SetupMatchPatternData matchSetupData, int smoothingKernel)
+ * JN: long imaqContourComputeDistances(long targetImage, long templateImage, long matchSetupData, int smoothingKernel)
+ * C: ComputeDistancesReport* imaqContourComputeDistances(const Image* targetImage, const Image* templateImage, const SetupMatchPatternData* matchSetupData, unsigned int smoothingKernel)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourComputeDistances(JNIEnv* env, jclass , jlong targetImage, jlong templateImage, jlong matchSetupData, jint smoothingKernel)
+{
+    ComputeDistancesReport* rv = imaqContourComputeDistances((const Image*)targetImage, (const Image*)templateImage, (const SetupMatchPatternData*)matchSetupData, (unsigned int)smoothingKernel);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ClassifyDistancesReport imaqContourClassifyDistances(Image targetImage, Image templateImage, SetupMatchPatternData matchSetupData, int smoothingKernel, RangeLabel[] distanceRanges)
+ * JN: long imaqContourClassifyDistances(long targetImage, long templateImage, long matchSetupData, int smoothingKernel, long distanceRanges, int numDistanceRanges)
+ * C: ClassifyDistancesReport* imaqContourClassifyDistances(const Image* targetImage, const Image* templateImage, const SetupMatchPatternData* matchSetupData, unsigned int smoothingKernel, const RangeLabel* distanceRanges, unsigned int numDistanceRanges)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourClassifyDistances(JNIEnv* env, jclass , jlong targetImage, jlong templateImage, jlong matchSetupData, jint smoothingKernel, jlong distanceRanges, jint numDistanceRanges)
+{
+    ClassifyDistancesReport* rv = imaqContourClassifyDistances((const Image*)targetImage, (const Image*)templateImage, (const SetupMatchPatternData*)matchSetupData, (unsigned int)smoothingKernel, (const RangeLabel*)distanceRanges, (unsigned int)numDistanceRanges);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ContourInfoReport imaqContourInfo(Image contourImage)
+ * JN: long imaqContourInfo(long contourImage)
+ * C: ContourInfoReport* imaqContourInfo(const Image* contourImage)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourInfo(JNIEnv* env, jclass , jlong contourImage)
+{
+    ContourInfoReport* rv = imaqContourInfo((const Image*)contourImage);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: SetupMatchPatternData imaqContourSetupMatchPattern(int enableSubPixelAccuracy, int useLearnCurveParameters, RangeSettingDouble[] rangeSettings)
+ * JN: long imaqContourSetupMatchPattern(long matchMode, int enableSubPixelAccuracy, long curveParams, int useLearnCurveParameters, long rangeSettings, int numRangeSettings)
+ * C: SetupMatchPatternData* imaqContourSetupMatchPattern(MatchMode* matchMode, unsigned int enableSubPixelAccuracy, CurveParameters* curveParams, unsigned int useLearnCurveParameters, const RangeSettingDouble* rangeSettings, unsigned int numRangeSettings)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourSetupMatchPattern(JNIEnv* env, jclass , jlong matchMode, jint enableSubPixelAccuracy, jlong curveParams, jint useLearnCurveParameters, jlong rangeSettings, jint numRangeSettings)
+{
+    SetupMatchPatternData* rv = imaqContourSetupMatchPattern((MatchMode*)matchMode, (unsigned int)enableSubPixelAccuracy, (CurveParameters*)curveParams, (unsigned int)useLearnCurveParameters, (const RangeSettingDouble*)rangeSettings, (unsigned int)numRangeSettings);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: SetupMatchPatternData imaqContourAdvancedSetupMatchPattern(GeometricAdvancedSetupDataOption[] geometricOptions)
+ * JN: long imaqContourAdvancedSetupMatchPattern(long matchSetupData, long geometricOptions, int numGeometricOptions)
+ * C: int imaqContourAdvancedSetupMatchPattern(SetupMatchPatternData* matchSetupData, GeometricAdvancedSetupDataOption* geometricOptions, unsigned int numGeometricOptions)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourAdvancedSetupMatchPattern(JNIEnv* env, jclass , jlong matchSetupData, jlong geometricOptions, jint numGeometricOptions)
+{
+    int rv = imaqContourAdvancedSetupMatchPattern((SetupMatchPatternData*)matchSetupData, (GeometricAdvancedSetupDataOption*)geometricOptions, (unsigned int)numGeometricOptions);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ContourFitLineReport imaqContourFitLine(Image image, double pixelRadius)
+ * JN: long imaqContourFitLine(long image, double pixelRadius)
+ * C: ContourFitLineReport* imaqContourFitLine(Image* image, double pixelRadius)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourFitLine(JNIEnv* env, jclass , jlong image, jdouble pixelRadius)
+{
+    ContourFitLineReport* rv = imaqContourFitLine((Image*)image, (double)pixelRadius);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: PartialCircle imaqContourFitCircle(Image image, double pixelRadius, int rejectOutliers)
+ * JN: long imaqContourFitCircle(long image, double pixelRadius, int rejectOutliers)
+ * C: PartialCircle* imaqContourFitCircle(Image* image, double pixelRadius, int rejectOutliers)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourFitCircle(JNIEnv* env, jclass , jlong image, jdouble pixelRadius, jint rejectOutliers)
+{
+    PartialCircle* rv = imaqContourFitCircle((Image*)image, (double)pixelRadius, (int)rejectOutliers);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: PartialEllipse imaqContourFitEllipse(Image image, double pixelRadius, int rejectOutliers)
+ * JN: long imaqContourFitEllipse(long image, double pixelRadius, int rejectOutliers)
+ * C: PartialEllipse* imaqContourFitEllipse(Image* image, double pixelRadius, int rejectOutliers)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourFitEllipse(JNIEnv* env, jclass , jlong image, jdouble pixelRadius, jint rejectOutliers)
+{
+    PartialEllipse* rv = imaqContourFitEllipse((Image*)image, (double)pixelRadius, (int)rejectOutliers);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ContourFitSplineReport imaqContourFitSpline(Image image, int degree, int numberOfControlPoints)
+ * JN: long imaqContourFitSpline(long image, int degree, int numberOfControlPoints)
+ * C: ContourFitSplineReport* imaqContourFitSpline(Image* image, int degree, int numberOfControlPoints)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourFitSpline(JNIEnv* env, jclass , jlong image, jint degree, jint numberOfControlPoints)
+{
+    ContourFitSplineReport* rv = imaqContourFitSpline((Image*)image, (int)degree, (int)numberOfControlPoints);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ContourFitPolynomialReport imaqContourFitPolynomial(Image image, int order)
+ * JN: long imaqContourFitPolynomial(long image, int order)
+ * C: ContourFitPolynomialReport* imaqContourFitPolynomial(Image* image, int order)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqContourFitPolynomial(JNIEnv* env, jclass , jlong image, jint order)
+{
+    ContourFitPolynomialReport* rv = imaqContourFitPolynomial((Image*)image, (int)order);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/*
+ * Edge Detection functions
+ */
+
+/* J: FindCircularEdgeReport imaqFindCircularEdge2(Image image, ROI roi, CoordinateSystem baseSystem, CoordinateSystem newSystem, FindCircularEdgeOptions edgeOptions, CircleFitOptions circleFitOptions)
+ * JN: long imaqFindCircularEdge2(long image, long roi, long baseSystem, long newSystem, long edgeOptions, long circleFitOptions)
+ * C: FindCircularEdgeReport* imaqFindCircularEdge2(Image* image, const ROI* roi, const CoordinateSystem* baseSystem, const CoordinateSystem* newSystem, const FindCircularEdgeOptions* edgeOptions, const CircleFitOptions* circleFitOptions)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFindCircularEdge2(JNIEnv* env, jclass , jlong image, jlong roi, jlong baseSystem, jlong newSystem, jlong edgeOptions, jlong circleFitOptions)
+{
+    FindCircularEdgeReport* rv = imaqFindCircularEdge2((Image*)image, (const ROI*)roi, (const CoordinateSystem*)baseSystem, (const CoordinateSystem*)newSystem, (const FindCircularEdgeOptions*)edgeOptions, (const CircleFitOptions*)circleFitOptions);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: FindConcentricEdgeReport imaqFindConcentricEdge2(Image image, ROI roi, CoordinateSystem baseSystem, CoordinateSystem newSystem, FindConcentricEdgeOptions edgeOptions, ConcentricEdgeFitOptions concentricEdgeFitOptions)
+ * JN: long imaqFindConcentricEdge2(long image, long roi, long baseSystem, long newSystem, long edgeOptions, long concentricEdgeFitOptions)
+ * C: FindConcentricEdgeReport* imaqFindConcentricEdge2(Image* image, const ROI* roi, const CoordinateSystem* baseSystem, const CoordinateSystem* newSystem, const FindConcentricEdgeOptions* edgeOptions, const ConcentricEdgeFitOptions* concentricEdgeFitOptions)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFindConcentricEdge2(JNIEnv* env, jclass , jlong image, jlong roi, jlong baseSystem, jlong newSystem, jlong edgeOptions, jlong concentricEdgeFitOptions)
+{
+    FindConcentricEdgeReport* rv = imaqFindConcentricEdge2((Image*)image, (const ROI*)roi, (const CoordinateSystem*)baseSystem, (const CoordinateSystem*)newSystem, (const FindConcentricEdgeOptions*)edgeOptions, (const ConcentricEdgeFitOptions*)concentricEdgeFitOptions);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/*
+ * Morphology Reconstruction functions
+ */
+
+/* J: void imaqGrayMorphologyReconstruct(Image dstImage, Image srcImage, Image markerImage, PointFloat[] points, MorphologyReconstructOperation operation, StructuringElement structuringElement, ROI roi)
+ * JN: void imaqGrayMorphologyReconstruct(long dstImage, long srcImage, long markerImage, long points, int numOfPoints, int operation, long structuringElement, long roi)
+ * C: int imaqGrayMorphologyReconstruct(Image* dstImage, Image* srcImage, const Image* markerImage, PointFloat* points, int numOfPoints, MorphologyReconstructOperation operation, const StructuringElement* structuringElement, const ROI* roi)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGrayMorphologyReconstruct(JNIEnv* env, jclass , jlong dstImage, jlong srcImage, jlong markerImage, jlong points, jint numOfPoints, jint operation, jlong structuringElement, jlong roi)
+{
+    int rv = imaqGrayMorphologyReconstruct((Image*)dstImage, (Image*)srcImage, (const Image*)markerImage, (PointFloat*)points, (int)numOfPoints, (MorphologyReconstructOperation)operation, (const StructuringElement*)structuringElement, (const ROI*)roi);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqMorphologyReconstruct(Image dstImage, Image srcImage, Image markerImage, PointFloat[] points, MorphologyReconstructOperation operation, Connectivity connectivity, ROI roi)
+ * JN: void imaqMorphologyReconstruct(long dstImage, long srcImage, long markerImage, long points, int numOfPoints, int operation, int connectivity, long roi)
+ * C: int imaqMorphologyReconstruct(Image* dstImage, Image* srcImage, const Image* markerImage, PointFloat* points, int numOfPoints, MorphologyReconstructOperation operation, Connectivity connectivity, const ROI* roi)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqMorphologyReconstruct(JNIEnv* env, jclass , jlong dstImage, jlong srcImage, jlong markerImage, jlong points, jint numOfPoints, jint operation, jint connectivity, jlong roi)
+{
+    int rv = imaqMorphologyReconstruct((Image*)dstImage, (Image*)srcImage, (const Image*)markerImage, (PointFloat*)points, (int)numOfPoints, (MorphologyReconstructOperation)operation, (Connectivity)connectivity, (const ROI*)roi);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Texture functions
+ */
+
+/* J: void imaqDetectTextureDefect(ClassifierSession session, Image destImage, Image srcImage, ROI roi, int initialStepSize, int finalStepSize, short defectPixelValue, double minClassificationScore)
+ * JN: void imaqDetectTextureDefect(long session, long destImage, long srcImage, long roi, int initialStepSize, int finalStepSize, short defectPixelValue, double minClassificationScore)
+ * C: int imaqDetectTextureDefect(ClassifierSession* session, Image* destImage, const Image* srcImage, const ROI* roi, int initialStepSize, int finalStepSize, unsigned char defectPixelValue, double minClassificationScore)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDetectTextureDefect(JNIEnv* env, jclass , jlong session, jlong destImage, jlong srcImage, jlong roi, jint initialStepSize, jint finalStepSize, jshort defectPixelValue, jdouble minClassificationScore)
+{
+    int rv = imaqDetectTextureDefect((ClassifierSession*)session, (Image*)destImage, (const Image*)srcImage, (const ROI*)roi, (int)initialStepSize, (int)finalStepSize, (unsigned char)defectPixelValue, (double)minClassificationScore);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Regions of Interest Manipulation functions
+ */
+
+/* J: ROI imaqMaskToROI(Image mask)
+ * JN: long imaqMaskToROI(long mask, long withinLimit)
+ * C: ROI* imaqMaskToROI(const Image* mask, int* withinLimit)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMaskToROI(JNIEnv* env, jclass , jlong mask, jlong withinLimit)
+{
+    ROI* rv = imaqMaskToROI((const Image*)mask, (int*)withinLimit);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ROIProfile imaqROIProfile(Image image, ROI roi)
+ * JN: long imaqROIProfile(long image, long roi)
+ * C: ROIProfile* imaqROIProfile(const Image* image, const ROI* roi)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqROIProfile(JNIEnv* env, jclass , jlong image, jlong roi)
+{
+    ROIProfile* rv = imaqROIProfile((const Image*)image, (const ROI*)roi);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: int imaqROIToMask(Image mask, ROI roi, int fillValue, Image imageModel)
+ * JN: int imaqROIToMask(long mask, long roi, int fillValue, long imageModel, long inSpace)
+ * C: int imaqROIToMask(Image* mask, const ROI* roi, int fillValue, const Image* imageModel, int* inSpace)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqROIToMask(JNIEnv* env, jclass , jlong mask, jlong roi, jint fillValue, jlong imageModel, jlong inSpace)
+{
+    int rv = imaqROIToMask((Image*)mask, (const ROI*)roi, (int)fillValue, (const Image*)imageModel, (int*)inSpace);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: void imaqTransformROI2(ROI roi, CoordinateSystem baseSystem, CoordinateSystem newSystem)
+ * JN: void imaqTransformROI2(long roi, long baseSystem, long newSystem)
+ * C: int imaqTransformROI2(ROI* roi, const CoordinateSystem* baseSystem, const CoordinateSystem* newSystem)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqTransformROI2(JNIEnv* env, jclass , jlong roi, jlong baseSystem, jlong newSystem)
+{
+    int rv = imaqTransformROI2((ROI*)roi, (const CoordinateSystem*)baseSystem, (const CoordinateSystem*)newSystem);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: LabelToROIReport imaqLabelToROI(Image image, int[] labelsIn, int maxNumVectors, int isExternelEdges)
+ * JN: long imaqLabelToROI(long image, long labelsIn, int numLabelsIn, int maxNumVectors, int isExternelEdges)
+ * C: LabelToROIReport* imaqLabelToROI(const Image* image, const unsigned int* labelsIn, unsigned int numLabelsIn, int maxNumVectors, int isExternelEdges)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqLabelToROI(JNIEnv* env, jclass , jlong image, jlong labelsIn, jint numLabelsIn, jint maxNumVectors, jint isExternelEdges)
+{
+    LabelToROIReport* rv = imaqLabelToROI((const Image*)image, (const unsigned int*)labelsIn, (unsigned int)numLabelsIn, (int)maxNumVectors, (int)isExternelEdges);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/*
+ * Morphology functions
+ */
+
+/* J: void imaqGrayMorphology(Image dest, Image source, MorphologyMethod method, StructuringElement structuringElement)
+ * JN: void imaqGrayMorphology(long dest, long source, int method, long structuringElement)
+ * C: int imaqGrayMorphology(Image* dest, Image* source, MorphologyMethod method, const StructuringElement* structuringElement)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGrayMorphology(JNIEnv* env, jclass , jlong dest, jlong source, jint method, jlong structuringElement)
+{
+    int rv = imaqGrayMorphology((Image*)dest, (Image*)source, (MorphologyMethod)method, (const StructuringElement*)structuringElement);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Classification functions
+ */
+
+/* J: void imaqAddClassifierSample(Image image, ClassifierSession session, ROI roi, String sampleClass, double[] featureVector)
+ * JN: void imaqAddClassifierSample(long image, long session, long roi, long sampleClass, long featureVector, int vectorSize)
+ * C: int imaqAddClassifierSample(Image* image, ClassifierSession* session, const ROI* roi, const char* sampleClass, double* featureVector, unsigned int vectorSize)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqAddClassifierSample(JNIEnv* env, jclass , jlong image, jlong session, jlong roi, jlong sampleClass, jlong featureVector, jint vectorSize)
+{
+    int rv = imaqAddClassifierSample((Image*)image, (ClassifierSession*)session, (const ROI*)roi, (const char*)sampleClass, (double*)featureVector, (unsigned int)vectorSize);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: ClassifierReportAdvanced imaqAdvanceClassify(Image image, ClassifierSession session, ROI roi, double[] featureVector)
+ * JN: long imaqAdvanceClassify(long image, long session, long roi, long featureVector, int vectorSize)
+ * C: ClassifierReportAdvanced* imaqAdvanceClassify(Image* image, const ClassifierSession* session, const ROI* roi, double* featureVector, unsigned int vectorSize)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqAdvanceClassify(JNIEnv* env, jclass , jlong image, jlong session, jlong roi, jlong featureVector, jint vectorSize)
+{
+    ClassifierReportAdvanced* rv = imaqAdvanceClassify((Image*)image, (const ClassifierSession*)session, (const ROI*)roi, (double*)featureVector, (unsigned int)vectorSize);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ClassifierReport imaqClassify(Image image, ClassifierSession session, ROI roi, double[] featureVector)
+ * JN: long imaqClassify(long image, long session, long roi, long featureVector, int vectorSize)
+ * C: ClassifierReport* imaqClassify(Image* image, const ClassifierSession* session, const ROI* roi, double* featureVector, unsigned int vectorSize)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqClassify(JNIEnv* env, jclass , jlong image, jlong session, jlong roi, jlong featureVector, jint vectorSize)
+{
+    ClassifierReport* rv = imaqClassify((Image*)image, (const ClassifierSession*)session, (const ROI*)roi, (double*)featureVector, (unsigned int)vectorSize);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ClassifierSession imaqCreateClassifier(ClassifierType type)
+ * JN: long imaqCreateClassifier(int type)
+ * C: ClassifierSession* imaqCreateClassifier(ClassifierType type)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCreateClassifier(JNIEnv* env, jclass , jint type)
+{
+    ClassifierSession* rv = imaqCreateClassifier((ClassifierType)type);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqDeleteClassifierSample(ClassifierSession session, int index)
+ * JN: void imaqDeleteClassifierSample(long session, int index)
+ * C: int imaqDeleteClassifierSample(ClassifierSession* session, int index)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDeleteClassifierSample(JNIEnv* env, jclass , jlong session, jint index)
+{
+    int rv = imaqDeleteClassifierSample((ClassifierSession*)session, (int)index);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: ClassifierAccuracyReport imaqGetClassifierAccuracy(ClassifierSession session)
+ * JN: long imaqGetClassifierAccuracy(long session)
+ * C: ClassifierAccuracyReport* imaqGetClassifierAccuracy(const ClassifierSession* session)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetClassifierAccuracy(JNIEnv* env, jclass , jlong session)
+{
+    ClassifierAccuracyReport* rv = imaqGetClassifierAccuracy((const ClassifierSession*)session);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ClassifierSampleInfo imaqGetClassifierSampleInfo(ClassifierSession session, int index)
+ * JN: long imaqGetClassifierSampleInfo(long session, int index, long numSamples)
+ * C: ClassifierSampleInfo* imaqGetClassifierSampleInfo(const ClassifierSession* session, int index, int* numSamples)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetClassifierSampleInfo(JNIEnv* env, jclass , jlong session, jint index, jlong numSamples)
+{
+    ClassifierSampleInfo* rv = imaqGetClassifierSampleInfo((const ClassifierSession*)session, (int)index, (int*)numSamples);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ColorOptions imaqGetColorClassifierOptions(ClassifierSession session)
+ * JN: long imaqGetColorClassifierOptions(long session, long options)
+ * C: int imaqGetColorClassifierOptions(const ClassifierSession* session, ColorOptions* options)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetColorClassifierOptions(JNIEnv* env, jclass , jlong session, jlong options)
+{
+    int rv = imaqGetColorClassifierOptions((const ClassifierSession*)session, (ColorOptions*)options);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: NearestNeighborOptions imaqGetNearestNeighborOptions(ClassifierSession session)
+ * JN: long imaqGetNearestNeighborOptions(long session, long options)
+ * C: int imaqGetNearestNeighborOptions(const ClassifierSession* session, NearestNeighborOptions* options)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetNearestNeighborOptions(JNIEnv* env, jclass , jlong session, jlong options)
+{
+    int rv = imaqGetNearestNeighborOptions((const ClassifierSession*)session, (NearestNeighborOptions*)options);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqGetParticleClassifierOptions2(ClassifierSession session)
+ * JN: void imaqGetParticleClassifierOptions2(long session, long preprocessingOptions, long options)
+ * C: int imaqGetParticleClassifierOptions2(const ClassifierSession* session, ParticleClassifierPreprocessingOptions2* preprocessingOptions, ParticleClassifierOptions* options)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetParticleClassifierOptions2(JNIEnv* env, jclass , jlong session, jlong preprocessingOptions, jlong options)
+{
+    int rv = imaqGetParticleClassifierOptions2((const ClassifierSession*)session, (ParticleClassifierPreprocessingOptions2*)preprocessingOptions, (ParticleClassifierOptions*)options);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: ClassifierSession imaqReadClassifierFile(ClassifierSession session, String fileName, ReadClassifierFileMode mode, String description)
+ * JN: long imaqReadClassifierFile(long session, long fileName, int mode, long type, long engine, long description)
+ * C: ClassifierSession* imaqReadClassifierFile(ClassifierSession* session, const char* fileName, ReadClassifierFileMode mode, ClassifierType* type, ClassifierEngineType* engine, String255 description)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadClassifierFile(JNIEnv* env, jclass , jlong session, jlong fileName, jint mode, jlong type, jlong engine, jlong description)
+{
+    ClassifierSession* rv = imaqReadClassifierFile((ClassifierSession*)session, (const char*)fileName, (ReadClassifierFileMode)mode, (ClassifierType*)type, (ClassifierEngineType*)engine, (char *)description);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqRelabelClassifierSample(ClassifierSession session, int index, String newClass)
+ * JN: void imaqRelabelClassifierSample(long session, int index, long newClass)
+ * C: int imaqRelabelClassifierSample(ClassifierSession* session, int index, const char* newClass)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqRelabelClassifierSample(JNIEnv* env, jclass , jlong session, jint index, jlong newClass)
+{
+    int rv = imaqRelabelClassifierSample((ClassifierSession*)session, (int)index, (const char*)newClass);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetParticleClassifierOptions2(ClassifierSession session, ParticleClassifierPreprocessingOptions2 preprocessingOptions, ParticleClassifierOptions options)
+ * JN: void imaqSetParticleClassifierOptions2(long session, long preprocessingOptions, long options)
+ * C: int imaqSetParticleClassifierOptions2(ClassifierSession* session, const ParticleClassifierPreprocessingOptions2* preprocessingOptions, const ParticleClassifierOptions* options)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetParticleClassifierOptions2(JNIEnv* env, jclass , jlong session, jlong preprocessingOptions, jlong options)
+{
+    int rv = imaqSetParticleClassifierOptions2((ClassifierSession*)session, (const ParticleClassifierPreprocessingOptions2*)preprocessingOptions, (const ParticleClassifierOptions*)options);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSetColorClassifierOptions(ClassifierSession session, ColorOptions options)
+ * JN: void imaqSetColorClassifierOptions(long session, long options)
+ * C: int imaqSetColorClassifierOptions(ClassifierSession* session, const ColorOptions* options)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetColorClassifierOptions(JNIEnv* env, jclass , jlong session, jlong options)
+{
+    int rv = imaqSetColorClassifierOptions((ClassifierSession*)session, (const ColorOptions*)options);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: NearestNeighborTrainingReport imaqTrainNearestNeighborClassifier(ClassifierSession session, NearestNeighborOptions options)
+ * JN: long imaqTrainNearestNeighborClassifier(long session, long options)
+ * C: NearestNeighborTrainingReport* imaqTrainNearestNeighborClassifier(ClassifierSession* session, const NearestNeighborOptions* options)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqTrainNearestNeighborClassifier(JNIEnv* env, jclass , jlong session, jlong options)
+{
+    NearestNeighborTrainingReport* rv = imaqTrainNearestNeighborClassifier((ClassifierSession*)session, (const NearestNeighborOptions*)options);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqWriteClassifierFile(ClassifierSession session, String fileName, WriteClassifierFileMode mode, String description)
+ * JN: void imaqWriteClassifierFile(long session, long fileName, int mode, long description)
+ * C: int imaqWriteClassifierFile(const ClassifierSession* session, const char* fileName, WriteClassifierFileMode mode, const String255 description)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteClassifierFile(JNIEnv* env, jclass , jlong session, jlong fileName, jint mode, jlong description)
+{
+    int rv = imaqWriteClassifierFile((const ClassifierSession*)session, (const char*)fileName, (WriteClassifierFileMode)mode, (char *)description);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Measure Distances functions
+ */
+
+/* J: ClampMax2Report imaqClampMax2(Image image, ROI roi, CoordinateSystem baseSystem, CoordinateSystem newSystem, CurveOptions curveSettings, ClampSettings clampSettings, ClampOverlaySettings clampOverlaySettings)
+ * JN: long imaqClampMax2(long image, long roi, long baseSystem, long newSystem, long curveSettings, long clampSettings, long clampOverlaySettings)
+ * C: ClampMax2Report* imaqClampMax2(Image* image, const ROI* roi, const CoordinateSystem* baseSystem, const CoordinateSystem* newSystem, const CurveOptions* curveSettings, const ClampSettings* clampSettings, const ClampOverlaySettings* clampOverlaySettings)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqClampMax2(JNIEnv* env, jclass , jlong image, jlong roi, jlong baseSystem, jlong newSystem, jlong curveSettings, jlong clampSettings, jlong clampOverlaySettings)
+{
+    ClampMax2Report* rv = imaqClampMax2((Image*)image, (const ROI*)roi, (const CoordinateSystem*)baseSystem, (const CoordinateSystem*)newSystem, (const CurveOptions*)curveSettings, (const ClampSettings*)clampSettings, (const ClampOverlaySettings*)clampOverlaySettings);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/*
+ * Inspection functions
+ */
+
+/* J: void imaqCompareGoldenTemplate(Image image, Image goldenTemplate, Image brightDefects, Image darkDefects, InspectionAlignment alignment, InspectionOptions options)
+ * JN: void imaqCompareGoldenTemplate(long image, long goldenTemplate, long brightDefects, long darkDefects, long alignment, long options)
+ * C: int imaqCompareGoldenTemplate(const Image* image, const Image* goldenTemplate, Image* brightDefects, Image* darkDefects, const InspectionAlignment* alignment, const InspectionOptions* options)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCompareGoldenTemplate(JNIEnv* env, jclass , jlong image, jlong goldenTemplate, jlong brightDefects, jlong darkDefects, jlong alignment, jlong options)
+{
+    int rv = imaqCompareGoldenTemplate((const Image*)image, (const Image*)goldenTemplate, (Image*)brightDefects, (Image*)darkDefects, (const InspectionAlignment*)alignment, (const InspectionOptions*)options);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqLearnGoldenTemplate(Image goldenTemplate, PointFloat originOffset, Image mask)
+ * JN: void imaqLearnGoldenTemplate(long goldenTemplate, long originOffset, long mask)
+ * C: int imaqLearnGoldenTemplate(Image* goldenTemplate, PointFloat originOffset, const Image* mask)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLearnGoldenTemplate(JNIEnv* env, jclass , jlong goldenTemplate, jlong originOffset, jlong mask)
+{
+    int rv = imaqLearnGoldenTemplate((Image*)goldenTemplate, *((PointFloat*)originOffset), (const Image*)mask);
+    if (rv == 0) throwJavaException(env);
+}
+
+/*
+ * Obsolete functions
+ */
+
+/* J: void imaqWritePNGFile(Image image, String fileName, int compressionSpeed, RGBValue colorTable)
+ * JN: void imaqWritePNGFile(long image, long fileName, int compressionSpeed, long colorTable)
+ * C: int imaqWritePNGFile(const Image* image, const char* fileName, unsigned int compressionSpeed, const RGBValue* colorTable)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWritePNGFile(JNIEnv* env, jclass , jlong image, jlong fileName, jint compressionSpeed, jlong colorTable)
+{
+    int rv = imaqWritePNGFile((const Image*)image, (const char*)fileName, (unsigned int)compressionSpeed, (const RGBValue*)colorTable);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: SelectParticlesResult imaqSelectParticles(Image image, ParticleReport reports, int reportCount, int rejectBorder, SelectParticleCriteria criteria, int criteriaCount)
+ * JN: long imaqSelectParticles(long image, long reports, int reportCount, int rejectBorder, long criteria, int criteriaCount, long selectedCount)
+ * C: ParticleReport* imaqSelectParticles(const Image* image, const ParticleReport* reports, int reportCount, int rejectBorder, const SelectParticleCriteria* criteria, int criteriaCount, int* selectedCount)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqSelectParticles(JNIEnv* env, jclass , jlong image, jlong reports, jint reportCount, jint rejectBorder, jlong criteria, jint criteriaCount, jlong selectedCount)
+{
+    ParticleReport* rv = imaqSelectParticles((const Image*)image, (const ParticleReport*)reports, (int)reportCount, (int)rejectBorder, (const SelectParticleCriteria*)criteria, (int)criteriaCount, (int*)selectedCount);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqParticleFilter(Image dest, Image source, ParticleFilterCriteria criteria, int criteriaCount, int rejectMatches, int connectivity8)
+ * JN: void imaqParticleFilter(long dest, long source, long criteria, int criteriaCount, int rejectMatches, int connectivity8)
+ * C: int imaqParticleFilter(Image* dest, Image* source, const ParticleFilterCriteria* criteria, int criteriaCount, int rejectMatches, int connectivity8)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqParticleFilter(JNIEnv* env, jclass , jlong dest, jlong source, jlong criteria, jint criteriaCount, jint rejectMatches, jint connectivity8)
+{
+    int rv = imaqParticleFilter((Image*)dest, (Image*)source, (const ParticleFilterCriteria*)criteria, (int)criteriaCount, (int)rejectMatches, (int)connectivity8);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: GetParticleInfoResult imaqGetParticleInfo(Image image, int connectivity8, ParticleInfoMode mode)
+ * JN: long imaqGetParticleInfo(long image, int connectivity8, int mode, long reportCount)
+ * C: ParticleReport* imaqGetParticleInfo(Image* image, int connectivity8, ParticleInfoMode mode, int* reportCount)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetParticleInfo(JNIEnv* env, jclass , jlong image, jint connectivity8, jint mode, jlong reportCount)
+{
+    ParticleReport* rv = imaqGetParticleInfo((Image*)image, (int)connectivity8, (ParticleInfoMode)mode, (int*)reportCount);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: float imaqCalcCoeff(Image image, ParticleReport report, MeasurementValue parameter)
+ * JN: float imaqCalcCoeff(long image, long report, int parameter, long coefficient)
+ * C: int imaqCalcCoeff(const Image* image, const ParticleReport* report, MeasurementValue parameter, float* coefficient)
+ */
+
+JNIEXPORT jfloat JNICALL Java_com_ni_vision_NIVision__1imaqCalcCoeff(JNIEnv* env, jclass , jlong image, jlong report, jint parameter, jlong coefficient)
+{
+    int rv = imaqCalcCoeff((const Image*)image, (const ParticleReport*)report, (MeasurementValue)parameter, (float*)coefficient);
+    if (rv == 0) throwJavaException(env);
+    return (jfloat)rv;
+}
+
+/* J: EdgeToolResult imaqEdgeTool(Image image, Point points, int numPoints, EdgeOptions options)
+ * JN: long imaqEdgeTool(long image, long points, int numPoints, long options, long numEdges)
+ * C: EdgeReport* imaqEdgeTool(const Image* image, const Point* points, int numPoints, const EdgeOptions* options, int* numEdges)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqEdgeTool(JNIEnv* env, jclass , jlong image, jlong points, jint numPoints, jlong options, jlong numEdges)
+{
+    EdgeReport* rv = imaqEdgeTool((const Image*)image, (const Point*)points, (int)numPoints, (const EdgeOptions*)options, (int*)numEdges);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: CirclesResult imaqCircles(Image dest, Image source, float minRadius, float maxRadius)
+ * JN: long imaqCircles(long dest, long source, float minRadius, float maxRadius, long numCircles)
+ * C: CircleReport* imaqCircles(Image* dest, const Image* source, float minRadius, float maxRadius, int* numCircles)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCircles(JNIEnv* env, jclass , jlong dest, jlong source, jfloat minRadius, jfloat maxRadius, jlong numCircles)
+{
+    CircleReport* rv = imaqCircles((Image*)dest, (const Image*)source, (float)minRadius, (float)maxRadius, (int*)numCircles);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: int imaqLabel(Image dest, Image source, int connectivity8)
+ * JN: int imaqLabel(long dest, long source, int connectivity8, long particleCount)
+ * C: int imaqLabel(Image* dest, Image* source, int connectivity8, int* particleCount)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqLabel(JNIEnv* env, jclass , jlong dest, jlong source, jint connectivity8, jlong particleCount)
+{
+    int rv = imaqLabel((Image*)dest, (Image*)source, (int)connectivity8, (int*)particleCount);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: BestEllipse imaqFitEllipse(PointFloat[] points)
+ * JN: long imaqFitEllipse(long points, int numPoints, long ellipse)
+ * C: int imaqFitEllipse(const PointFloat* points, int numPoints, BestEllipse* ellipse)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFitEllipse(JNIEnv* env, jclass , jlong points, jint numPoints, jlong ellipse)
+{
+    int rv = imaqFitEllipse((const PointFloat*)points, (int)numPoints, (BestEllipse*)ellipse);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: BestCircle imaqFitCircle(PointFloat[] points)
+ * JN: long imaqFitCircle(long points, int numPoints, long circle)
+ * C: int imaqFitCircle(const PointFloat* points, int numPoints, BestCircle* circle)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFitCircle(JNIEnv* env, jclass , jlong points, jint numPoints, jlong circle)
+{
+    int rv = imaqFitCircle((const PointFloat*)points, (int)numPoints, (BestCircle*)circle);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: MatchPatternResult imaqMatchPattern(Image image, Image pattern, MatchPatternOptions options, Rect searchRect)
+ * JN: long imaqMatchPattern(long image, long pattern, long options, long searchRect, long numMatches)
+ * C: PatternMatch* imaqMatchPattern(const Image* image, Image* pattern, const MatchPatternOptions* options, Rect searchRect, int* numMatches)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchPattern(JNIEnv* env, jclass , jlong image, jlong pattern, jlong options, jlong searchRect, jlong numMatches)
+{
+    PatternMatch* rv = imaqMatchPattern((const Image*)image, (Image*)pattern, (const MatchPatternOptions*)options, *((Rect*)searchRect), (int*)numMatches);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqConvex(Image dest, Image source)
+ * JN: void imaqConvex(long dest, long source)
+ * C: int imaqConvex(Image* dest, const Image* source)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqConvex(JNIEnv* env, jclass , jlong dest, jlong source)
+{
+    int rv = imaqConvex((Image*)dest, (const Image*)source);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: int imaqIsVisionInfoPresent(Image image, VisionInfoType type)
+ * JN: int imaqIsVisionInfoPresent(long image, int type, long present)
+ * C: int imaqIsVisionInfoPresent(const Image* image, VisionInfoType type, int* present)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqIsVisionInfoPresent(JNIEnv* env, jclass , jlong image, jint type, jlong present)
+{
+    int rv = imaqIsVisionInfoPresent((const Image*)image, (VisionInfoType)type, (int*)present);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: float imaqLineGaugeTool(Image image, Point start, Point end, LineGaugeMethod method, EdgeOptions edgeOptions, CoordinateTransform reference)
+ * JN: float imaqLineGaugeTool(long image, long start, long end, int method, long edgeOptions, long reference, long distance)
+ * C: int imaqLineGaugeTool(const Image* image, Point start, Point end, LineGaugeMethod method, const EdgeOptions* edgeOptions, const CoordinateTransform* reference, float* distance)
+ */
+
+JNIEXPORT jfloat JNICALL Java_com_ni_vision_NIVision__1imaqLineGaugeTool(JNIEnv* env, jclass , jlong image, jlong start, jlong end, jint method, jlong edgeOptions, jlong reference, jlong distance)
+{
+    int rv = imaqLineGaugeTool((const Image*)image, *((Point*)start), *((Point*)end), (LineGaugeMethod)method, (const EdgeOptions*)edgeOptions, (const CoordinateTransform*)reference, (float*)distance);
+    if (rv == 0) throwJavaException(env);
+    return (jfloat)rv;
+}
+
+/* J: void imaqBestCircle(PointFloat[] points)
+ * JN: void imaqBestCircle(long points, int numPoints, long center, long radius)
+ * C: int imaqBestCircle(const PointFloat* points, int numPoints, PointFloat* center, double* radius)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqBestCircle(JNIEnv* env, jclass , jlong points, jint numPoints, jlong center, jlong radius)
+{
+    int rv = imaqBestCircle((const PointFloat*)points, (int)numPoints, (PointFloat*)center, (double*)radius);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqSavePattern(Image pattern, String fileName)
+ * JN: void imaqSavePattern(long pattern, long fileName)
+ * C: int imaqSavePattern(const Image* pattern, const char* fileName)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSavePattern(JNIEnv* env, jclass , jlong pattern, jlong fileName)
+{
+    int rv = imaqSavePattern((const Image*)pattern, (const char*)fileName);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqLoadPattern(Image pattern, String fileName)
+ * JN: void imaqLoadPattern(long pattern, long fileName)
+ * C: int imaqLoadPattern(Image* pattern, const char* fileName)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLoadPattern(JNIEnv* env, jclass , jlong pattern, jlong fileName)
+{
+    int rv = imaqLoadPattern((Image*)pattern, (const char*)fileName);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqTransformROI(ROI roi, Point originStart, float angleStart, Point originFinal, float angleFinal)
+ * JN: void imaqTransformROI(long roi, long originStart, float angleStart, long originFinal, float angleFinal)
+ * C: int imaqTransformROI(ROI* roi, Point originStart, float angleStart, Point originFinal, float angleFinal)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqTransformROI(JNIEnv* env, jclass , jlong roi, jlong originStart, jfloat angleStart, jlong originFinal, jfloat angleFinal)
+{
+    int rv = imaqTransformROI((ROI*)roi, *((Point*)originStart), (float)angleStart, *((Point*)originFinal), (float)angleFinal);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqCoordinateReference(Point points, ReferenceMode mode)
+ * JN: void imaqCoordinateReference(long points, int mode, long origin, long angle)
+ * C: int imaqCoordinateReference(const Point* points, ReferenceMode mode, Point* origin, float* angle)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCoordinateReference(JNIEnv* env, jclass , jlong points, jint mode, jlong origin, jlong angle)
+{
+    int rv = imaqCoordinateReference((const Point*)points, (ReferenceMode)mode, (Point*)origin, (float*)angle);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: ContourInfo imaqGetContourInfo(ROI roi, int id)
+ * JN: long imaqGetContourInfo(long roi, int id)
+ * C: ContourInfo* imaqGetContourInfo(const ROI* roi, ContourID id)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetContourInfo(JNIEnv* env, jclass , jlong roi, jint id)
+{
+    ContourInfo* rv = imaqGetContourInfo((const ROI*)roi, (ContourID)id);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqSetWindowOverlay(int windowNumber, Overlay overlay)
+ * JN: void imaqSetWindowOverlay(int windowNumber, long overlay)
+ * C: int imaqSetWindowOverlay(int windowNumber, const Overlay* overlay)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetWindowOverlay(JNIEnv* env, jclass , jint windowNumber, jlong overlay)
+{
+    int rv = imaqSetWindowOverlay((int)windowNumber, (const Overlay*)overlay);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: Overlay imaqCreateOverlayFromROI(ROI roi)
+ * JN: long imaqCreateOverlayFromROI(long roi)
+ * C: Overlay* imaqCreateOverlayFromROI(const ROI* roi)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCreateOverlayFromROI(JNIEnv* env, jclass , jlong roi)
+{
+    Overlay* rv = imaqCreateOverlayFromROI((const ROI*)roi);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqSetCalibrationInfo(Image image, CalibrationUnit unit, float xDistance, float yDistance)
+ * JN: void imaqSetCalibrationInfo(long image, int unit, float xDistance, float yDistance)
+ * C: int imaqSetCalibrationInfo(Image* image, CalibrationUnit unit, float xDistance, float yDistance)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetCalibrationInfo(JNIEnv* env, jclass , jlong image, jint unit, jfloat xDistance, jfloat yDistance)
+{
+    int rv = imaqSetCalibrationInfo((Image*)image, (CalibrationUnit)unit, (float)xDistance, (float)yDistance);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqGetCalibrationInfo(Image image)
+ * JN: void imaqGetCalibrationInfo(long image, long unit, long xDistance, long yDistance)
+ * C: int imaqGetCalibrationInfo(const Image* image, CalibrationUnit* unit, float* xDistance, float* yDistance)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetCalibrationInfo(JNIEnv* env, jclass , jlong image, jlong unit, jlong xDistance, jlong yDistance)
+{
+    int rv = imaqGetCalibrationInfo((const Image*)image, (CalibrationUnit*)unit, (float*)xDistance, (float*)yDistance);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: int imaqConstructROI(Image image, ROI roi, Tool initialTool, ToolWindowOptions tools, ConstructROIOptions options)
+ * JN: int imaqConstructROI(long image, long roi, int initialTool, long tools, long options, long okay)
+ * C: int imaqConstructROI(const Image* image, ROI* roi, Tool initialTool, const ToolWindowOptions* tools, const ConstructROIOptions* options, int* okay)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqConstructROI(JNIEnv* env, jclass , jlong image, jlong roi, jint initialTool, jlong tools, jlong options, jlong okay)
+{
+    int rv = imaqConstructROI((const Image*)image, (ROI*)roi, (Tool)initialTool, (const ToolWindowOptions*)tools, (const ConstructROIOptions*)options, (int*)okay);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: void imaqGetParticleClassifierOptions(ClassifierSession session)
+ * JN: void imaqGetParticleClassifierOptions(long session, long preprocessingOptions, long options)
+ * C: int imaqGetParticleClassifierOptions(const ClassifierSession* session, ParticleClassifierPreprocessingOptions* preprocessingOptions, ParticleClassifierOptions* options)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetParticleClassifierOptions(JNIEnv* env, jclass , jlong session, jlong preprocessingOptions, jlong options)
+{
+    int rv = imaqGetParticleClassifierOptions((const ClassifierSession*)session, (ParticleClassifierPreprocessingOptions*)preprocessingOptions, (ParticleClassifierOptions*)options);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqZoomWindow(int windowNumber, int xZoom, int yZoom, Point center)
+ * JN: void imaqZoomWindow(int windowNumber, int xZoom, int yZoom, long center)
+ * C: int imaqZoomWindow(int windowNumber, int xZoom, int yZoom, Point center)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqZoomWindow(JNIEnv* env, jclass , jint windowNumber, jint xZoom, jint yZoom, jlong center)
+{
+    int rv = imaqZoomWindow((int)windowNumber, (int)xZoom, (int)yZoom, *((Point*)center));
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqGetWindowZoom(int windowNumber)
+ * JN: void imaqGetWindowZoom(int windowNumber, long xZoom, long yZoom)
+ * C: int imaqGetWindowZoom(int windowNumber, int* xZoom, int* yZoom)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqGetWindowZoom(JNIEnv* env, jclass , jint windowNumber, jlong xZoom, jlong yZoom)
+{
+    int rv = imaqGetWindowZoom((int)windowNumber, (int*)xZoom, (int*)yZoom);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: int imaqParticleFilter3(Image dest, Image source, ParticleFilterCriteria2 criteria, int criteriaCount, ParticleFilterOptions options, ROI roi)
+ * JN: int imaqParticleFilter3(long dest, long source, long criteria, int criteriaCount, long options, long roi, long numParticles)
+ * C: int imaqParticleFilter3(Image* dest, Image* source, const ParticleFilterCriteria2* criteria, int criteriaCount, const ParticleFilterOptions* options, const ROI* roi, int* numParticles)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqParticleFilter3(JNIEnv* env, jclass , jlong dest, jlong source, jlong criteria, jint criteriaCount, jlong options, jlong roi, jlong numParticles)
+{
+    int rv = imaqParticleFilter3((Image*)dest, (Image*)source, (const ParticleFilterCriteria2*)criteria, (int)criteriaCount, (const ParticleFilterOptions*)options, (const ROI*)roi, (int*)numParticles);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: ReadTextReport2 imaqReadText2(Image image, CharSet set, ROI roi, ReadTextOptions readOptions, OCRProcessingOptions processingOptions, OCRSpacingOptions spacingOptions)
+ * JN: long imaqReadText2(long image, long set, long roi, long readOptions, long processingOptions, long spacingOptions)
+ * C: ReadTextReport2* imaqReadText2(const Image* image, const CharSet* set, const ROI* roi, const ReadTextOptions* readOptions, const OCRProcessingOptions* processingOptions, const OCRSpacingOptions* spacingOptions)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadText2(JNIEnv* env, jclass , jlong image, jlong set, jlong roi, jlong readOptions, jlong processingOptions, jlong spacingOptions)
+{
+    ReadTextReport2* rv = imaqReadText2((const Image*)image, (const CharSet*)set, (const ROI*)roi, (const ReadTextOptions*)readOptions, (const OCRProcessingOptions*)processingOptions, (const OCRSpacingOptions*)spacingOptions);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: LearnPatternAdvancedOptions imaqLearnPattern2(Image image, LearningMode learningMode)
+ * JN: long imaqLearnPattern2(long image, int learningMode, long advancedOptions)
+ * C: int imaqLearnPattern2(Image* image, LearningMode learningMode, LearnPatternAdvancedOptions* advancedOptions)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqLearnPattern2(JNIEnv* env, jclass , jlong image, jint learningMode, jlong advancedOptions)
+{
+    int rv = imaqLearnPattern2((Image*)image, (LearningMode)learningMode, (LearnPatternAdvancedOptions*)advancedOptions);
+    if (rv == 0) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqDivide(Image dest, Image sourceA, Image sourceB)
+ * JN: void imaqDivide(long dest, long sourceA, long sourceB)
+ * C: int imaqDivide(Image* dest, const Image* sourceA, const Image* sourceB)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDivide(JNIEnv* env, jclass , jlong dest, jlong sourceA, jlong sourceB)
+{
+    int rv = imaqDivide((Image*)dest, (const Image*)sourceA, (const Image*)sourceB);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: EdgeReport2 imaqEdgeTool3(Image image, ROI roi, EdgeProcess processType, EdgeOptions2 edgeOptions)
+ * JN: long imaqEdgeTool3(long image, long roi, int processType, long edgeOptions)
+ * C: EdgeReport2* imaqEdgeTool3(const Image* image, const ROI* roi, EdgeProcess processType, const EdgeOptions2* edgeOptions)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqEdgeTool3(JNIEnv* env, jclass , jlong image, jlong roi, jint processType, jlong edgeOptions)
+{
+    EdgeReport2* rv = imaqEdgeTool3((const Image*)image, (const ROI*)roi, (EdgeProcess)processType, (const EdgeOptions2*)edgeOptions);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ConcentricRakeReport imaqConcentricRake(Image image, ROI roi, ConcentricRakeDirection direction, EdgeProcess process, RakeOptions options)
+ * JN: long imaqConcentricRake(long image, long roi, int direction, int process, long options)
+ * C: ConcentricRakeReport* imaqConcentricRake(const Image* image, const ROI* roi, ConcentricRakeDirection direction, EdgeProcess process, const RakeOptions* options)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqConcentricRake(JNIEnv* env, jclass , jlong image, jlong roi, jint direction, jint process, jlong options)
+{
+    ConcentricRakeReport* rv = imaqConcentricRake((const Image*)image, (const ROI*)roi, (ConcentricRakeDirection)direction, (EdgeProcess)process, (const RakeOptions*)options);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: SpokeReport imaqSpoke(Image image, ROI roi, SpokeDirection direction, EdgeProcess process, SpokeOptions options)
+ * JN: long imaqSpoke(long image, long roi, int direction, int process, long options)
+ * C: SpokeReport* imaqSpoke(const Image* image, const ROI* roi, SpokeDirection direction, EdgeProcess process, const SpokeOptions* options)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqSpoke(JNIEnv* env, jclass , jlong image, jlong roi, jint direction, jint process, jlong options)
+{
+    SpokeReport* rv = imaqSpoke((const Image*)image, (const ROI*)roi, (SpokeDirection)direction, (EdgeProcess)process, (const SpokeOptions*)options);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqLearnPattern(Image image, LearningMode learningMode)
+ * JN: void imaqLearnPattern(long image, int learningMode)
+ * C: int imaqLearnPattern(Image* image, LearningMode learningMode)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqLearnPattern(JNIEnv* env, jclass , jlong image, jint learningMode)
+{
+    int rv = imaqLearnPattern((Image*)image, (LearningMode)learningMode);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: MatchPattern2Result imaqMatchPattern2(Image image, Image pattern, MatchPatternOptions options, MatchPatternAdvancedOptions advancedOptions, Rect searchRect)
+ * JN: long imaqMatchPattern2(long image, long pattern, long options, long advancedOptions, long searchRect, long numMatches)
+ * C: PatternMatch* imaqMatchPattern2(const Image* image, const Image* pattern, const MatchPatternOptions* options, const MatchPatternAdvancedOptions* advancedOptions, Rect searchRect, int* numMatches)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchPattern2(JNIEnv* env, jclass , jlong image, jlong pattern, jlong options, jlong advancedOptions, jlong searchRect, jlong numMatches)
+{
+    PatternMatch* rv = imaqMatchPattern2((const Image*)image, (const Image*)pattern, (const MatchPatternOptions*)options, (const MatchPatternAdvancedOptions*)advancedOptions, *((Rect*)searchRect), (int*)numMatches);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: void imaqSetParticleClassifierOptions(ClassifierSession session, ParticleClassifierPreprocessingOptions preprocessingOptions, ParticleClassifierOptions options)
+ * JN: void imaqSetParticleClassifierOptions(long session, long preprocessingOptions, long options)
+ * C: int imaqSetParticleClassifierOptions(ClassifierSession* session, const ParticleClassifierPreprocessingOptions* preprocessingOptions, const ParticleClassifierOptions* options)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetParticleClassifierOptions(JNIEnv* env, jclass , jlong session, jlong preprocessingOptions, jlong options)
+{
+    int rv = imaqSetParticleClassifierOptions((ClassifierSession*)session, (const ParticleClassifierPreprocessingOptions*)preprocessingOptions, (const ParticleClassifierOptions*)options);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: void imaqCopyCalibrationInfo(Image dest, Image source)
+ * JN: void imaqCopyCalibrationInfo(long dest, long source)
+ * C: int imaqCopyCalibrationInfo(Image* dest, const Image* source)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqCopyCalibrationInfo(JNIEnv* env, jclass , jlong dest, jlong source)
+{
+    int rv = imaqCopyCalibrationInfo((Image*)dest, (const Image*)source);
+    if (rv == 0) throwJavaException(env);
+}
+
+/* J: int imaqParticleFilter2(Image dest, Image source, ParticleFilterCriteria2[] criteria, int rejectMatches, int connectivity8)
+ * JN: int imaqParticleFilter2(long dest, long source, long criteria, int criteriaCount, int rejectMatches, int connectivity8, long numParticles)
+ * C: int imaqParticleFilter2(Image* dest, Image* source, const ParticleFilterCriteria2* criteria, int criteriaCount, int rejectMatches, int connectivity8, int* numParticles)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqParticleFilter2(JNIEnv* env, jclass , jlong dest, jlong source, jlong criteria, jint criteriaCount, jint rejectMatches, jint connectivity8, jlong numParticles)
+{
+    int rv = imaqParticleFilter2((Image*)dest, (Image*)source, (const ParticleFilterCriteria2*)criteria, (int)criteriaCount, (int)rejectMatches, (int)connectivity8, (int*)numParticles);
+    if (rv == 0) throwJavaException(env);
+    return (jint)rv;
+}
+
+/* J: EdgeTool2Result imaqEdgeTool2(Image image, Point points, int numPoints, EdgeProcess process, EdgeOptions options)
+ * JN: long imaqEdgeTool2(long image, long points, int numPoints, int process, long options, long numEdges)
+ * C: EdgeReport* imaqEdgeTool2(const Image* image, const Point* points, int numPoints, EdgeProcess process, const EdgeOptions* options, int* numEdges)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqEdgeTool2(JNIEnv* env, jclass , jlong image, jlong points, jint numPoints, jint process, jlong options, jlong numEdges)
+{
+    EdgeReport* rv = imaqEdgeTool2((const Image*)image, (const Point*)points, (int)numPoints, (EdgeProcess)process, (const EdgeOptions*)options, (int*)numEdges);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: int imaqAddRotatedRectContour(ROI roi, RotatedRect rect)
+ * JN: int imaqAddRotatedRectContour(long roi, long rect)
+ * C: ContourID imaqAddRotatedRectContour(ROI* roi, RotatedRect rect)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqAddRotatedRectContour(JNIEnv* env, jclass , jlong roi, jlong rect)
+{
+    ContourID rv = imaqAddRotatedRectContour((ROI*)roi, *((RotatedRect*)rect));
+    
+    return (jint)rv;
+}
+
+/* J: ReadDataMatrixBarcodeResult imaqReadDataMatrixBarcode(Image image, ROI roi, DataMatrixOptions options)
+ * JN: long imaqReadDataMatrixBarcode(long image, long roi, long options, long numBarcodes)
+ * C: Barcode2DInfo* imaqReadDataMatrixBarcode(const Image* image, const ROI* roi, const DataMatrixOptions* options, unsigned int* numBarcodes)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadDataMatrixBarcode(JNIEnv* env, jclass , jlong image, jlong roi, jlong options, jlong numBarcodes)
+{
+    Barcode2DInfo* rv = imaqReadDataMatrixBarcode((const Image*)image, (const ROI*)roi, (const DataMatrixOptions*)options, (unsigned int*)numBarcodes);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: LinearAverages imaqLinearAverages(Image image, Rect rect)
+ * JN: long imaqLinearAverages(long image, long rect)
+ * C: LinearAverages* imaqLinearAverages(const Image* image, Rect rect)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqLinearAverages(JNIEnv* env, jclass , jlong image, jlong rect)
+{
+    LinearAverages* rv = imaqLinearAverages((const Image*)image, *((Rect*)rect));
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: MatchGeometricPatternResult imaqMatchGeometricPattern(Image image, Image pattern, CurveOptions curveOptions, MatchGeometricPatternOptions matchOptions, MatchGeometricPatternAdvancedOptions advancedMatchOptions, ROI roi)
+ * JN: long imaqMatchGeometricPattern(long image, long pattern, long curveOptions, long matchOptions, long advancedMatchOptions, long roi, long numMatches)
+ * C: GeometricPatternMatch* imaqMatchGeometricPattern(const Image* image, const Image* pattern, const CurveOptions* curveOptions, const MatchGeometricPatternOptions* matchOptions, const MatchGeometricPatternAdvancedOptions* advancedMatchOptions, const ROI* roi, int* numMatches)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchGeometricPattern(JNIEnv* env, jclass , jlong image, jlong pattern, jlong curveOptions, jlong matchOptions, jlong advancedMatchOptions, jlong roi, jlong numMatches)
+{
+    GeometricPatternMatch* rv = imaqMatchGeometricPattern((const Image*)image, (const Image*)pattern, (const CurveOptions*)curveOptions, (const MatchGeometricPatternOptions*)matchOptions, (const MatchGeometricPatternAdvancedOptions*)advancedMatchOptions, (const ROI*)roi, (int*)numMatches);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: CharInfo imaqGetCharInfo(CharSet set, int index)
+ * JN: long imaqGetCharInfo(long set, int index)
+ * C: CharInfo* imaqGetCharInfo(const CharSet* set, int index)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetCharInfo(JNIEnv* env, jclass , jlong set, jint index)
+{
+    CharInfo* rv = imaqGetCharInfo((const CharSet*)set, (int)index);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ReadTextReport imaqReadText(Image image, CharSet set, ROI roi, ReadTextOptions readOptions, OCRProcessingOptions processingOptions, OCRSpacingOptions spacingOptions)
+ * JN: long imaqReadText(long image, long set, long roi, long readOptions, long processingOptions, long spacingOptions)
+ * C: ReadTextReport* imaqReadText(const Image* image, const CharSet* set, const ROI* roi, const ReadTextOptions* readOptions, const OCRProcessingOptions* processingOptions, const OCRSpacingOptions* spacingOptions)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadText(JNIEnv* env, jclass , jlong image, jlong set, jlong roi, jlong readOptions, jlong processingOptions, jlong spacingOptions)
+{
+    ReadTextReport* rv = imaqReadText((const Image*)image, (const CharSet*)set, (const ROI*)roi, (const ReadTextOptions*)readOptions, (const OCRProcessingOptions*)processingOptions, (const OCRSpacingOptions*)spacingOptions);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ThresholdData imaqAutoThreshold(Image dest, Image source, int numClasses, ThresholdMethod method)
+ * JN: long imaqAutoThreshold(long dest, long source, int numClasses, int method)
+ * C: ThresholdData* imaqAutoThreshold(Image* dest, Image* source, int numClasses, ThresholdMethod method)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqAutoThreshold(JNIEnv* env, jclass , jlong dest, jlong source, jint numClasses, jint method)
+{
+    ThresholdData* rv = imaqAutoThreshold((Image*)dest, (Image*)source, (int)numClasses, (ThresholdMethod)method);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: ColorHistogramReport imaqColorHistogram(Image image, int numClasses, ColorMode mode, Image mask)
+ * JN: long imaqColorHistogram(long image, int numClasses, int mode, long mask)
+ * C: ColorHistogramReport* imaqColorHistogram(Image* image, int numClasses, ColorMode mode, const Image* mask)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqColorHistogram(JNIEnv* env, jclass , jlong image, jint numClasses, jint mode, jlong mask)
+{
+    ColorHistogramReport* rv = imaqColorHistogram((Image*)image, (int)numClasses, (ColorMode)mode, (const Image*)mask);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
+/* J: RakeReport imaqRake(Image image, ROI roi, RakeDirection direction, EdgeProcess process, RakeOptions options)
+ * JN: long imaqRake(long image, long roi, int direction, int process, long options)
+ * C: RakeReport* imaqRake(const Image* image, const ROI* roi, RakeDirection direction, EdgeProcess process, const RakeOptions* options)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqRake(JNIEnv* env, jclass , jlong image, jlong roi, jint direction, jint process, jlong options)
+{
+    RakeReport* rv = imaqRake((const Image*)image, (const ROI*)roi, (RakeDirection)direction, (EdgeProcess)process, (const RakeOptions*)options);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+}
diff --git a/wpilibj/wpilibJavaJNI/nivision/gen_java.py b/wpilibj/wpilibJavaJNI/nivision/gen_java.py
new file mode 100644
index 0000000000000000000000000000000000000000..465413f1755a8d227295c2a2354e8941d8bec05b
--- /dev/null
+++ b/wpilibj/wpilibJavaJNI/nivision/gen_java.py
@@ -0,0 +1,1670 @@
+from __future__ import print_function
+import sys
+import os
+import re
+try:
+    import configparser
+except ImportError:
+    import ConfigParser as configparser
+
+from nivision_parse import *
+
+java_accessor_map = {
+        "B": "",
+        "C": "Char",
+        "S": "Short",
+        "I": "Int",
+        "J": "Long",
+        "F": "Float",
+        "D": "Double",
+        }
+
+java_size_map = {
+        "B": 1,
+        "C": 2,
+        "S": 2,
+        "I": 4,
+        "J": 8,
+        "F": 4,
+        "D": 8,
+        }
+
+class JavaType:
+    def __init__(self, j_type, jn_type, jni_type, jni_sig, is_enum=False, is_struct=False, is_opaque=False, string_array=False, array_size=None):
+        self.j_type = j_type
+        self.jn_type = jn_type
+        self.jni_type = jni_type
+        self.jni_sig = jni_sig
+        self.is_enum = is_enum
+        self.is_struct = is_struct
+        self.is_opaque = is_opaque
+        self.string_array = string_array
+        self.array_size = array_size
+
+    def copy(self):
+        return JavaType(self.j_type, self.jn_type, self.jni_type, self.jni_sig,
+                        is_enum=self.is_enum, is_struct=self.is_struct,
+                        is_opaque=self.is_opaque,
+                        string_array=self.string_array,
+                        array_size=self.array_size)
+
+    def __repr__(self):
+        return "JavaType(%s, %s, %s, %s, is_enum=%s, is_struct=%s, is_opaque=%s, string_array=%s, array_size=%s)" % (
+                self.j_type, self.jn_type, self.jni_type, self.jni_sig,
+                self.is_enum, self.is_struct,
+                self.is_opaque, self.string_array, self.array_size)
+
+java_types_map = {
+        ("void", None): JavaType("void", "void", "void", None),
+        ("env", None): JavaType("", "", "JNIEnv*", None),
+        ("cls", None): JavaType("", "", "jclass", None),
+        ("int", None): JavaType("int", "int", "jint", "I"),
+        ("char", None): JavaType("byte", "byte", "jbyte", "B"),
+        ("wchar_t", None): JavaType("char", "char", "jchar", "C"),
+        ("unsigned char", None): JavaType("short", "short", "jshort", "S"),
+        ("short", None): JavaType("short", "short", "jshort", "S"),
+        ("unsigned short", None): JavaType("int", "int", "jint", "I"),
+        ("unsigned", None): JavaType("int", "int", "jint", "I"),
+        ("unsigned int", None): JavaType("int", "int", "jint", "I"),
+        ("long", None): JavaType("long", "long", "jlong", "J"),
+        ("unsigned long", None): JavaType("long", "long", "jlong", "J"),
+        ("__int64", None): JavaType("long", "long", "jlong", "J"),
+        ("long long", None): JavaType("long", "long", "jlong", "J"),
+        ("unsigned __int64", None): JavaType("long", "long", "jlong", "J"),
+        ("__uint64", None): JavaType("long", "long", "jlong", "J"),
+        ("unsigned long long", None): JavaType("long", "long", "jlong", "J"),
+        ("float", None): JavaType("float", "float", "jfloat", "F"),
+        ("double", None): JavaType("double", "double", "jdouble", "D"),
+        ("long double", None): JavaType("double", "double", "jdouble", "D"),
+        ("unsigned char*", None): JavaType("String", "String", "jstring", "Ljava/lang/String;"),
+        ("char*", None): JavaType("String", "String", "jstring", "Ljava/lang/String;"),
+        #("void*", None): JavaType("c_void_p", "long", "jlong", "J"),
+        #("size_t", None): JavaType("long", "long", "jlong", "J"),
+        ("String255", None): JavaType("String", "String", "jstring", "Ljava/lang/String;", string_array=True, array_size="256"),
+        ("String255", ""): JavaType("String[]", "String[]", "jstringArray", "[Ljava/lang/String;", string_array=True, array_size="256"),
+        ("char*", ""): JavaType("String[]", "String[]", "jstringArray", "[Ljava/lang/String;"),
+        ("char", ""): JavaType("String", "String", "jstring", "Ljava/lang/String;", string_array=True, array_size=""),
+        ("unsigned char", ""): JavaType("byte[]", "byte[]", "jbyteArray", "[B"),
+        ("short", ""): JavaType("short[]", "short[]", "jshortArray", "[S"),
+        ("int", ""): JavaType("int[]", "int[]", "jintArray", "[I"),
+        ("unsigned int", ""): JavaType("int[]", "int[]", "jintArray", "[I"),
+        ("long", ""): JavaType("long[]", "long[]", "jlongArray", "[J"),
+        ("float", ""): JavaType("float[]", "float[]", "jfloatArray", "[F"),
+        ("double", ""): JavaType("double[]", "double[]", "jdoubleArray", "[D"),
+        }
+
+def c_to_jtype(name, arr):
+    jtype = java_types_map.get((name, arr), None)
+    if jtype is not None:
+        return jtype
+
+    # sized array is treated the same as unsized
+    if arr is not None and arr != "":
+        jtype = c_to_jtype(name, "").copy()
+        jtype.array_size = arr
+        java_types_map[(name, arr)] = jtype # cache
+        return jtype
+
+    # Opaque structures
+    if name in opaque_structs:
+        if arr is None:
+            jtype = JavaType(name, "long", "jlong", "J", is_opaque=True)
+        else:
+            # FIXME
+            jtype = JavaType(name+"[]", "long[]", "jlongArray", "[J", is_opaque=True)
+        java_types_map[(name, arr)] = jtype # cache
+        return jtype
+
+    # Enums
+    if name in enums:
+        if arr is None:
+            jtype = JavaType(name, "int", "jint", "I", is_enum=True)
+        else:
+            # FIXME
+            jtype = JavaType(name+"[]", "int[]", "jintArray", "[I", is_enum=True)
+        java_types_map[(name, arr)] = jtype # cache
+        return jtype
+
+    # handle pointers as void* (FIXME)
+    if name[-1] == '*':
+        if name[:-1] not in structs and name[:-1] not in defined:
+            return java_types_map[("void*", None)]
+        return c_to_jtype(name[:-1], arr)
+
+    # Otherwise it's a normal structure object
+    if arr is None:
+        jtype = JavaType(name, "long", "jlong", "J", is_struct=True)
+    else:
+        # FIXME
+        jtype = JavaType(name+"[]", "long[]", "jlongArray", "[J", is_struct=True)
+    java_types_map[(name, arr)] = jtype
+    return jtype
+
+class JavaEmitData:
+    def __init__(self):
+        self.construct = []
+        self.backingRead = []
+        self.read = []
+        self.writeBufs = []
+        self.write = []
+        self.backingWrite = []
+        self.toArg = ""
+
+    def addConstruct(self, s):
+        self.construct.extend(s.split('\n')[1 if s[0]=='\n' else 0:])
+
+    def addBackingRead(self, s):
+        self.backingRead.extend(s.split('\n')[1 if s[0]=='\n' else 0:])
+
+    def addRead(self, s):
+        self.read.extend(s.split('\n')[1 if s[0]=='\n' else 0:])
+
+    def addWriteBuf(self, s):
+        self.writeBufs.append(s)
+
+    def addWrite(self, s):
+        self.write.extend(s.split('\n')[1 if s[0]=='\n' else 0:])
+
+    def addBackingWrite(self, s):
+        self.backingWrite.extend(s.split('\n')[1 if s[0]=='\n' else 0:])
+
+class JavaEmitArrayData(JavaEmitData):
+    def __init__(self):
+        JavaEmitData.__init__(self)
+        self.addConstruct("{fname} = new {ftype_one}[0];")
+        self.addBackingRead("int {size_fname} = {backing}.get{jaccessor}({size_foffset});")
+        self.addBackingWrite("{backing}.put{jaccessor}({size_foffset}, {fname}.length);")
+
+# sized array of null-terminated strings
+strzArrayEmitSized = JavaEmitArrayData()
+strzArrayEmitSized.addBackingRead("long {fname}_addr = getPointer({backing}, {foffset});")
+strzArrayEmitSized.addRead("""
+{fname} = new String[{size_fname}];
+if ({size_fname} > 0 && {fname}_addr != 0) {{
+    ByteBuffer bb = newDirectByteBuffer({fname}_addr, {size_fname}*{pointer_sz});
+    for (int i=0, off=0; i<{size_fname}; i++, off += {pointer_sz}) {{
+        long addr = getPointer(bb, off);
+        if (addr == 0)
+            {fname}[i] = null;
+        else {{
+            ByteBuffer bb2 = newDirectByteBuffer(addr, 1000); // FIXME
+            while (bb2.get() != 0) {{}}
+            byte[] bytes = new byte[bb2.position()-1];
+            bb2.rewind();
+            getBytes(bb2, bytes, 0, bytes.length);
+            try {{
+                {fname}[i] = new String(bytes, "UTF-8");
+            }} catch (UnsupportedEncodingException e) {{
+                {fname}[i] = "";
+            }}
+        }}
+    }}
+}}""")
+strzArrayEmitSized.addWriteBuf("{buftype} {fname}_buf")
+strzArrayEmitSized.addWriteBuf("{buftype}[] {fname}_bufs")
+strzArrayEmitSized.addWrite("""
+{fname}_buf = ByteBuffer.allocateDirect({fname}.length*{pointer_sz});
+for (int i=0, off=0; i<{fname}.length; i++, off += {pointer_sz}) {{
+    if ({fname}[i] == null)
+        putPointer({fname}_buf, off, 0);
+    else {{
+        byte[] bytes;
+        try {{
+            bytes = {fname}[i].getBytes("UTF-8");
+        }} catch (UnsupportedEncodingException e) {{
+            bytes = new byte[0];
+        }}
+        {fname}_bufs[i] = ByteBuffer.allocateDirect(bytes.length+1);
+        putBytes({fname}_bufs[i], bytes, 0, bytes.length).put(bytes.length, (byte)0);
+        putPointer({fname}_buf, off, getByteBufferAddress({fname}_bufs[i]));
+    }}
+}}""")
+strzArrayEmitSized.addBackingWrite("putPointer({backing}, {foffset}, {fname}_buf);")
+
+# unsized array; final terminating zero determines the length
+strzArrayEmitUnsized = JavaEmitData()
+strzArrayEmitUnsized.addConstruct("{fname} = new {ftype_one}[0];")
+strzArrayEmitUnsized.addBackingRead("long {fname}_addr = getPointer({backing}, {foffset});")
+strzArrayEmitUnsized.addRead("""
+{{
+    if ({fname}_addr == 0)
+        {fname} = new {ftype_one}[0];
+    else {{
+        // prescan to find length
+        ByteBuffer bb = newDirectByteBuffer({fname}_addr, 1000*{pointer_sz}); // FIXME
+        int size = 0;
+        for (int off=0; getPointer(bb, off) != 0; size++, off += {pointer_sz}) {{ }}
+        {fname} = new String[size];
+        for (int i=0, off=0; i<size; i++, off += {pointer_sz}) {{
+            long addr = getPointer(bb, off);
+            if (addr == 0)
+                {fname}[i] = null;
+            else {{
+                ByteBuffer bb2 = newDirectByteBuffer(addr, 1000); // FIXME
+                while (bb2.get() != 0) {{}}
+                byte[] bytes = new byte[bb2.position()-1];
+                bb2.rewind();
+                getBytes(bb2, 0, bytes.length);
+                try {{
+                    {fname}[i] = new String(bytes, "UTF-8");
+                }} catch (UnsupportedEncodingException e) {{
+                    {fname}[i] = "";
+                }}
+            }}
+        }}
+    }}
+}}""")
+strzArrayEmitUnsized.addWriteBuf("{buftype} {fname}_buf")
+strzArrayEmitUnsized.addWriteBuf("{buftype}[] {fname}_bufs")
+strzArrayEmitUnsized.addWrite("""
+{fname}_buf = ByteBuffer.allocateDirect(({fname}.length+1)*{pointer_sz});
+for (int i=0, off=0; i<{fname}.length; i++, off += {pointer_sz}) {{
+    if ({fname}[i] == null)
+        putPointer({fname}_buf, off, 0);
+    else {{
+        byte[] bytes;
+        try {{
+            bytes = {fname}[i].getBytes("UTF-8");
+        }} catch (UnsupportedEncodingException e) {{
+            bytes = new byte[0];
+        }}
+        {fname}_bufs[i] = ByteBuffer.allocateDirect(bytes.length+1);
+        putBytes({fname}_bufs[i], bytes, 0, bytes.length).put(bytes.length, (byte)0);
+        putPointer({fname}_buf, off, getByteBufferAddress({fname}_bufs[i]));
+    }}
+}}
+putPointer({fname}_buf, {fname}.length*{pointer_sz}, 0); // terminator""")
+strzArrayEmitUnsized.addBackingWrite("putPointer({backing}, {foffset}, {fname}_buf);")
+
+# array of enum values
+enumArrayEmit = JavaEmitArrayData()
+enumArrayEmit.addBackingRead("long {fname}_addr = getPointer({backing}, {foffset});")
+enumArrayEmit.addRead("""
+{fname} = new {ftype_one}[{size_fname}];
+if ({size_fname} > 0 && {fname}_addr != 0) {{
+    ByteBuffer bb = newDirectByteBuffer({fname}_addr, {size_fname}*%d);
+    for (int i=0, off=0; i<{size_fname}; i++, off += %d) {{
+        {fname}[i] = {ftype_one}.fromValue(bb.getInt(off));
+    }}
+}}""" % (4, 4))
+enumArrayEmit.addWriteBuf("{buftype} {fname}_buf")
+enumArrayEmit.addWrite("""
+{fname}_buf = ByteBuffer.allocateDirect({fname}.length*%d);
+for (int i=0, off=0; i<{fname}.length; i++, off += %d) {{
+    if ({fname} != null)
+        {fname}_buf.putInt(off, {fname}[i].getValue());
+}}""" % (4, 4))
+enumArrayEmit.addBackingWrite("putPointer({backing}, {foffset}, {fname}_buf);")
+enumArrayEmit.toArg = "getByteBufferAddress({fname}_buf)"
+
+# array of opaque structures
+opaqueArrayEmit = JavaEmitArrayData()
+opaqueArrayEmit.addBackingRead("long {fname}_addr = getPointer({backing}, {foffset});")
+opaqueArrayEmit.addRead("""
+{fname} = new {ftype_one}[{size_fname}];
+if ({size_fname} > 0 && {fname}_addr != 0) {{
+    ByteBuffer bb = newDirectByteBuffer({fname}_addr, {size_fname}*{pointer_sz});
+    for (int i=0, off=0; i<{size_fname}; i++, off += {pointer_sz}) {{
+        {fname}[i] = new {ftype_one}(getPointer(bb, off), false);
+    }}
+}}""")
+opaqueArrayEmit.addWriteBuf("{buftype} {fname}_buf")
+opaqueArrayEmit.addWrite("""
+{fname}_buf = ByteBuffer.allocateDirect({fname}.length*{pointer_sz});
+for (int i=0, off=0; i<{fname}.length; i++, off += {pointer_sz}) {{
+    putPointer({fname}_buf, off, {fname}[i]);
+}}""")
+opaqueArrayEmit.addBackingWrite("putPointer({backing}, {foffset}, {fname}_buf);")
+opaqueArrayEmit.toArg = "getByteBufferAddress({fname}_buf)"
+
+# array of String255
+string255ArrayEmit = JavaEmitArrayData()
+string255ArrayEmit.addBackingRead("""
+{fname} = new String[{size_fname}];
+if ({size_fname} > 0) {{
+    byte[] bytes = new byte[%d];
+    int len;
+    for (int i=0, off={foffset}; i<{size_fname}; i++, off += %d) {{
+        getBytes({backing}, bytes, off, %d);
+        for (len=0; len<bytes.length && bytes[len] != 0; len++) {{}}
+        try {{
+            {fname}[i] = new String(bytes, 0, len, "UTF-8");
+        }} catch (UnsupportedEncodingException e) {{
+            {fname}[i] = "";
+        }}
+    }}
+}}""" % (256, 256, 256))
+string255ArrayEmit.addBackingWrite("""
+for (int i=0, off={foffset}; i<{size_fname}; i++, off += %d) {{
+    byte[] bytes;
+    try {{
+        bytes = {fname}.getBytes("UTF-8");
+    }} catch (UnsupportedEncodingException e) {{
+        bytes = new byte[0];
+    }}
+    putBytes({backing}, bytes, off, bytes.length);
+    for (int i=bytes.length; i<%d; i++)
+        {backing}.put(off+i, (byte)0); // fill with zero
+}}""" % (256, 256))
+
+# array of normal structures
+structArrayEmit = JavaEmitArrayData()
+structArrayEmit.addBackingRead("long {fname}_addr = getPointer({backing}, {foffset});")
+structArrayEmit.addRead("""
+{fname} = new {ftype_one}[{size_fname}];
+if ({size_fname} > 0 && {fname}_addr != 0) {{
+    ByteBuffer bb = newDirectByteBuffer({fname}_addr, {size_fname}*{struct_sz});
+    for (int i=0, off=0; i<{size_fname}; i++, off += {struct_sz}) {{
+        {fname}[i] = new {ftype_one}(bb, off);
+        {fname}[i].read();
+    }}
+}}""")
+structArrayEmit.addWriteBuf("{buftype} {fname}_buf")
+# FIXME: This can be optimized for the read->write case.
+structArrayEmit.addWrite("""
+{fname}_buf = ByteBuffer.allocateDirect({fname}.length*{struct_sz});
+for (int i=0, off=0; i<{fname}.length; i++, off += {struct_sz}) {{
+    {fname}[i].setBuffer({fname}_buf, off);
+    {fname}[i].write();
+}}""")
+structArrayEmit.addBackingWrite("putPointer({backing}, {foffset}, {fname}_buf);")
+structArrayEmit.toArg = "getByteBufferAddress({fname}_buf)"
+
+# array of bytes
+byteArrayEmit = JavaEmitArrayData()
+byteArrayEmit.addBackingRead("long {fname}_addr = getPointer({backing}, {foffset});")
+byteArrayEmit.addRead("""
+{fname} = new {ftype_one}[{size_fname}];
+if ({size_fname} > 0 && {fname}_addr != 0) {{
+    getBytes(newDirectByteBuffer({fname}_addr, {size_fname}), {fname}, 0, {size_fname});
+}}""")
+byteArrayEmit.addWriteBuf("{buftype} {fname}_buf")
+byteArrayEmit.addWrite("""
+{fname}_buf = ByteBuffer.allocateDirect({fname}.length);
+putBytes({fname}_buf, {fname}, 0, {fname}.length);""")
+byteArrayEmit.addBackingWrite("putPointer({backing}, {foffset}, {fname}_buf);")
+byteArrayEmit.toArg = "getByteBufferAddress({fname}_buf)"
+
+# array of java types
+jtypeArrayEmit = JavaEmitArrayData()
+jtypeArrayEmit.addBackingRead("long {fname}_addr = getPointer({backing}, {foffset});")
+jtypeArrayEmit.addRead("""{fname} = new {ftype_one}[{size_fname}];
+if ({size_fname} > 0 && {fname}_addr != 0) {{
+    newDirectByteBuffer({fname}_addr, {size_fname}*{struct_sz}).as{buftype}().get({fname});
+}}""")
+jtypeArrayEmit.addWriteBuf("ByteBuffer {fname}_buf")
+jtypeArrayEmit.addWrite("""
+{fname}_buf = ByteBuffer.allocateDirect({fname}.length*{struct_sz});
+{fname}_buf.as{buftype}().put({fname}).rewind();""")
+jtypeArrayEmit.addBackingWrite("putPointer({backing}, {foffset}, {fname}_buf);")
+jtypeArrayEmit.toArg = "getByteBufferAddress({fname}_buf)"
+
+# enum
+enumEmit = JavaEmitData()
+enumEmit.addBackingRead("{fname} = {ftype}.fromValue({backing}.getInt({foffset}));")
+enumEmit.addBackingWrite("""if ({fname} != null)
+    {backing}.putInt({foffset}, {fname}.getValue());""")
+enumEmit.toArg = "{fname}.getValue()"
+
+# opaque structure
+opaqueEmit = JavaEmitData()
+opaqueEmit.addBackingRead("long {fname}_addr = getPointer({backing}, {foffset});")
+opaqueEmit.addRead("""if ({fname}_addr == 0)
+    {fname} = null;
+else
+    {fname} = new {ftype}({fname}_addr, false);""")
+opaqueEmit.addBackingWrite("putPointer({backing}, {foffset}, {fname});")
+opaqueEmit.toArg = "{fname}.getAddress()"
+
+# inline normal structure
+structEmit = JavaEmitData()
+structEmit.addConstruct("{fname} = new {ftype}({backing}, {foffset});")
+structEmit.addRead("{fname}.read();")
+structEmit.addWrite("{fname}.write();")
+structEmit.toArg = "{fname}.getAddress()"
+
+# java type
+jtypeEmit = JavaEmitData()
+jtypeEmit.addBackingRead("{fname} = {backing}.get{jaccessor}({foffset});")
+jtypeEmit.addBackingWrite("{backing}.put{jaccessor}({foffset}, {fname});")
+
+# string - array of characters
+strSizedEmit = JavaEmitData()
+strSizedEmit.addBackingRead("""{{
+    byte[] bytes = new byte[{array_size}];
+    getBytes({backing}, bytes, {foffset}, {array_size});
+    int len;
+    for (len=0; len<bytes.length && bytes[len] != 0; len++) {{}}
+    try {{
+        {fname} = new String(bytes, 0, len, "UTF-8");
+    }} catch (UnsupportedEncodingException e) {{
+        {fname} = "";
+    }}
+}}""")
+strSizedEmit.addBackingWrite("""
+if ({fname} != null) {{
+    byte[] bytes;
+    try {{
+        bytes = {fname}.getBytes("UTF-8");
+    }} catch (UnsupportedEncodingException e) {{
+        bytes = new byte[0];
+    }}
+    putBytes({backing}, bytes, {foffset}, bytes.length);
+    for (int i=bytes.length; i<{array_size}; i++)
+        {backing}.put(i, (byte)0); // fill with zero
+}}""")
+
+# null terminated string
+strzEmit = JavaEmitData()
+strzEmit.addBackingRead("long {fname}_addr = getPointer({backing}, {foffset});")
+strzEmit.addRead("""if ({fname}_addr == 0)
+    {fname} = null;
+else {{
+    ByteBuffer bb = newDirectByteBuffer({fname}_addr, 1000); // FIXME
+    while (bb.get() != 0) {{}}
+    byte[] bytes = new byte[bb.position()-1];
+    getBytes(bb, bytes, 0, bytes.length);
+    try {{
+        {fname} = new String(bytes, "UTF-8");
+    }} catch (UnsupportedEncodingException e) {{
+        {fname} = "";
+    }}
+}}
+""")
+strzEmit.addWriteBuf("{buftype} {fname}_buf")
+strzEmit.addWrite("""
+if ({fname} != null) {{
+    byte[] {fname}_bytes;
+    try {{
+        {fname}_bytes = {fname}.getBytes("UTF-8");
+    }} catch (UnsupportedEncodingException e) {{
+        {fname}_bytes = new byte[0];
+    }}
+    {fname}_buf = ByteBuffer.allocateDirect({fname}_bytes.length+1);
+    putBytes({fname}_buf, {fname}_bytes, 0, {fname}_bytes.length).put({fname}_bytes.length, (byte)0);
+}}""")
+strzEmit.addBackingWrite("putPointer({backing}, {foffset}, {fname} == null ? 0 : getByteBufferAddress({fname}_buf));")
+strzEmit.toArg = "{fname} == null ? 0 : getByteBufferAddress({fname}_buf)"
+
+class JavaStructEmitHelper:
+    def __init__(self, emit, name, fields, sized_members=None):
+        self.emit = emit
+        self.name = name
+        self.fields = fields
+
+        self.exclude_members = set(self.config_get("exclude_members", "").split(','))
+        self.exclude_members |= set(x.split(':')[0] for x in self.config_get("uniontype", "").split(','))
+        self.union_members = {}
+        for v in self.config_get("uniontype", "").split(','):
+            if not v:
+                continue
+            vl = v.split(':')
+            self.union_members[vl[0]] = (vl[1], [tuple(y.strip() for y in x.split('=')) for x in vl[2:]])
+
+        if sized_members is not None:
+            self.sized_members = sized_members
+        else:
+            self.sized_members = dict(tuple(y.strip() for y in x.split(':')) for x in
+                    self.config_get("arraysize", "").split(',') if x)
+        self.size_members = dict((x, None) for x in self.sized_members.values())
+
+        # get type of each sized member
+        for fname, ftype, arr, comment in fields:
+            if fname in self.size_members:
+                self.size_members[fname] = ftype
+
+    def config_get(self, option, fallback):
+        return self.emit.config_get(self.name, option, fallback)
+
+    def config_getboolean(self, section, option, fallback):
+        return self.emit.config_getboolean(self.name, option, fallback)
+
+    def config_struct_get(self, option):
+        return self.emit.config_struct.get(self.name, option)
+
+    def get_field_java_code(self, fname, ftype, arr, foffset, jfielddefs_private, backing="backing"):
+        """Returns dict of fielddef, init, read, write, type
+        """
+        if ftype.startswith("const"):
+            ftype = ftype[5:].strip()
+        if fname in self.sized_members:
+            # Change from pointer to array
+            if ftype[-1] == '*':
+                ftype = ftype[:-1]
+            arr = ""
+            size_fname = self.sized_members[fname]
+            size_jtype = c_to_jtype(self.size_members[size_fname], None)
+            size_foffset = self.config_struct_get(size_fname)
+        else:
+            size_fname=""
+            size_jtype=None
+            size_foffset=None
+
+        is_pointer = False
+        if ftype[-1] == '*' and ftype[:-1] in opaque_structs:
+            # silently strip pointer from native structs
+            ftype = ftype[:-1]
+        elif ftype[-1] == '*' and (ftype, arr) not in java_types_map:
+            # Not an array, but not inline either
+            ftype = ftype[:-1]
+            is_pointer = True
+
+        # Hopefully the base type now
+        jtype = c_to_jtype(ftype, arr)
+
+        struct_sz = None
+        buftype = "ByteBuffer"
+        array_size = jtype.array_size or ""
+        jaccessor = None
+
+        writeBufs = []
+        backingRead = []
+        read = []
+        write = []
+        backingWrite = []
+        construct = []
+        toArg = ""
+
+        typeemit = None
+        if jtype.jni_sig == "[Ljava/lang/String;":
+            # null-terminated strings
+            if size_fname:
+                jaccessor = java_accessor_map[size_jtype.jni_sig[0]]
+                typeemit = strzArrayEmitSized
+            else:
+                typeemit = strzArrayEmitUnsized
+        elif jtype.jni_sig[0] == '[':
+            if is_pointer: raise NotImplementedError("pointer to array")
+            if arr:
+                construct.append("{fname} = new {ftype_one}[%s];" % arr)
+                if jtype.is_opaque or jtype.is_enum:
+                    raise NotImplementedError("array of opaque and enum not implemented")
+                elif jtype.is_struct:
+                    struct_sz = self.emit.config_struct.get(jtype.j_type[:-2], "_SIZE_")
+                    construct.extend(("""
+for (int i=0, off={foffset}; i<%s; i++, off += {struct_sz})
+    {fname}[i] = new {ftype_one}({backing}, off);""" % arr).split('\n'))
+                    read.extend(("""for ({ftype_one} it : {fname}) {{
+    it.read();
+}}""").split('\n'))
+                    write.extend(("""for ({ftype_one} it : {fname}) {{
+    it.write();
+}}""").split('\n'))
+                else:
+                    raise NotImplementedError("sized array of unknown type")
+            else:
+                jaccessor = java_accessor_map[size_jtype.jni_sig[0]]
+                if jtype.is_enum:
+                    typeemit = enumArrayEmit
+                elif jtype.is_opaque:
+                    typeemit = opaqueArrayEmit
+                elif ftype == "String255":
+                    typeemit = string255ArrayEmit
+                elif jtype.is_struct:
+                    struct_sz = self.emit.config_struct.get(jtype.j_type[:-2], "_SIZE_")
+                    typeemit = structArrayEmit
+                elif jtype.jni_sig[1] == 'B':
+                    typeemit = byteArrayEmit
+                elif jtype.jni_sig[1] in java_accessor_map:
+                    buftype = "%sBuffer" % java_accessor_map[jtype.jni_sig[1]]
+                    struct_sz = java_size_map[jtype.jni_sig[1]]
+                    typeemit = jtypeArrayEmit
+                else:
+                    raise ValueError("unrecognized jni signature '%s'" % jtype.jni_sig)
+        elif jtype.is_enum:
+            if is_pointer: raise NotImplementedError("pointer to enum")
+            typeemit = enumEmit
+        elif jtype.is_opaque or (jtype.is_struct and is_pointer):
+            typeemit = opaqueEmit
+        elif jtype.is_struct:
+            typeemit = structEmit
+        elif jtype.jni_sig[0] in java_accessor_map:
+            if is_pointer: raise NotImplementedError("pointer to raw")
+            jaccessor = java_accessor_map[jtype.jni_sig[0]]
+            typeemit = jtypeEmit
+        elif jtype.jni_sig == "Ljava/lang/String;":
+            if is_pointer: raise NotImplementedError("pointer to string")
+            if jtype.string_array:
+                typeemit = strSizedEmit
+            else:
+                typeemit = strzEmit
+        else:
+            raise ValueError("unrecognized jni signature '%s'" % jtype.jni_sig)
+
+        if typeemit is not None:
+            writeBufs.extend(typeemit.writeBufs)
+            construct.extend(typeemit.construct)
+            backingRead.extend(typeemit.backingRead)
+            read.extend(typeemit.read)
+            write.extend(typeemit.write)
+            backingWrite.extend(typeemit.backingWrite)
+            toArg = typeemit.toArg
+
+        for buf in writeBufs:
+            jfielddefs_private.append("private %s;" % buf.format(buftype=buftype, fname=fname))
+        jfielddef = 'public %s %s;' % (jtype.j_type, fname)
+
+        fargs = dict(fname=fname,
+                     ftype=jtype.j_type,
+                     ftype_one=jtype.j_type[:-2],
+                     foffset=foffset,
+                     size_fname=fname+"_"+size_fname,
+                     size_foffset=size_foffset,
+                     pointer_sz=self.emit.config_struct.get("_platform_", "pointer"),
+                     struct_sz=struct_sz,
+                     array_size=array_size,
+                     buftype=buftype,
+                     jaccessor=jaccessor,
+                     backing=backing)
+        jconstruct = [x.format(**fargs) for x in construct]
+        jwritebufs = [x.format(**fargs) for x in writeBufs]
+        jbackingread = [x.format(**fargs) for x in backingRead]
+        jread = [x.format(**fargs) for x in read]
+        jwrite = [x.format(**fargs) for x in write]
+        jbackingwrite = [x.format(**fargs) for x in backingWrite]
+        jtoarg = toArg.format(**fargs)
+
+        return dict(fielddef=jfielddef,
+                    construct=jconstruct,
+                    write_bufs=jwritebufs,
+                    backing_read=jbackingread,
+                    read=jread,
+                    write=jwrite,
+                    backing_write=jbackingwrite,
+                    to_arg=jtoarg,
+                    type=jtype,
+                    is_pointer=is_pointer,
+                    arr=arr,
+                    size_fname=size_fname,
+                    size_jtype=size_jtype,
+                    size_foffset=size_foffset)
+
+    def get_java_code(self):
+        jcargs = []
+        jcinit = []
+        jfielddefs = []
+        jfielddefs_private = []
+        jconstruct = []
+        jread = []
+        jwrite = []
+
+        # standard struct fields
+        for fname, ftype, arr, comment in self.fields:
+            if fname in self.size_members or fname in self.exclude_members:
+                continue # don't emit
+
+            if ":" in fname:
+                continue # TODO: bit field
+            foffset = self.config_struct_get(fname)
+            field = self.get_field_java_code(fname, ftype, arr, foffset, jfielddefs_private)
+
+            # XXX: hack to get short and float to work reasonably
+            if field["type"].j_type == "short":
+                jcargs.append("int {fname}".format(fname=fname))
+                jcinit.append("this.{fname} = (short){fname};".format(fname=fname))
+            elif field["type"].j_type == "float":
+                jcargs.append("double {fname}".format(fname=fname))
+                jcinit.append("this.{fname} = (float){fname};".format(fname=fname))
+            else:
+                jcargs.append("{ftype} {fname}".format(ftype=field["type"].j_type, fname=fname))
+                jcinit.append("this.{fname} = {fname};".format(fname=fname))
+
+            fielddef = field["fielddef"]
+            if comment is not None:
+                fielddef += ' // %s' % comment
+            jfielddefs.append(fielddef)
+            jconstruct.extend(field["construct"])
+            jread.extend(field["backing_read"])
+            jread.extend(field["read"])
+            jwrite.extend(field["write"])
+            jwrite.extend(field["backing_write"])
+
+        # typed union fields
+        jfielddefs_union_private = []
+        for union_name, (switchvalue_name, members) in self.union_members.items():
+            # get union structure name and type info
+            for fname, ftype, arr, comment in self.fields:
+                if fname == union_name:
+                    union_ftype = ftype
+                elif fname == switchvalue_name:
+                    switchvalue_ftype = ftype
+            unionfields = self.emit.unions[union_ftype]
+
+            # build map of union fields for faster lookup
+            ufieldmap = {}
+            for fname, ftype, arr, comment in unionfields:
+                ufieldmap[fname] = (ftype, arr, comment)
+
+            # common offset
+            foffset = self.config_struct_get(union_name)
+
+            for enumval, fname in members:
+                # find the rest of the info from the union fields
+                ftype, arr, comment = ufieldmap[fname]
+
+                field = self.get_field_java_code(fname, ftype, arr, foffset, jfielddefs_union_private)
+
+                fielddef = field["fielddef"]
+                read = field["backing_read"]
+                read.extend(field["read"])
+                write = field["write"]
+                write.extend(field["backing_write"])
+                if comment is not None:
+                    fielddef += ' // %s' % comment
+                jfielddefs.append(fielddef)
+                jconstruct.extend(field["construct"])
+                if enumval.startswith("IMAQ_"):
+                    enumval = enumval[5:]
+                ifcheck = "if (%s == %s.%s) " % (switchvalue_name, switchvalue_ftype, enumval)
+                if len(read[0]) > 0 and read[0][0] == '{':
+                    read[0] = ifcheck + read[0]
+                else:
+                    read = ("    " + "\n    ".join(read)).split('\n')
+                    read.insert(0, ifcheck + "{")
+                    read.append("}")
+                if len(write[0]) > 0 and write[0][0] == '{':
+                    write[0] = ifcheck + write[0]
+                else:
+                    write = ("    " + "\n    ".join(write)).split('\n')
+                    write.insert(0, ifcheck + "{")
+                    write.append("}")
+
+                jread.extend(read)
+                jwrite.extend(write)
+
+        jfielddefs.extend(jfielddefs_private)
+
+        # Java definition
+        p1 = """
+    public static class {name} extends DisposedStruct {{
+        {jfielddefs}
+
+        private void init() {{
+            {jconstruct}
+        }}
+        public {name}() {{
+            super({size});
+            init();
+        }}"""
+
+        if jcargs:
+            p2 = """
+        public {name}({jcargs}) {{
+            super({size});
+            {jcinit}
+        }}"""
+        else:
+            p2 = ""
+
+        p3 = """
+        protected {name}(ByteBuffer backing, int offset) {{
+            super(backing, offset, {size});
+            init();
+        }}
+        protected {name}(long nativeObj, boolean owned) {{
+            super(nativeObj, owned, {size});
+            init();
+        }}
+        protected void setBuffer(ByteBuffer backing, int offset) {{
+            super.setBuffer(backing, offset, {size});
+        }}
+        public void read() {{
+            {jread}
+        }}
+        public void write() {{
+            {jwrite}
+        }}
+        public int size() {{
+            return {size};
+        }}
+    }}"""
+        return "".join([p1,p2,p3]).format(
+                name=self.name,
+                jfielddefs="\n        ".join(jfielddefs),
+                jread="\n            ".join(jread),
+                jwrite="\n            ".join(jwrite),
+                jconstruct="\n            ".join(jconstruct),
+                jcargs=", ".join(jcargs),
+                jcinit="\n            ".join(jcinit),
+                size=self.config_struct_get("_SIZE_"))
+
+
+class JavaEmitter:
+    def __init__(self, outdir, config, config_struct):
+        self.outdir = outdir
+        self.config = config
+        self.config_struct = config_struct
+        self.package = "com.ni.vision"
+        self.classname = "NIVision"
+        self.classpath = self.package.replace(".", "/") + "/" + self.classname
+
+        self.unions = {}
+
+        with open(os.path.join(outdir, "VisionException.java"), "wt") as f:
+            print("""//
+// This file is auto-generated by wpilibj/wpilibJavaJNI/nivision/gen_java.py
+// Please do not edit!
+//
+
+package {package};
+
+public class VisionException extends RuntimeException {{
+
+    private static final long serialVersionUID = 1L;
+
+    public VisionException(String msg) {{
+        super(msg);
+    }}
+
+    @Override
+    public String toString() {{
+        return "VisionException [" + super.toString() + "]";
+    }}
+}}""".format(package=self.package), file=f)
+
+        self.out = open(os.path.join(outdir, "NIVision.java"), "wt")
+        print("""//
+// This file is auto-generated by wpilibj/wpilibJavaJNI/nivision/gen_java.py
+// Please do not edit!
+//
+
+package {package};
+
+import java.lang.reflect.*;
+import java.io.UnsupportedEncodingException;
+import java.nio.Buffer;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+
+public class {classname} {{
+    private {classname}() {{}}
+
+    private static native void imaqDispose(long addr);
+
+    private static Constructor<?> constructDirectByteBuffer;
+    private static Field bufferAddressField;
+
+    static {{
+        try {{
+            Class<?>[] cArg = new Class[2];
+            cArg[0] = long.class;
+            cArg[1] = int.class;
+            constructDirectByteBuffer = Class.forName("java.nio.DirectByteBuffer").getDeclaredConstructor(cArg);
+            constructDirectByteBuffer.setAccessible(true);
+
+            bufferAddressField = Buffer.class.getDeclaredField("address");
+            bufferAddressField.setAccessible(true);
+        }} catch (ReflectiveOperationException e) {{
+            throw new ExceptionInInitializerError(e);
+        }}
+    }}
+
+    private static ByteBuffer newDirectByteBuffer(long addr, int cap) {{
+        try {{
+            return ((ByteBuffer)(constructDirectByteBuffer.newInstance(addr, cap))).order(ByteOrder.nativeOrder());
+        }} catch (ReflectiveOperationException e) {{
+            throw new ExceptionInInitializerError(e);
+        }}
+    }}
+
+    private static long getByteBufferAddress(ByteBuffer bb) {{
+        try {{
+            return bufferAddressField.getLong(bb);
+        }} catch (IllegalAccessException e) {{
+            return 0;
+        }}
+    }}
+
+    public static ByteBuffer sliceByteBuffer(ByteBuffer bb, int offset, int size) {{
+        ByteBuffer new_bb = bb.duplicate();
+        new_bb.position(offset);
+        new_bb.limit(size);
+        return new_bb;
+    }}
+
+    public static ByteBuffer getBytes(ByteBuffer bb, byte[] dst, int offset, int size) {{
+        for (int i=offset; i<offset+size; i++)
+            dst[i] = bb.get(i);
+        return bb;
+    }}
+
+    public static ByteBuffer putBytes(ByteBuffer bb, byte[] src, int offset, int size) {{
+        for (int i=offset; i<offset+size; i++)
+            bb.put(i, src[i]);
+        return bb;
+    }}
+
+    private static abstract class DisposedStruct {{
+        protected ByteBuffer backing;
+        private boolean owned;
+        protected DisposedStruct(int size) {{
+            backing = ByteBuffer.allocateDirect(size);
+            backing.order(ByteOrder.nativeOrder());
+            owned = false;
+        }}
+        protected DisposedStruct(ByteBuffer backing, int offset, int size) {{
+            this.backing = sliceByteBuffer(backing, offset, size);
+            owned = false;
+        }}
+        private DisposedStruct(long nativeObj, boolean owned, int size) {{
+            backing = newDirectByteBuffer(nativeObj, size);
+            this.owned = owned;
+        }}
+        public void free() {{
+            if (owned) {{
+                imaqDispose(getByteBufferAddress(backing));
+                owned = false;
+                backing = null;
+            }}
+        }}
+        @Override
+        protected void finalize() throws Throwable {{
+            if (owned)
+                imaqDispose(getByteBufferAddress(backing));
+            super.finalize();
+        }}
+        public long getAddress() {{
+            if (backing == null)
+                return 0;
+            write();
+            return getByteBufferAddress(backing);
+        }}
+        protected void setBuffer(ByteBuffer backing, int offset, int size) {{
+            this.backing = sliceByteBuffer(backing, offset, size);
+        }}
+
+        abstract public void read();
+        abstract public void write();
+        abstract public int size();
+    }}
+
+    private static abstract class OpaqueStruct {{
+        private long nativeObj;
+        private boolean owned;
+        private OpaqueStruct() {{
+            this.nativeObj = 0;
+            this.owned = false;
+        }}
+        private OpaqueStruct(long nativeObj, boolean owned) {{
+            this.nativeObj = nativeObj;
+            this.owned = owned;
+        }}
+        public void free() {{
+            if (owned && nativeObj != 0) {{
+                imaqDispose(nativeObj);
+                owned = false;
+                nativeObj = 0;
+            }}
+        }}
+        @Override
+        protected void finalize() throws Throwable {{
+            if (owned && nativeObj != 0)
+                imaqDispose(nativeObj);
+            super.finalize();
+        }}
+        public long getAddress() {{
+            return nativeObj;
+        }}
+    }}""".format(package=self.package, classname=self.classname), file=self.out)
+
+        if int(self.config_struct.get("_platform_", "pointer")) == 4:
+            # 32-bit addressing
+            java_types_map[("void*", None)] = JavaType("c_void_p", "int", "jint", "I")
+            java_types_map[("size_t", None)] = JavaType("int", "int", "jint", "I")
+            print("""
+    private static long getPointer(ByteBuffer bb, int offset) {
+        return (long)bb.getInt(offset);
+    }
+    private static void putPointer(ByteBuffer bb, int offset, long address) {
+        bb.putInt(offset, (int)address);
+    }
+    private static void putPointer(ByteBuffer bb, int offset, ByteBuffer buf) {
+        if (buf == null)
+            bb.putInt(offset, 0);
+        else
+            bb.putInt(offset, (int)getByteBufferAddress(buf));
+    }
+    private static void putPointer(ByteBuffer bb, int offset, DisposedStruct struct) {
+        if (struct == null)
+            bb.putInt(offset, 0);
+        else
+            bb.putInt(offset, (int)struct.getAddress());
+    }
+    private static void putPointer(ByteBuffer bb, int offset, OpaqueStruct struct) {
+        if (struct == null)
+            bb.putInt(offset, 0);
+        else
+            bb.putInt(offset, (int)struct.getAddress());
+    }""", file=self.out)
+        else:
+            # 64-bit addressing
+            java_types_map[("void*", None)] = JavaType("c_void_p", "long", "jlong", "J")
+            java_types_map[("size_t", None)] = JavaType("long", "long", "jlong", "J")
+            print("""
+    private static long getPointer(ByteBuffer bb, int offset) {
+        return bb.getLong(offset);
+    }
+    private static void putPointer(ByteBuffer bb, int offset, long address) {
+        bb.putLong(offset, address);
+    }
+    private static void putPointer(ByteBuffer bb, int offset, ByteBuffer buf) {
+        if (buf == null)
+            bb.putLong(offset, 0);
+        else
+            bb.putLong(offset, getByteBufferAddress(buf));
+    }
+    private static void putPointer(ByteBuffer bb, int offset, OpaqueStruct struct) {
+        if (struct == null)
+            bb.putLong(offset, 0);
+        else
+            bb.putLong(offset, struct.getAddress());
+    }
+    private static void putPointer(ByteBuffer bb, int offset, DisposedStruct struct) {
+        if (struct == null)
+            bb.putLong(offset, 0);
+        else
+            bb.putLong(offset, struct.getAddress());
+    }""", file=self.out)
+
+        self.outc = open(os.path.join(outdir, "NIVision.cpp"), "wt")
+        print("""//
+// This file is auto-generated by wpilibj/wpilibJavaJNI/nivision/gen_java.py
+// Please do not edit!
+//
+
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <jni.h>
+#include <nivision.h>
+
+// throw java exception
+static void throwJavaException(JNIEnv *env) {{
+    jclass je = env->FindClass("{packagepath}/VisionException");
+    int err = imaqGetLastError();
+    char* err_text = imaqGetErrorText(err);
+    char* full_err_msg = (char*)malloc(30+strlen(err_text));
+    sprintf(full_err_msg, "imaqError: %d: %s", err, err_text);
+    imaqDispose(err_text);
+    env->ThrowNew(je, full_err_msg);
+    free(full_err_msg);
+}}
+
+extern "C" {{
+
+JNIEXPORT void JNICALL Java_{package}_{classname}__1imaqDispose(JNIEnv* , jclass , jlong addr)
+{{
+    imaqDispose((void*)addr);
+}}""".format(packagepath=self.package.replace(".", "/"),
+           package=self.package.replace(".", "_"),
+           classname=self.classname), file=self.outc)
+
+        self.block_comment("Opaque Structures")
+        for name in sorted(opaque_structs):
+            self.opaque_struct(name)
+
+    def finish(self):
+        print("}", file=self.out)
+        print("}", file=self.outc)
+
+    def config_get(self, section, option, fallback):
+        try:
+            return self.config.get(section, option)
+        except (ValueError, configparser.NoSectionError, configparser.NoOptionError):
+            return fallback
+
+    def config_getboolean(self, section, option, fallback):
+        try:
+            return self.config.getboolean(section, option)
+        except (ValueError, configparser.NoSectionError, configparser.NoOptionError):
+            return fallback
+
+    def block_comment(self, comment):
+        print("""
+    /**
+     * {comment}
+     */""".format(comment=comment), file=self.out)
+        print("""
+/*
+ * {comment}
+ */""".format(comment=comment), file=self.outc)
+
+    def opaque_struct(self, name):
+        print("""
+    public static class {name} extends OpaqueStruct {{
+        private {name}() {{}}
+        private {name}(long nativeObj, boolean owned) {{
+            super(nativeObj, owned);
+        }}
+    }}""".format(name=name), file=self.out)
+
+    def define(self, name, value, comment):
+        if self.config_getboolean(name, "exclude", fallback=False):
+            return
+        if name in opaque_structs:
+            return
+        if name.startswith("ERR_"):
+            return
+        clean = None
+        type = None
+        after_struct = False
+        if value == "TRUE":
+            clean = "true"
+            type = "boolean"
+        elif value == "FALSE":
+            clean = "false"
+            type = "boolean"
+        elif name.startswith("IMAQ_INIT_RGB") and value[0] == '{' and value[-1] == '}':
+            return
+        elif value.startswith("imaqMake"):
+            clean = "new " + value[8:]
+            type = value.split("(")[0][8:]
+            after_struct = True
+        elif value[0] == '"':
+            if len(value) == 2:
+                clean = "{ 0 }"
+            else:
+                clean = "{ %s,0 }" % ",".join("0x%x" % ord(c) for c in value[1:-1])
+            type = "byte[]"
+        elif number_re.match(value):
+            clean = value
+            type = "int"
+        elif constant_re.match(value):
+            clean = value
+            after_struct = value not in defined
+
+        if clean is None:
+            print("Invalid #define: %s" % name)
+            return
+
+        # strip IMAQ_ prefix
+        if name.startswith("IMAQ_"):
+            name = name[5:]
+
+        code = "    public static final {type} {name} = {value};" \
+                .format(type=type, name=name, value=clean)
+        if after_struct:
+            define_after_struct.append((name, code))
+            return
+
+        print(code, file=self.out)
+        defined.add(name)
+
+    def text(self, text):
+        print(text, file=self.out)
+
+    def static_const(self, name, ctype, value):
+        # strip IMAQ_ prefix
+        if name.startswith("IMAQ_"):
+            name = name[5:]
+
+        if hasattr(value, "__iter__"):
+            code = "    public static final {ctype} {name} = new {ctype}({value});"
+            value = ", ".join(value)
+        else:
+            code = "{name} = {value};"
+        print(code.format(name=name, value=value, ctype=ctype),
+              file=self.out)
+        defined.add(name)
+
+    def enum(self, name, values):
+        if self.config_getboolean(name, "exclude", fallback=False):
+            return
+        if name in opaque_structs:
+            return
+        valuestrs = []
+        need_search = False
+        prev_value = -1
+        for vname, value, comment in values:
+            if vname.endswith("SIZE_GUARD"):
+                continue
+            if vname.startswith("IMAQ_"):
+                vname = vname[5:]
+            if vname[0] in "0123456789":
+                vname = "C" + vname
+            valuestrs.append("%s(%s),%s" % (vname, value, " // %s" % comment if comment else ""))
+            defined.add(vname)
+            value_i = int(value, 0)
+            if value_i < 0 or value_i != (prev_value + 1):
+                # need to do search instead of index for fromValue()
+                need_search = True
+            prev_value = value_i
+
+        print("""
+    public static enum {name} {{
+        {values}
+        ;
+        private final int value;
+        private {name}(int value) {{
+            this.value = value;
+        }}
+        public static {name} fromValue(int val) {{""".format(name=name, values="\n        ".join(valuestrs)), file=self.out)
+        if need_search:
+            print("""            for ({name} v : values()) {{
+                if (v.value == val)
+                    return v;
+            }}
+            return null;""".format(name=name), file=self.out)
+        else:
+            print("""            try {{
+                return values()[val];
+            }} catch (ArrayIndexOutOfBoundsException e) {{
+                return null;
+            }}""".format(), file=self.out)
+        print("""        }}
+        public int getValue() {{
+            return value;
+        }}
+    }}""".format(), file=self.out)
+        defined.add(name)
+        enums.add(name)
+
+    def typedef(self, name, typedef, arr):
+        if self.config_getboolean(name, "exclude", fallback=False):
+            return
+        if name in opaque_structs:
+            return
+        if typedef.startswith("struct"):
+            return
+        elif typedef.startswith("union"):
+            return
+        else:
+            java_types_map[(name, arr)] = c_to_jtype(typedef, arr).copy()
+            if arr is None:
+                java_types_map[(name, "")] = c_to_jtype(typedef, "").copy()
+        defined.add(name)
+
+    def typedef_function(self, name, restype, params):
+        if self.config_getboolean(name, "exclude", fallback=False):
+            return
+        if name in opaque_structs:
+            return
+        raise NotImplementedError("typedef function not implemented")
+
+    def function(self, name, restype, params):
+        if self.config_getboolean(name, "exclude", fallback=False):
+            return
+
+        # common return cases
+        retpointer = self.config_getboolean(name, "rvdisposed", fallback=False)
+        j_funcargs = []
+        jn_funcargs = []
+        jni_funcargs = [("env", java_types_map["env", None]),
+                        ("", java_types_map["cls", None])]
+        jn_passedargs = {}
+
+        paramtypes = {}
+        jinit = []
+        jfini = []
+        exceptioncheck = ""
+        retc = ""
+        jretc = ""
+
+        if restype == "int":
+            functype = "STDFUNC"
+            rettype = c_to_jtype("void", None)
+            exceptioncheck = "if (rv == 0) throwJavaException(env);"
+        else:
+            if restype[-1] == "*":
+                functype = "STDPTRFUNC"
+                exceptioncheck = "if (!rv) throwJavaException(env);"
+            else:
+                functype = "RETFUNC"
+
+            if restype[-1] == "*" and restype[:-1] in opaque_structs:
+                # silently strip pointer from native structs
+                rettype = c_to_jtype(restype[:-1], None)
+            else:
+                rettype = c_to_jtype(restype, None)
+
+        # TODO: defaults
+        #defaults = dict((y.strip() for y in x.split(':')) for x in
+        #        self.config_get(name, "defaults", "").split(',') if x)
+
+        sized_params = dict(tuple(y.strip() for y in x.split(':')) for x in
+                self.config_get(name, "arraysize", "").split(',') if x)
+        size_params = set(sized_params.values())
+
+        inparams = [x.strip() for x in self.config_get(name, "inparams", "").split(',') if x.strip()]
+        outparams = [x.strip() for x in self.config_get(name, "outparams", "").split(',') if x.strip()]
+        nullokparams = [x.strip() for x in self.config_get(name, "nullok", "").split(',') if x.strip()]
+        # guess additional output parameters
+        for pname, ptype, arr in params:
+            if (pname not in inparams
+                and pname not in outparams
+                and pname not in sized_params
+                and ptype
+                and not ptype.startswith("const")
+                and ptype[:-1] not in opaque_structs
+                and ptype[-1] == "*"):
+                outparams.append(pname)
+
+        retarraysize = self.config_get(name, "retarraysize", "").strip()
+        if retarraysize:
+            size_params.add(retarraysize)
+            #rettype = c_to_jtype(restype, "")
+            if retarraysize not in outparams:
+                outparams.append(retarraysize)
+
+        retowned = not self.config_getboolean(name, "retunowned", False)
+
+        # Input and output parameter code is generated with the help of
+        # "virtual" structures.  The input parameters are collected in one
+        # structure, the output parameters in another.  Only if there are
+        # multiple output parameters or an output array is the output
+        # structure actually generated into the Java code.
+
+        instruct_fields = [(pname, ptype, arr, "") for (pname, ptype, arr)
+                           in params if pname != "void"]
+        helper = JavaStructEmitHelper(self, name, instruct_fields)
+        helper.config_struct_get = lambda o: "0"
+
+        # "pointer" type to use for JN/JNI
+        jtype_ptr = java_types_map[("long", None)]
+
+        jfielddefs_private = []
+        for fname, ftype, arr, comment in helper.fields:
+            #print(fname, ftype, arr)
+            is_outparam = (fname in outparams)
+            is_nullok = (fname in nullokparams) and not is_outparam
+
+            if is_outparam:
+                assert ftype[-1] == '*'
+                ftype = ftype[:-1]
+            field = helper.get_field_java_code(fname, ftype, arr, 0, jfielddefs_private, backing="%s_buf" % fname)
+            paramtypes[fname] = (ftype, arr, field["type"])
+            if is_outparam:
+                jn_funcargs.append((fname, jtype_ptr))
+                jni_funcargs.append((fname, jtype_ptr))
+                continue
+
+            write_bufs = field["write_bufs"]
+            write = field["write"]
+            jtype = field["type"]
+            arr = field["arr"]
+            is_pointer = field["is_pointer"]
+            to_arg = field["to_arg"]
+
+            if jtype.j_type == "c_void_p":
+                raise NotImplementedError("void pointer not implemented")
+
+            # input parameter generation
+            if fname not in size_params:
+                j_funcargs.append((fname, jtype))
+            # for JN/JNI, force all pointer/arrays to simple "long" type
+            if ftype[-1] == '*' or jtype.string_array:
+                jn_funcargs.append((fname, jtype_ptr))
+                jni_funcargs.append((fname, jtype_ptr))
+            else:
+                jn_funcargs.append((fname, jtype))
+                jni_funcargs.append((fname, jtype))
+
+            # determine what to pass and how (e.g. jinit code)
+            if jtype.jni_sig == "[Ljava/lang/String;":
+                raise NotImplementedError("string array")
+            elif jtype.jni_sig[0] == '[':
+                if arr:
+                    raise NotImplementedError("sized array")
+                else:
+                    jinit.append("{size_jtype} {size_fname} = {fname}.length;".format(size_jtype=field["size_jtype"].j_type, size_fname=field["size_fname"], fname=fname))
+                    jinit.extend("%s = null;" % x for x in write_bufs)
+                    jinit.extend(write)
+                    jn_passedargs[fname] = to_arg
+            elif jtype.is_enum:
+                jn_passedargs[fname] = to_arg
+            elif jtype.is_opaque:
+                if is_nullok:
+                    to_arg = "%s == null ? 0 : %s" % (fname, to_arg)
+                jn_passedargs[fname] = to_arg
+            elif jtype.is_struct:
+                if is_nullok:
+                    to_arg = "%s == null ? 0 : %s" % (fname, to_arg)
+                jn_passedargs[fname] = to_arg
+            elif jtype.jni_sig[0] in java_accessor_map:
+                jn_passedargs[fname] = fname
+            elif jtype.jni_sig == "Ljava/lang/String;":
+                if jtype.string_array:
+                    jinit.append("ByteBuffer {fname}_buf = ByteBuffer.allocateDirect({array_size});".format(fname=fname, array_size=256))
+                    jinit.extend(field["backing_write"])
+                    jn_passedargs[fname] = "{fname} == null ? 0 : getByteBufferAddress({fname}_buf)".format(fname=fname)
+                else:
+                    jinit.extend("%s = null;" % x for x in write_bufs)
+                    jinit.extend(write)
+                    jn_passedargs[fname] = to_arg
+            else:
+                raise ValueError("unrecognized jni signature '%s'" % jtype.jni_sig)
+
+        if rettype.j_type == "c_void_p":
+            raise NotImplementedError("%s: void pointer not implemented")
+
+        jrettype = rettype.j_type
+
+        outstruct_name = None
+        #print(name, outparams, retarraysize)
+        if outparams or retarraysize:
+            # create a return buffer (TODO: optimize size)
+            jinit.append("ByteBuffer rv_buf = ByteBuffer.allocateDirect(%d);" % ((len(outparams)+1)*8))
+            jinit.append("long rv_addr = getByteBufferAddress(rv_buf);")
+
+            # create a return structure
+            outstruct_fields = [(pname, ptype[:-1], arr, "")
+                                for (pname, ptype, arr) in params
+                                if pname in outparams]
+            outstruct_sized_members = {}
+            outstruct_name = name[4:] + "Result"
+
+            jconstruct_args = [("rv_buf", "ByteBuffer")]
+            jconstruct = []
+            if retarraysize:
+                jconstruct_args.append(("jn_rv", "long"))
+                jconstruct.append("array_addr = jn_rv;")
+
+            if retarraysize:
+                outstruct_fields.append(("array", restype, "", ""))
+                outstruct_sized_members["array"] = retarraysize
+            elif functype != "STDFUNC":
+                outstruct_fields.append(("val", restype, None, ""))
+
+            helper = JavaStructEmitHelper(self, outstruct_name, outstruct_fields,
+                                          sized_members=outstruct_sized_members)
+            helper.config_struct_get = lambda o: "0"
+            jfielddefs = []
+            jfielddefs_private = []
+            off = 0
+            for fname, ftype, arr, comment in helper.fields:
+                field = helper.get_field_java_code(fname, ftype, arr, off, jfielddefs_private, backing="rv_buf")
+                if field["type"].j_type == "c_void_p":
+                    raise NotImplementedError("void pointer not implemented")
+                if fname == retarraysize:
+                    jconstruct.append(field["fielddef"].replace("public ", "").replace(fname, "array_%s" % fname))
+                    jconstruct.extend(x.replace(fname, "array_%s" % fname) for x in field["backing_read"])
+                    jn_passedargs[fname] = "rv_addr+%d" % off
+                    off += 8
+                    continue
+                jfielddefs.append(field["fielddef"])
+
+                if fname == "array":
+                    #jconstruct.extend(field["backing_read"])
+                    jconstruct.extend(field["read"])
+                elif fname != "val":
+                    jn_passedargs[fname] = "rv_addr+%d" % off
+                    off += 8
+                    jconstruct.extend(field["construct"])
+                    jconstruct.extend(field["backing_read"])
+                    jconstruct.extend(field["read"])
+
+            if retarraysize:
+                jfielddefs.append("private long array_addr;")
+
+            # optimize len(outparams) == 1 case to directly return it.
+            if len(outparams) == 1 and not retarraysize and rettype.j_type == "void":
+                jfini.extend(x.replace("public ", "") for x in jfielddefs)
+                jfini.extend(jconstruct)
+                jretc = "return %s;" % outparams[0]
+                jrettype = paramtypes[outparams[0]][2].j_type
+                rettype = paramtypes[outparams[0]][2]
+            else:
+                defined.add(outstruct_name)
+                jfini.append("{struct_name} rv = new {struct_name}({args});".format(struct_name=outstruct_name, args=", ".join(x[0] for x in jconstruct_args)))
+                if not retarraysize and functype != "STDFUNC":
+                    jfini.append("rv.val = new {type}(jn_rv, {owned});".format(type=rettype.j_type, owned="true" if retowned else "false"))
+
+                jrettype = outstruct_name
+                if retarraysize:
+                    rettype = c_to_jtype(outstruct_name, None)
+                #else:
+                #    rettype = java_types_map[("void", None)]
+
+                print("""
+    public static class {struct_name} {{
+        {jfielddefs}
+        private {struct_name}({jconstruct_args}) {{
+            {jconstruct}
+        }}""".format(struct_name=outstruct_name,
+                 jfielddefs="\n        ".join(jfielddefs),
+                 jconstruct_args=", ".join("%s %s" % (x[1], x[0]) for x in jconstruct_args),
+                 jconstruct="\n            ".join(jconstruct)),
+                      file=self.out)
+                if retarraysize:
+                    print("""
+        @Override
+        protected void finalize() throws Throwable {{
+            imaqDispose(array_addr);
+            super.finalize();
+        }}
+    }}""".format(struct_name=outstruct_name), file=self.out)
+                else:
+                    print("    }", file=self.out)
+
+                jretc = "return rv;"
+        elif functype != "STDFUNC":
+            if rettype.is_enum:
+                jretc = "return {type}.fromValue(jn_rv);".format(type=rettype.j_type)
+            elif rettype.is_struct or rettype.is_opaque:
+                jretc = "return new {type}(jn_rv, {owned});".format(type=rettype.j_type, owned="true" if retowned else "false")
+            else:
+                jretc = "return jn_rv;"
+
+        #
+        # Java function
+        #
+        #assert name.startswith("imaq")
+        #name = name[4].lower() + name[5:]
+
+        print("""
+    public static {rettype} {name}({args}) {{
+        {init}
+        {rv}_{name}({passedargs});
+        {fini}{retcode}
+    }}""".format(rettype=jrettype,
+                 name=name,
+                 args=", ".join("%s %s" % (x[1].j_type, x[0]) for x in j_funcargs),
+                 init="\n        ".join(jinit),
+                 fini="\n        ".join(jfini),
+                 rv="%s jn_rv = " % rettype.jn_type if rettype.jn_type != "void" else "",
+                 retcode="\n        "+jretc if jretc else "",
+                 passedargs=", ".join(jn_passedargs[x[0]] if x[0] in jn_passedargs else "UNKNOWN" for x in jn_funcargs)),
+                file=self.out)
+
+        #
+        # Native Java function
+        #
+        print("""    private static native {rettype} _{name}({args});""".format(
+              rettype=rettype.jn_type, name=name,
+              args=", ".join("%s %s" % (x[1].jn_type, x[0]) for x in jn_funcargs)),
+              file=self.out)
+
+        #
+        # C function
+        #
+        print("""
+/* J: {jrettype} {name}({jargs})
+ * JN: {jnrettype} {name}({jnargs})
+ * C: {restype} {name}({cparams})
+ */""".format(name=name,
+              jrettype=rettype.j_type,
+              jargs=", ".join("%s %s" % (x[1].j_type, x[0]) for x in j_funcargs),
+              jnrettype=rettype.jn_type,
+              jnargs=", ".join("%s %s" % (x[1].jn_type, x[0]) for x in jn_funcargs),
+              restype=restype,
+              cparams=", ".join("%s %s" % (ptype, pname) for pname, ptype, arr in params)),
+              file=self.outc)
+
+        cargs = []
+        for pname, ptype, arr in params:
+            if pname == "void":
+                continue
+            if ptype in structs:
+                cargs.append("*((%s*)%s)" % (ptype, pname))
+            elif ptype.endswith("String255"):
+                cargs.append("(char *)%s" % pname)
+            else:
+                cargs.append("(%s)%s" % (ptype, pname))
+
+        callcfunc = "{restype} rv = {name}({args});".format(name=name,
+                restype=restype,
+                args=", ".join(cargs))
+
+        print("""
+JNIEXPORT {rettype} JNICALL Java_{package}_{classname}__1{name}({args})
+{{
+    {callfunc}
+    {exceptioncheck}{retcode}
+}}""".format(rettype=rettype.jni_type,
+             package=self.package.replace(".", "_"),
+             classname=self.classname,
+             name=name,
+             args=", ".join("%s %s" % (x[1].jni_type, x[0]) for x in jni_funcargs),
+             callfunc=callcfunc,
+             exceptioncheck=exceptioncheck,
+             retcode="\n    return (%s)rv;" % rettype.jni_type if rettype.jni_type != "void" else ""),
+              file=self.outc)
+
+        defined.add(name)
+
+    def struct(self, name, fields):
+        if self.config_getboolean(name, "exclude", fallback=False):
+            return
+        if name in opaque_structs:
+            return
+        defined.add(name)
+
+        helper = JavaStructEmitHelper(self, name, fields)
+        print(helper.get_java_code(), file=self.out)
+
+    def union(self, name, fields):
+        self.unions[name] = fields
+
+def generate(srcdir, outdir, config_struct_path, configpath, nivisionhpath):
+    # read config files
+    config_struct = configparser.ConfigParser()
+    config_struct.read(config_struct_path)
+    config = configparser.ConfigParser()
+    config.read(configpath)
+    block_comment_exclude = set(x.strip() for x in
+            config.get("Block Comment", "exclude").splitlines())
+
+    # open input file
+    inf = open(nivisionhpath)
+
+    # prescan for undefined structures
+    prescan_file(inf)
+    inf.seek(0)
+
+    # generate
+    emit = JavaEmitter(outdir, config, config_struct)
+    parse_file(emit, inf, block_comment_exclude)
+    emit.finish()
+
+if __name__ == "__main__":
+    if len(sys.argv) < 3:
+        print("Usage: gen_wrap.py <nivision.h> config_struct.ini [config.ini]")
+        exit(0)
+
+    fname = sys.argv[1]
+    config_struct_name = sys.argv[2]
+    configname = "nivision_2011.ini"
+    if len(sys.argv) >= 4:
+        configname = sys.argv[3]
+
+    generate("", "", config_struct_name, configname, fname)
diff --git a/wpilibj/wpilibJavaJNI/nivision/gen_struct_sizer.py b/wpilibj/wpilibJavaJNI/nivision/gen_struct_sizer.py
new file mode 100644
index 0000000000000000000000000000000000000000..d7c73c3a7484eb5f12e5bd2486982f3d15913dc2
--- /dev/null
+++ b/wpilibj/wpilibJavaJNI/nivision/gen_struct_sizer.py
@@ -0,0 +1,113 @@
+from __future__ import print_function
+import sys
+import os
+import re
+try:
+    import configparser
+except ImportError:
+    import ConfigParser as configparser
+
+from nivision_parse import *
+
+class StructSizerEmitter:
+    def __init__(self, out, config):
+        self.out = out
+        self.config = config
+        print("""#include <stdio.h>
+#include <nivision.h>
+
+int main()
+{
+    printf("[_platform_]\\npointer=%d\\n", (int)sizeof(void*));
+""", file=self.out)
+
+    def finish(self):
+        print("}", file=self.out)
+
+    def config_get(self, section, option, fallback):
+        try:
+            return self.config.get(section, option)
+        except (ValueError, configparser.NoSectionError, configparser.NoOptionError):
+            return fallback
+
+    def config_getboolean(self, section, option, fallback):
+        try:
+            return self.config.getboolean(section, option)
+        except (ValueError, configparser.NoSectionError, configparser.NoOptionError):
+            return fallback
+
+    def block_comment(self, comment):
+        pass
+
+    def opaque_struct(self, name):
+        pass
+
+    def define(self, name, value, comment):
+        pass
+
+    def text(self, text):
+        print(text, file=self.out)
+
+    def static_const(self, name, ctype, value):
+        pass
+
+    def enum(self, name, values):
+        pass
+
+    def typedef(self, name, typedef, arr):
+        pass
+
+    def typedef_function(self, name, restype, params):
+        pass
+
+    def function(self, name, restype, params):
+        pass
+
+    def structunion(self, ctype, name, fields):
+        if name in opaque_structs:
+            return
+
+        print('printf("[{name}]\\n_SIZE_=%d\\n", (int)sizeof({name}));'.format(name=name), file=self.out)
+
+        for fname, ftype, arr, comment in fields:
+            if ':' in fname:
+                continue # can't handle bitfields
+            print('printf("{field}=%d\\n", (int)offsetof({name}, {field}));'.format(name=name, field=fname), file=self.out)
+
+    def struct(self, name, fields):
+        self.structunion("Structure", name, fields)
+
+    def union(self, name, fields):
+        self.structunion("Union", name, fields)
+
+def generate(srcdir, configpath=None, nivisionhpath=None):
+    # read config file
+    config = configparser.ConfigParser()
+    config.read(configpath)
+    block_comment_exclude = set(x.strip() for x in
+            config.get("Block Comment", "exclude").splitlines())
+
+    # open input file
+    inf = open(nivisionhpath)
+
+    # prescan for undefined structures
+    prescan_file(inf)
+    inf.seek(0)
+
+    # generate
+    with open("struct_sizer.c", "wt") as out:
+        emit = StructSizerEmitter(out, config)
+        parse_file(emit, inf, block_comment_exclude)
+        emit.finish()
+
+if __name__ == "__main__":
+    if len(sys.argv) < 2:
+        print("Usage: gen_struct_sizer.py <nivision.h> [config.ini]")
+        exit(0)
+
+    fname = sys.argv[1]
+    configname = "nivision_2011.ini"
+    if len(sys.argv) >= 3:
+        configname = sys.argv[2]
+
+    generate("", configname, fname)
diff --git a/wpilibj/wpilibJavaJNI/nivision/generateJNI.sh b/wpilibj/wpilibJavaJNI/nivision/generateJNI.sh
new file mode 100755
index 0000000000000000000000000000000000000000..6c68013c2f84a8c0daa2d4b1bd6d761204129709
--- /dev/null
+++ b/wpilibj/wpilibJavaJNI/nivision/generateJNI.sh
@@ -0,0 +1,12 @@
+#!/bin/bash
+#This script should be able to generate the JNI
+#   bindings for NIVision.  At some point,
+#   it should be integrated into the build system.
+# Assumes running from allwpilib/wpilibj/wpilibJavaJNI/nivision
+# Get files that we node to generate from.
+# Run python generator.
+python gen_java.py ../../../wpilibc/wpilibC++Devices/include/nivision.h nivision_arm.ini nivision_2011.ini
+# Stick generated files into appropriate places.
+cp NIVision.cpp ../lib/NIVisionJNI.cpp
+mkdir -p ../../wpilibJavaDevices/src/main/java/com/ni/vision
+cp *.java ../../wpilibJavaDevices/src/main/java/com/ni/vision/
diff --git a/wpilibj/wpilibJavaJNI/nivision/nivision_2011.ini b/wpilibj/wpilibJavaJNI/nivision/nivision_2011.ini
new file mode 100644
index 0000000000000000000000000000000000000000..bf0f51fb2d6453985e17bf504da5c72db7bdd3a3
--- /dev/null
+++ b/wpilibj/wpilibJavaJNI/nivision/nivision_2011.ini
@@ -0,0 +1,821 @@
+;
+; [name]
+; arraysize -- comma separated list of "param:numParam" where param is the
+;              name of the pointer parameter, and numParam is the name of
+;              the parameter that contains the array size for the pointer
+; retarraysize -- name of the pass-by-reference parameter that on function
+;                 return contains the array size of the returned pointer
+; exclude -- if True, no code is output for this name (full custom)
+; underscore -- if True, only underscored raw wrapper is output (partial custom)
+; outparams -- comma separated list of output parameter names
+; inparams -- comma separated list of parameter names that are input
+;             parameters (e.g. not output parameters)
+; defaults -- comma separated list of "param:default" where param is the
+;             parameter name and default is the default value
+; exclude_members -- for structures, members to not emit
+; nullok -- comma separated list of parameter names that may be null
+; retref -- parameter that (if non-null) is returned as a reference
+; retunowned -- if True, return value should not be owned
+;
+; The generator code auto-detects many parameters, so this file is only needed
+; for overriding the auto-detected behavior.
+
+; defines
+[IMAQ_IMPORT]
+exclude=True
+[IMAQ_FUNC]
+exclude=True
+[IMAQ_STDCALL]
+exclude=True
+[IMAQ_CALLBACK]
+exclude=True
+[IMAQ_DEFAULT_LEARNING_MODE]
+exclude=True
+[ERR_INVALID_COLORCOMPLEXITY]
+exclude=True
+
+; structures
+[PolyModel]
+arraysize=kCoeffs:numKCoeffs
+[CalibrationReferencePoints]
+arraysize=pixelCoords:numPixelCoords,realCoords:numRealCoords
+[GetCameraParametersReport]
+#TODO: projectionMatrix:projectionMatrixRows*projectionMatrixCols
+exclude_members=projectionMatrix
+[GetCalibrationInfoReport]
+#TODO: errorMap:errorMapRows*errorMapCols
+exclude_members=errorMap
+[ContourFitSplineReport]
+arraysize=points:numberOfPoints
+[ContourFitPolynomialReport]
+arraysize=bestFit:numberOfPoints,polynomialCoefficients:numberOfCoefficients
+[SetupMatchPatternData]
+arraysize=matchSetupData:numMatchSetupData
+[ContourInfoReport]
+arraysize=pointsPixel:numPointsPixel,pointsReal:numPointsReal,curvaturePixel:numCurvaturePixel,curvatureReal:numCurvatureReal
+[SupervisedColorSegmentationReport]
+arraysize=labelOut:numLabelOut
+[LabelToROIReport]
+arraysize=roiArray:numOfROIs,labelsOutArray:numOfLabels,isTooManyVectorsArray:isTooManyVectorsArraySize
+[ClassifiedCurve]
+arraysize=curvePoints:numCurvePoints
+[CurvatureAnalysisReport]
+arraysize=curves:numCurves
+[ComputeDistancesReport]
+arraysize=distances:numDistances,distancesReal:numDistancesReal
+[ClassifiedDisparity]
+arraysize=templateSubsection:numTemplateSubsection,targetSubsection:numTargetSubsection
+[ClassifyDistancesReport]
+arraysize=classifiedDistances:numClassifiedDistances
+[ContourComputeCurvatureReport]
+arraysize=curvaturePixel:numCurvaturePixel,curvatureReal:numCurvatureReal
+[ExtractContourReport]
+arraysize=contourPoints:numContourPoints,sourcePoints:numSourcePoints
+[ExtractTextureFeaturesReport]
+arraysize=waveletBands:numWaveletBands
+#TODO: textureFeatures:textureFeaturesRows:textureFeaturesCols
+exclude_members=textureFeatures
+[WaveletBandsReport]
+#TODO: LLBand:rows:cols
+#TODO: LHBand:rows:cols
+#TODO: HLBand:rows:cols
+#TODO: HHBand:rows:cols
+#TODO: LLLBand:rows:cols
+#TODO: LLHBand:rows:cols
+#TODO: LHHBand:rows:cols
+exclude_members=LLBand,LHBand,HLBand,HHBand,LLLBand,LLHBand,LHHBand
+[MeasureParticlesReport]
+#TODO: pixelMeasurements:numParticles:numMeasurements
+#TODO: calibratedMeasurements:numParticles:numMeasurements
+exclude_members=pixelMeasurements,calibratedMeasurements
+[ClassifierReportAdvanced]
+arraysize=allScores:allScoresSize,sampleScores:sampleScoresSize
+[FindEdgeReport]
+arraysize=straightEdges:numStraightEdges
+[ReadTextReport3]
+arraysize=characterReport:numCharacterReports
+[EdgeReport2]
+arraysize=edges:numEdges,gradientInfo:numGradientInfo
+[ConcentricRakeReport2]
+arraysize=firstEdges:numFirstEdges,lastEdges:numLastEdges,searchArcs:numSearchArcs
+[SpokeReport2]
+arraysize=firstEdges:numFirstEdges,lastEdges:numLastEdges,searchLines:numSearchLines
+[RakeReport2]
+arraysize=firstEdges:numFirstEdges,lastEdges:numLastEdges,searchLines:numSearchLines
+[QRCodeDataToken]
+arraysize=data:dataLength
+[StraightEdgeReport2]
+arraysize=straightEdges:numStraightEdges,searchLines:numSearchLines
+[StraightEdge]
+arraysize=usedEdges:numUsedEdges
+[QRCodeReport]
+arraysize=data:dataLength,tokenizedData:sizeOfTokenizedData
+[DataMatrixReport]
+arraysize=data:dataLength
+[ReadTextReport2]
+arraysize=characterReport:numCharacterReports
+[FeatureData]
+arraysize=contourPoints:numContourPoints
+uniontype=feature:type:IMAQ_CIRCLE_FEATURE=circle:IMAQ_ELLIPSE_FEATURE=ellipse:IMAQ_CONST_CURVE_FEATURE=constCurve:IMAQ_RECTANGLE_FEATURE=rectangle:IMAQ_LEG_FEATURE=leg:IMAQ_CORNER_FEATURE=corner:IMAQ_PARALLEL_LINE_PAIR_FEATURE=parallelLinePair:IMAQ_PAIR_OF_PARALLEL_LINE_PAIRS_FEATURE=pairOfParallelLinePairs:IMAQ_LINE_FEATURE=line:IMAQ_CLOSED_CURVE_FEATURE=closedCurve
+[GeometricPatternMatch2]
+arraysize=featureData:numFeatureData
+[ShapeDetectionOptions]
+arraysize=angleRanges:numAngleRanges
+[Curve]
+arraysize=points:numPoints
+[Barcode2DInfo]
+arraysize=data:dataLength
+[ClassifierAccuracyReport]
+arraysize=classNames:size,classAccuracy:size,classPredictiveValue:size
+#TODO: classificationDistribution:classPredictiveValue:size
+exclude_members=classificationDistribution
+[NearestNeighborTrainingReport]
+arraysize=allScores:allScoresSize
+#TODO: classDistancesTable
+exclude_members=classDistancesTable
+[ClassifierSampleInfo]
+arraysize=featureVector:featureVectorSize
+[ClassifierReport]
+arraysize=allScores:allScoresSize
+[MatchGeometricPatternOptions]
+arraysize=angleRanges:numAngleRanges
+[ConstructROIOptions2]
+arraysize=palette:numColors
+[BestEllipse2]
+arraysize=pointsUsed:numPointsUsed
+[BestCircle2]
+arraysize=pointsUsed:numPointsUsed
+[ReadTextOptions]
+arraysize=validChars:numValidChars
+[ReadTextReport]
+arraysize=characterReport:numCharacterReports
+[EdgeLocationReport]
+arraysize=edges:numEdges
+[ImageInfo]
+#TODO: imageStart
+exclude_members=reserved0,reserved1,imageStart
+[LCDReport]
+arraysize=segmentInfo:numCharacters
+exclude_members=reserved
+[LCDSegments]
+exclude_members=reserved
+[LearnColorPatternOptions]
+arraysize=colorsToIgnore:numColorsToIgnore
+[LinearAverages]
+arraysize=columnAverages:columnCount,rowAverages:rowCount,risingDiagAverages:risingDiagCount,fallingDiagAverages:fallingDiagCount
+[LineProfile]
+arraysize=profileData:dataCount
+[MatchColorPatternOptions]
+arraysize=angleRanges:numRanges
+[HistogramReport]
+arraysize=histogram:histogramCount
+[BestLine]
+arraysize=pointsUsed:numPointsUsed
+[CalibrationInfo]
+#TODO: errorMap:mapColumns*mapRows
+exclude_members=errorMap
+[CalibrationPoints]
+arraysize=pixelCoordinates:numCoordinates,realWorldCoordinates:numCoordinates
+[CaliperReport]
+exclude_members=reserved
+[ClosedContour]
+arraysize=points:numPoints
+[ColorInformation]
+arraysize=info:infoCount
+[ConcentricRakeReport]
+arraysize=rakeArcs:numArcs,firstEdges:numFirstEdges,lastEdges:numLastEdges,allEdges:numLinesWithEdges,linesWithEdges:numLinesWithEdges
+[ConstructROIOptions]
+arraysize=palette:numColors
+[ContourInfo]
+arraysize=points:numPoints
+[ContourInfo2]
+uniontype=structure:type:IMAQ_POINT=point:IMAQ_LINE=line:IMAQ_RECT=rect:IMAQ_OVAL=ovalBoundingBox:IMAQ_CLOSED_CONTOUR=closedContour:IMAQ_OPEN_CONTOUR=openContour:IMAQ_ANNULUS=annulus:IMAQ_ROTATED_RECT=rotatedRect
+[UserPointSymbol]
+#TODO: pixels:cols*rows
+exclude_members=pixels
+[MatchPatternOptions]
+arraysize=angleRanges:numRanges
+[OpenContour]
+arraysize=points:numPoints
+[QuantifyReport]
+arraysize=regions:regionCount
+[RakeReport]
+arraysize=rakeLines:numRakeLines,firstEdges:numFirstEdges,lastEdges:numLastEdges,allEdges:numLinesWithEdges,linesWithEdges:numLinesWithEdges
+[TransformReport]
+arraysize=points:numPoints,validPoints:numPoints
+[MeterArc]
+arraysize=arcCoordPoints:numOfArcCoordPoints
+[StructuringElement]
+#TODO: arraysize=kernel:matrixRows*matrixCols
+exclude_members=kernel
+[SpokeReport]
+arraysize=spokeLines:numSpokeLines,firstEdges:numFirstEdges,lastEdges:numLastEdges,allEdges:numLinesWithEdges,linesWithEdges:numLinesWithEdges
+[ToolWindowOptions]
+exclude_members=reserved2,reserved3,reserved4
+[EventCallback]
+exclude=True
+
+; Logical functions
+; TODO: constant versions
+[imaqAndConstant]
+exclude=True
+[imaqCompareConstant]
+exclude=True
+[imaqLogicalDifferenceConstant]
+exclude=True
+[imaqNandConstant]
+exclude=True
+[imaqNorConstant]
+exclude=True
+[imaqOrConstant]
+exclude=True
+[imaqXnorConstant]
+exclude=True
+[imaqXorConstant]
+exclude=True
+
+; Arithmetic functions
+; TODO: constant versions
+[imaqAbsoluteDifferenceConstant]
+exclude=True
+[imaqAddConstant]
+exclude=True
+[imaqAverageConstant]
+exclude=True
+[imaqDivideConstant2]
+exclude=True
+[imaqMaxConstant2]
+exclude=True
+[imaqMinConstant]
+exclude=True
+[imaqModuloConstant]
+exclude=True
+[imaqMultiplyConstant]
+exclude=True
+[imaqSubtractConstant]
+exclude=True
+
+; Particle Analysis functions
+[imaqCountParticles]
+outparams=numParticles
+[imaqMeasureParticle]
+outparams=value
+[imaqMeasureParticles]
+arraysize=measurements:numMeasurements
+[imaqParticleFilter4]
+arraysize=criteria:criteriaCount
+outparams=numParticles
+
+; Morphology functions
+[imaqFindCircles]
+retarraysize=numCircles
+[imaqLabel2]
+outparams=particleCount
+[imaqMorphology]
+nullok=structuringElement
+[imaqSeparation]
+nullok=structuringElement
+[imaqSimpleDistance]
+nullok=structuringElement
+[imaqSizeFilter]
+nullok=structuringElement
+
+; Acquisition functions
+[imaqCopyFromRing]
+nullok=image,imageNumber
+outparams=imageNumber
+retref=image
+[imaqExtractFromRing]
+nullok=imageNumber
+outparams=imageNumber
+retunowned=True
+[imaqGrab]
+nullok=image
+retref=image
+[imaqSetupRing]
+arraysize=images:numImages
+inparams=images
+[imaqSetupSequence]
+arraysize=images:numImages
+inparams=images
+[imaqSnap]
+nullok=image
+retref=image
+
+; Caliper functions
+[imaqCaliperTool]
+retarraysize=numEdgePairs
+arraysize=points:numPoints
+[imaqDetectExtremes]
+retarraysize=numExtremes
+arraysize=pixels:numPixels
+[imaqFindTransformRect2]
+outparams=baseSystem,newSystem,axisReport
+[imaqFindTransformRects2]
+outparams=baseSystem,newSystem,axisReport
+[imaqSimpleEdge]
+retarraysize=numEdges
+arraysize=points:numPoints
+
+; Spatial Filters functions
+[imaqCannyEdgeFilter]
+nullok=options
+[imaqConvolve2]
+inparams=kernel
+exclude=True
+[imaqEdgeFilter]
+nullok=mask
+[imaqLowPass]
+nullok=mask
+[imaqMedianFilter]
+nullok=mask
+[imaqNthOrderFilter]
+nullok=mask
+
+; Drawing functions
+[imaqDrawTextOnImage]
+nullok=options,fontNameUsed
+
+; Interlacing functions
+[imaqInterlaceSeparate]
+nullok=odd,even
+
+; Image Information functions
+[imaqEnumerateCustomKeys]
+retarraysize=size
+[imaqGetImageSize]
+nullok=width,height
+[imaqGetPixelAddress]
+underscored=True
+[imaqReadCustomData]
+underscored=True
+
+; Display functions
+[imaqGetLastKey]
+nullok=keyPressed,windowNumber,modifiers
+[imaqGetWindowCenterPos]
+outparams=centerPosition
+
+; Image Manipulation functions
+[imaqCast]
+nullok=lookup
+exclude=True
+[imaqFlatten]
+underscored=True
+exclude=True
+[imaqRotate2]
+# TODO because of PixelValue
+exclude=True
+[imaqShift]
+# TODO because of PixelValue
+exclude=True
+[imaqUnflatten]
+underscored=True
+exclude=True
+
+; File I/O functions
+[imaqGetAVIInfo]
+outparams=info
+[imaqGetFileInfo]
+nullok=calibrationUnit,calibrationX,calibrationY,width,height,imageType
+[imaqGetFilterNames]
+retarraysize=numFilters
+[imaqLoadImagePopup]
+retarraysize=numPaths
+[imaqReadAVIFrame]
+exclude=True
+[imaqReadFile]
+nullok=colorTable,numColors
+[imaqWriteBMPFile]
+nullok=colorTable
+defaults=colorTable:null
+[imaqWriteFile]
+nullok=colorTable
+defaults=colorTable:null
+[imaqWriteJPEGFile]
+nullok=colorTable
+defaults=colorTable:null
+inparams=colorTable
+[imaqWritePNGFile2]
+nullok=colorTable
+defaults=colorTable:null
+[imaqWriteTIFFFile]
+nullok=options,colorTable
+defaults=options:null,colorTable:null
+
+; Analytic Geometry functions
+[imaqBuildCoordinateSystem]
+outparams=system
+[imaqFitCircle2]
+arraysize=points:numPoints
+[imaqFitEllipse2]
+arraysize=points:numPoints
+[imaqFitLine]
+arraysize=points:numPoints
+[imaqGetBisectingLine]
+outparams=bisectStart,bisectEnd
+[imaqGetIntersection]
+outparams=intersection
+[imaqGetMidLine]
+outparams=midLineStart,midLineEnd
+[imaqGetPerpendicularLine]
+outparams=perpLineStart,perpLineEnd
+[imaqGetPointsOnContour]
+retarraysize=numSegments
+[imaqGetPointsOnLine]
+retarraysize=numPoints
+[imaqInterpolatePoints]
+retarraysize=interpCount
+arraysize=points:numPoints
+
+; Clipboard functions
+[imaqClipboardToImage]
+nullok=palette
+[imaqImageToClipboard]
+nullok=palette
+
+; Image Management functions
+[imaqCreateImage]
+defaults=borderSize:0
+[imaqImageToArray]
+nullok=columns,rows
+underscored=True
+exclude=True
+
+; Color Processing functions
+[imaqChangeColorSpace2]
+# TODO because of Color2
+exclude=True
+[imaqColorBCGTransform]
+nullok=redOptions,greenOptions,blueOptions,mask
+[imaqColorHistogram2]
+nullok=mask
+[imaqColorLookup]
+nullok=mask,plane1,plane2,plane3
+exclude=True
+[imaqColorThreshold]
+nullok=plane1Range,plane2Range,plane3Range
+
+; Transform functions
+[imaqBCGTransform]
+nullok=mask
+[imaqEqualize]
+nullok=mask
+[imaqInverse]
+nullok=mask
+[imaqMathTransform]
+nullok=mask
+[imaqLookup2]
+nullok=mask
+exclude=True
+
+; Window Management functions
+[imaqGetMousePos]
+nullok=position,windowNumber
+[imaqGetWindowBackground]
+outparams=backgroundColor
+[imaqGetWindowDisplayMapping]
+outparams=mapping
+[imaqGetWindowGrid]
+nullok=xResolution,yResolution
+[imaqGetWindowPos]
+outparams=position
+[imaqGetWindowSize]
+nullok=width,height
+[imaqSetWindowPalette]
+arraysize=palette:numColors
+nullok=palette
+
+; Utilities functions
+; Many Make* functions are faster in native Python
+[imaqMakeAnnulus]
+exclude=True
+[imaqMakePoint]
+exclude=True
+[imaqMakePointFloat]
+exclude=True
+[imaqMakeRect]
+exclude=True
+[imaqMakeRectFromRotatedRect]
+exclude=True
+[imaqMakeRotatedRect]
+exclude=True
+[imaqMakeRotatedRectFromRect]
+exclude=True
+[imaqMulticoreOptions]
+underscored=True
+
+; Tool Window functions
+[imaqGetLastEvent]
+nullok=windowNumber,tool,rect
+outparams=type,tool,rect
+[imaqGetToolWindowPos]
+outparams=position
+[imaqSetEventCallback]
+exclude=True
+[imaqSetupToolWindow]
+nullok=options
+
+; Meter functions
+[imaqReadMeter]
+outparams=endOfNeedle
+
+; Calibration functions
+[imaqCorrectCalibratedImage]
+# TODO because of PixelValue
+exclude=True
+[imaqTransformPixelToRealWorld]
+arraysize=pixelCoordinates:numCoordinates
+[imaqTransformRealWorldToPixel]
+arraysize=realWorldCoordinates:numCoordinates
+
+; Pixel Manipulation functions
+[imaqArrayToComplexPlane]
+exclude=True
+[imaqComplexPlaneToArray]
+nullok=columns,rows
+underscored=True
+exclude=True
+[imaqExtractColorPlanes]
+nullok=plane1,plane2,plane3
+[imaqFillImage]
+nullok=mask
+# TODO because of PixelValue
+exclude=True
+[imaqGetLine]
+nullok=numPoints
+underscored=True
+exclude=True
+[imaqGetPixel]
+outparams=value
+# TODO because of PixelValue
+exclude=True
+[imaqReplaceColorPlanes]
+nullok=plane1,plane2,plane3
+[imaqSetLine]
+underscored=True
+exclude=True
+[imaqSetPixel]
+# TODO because of PixelValue
+exclude=True
+
+; Color Matching functions
+[imaqLearnColor]
+nullok=roi
+[imaqMatchColor]
+retarraysize=numScores
+nullok=roi
+
+; Barcode I/O functions
+[imaqGradeDataMatrixBarcodeAIM]
+outparams=report
+[imaqReadBarcode]
+nullok=roi
+[imaqReadPDF417Barcode]
+retarraysize=numBarcodes
+[imaqReadQRCode]
+defaults=reserved:IMAQ_QR_NO_GRADING
+
+; LCD functions
+[imaqFindLCDSegments]
+nullok=options
+[imaqReadLCD]
+nullok=options
+
+; Shape Matching functions
+[imaqMatchShape]
+retarraysize=numMatches
+
+; Contours functions
+[imaqAddClosedContour]
+arraysize=points:numPoints
+[imaqAddOpenContour]
+arraysize=points:numPoints
+[imaqGetContourColor]
+outparams=contourColor
+
+; Regions of Interest functions
+[imaqGetROIBoundingBox]
+outparams=boundingBox
+[imaqGetROIColor]
+outparams=roiColor
+[imaqSetWindowROI]
+nullok=roi
+
+; Image Analysis functions
+[imaqExtractCurves]
+retarraysize=numCurves
+[imaqHistogram]
+nullok=mask
+[imaqQuantify]
+nullok=mask
+
+; Error Management functions
+[imaqClearError]
+exclude=True
+[imaqGetErrorText]
+exclude=True
+[imaqGetLastError]
+exclude=True
+[imaqGetLastErrorFunc]
+exclude=True
+[imaqSetError]
+nullok=function
+exclude=True
+
+; Threshold functions
+[imaqMultithreshold]
+arraysize=ranges:numRanges
+
+; Memory Management functions
+[imaqDispose]
+# This is done as a full-custom function
+exclude=True
+
+; Pattern Matching functions
+[imaqDetectCircles]
+retarraysize=numMatchesReturned
+[imaqDetectEllipses]
+retarraysize=numMatchesReturned
+[imaqDetectLines]
+retarraysize=numMatchesReturned
+[imaqDetectRectangles]
+retarraysize=numMatchesReturned
+[imaqGetGeometricFeaturesFromCurves]
+retarraysize=numFeatures
+arraysize=curves:numCurves,featureTypes:numFeatureTypes
+[imaqGetGeometricTemplateFeatureInfo]
+retarraysize=numFeatures
+[imaqLearnMultipleGeometricPatterns]
+arraysize=patterns:numberOfPatterns
+exclude=True
+[imaqMatchColorPattern]
+retarraysize=numMatches
+[imaqMatchGeometricPattern2]
+retarraysize=numMatches
+[imaqMatchMultipleGeometricPatterns]
+retarraysize=numMatches
+[imaqReadMultipleGeometricPatternFile]
+underscored=True
+[imaqRefineMatches]
+retarraysize=numCandidatesOut
+arraysize=candidatesIn:numCandidatesIn
+[imaqMatchGeometricPattern3]
+retarraysize=numMatches
+[imaqMatchPattern3]
+retarraysize=numMatches
+nullok=options
+
+; Overlay functions
+[imaqGetOverlayProperties]
+outparams=transformBehaviors
+[imaqMergeOverlay]
+arraysize=palette:numColors
+[imaqOverlayBitmap]
+underscored=True
+[imaqOverlayClosedContour]
+arraysize=points:numPoints
+[imaqOverlayOpenContour]
+arraysize=points:numPoints
+[imaqOverlayPoints]
+arraysize=points:numPoints,colors:numColors
+
+; OCR functions
+[imaqVerifyPatterns]
+arraysize=expectedPatterns:patternCount
+retarraysize=numScores
+[imaqVerifyText]
+retarraysize=numScores
+
+; Geometric Matching functions
+[imaqContourClassifyCurvature]
+arraysize=curvatureClasses:numCurvatureClasses
+[imaqContourClassifyDistances]
+arraysize=distanceRanges:numDistanceRanges
+[imaqContourSetupMatchPattern]
+arraysize=rangeSettings:numRangeSettings
+[imaqContourAdvancedSetupMatchPattern]
+arraysize=geometricOptions:numGeometricOptions
+
+; Morphology Reconstruction functions
+[imaqGrayMorphologyReconstruct]
+arraysize=points:numOfPoints
+[imaqMorphologyReconstruct]
+arraysize=points:numOfPoints
+
+; Texture functions
+[imaqCooccurrenceMatrix]
+exclude=True
+[imaqExtractTextureFeatures]
+inparams=waveletBands
+exclude=True
+[imaqExtractWaveletBands]
+inparams=waveletBands
+exclude=True
+
+; Regions of Interest Manipulation functions
+[imaqMaskToROI]
+nullok=withinLimit
+[imaqROIToMask]
+nullok=imageModel,inSpace
+[imaqLabelToROI]
+arraysize=labelsIn:numLabelsIn
+
+; Morphology functions
+[imaqGrayMorphology]
+nullok=structuringElement
+
+; Classification functions
+[imaqAddClassifierSample]
+arraysize=featureVector:vectorSize
+[imaqAdvanceClassify]
+arraysize=featureVector:vectorSize
+[imaqClassify]
+arraysize=featureVector:vectorSize
+[imaqGetColorClassifierOptions]
+outparams=options
+[imaqGetNearestNeighborOptions]
+outparams=options
+;[imaqReadClassifierFile]
+;[imaqWriteClassifierFile]
+
+; Obsolete functions
+[imaqWritePNGFile]
+nullok=colorTable
+defaults=colorTable:null
+[imaqRotate]
+# TODO because of PixelValue
+exclude=True
+[imaqSelectParticles]
+retarraysize=selectedCount
+[imaqGetParticleInfo]
+retarraysize=reportCount
+[imaqEdgeTool]
+retarraysize=numEdges
+[imaqCircles]
+retarraysize=numCircles
+[imaqFitEllipse]
+arraysize=points:numPoints
+outparams=ellipse
+[imaqFitCircle]
+arraysize=points:numPoints
+outparams=circle
+[imaqChangeColorSpace]
+# TODO because of Color
+exclude=True
+[imaqMatchPattern]
+retarraysize=numMatches
+nullok=options
+[imaqLineGaugeTool]
+nullok=reference
+[imaqBestCircle]
+arraysize=points:numPoints
+outparams=center
+[imaqCoordinateReference]
+outparams=origin
+[imaqSetWindowOverlay]
+nullok=overlay
+[imaqGetCalibrationInfo]
+outparams=unit,xDistance,yDistance
+nullok=unit,xDistance,yDistance
+[imaqGetParticleClassifierOptions]
+outparams=preprocessingOptions,options
+[imaqConvolve]
+nullok=mask
+inparams=kernel
+exclude=True
+[imaqDivideConstant]
+# TODO because of PixelValue
+exclude=True
+[imaqLookup]
+nullok=mask
+exclude=True
+[imaqMatchPattern2]
+retarraysize=numMatches
+nullok=options
+[imaqMaxConstant]
+# TODO because of PixelValue
+exclude=True
+[imaqParticleFilter2]
+arraysize=criteria:criteriaCount
+[imaqEdgeTool2]
+retarraysize=numEdges
+[imaqReadDataMatrixBarcode]
+retarraysize=numBarcodes
+[imaqMatchGeometricPattern]
+retarraysize=numMatches
+[imaqColorHistogram]
+nullok=mask
+
+; block comment exclusion list
+[Block Comment]
+exclude=
+ Includes
+ Control Defines
+ Macros
+ This accomplishes said task.
+ If using Visual C++, force startup & shutdown code to run.
+ Error Management functions
+ Callback Function Type
+ Backwards Compatibility
+ Error Codes
diff --git a/wpilibj/wpilibJavaJNI/nivision/nivision_arm.ini b/wpilibj/wpilibJavaJNI/nivision/nivision_arm.ini
new file mode 100644
index 0000000000000000000000000000000000000000..08ea2e0abd07cf78e7c71b1099c222fe665c73c8
--- /dev/null
+++ b/wpilibj/wpilibJavaJNI/nivision/nivision_arm.ini
@@ -0,0 +1,1863 @@
+[_platform_]
+pointer=4
+[DivisionModel]
+_SIZE_=4
+kappa=0
+[FocalLength]
+_SIZE_=8
+fx=0
+fy=4
+[PolyModel]
+_SIZE_=16
+kCoeffs=0
+numKCoeffs=4
+p1=8
+p2=12
+[DistortionModelParams]
+_SIZE_=24
+distortionModel=0
+polyModel=4
+divisionModel=20
+[PointFloat]
+_SIZE_=8
+x=0
+y=4
+[InternalParameters]
+_SIZE_=20
+isInsufficientData=0
+focalLength=4
+opticalCenter=12
+[MaxGridSize]
+_SIZE_=8
+xMax=0
+yMax=4
+[ImageSize]
+_SIZE_=8
+xRes=0
+yRes=4
+[CalibrationReferencePoints]
+_SIZE_=28
+pixelCoords=0
+numPixelCoords=4
+realCoords=8
+numRealCoords=12
+units=16
+imageSize=20
+[GetCameraParametersReport]
+_SIZE_=56
+projectionMatrix=0
+projectionMatrixRows=4
+projectionMatrixCols=8
+distortion=12
+internalParams=36
+[CalibrationAxisInfo]
+_SIZE_=16
+center=0
+rotationAngle=8
+axisDirection=12
+[CalibrationLearnSetupInfo]
+_SIZE_=20
+calibrationMethod=0
+distortionModel=4
+scaleMode=8
+roiMode=12
+learnCorrectionTable=16
+[GridDescriptor]
+_SIZE_=12
+xStep=0
+yStep=4
+unit=8
+[ErrorStatistics]
+_SIZE_=32
+mean=0
+maximum=8
+standardDeviation=16
+distortion=24
+[GetCalibrationInfoReport]
+_SIZE_=104
+userRoi=0
+calibrationRoi=4
+axisInfo=8
+learnSetupInfo=24
+gridDescriptor=44
+errorMap=56
+errorMapRows=60
+errorMapCols=64
+errorStatistics=72
+[EdgePolarity]
+_SIZE_=8
+start=0
+end=4
+[ClampSettings]
+_SIZE_=16
+angleRange=0
+edgePolarity=8
+[PointDouble]
+_SIZE_=16
+x=0
+y=8
+[PointDoublePair]
+_SIZE_=32
+start=0
+end=16
+[ClampResults]
+_SIZE_=32
+distancePix=0
+distanceRealWorld=8
+angleAbs=16
+angleRelative=24
+[ClampPoints]
+_SIZE_=64
+pixel=0
+realWorld=32
+[RGBValue]
+_SIZE_=4
+B=0
+G=1
+R=2
+alpha=3
+[ClampOverlaySettings]
+_SIZE_=36
+showSearchArea=0
+showCurves=4
+showClampLocation=8
+showResult=12
+searchAreaColor=16
+curvesColor=20
+clampLocationsColor=24
+resultColor=28
+overlayGroupName=32
+[ClampMax2Report]
+_SIZE_=104
+clampResults=0
+clampPoints=32
+calibrationValid=96
+[ContourFitSplineReport]
+_SIZE_=8
+points=0
+numberOfPoints=4
+[LineFloat]
+_SIZE_=16
+start=0
+end=8
+[LineEquation]
+_SIZE_=24
+a=0
+b=8
+c=16
+[ContourFitLineReport]
+_SIZE_=40
+lineSegment=0
+lineEquation=16
+[ContourFitPolynomialReport]
+_SIZE_=16
+bestFit=0
+numberOfPoints=4
+polynomialCoefficients=8
+numberOfCoefficients=12
+[PartialCircle]
+_SIZE_=32
+center=0
+radius=8
+startAngle=16
+endAngle=24
+[PartialEllipse]
+_SIZE_=48
+center=0
+angle=8
+majorRadius=16
+minorRadius=24
+startAngle=32
+endAngle=40
+[SetupMatchPatternData]
+_SIZE_=8
+matchSetupData=0
+numMatchSetupData=4
+[RangeSettingDouble]
+_SIZE_=24
+settingType=0
+min=8
+max=16
+[GeometricAdvancedSetupDataOption]
+_SIZE_=16
+type=0
+value=8
+[ContourInfoReport]
+_SIZE_=56
+pointsPixel=0
+numPointsPixel=4
+pointsReal=8
+numPointsReal=12
+curvaturePixel=16
+numCurvaturePixel=20
+curvatureReal=24
+numCurvatureReal=28
+length=32
+lengthReal=40
+hasEquation=48
+[ROILabel]
+_SIZE_=8
+className=0
+label=4
+[SupervisedColorSegmentationReport]
+_SIZE_=8
+labelOut=0
+numLabelOut=4
+[LabelToROIReport]
+_SIZE_=24
+roiArray=0
+numOfROIs=4
+labelsOutArray=8
+numOfLabels=12
+isTooManyVectorsArray=16
+isTooManyVectorsArraySize=20
+[ColorSegmenationOptions]
+_SIZE_=24
+windowX=0
+windowY=4
+stepSize=8
+minParticleArea=12
+maxParticleArea=16
+isFineSegment=20
+[ClassifiedCurve]
+_SIZE_=48
+length=0
+lengthReal=8
+maxCurvature=16
+maxCurvatureReal=24
+label=32
+curvePoints=36
+numCurvePoints=40
+[RangeDouble]
+_SIZE_=16
+minValue=0
+maxValue=8
+[RangeLabel]
+_SIZE_=24
+range=0
+label=16
+[CurvatureAnalysisReport]
+_SIZE_=8
+curves=0
+numCurves=4
+[Disparity]
+_SIZE_=40
+current=0
+reference=16
+distance=32
+[ComputeDistancesReport]
+_SIZE_=16
+distances=0
+numDistances=4
+distancesReal=8
+numDistancesReal=12
+[MatchMode]
+_SIZE_=12
+rotation=0
+scale=4
+occlusion=8
+[ClassifiedDisparity]
+_SIZE_=56
+length=0
+lengthReal=8
+maxDistance=16
+maxDistanceReal=24
+label=32
+templateSubsection=36
+numTemplateSubsection=40
+targetSubsection=44
+numTargetSubsection=48
+[ClassifyDistancesReport]
+_SIZE_=8
+classifiedDistances=0
+numClassifiedDistances=4
+[ContourComputeCurvatureReport]
+_SIZE_=16
+curvaturePixel=0
+numCurvaturePixel=4
+curvatureReal=8
+numCurvatureReal=12
+[ContourOverlaySettings]
+_SIZE_=16
+overlay=0
+color=4
+width=8
+maintainWidth=12
+[CurveParameters]
+_SIZE_=28
+extractionMode=0
+threshold=4
+filterSize=8
+minLength=12
+searchStep=16
+maxEndPointGap=20
+subpixel=24
+[ExtractContourReport]
+_SIZE_=16
+contourPoints=0
+numContourPoints=4
+sourcePoints=8
+numSourcePoints=12
+[ConnectionConstraint]
+_SIZE_=24
+constraintType=0
+range=8
+[ExtractTextureFeaturesReport]
+_SIZE_=20
+waveletBands=0
+numWaveletBands=4
+textureFeatures=8
+textureFeaturesRows=12
+textureFeaturesCols=16
+[WaveletBandsReport]
+_SIZE_=40
+LLBand=0
+LHBand=4
+HLBand=8
+HHBand=12
+LLLBand=16
+LLHBand=20
+LHLBand=24
+LHHBand=28
+rows=32
+cols=36
+[CircleFitOptions]
+_SIZE_=24
+maxRadius=0
+stepSize=8
+processType=16
+[EdgeOptions2]
+_SIZE_=24
+polarity=0
+kernelSize=4
+width=8
+minThreshold=12
+interpolationType=16
+columnProcessingMode=20
+[FindCircularEdgeOptions]
+_SIZE_=64
+direction=0
+showSearchArea=4
+showSearchLines=8
+showEdgesFound=12
+showResult=16
+searchAreaColor=20
+searchLinesColor=24
+searchEdgesColor=28
+resultColor=32
+overlayGroupName=36
+edgeOptions=40
+[FindConcentricEdgeOptions]
+_SIZE_=64
+direction=0
+showSearchArea=4
+showSearchLines=8
+showEdgesFound=12
+showResult=16
+searchAreaColor=20
+searchLinesColor=24
+searchEdgesColor=28
+resultColor=32
+overlayGroupName=36
+edgeOptions=40
+[ConcentricEdgeFitOptions]
+_SIZE_=24
+maxRadius=0
+stepSize=8
+processType=16
+[FindConcentricEdgeReport]
+_SIZE_=80
+startPt=0
+endPt=8
+startPtCalibrated=16
+endPtCalibrated=24
+angle=32
+angleCalibrated=40
+straightness=48
+avgStrength=56
+avgSNR=64
+lineFound=72
+[FindCircularEdgeReport]
+_SIZE_=64
+centerCalibrated=0
+radiusCalibrated=8
+center=16
+radius=24
+roundness=32
+avgStrength=40
+avgSNR=48
+circleFound=56
+[WindowSize]
+_SIZE_=12
+x=0
+y=4
+stepSize=8
+[DisplacementVector]
+_SIZE_=8
+x=0
+y=4
+[WaveletOptions]
+_SIZE_=8
+typeOfWavelet=0
+minEnergy=4
+[CooccurrenceOptions]
+_SIZE_=12
+level=0
+displacement=4
+[ParticleClassifierLocalThresholdOptions]
+_SIZE_=24
+method=0
+particleType=4
+windowWidth=8
+windowHeight=12
+deviationWeight=16
+[RangeFloat]
+_SIZE_=8
+minValue=0
+maxValue=4
+[ParticleClassifierAutoThresholdOptions]
+_SIZE_=16
+method=0
+particleType=4
+limits=8
+[ParticleClassifierPreprocessingOptions2]
+_SIZE_=64
+thresholdType=0
+manualThresholdRange=4
+autoThresholdOptions=12
+localThresholdOptions=32
+rejectBorder=56
+numErosions=60
+[MeasureParticlesReport]
+_SIZE_=16
+pixelMeasurements=0
+calibratedMeasurements=4
+numParticles=8
+numMeasurements=12
+[GeometricPatternMatch3]
+_SIZE_=116
+position=0
+rotation=8
+scale=12
+score=16
+corner=20
+inverse=52
+occlusion=56
+templateMatchCurveScore=60
+matchTemplateCurveScore=64
+correlationScore=68
+calibratedPosition=72
+calibratedRotation=80
+calibratedCorner=84
+[MatchGeometricPatternAdvancedOptions3]
+_SIZE_=88
+subpixelIterations=0
+subpixelTolerance=8
+initialMatchListLength=16
+targetTemplateCurveScore=20
+correlationScore=24
+minMatchSeparationDistance=32
+minMatchSeparationAngle=40
+minMatchSeparationScale=48
+maxMatchOverlap=56
+coarseResult=64
+enableCalibrationSupport=68
+enableContrastReversal=72
+matchStrategy=76
+refineMatchFactor=80
+subpixelMatchFactor=84
+[ColorOptions]
+_SIZE_=12
+colorClassificationResolution=0
+useLuminance=4
+colorMode=8
+[SampleScore]
+_SIZE_=12
+className=0
+distance=4
+index=8
+[ClassifierReportAdvanced]
+_SIZE_=28
+bestClassName=0
+classificationScore=4
+identificationScore=8
+allScores=12
+allScoresSize=16
+sampleScores=20
+sampleScoresSize=24
+[LearnGeometricPatternAdvancedOptions2]
+_SIZE_=40
+minScaleFactor=0
+maxScaleFactor=8
+minRotationAngleValue=16
+maxRotationAngleValue=24
+imageSamplingFactor=32
+[ParticleFilterOptions2]
+_SIZE_=16
+rejectMatches=0
+rejectBorder=4
+fillHoles=8
+connectivity8=12
+[FindEdgeOptions2]
+_SIZE_=64
+direction=0
+showSearchArea=4
+showSearchLines=8
+showEdgesFound=12
+showResult=16
+searchAreaColor=20
+searchLinesColor=24
+searchEdgesColor=28
+resultColor=32
+overlayGroupName=36
+edgeOptions=40
+[FindEdgeReport]
+_SIZE_=8
+straightEdges=0
+numStraightEdges=4
+[FindTransformRectOptions2]
+_SIZE_=64
+direction=0
+showSearchArea=4
+showSearchLines=8
+showEdgesFound=12
+showResult=16
+searchAreaColor=20
+searchLinesColor=24
+searchEdgesColor=28
+resultColor=32
+overlayGroupName=36
+edgeOptions=40
+[FindTransformRectsOptions2]
+_SIZE_=88
+direction=0
+showSearchArea=4
+showSearchLines=8
+showEdgesFound=12
+showResult=16
+searchAreaColor=20
+searchLinesColor=24
+searchEdgesColor=28
+resultColor=32
+overlayGroupName=36
+primaryEdgeOptions=40
+secondaryEdgeOptions=64
+[ReadTextReport3]
+_SIZE_=16
+readString=0
+characterReport=4
+numCharacterReports=8
+roiBoundingCharacters=12
+[CharacterStatistics]
+_SIZE_=20
+left=0
+top=4
+width=8
+height=12
+characterSize=16
+[CharReport3]
+_SIZE_=44
+character=0
+classificationScore=4
+verificationScore=8
+verified=12
+lowThreshold=16
+highThreshold=20
+characterStats=24
+[ArcInfo2]
+_SIZE_=32
+center=0
+radius=8
+startAngle=16
+endAngle=24
+[EdgeReport2]
+_SIZE_=20
+edges=0
+numEdges=4
+gradientInfo=8
+numGradientInfo=12
+calibrationValid=16
+[SearchArcInfo]
+_SIZE_=56
+arcCoordinates=0
+edgeReport=32
+[ConcentricRakeReport2]
+_SIZE_=24
+firstEdges=0
+numFirstEdges=4
+lastEdges=8
+numLastEdges=12
+searchArcs=16
+numSearchArcs=20
+[SpokeReport2]
+_SIZE_=24
+firstEdges=0
+numFirstEdges=4
+lastEdges=8
+numLastEdges=12
+searchLines=16
+numSearchLines=20
+[EdgeInfo]
+_SIZE_=56
+position=0
+calibratedPosition=8
+distance=16
+calibratedDistance=24
+magnitude=32
+noisePeak=40
+rising=48
+[SearchLineInfo]
+_SIZE_=36
+lineCoordinates=0
+edgeReport=16
+[RakeReport2]
+_SIZE_=24
+firstEdges=0
+numFirstEdges=4
+lastEdges=8
+numLastEdges=12
+searchLines=16
+numSearchLines=20
+[TransformBehaviors]
+_SIZE_=16
+ShiftBehavior=0
+ScaleBehavior=4
+RotateBehavior=8
+SymmetryBehavior=12
+[QRCodeDataToken]
+_SIZE_=16
+mode=0
+modeData=4
+data=8
+dataLength=12
+[ParticleFilterOptions]
+_SIZE_=12
+rejectMatches=0
+rejectBorder=4
+connectivity8=8
+[StraightEdgeReport2]
+_SIZE_=16
+straightEdges=0
+numStraightEdges=4
+searchLines=8
+numSearchLines=12
+[StraightEdgeOptions]
+_SIZE_=80
+numLines=0
+searchMode=4
+minScore=8
+maxScore=16
+orientation=24
+angleRange=32
+angleTolerance=40
+stepSize=48
+minSignalToNoiseRatio=56
+minCoverage=64
+houghIterations=72
+[StraightEdge]
+_SIZE_=88
+straightEdgeCoordinates=0
+calibratedStraightEdgeCoordinates=16
+angle=32
+calibratedAngle=40
+score=48
+straightness=56
+averageSignalToNoiseRatio=64
+calibrationValid=72
+usedEdges=76
+numUsedEdges=80
+[QRCodeSearchOptions]
+_SIZE_=48
+rotationMode=0
+skipLocation=4
+edgeThreshold=8
+demodulationMode=16
+cellSampleSize=24
+cellFilterMode=32
+skewDegreesAllowed=40
+[QRCodeSizeOptions]
+_SIZE_=8
+minSize=0
+maxSize=4
+[QRCodeDescriptionOptions]
+_SIZE_=32
+dimensions=0
+polarity=8
+mirror=16
+modelType=24
+[QRCodeReport]
+_SIZE_=136
+found=0
+data=4
+dataLength=8
+boundingBox=12
+tokenizedData=44
+sizeOfTokenizedData=48
+numErrorsCorrected=52
+dimensions=56
+version=60
+modelType=64
+streamMode=68
+matrixPolarity=72
+mirrored=80
+positionInAppendStream=84
+sizeOfAppendStream=88
+firstEAN128ApplicationID=92
+firstECIDesignator=96
+appendStreamIdentifier=100
+minimumEdgeStrength=104
+demodulationMode=112
+cellSampleSize=120
+cellFilterMode=128
+[AIMGradeReport]
+_SIZE_=40
+overallGrade=0
+decodingGrade=4
+symbolContrastGrade=8
+symbolContrast=12
+printGrowthGrade=16
+printGrowth=20
+axialNonuniformityGrade=24
+axialNonuniformity=28
+unusedErrorCorrectionGrade=32
+unusedErrorCorrection=36
+[DataMatrixSizeOptions]
+_SIZE_=12
+minSize=0
+maxSize=4
+quietZoneWidth=8
+[DataMatrixDescriptionOptions]
+_SIZE_=56
+aspectRatio=0
+rows=4
+columns=8
+rectangle=12
+ecc=16
+polarity=24
+cellFill=32
+minBorderIntegrity=40
+mirrorMode=48
+[DataMatrixSearchOptions]
+_SIZE_=56
+rotationMode=0
+skipLocation=4
+edgeThreshold=8
+demodulationMode=16
+cellSampleSize=24
+cellFilterMode=32
+skewDegreesAllowed=40
+maxIterations=44
+initialSearchVectorWidth=48
+[DataMatrixReport]
+_SIZE_=144
+found=0
+binary=4
+data=8
+dataLength=12
+boundingBox=16
+numErrorsCorrected=48
+numErasuresCorrected=52
+aspectRatio=56
+rows=60
+columns=64
+ecc=72
+polarity=80
+cellFill=88
+borderIntegrity=96
+mirrored=100
+minimumEdgeStrength=104
+demodulationMode=112
+cellSampleSize=120
+cellFilterMode=128
+iterations=136
+[JPEG2000FileAdvancedOptions]
+_SIZE_=16
+waveletMode=0
+useMultiComponentTransform=4
+maxWaveletTransformLevel=8
+quantizationStepSize=12
+[MatchGeometricPatternAdvancedOptions2]
+_SIZE_=88
+minFeaturesUsed=0
+maxFeaturesUsed=4
+subpixelIterations=8
+subpixelTolerance=16
+initialMatchListLength=24
+matchTemplateCurveScore=28
+correlationScore=32
+minMatchSeparationDistance=40
+minMatchSeparationAngle=48
+minMatchSeparationScale=56
+maxMatchOverlap=64
+coarseResult=72
+smoothContours=76
+enableCalibrationSupport=80
+[InspectionAlignment]
+_SIZE_=16
+position=0
+rotation=8
+scale=12
+[InspectionOptions]
+_SIZE_=24
+registrationMethod=0
+normalizationMethod=4
+edgeThicknessToIgnore=8
+brightThreshold=12
+darkThreshold=16
+binary=20
+[CharReport2]
+_SIZE_=56
+character=0
+corner=4
+lowThreshold=36
+highThreshold=40
+classificationScore=44
+verificationScore=48
+verified=52
+[CharInfo2]
+_SIZE_=16
+charValue=0
+charImage=4
+internalImage=8
+isReferenceChar=12
+[ReadTextReport2]
+_SIZE_=12
+readString=0
+characterReport=4
+numCharacterReports=8
+[EllipseFeature]
+_SIZE_=32
+position=0
+rotation=8
+minorRadius=16
+majorRadius=24
+[CircleFeature]
+_SIZE_=16
+position=0
+radius=8
+[ConstCurveFeature]
+_SIZE_=32
+position=0
+radius=8
+startAngle=16
+endAngle=24
+[RectangleFeature]
+_SIZE_=64
+position=0
+corner=8
+rotation=40
+width=48
+height=56
+[LegFeature]
+_SIZE_=64
+position=0
+corner=8
+rotation=40
+width=48
+height=56
+[CornerFeature]
+_SIZE_=32
+position=0
+rotation=8
+enclosedAngle=16
+isVirtual=24
+[LineFeature]
+_SIZE_=32
+startPoint=0
+endPoint=8
+length=16
+rotation=24
+[ParallelLinePairFeature]
+_SIZE_=48
+firstStartPoint=0
+firstEndPoint=8
+secondStartPoint=16
+secondEndPoint=24
+rotation=32
+distance=40
+[PairOfParallelLinePairsFeature]
+_SIZE_=112
+firstParallelLinePair=0
+secondParallelLinePair=48
+rotation=96
+distance=104
+[GeometricFeature]
+_SIZE_=4
+circle=0
+ellipse=0
+constCurve=0
+rectangle=0
+leg=0
+corner=0
+parallelLinePair=0
+pairOfParallelLinePairs=0
+line=0
+closedCurve=0
+[FeatureData]
+_SIZE_=16
+type=0
+contourPoints=4
+numContourPoints=8
+feature=12
+[GeometricPatternMatch2]
+_SIZE_=380
+position=0
+rotation=8
+scale=12
+score=16
+corner=20
+inverse=52
+occlusion=56
+templateMatchCurveScore=60
+matchTemplateCurveScore=64
+correlationScore=68
+label=72
+featureData=328
+numFeatureData=332
+calibratedPosition=336
+calibratedRotation=344
+calibratedCorner=348
+[ClosedCurveFeature]
+_SIZE_=16
+position=0
+arcLength=8
+[LineMatch]
+_SIZE_=40
+startPoint=0
+endPoint=8
+length=16
+rotation=24
+score=32
+[LineDescriptor]
+_SIZE_=16
+minLength=0
+maxLength=8
+[RectangleDescriptor]
+_SIZE_=32
+minWidth=0
+maxWidth=8
+minHeight=16
+maxHeight=24
+[RectangleMatch]
+_SIZE_=64
+corner=0
+rotation=32
+width=40
+height=48
+score=56
+[EllipseDescriptor]
+_SIZE_=32
+minMajorRadius=0
+maxMajorRadius=8
+minMinorRadius=16
+maxMinorRadius=24
+[EllipseMatch]
+_SIZE_=40
+position=0
+rotation=8
+majorRadius=16
+minorRadius=24
+score=32
+[CircleMatch]
+_SIZE_=24
+position=0
+radius=8
+score=16
+[CircleDescriptor]
+_SIZE_=16
+minRadius=0
+maxRadius=8
+[ShapeDetectionOptions]
+_SIZE_=32
+mode=0
+angleRanges=4
+numAngleRanges=8
+scaleRange=12
+minMatchScore=24
+[Curve]
+_SIZE_=48
+points=0
+numPoints=4
+closed=8
+curveLength=16
+minEdgeStrength=24
+maxEdgeStrength=32
+averageEdgeStrength=40
+[CurveOptions]
+_SIZE_=36
+extractionMode=0
+threshold=4
+filterSize=8
+minLength=12
+rowStepSize=16
+columnStepSize=20
+maxEndPointGap=24
+onlyClosed=28
+subpixelAccuracy=32
+[Barcode2DInfo]
+_SIZE_=64
+type=0
+binary=4
+data=8
+dataLength=12
+boundingBox=16
+numErrorsCorrected=48
+numErasuresCorrected=52
+rows=56
+columns=60
+[DataMatrixOptions]
+_SIZE_=20
+searchMode=0
+contrast=4
+cellShape=8
+barcodeShape=12
+subtype=16
+[ClassifierAccuracyReport]
+_SIZE_=24
+size=0
+accuracy=4
+classNames=8
+classAccuracy=12
+classPredictiveValue=16
+classificationDistribution=20
+[NearestNeighborClassResult]
+_SIZE_=12
+className=0
+standardDeviation=4
+count=8
+[NearestNeighborTrainingReport]
+_SIZE_=12
+classDistancesTable=0
+allScores=4
+allScoresSize=8
+[ParticleClassifierPreprocessingOptions]
+_SIZE_=36
+manualThreshold=0
+manualThresholdRange=4
+autoThresholdMethod=12
+limits=16
+particleType=24
+rejectBorder=28
+numErosions=32
+[ClassifierSampleInfo]
+_SIZE_=16
+className=0
+featureVector=4
+featureVectorSize=8
+thumbnail=12
+[ClassScore]
+_SIZE_=8
+className=0
+distance=4
+[ClassifierReport]
+_SIZE_=20
+bestClassName=0
+classificationScore=4
+identificationScore=8
+allScores=12
+allScoresSize=16
+[NearestNeighborOptions]
+_SIZE_=12
+method=0
+metric=4
+k=8
+[ParticleClassifierOptions]
+_SIZE_=8
+scaleDependence=0
+mirrorDependence=4
+[RGBU64Value]
+_SIZE_=8
+B=0
+G=2
+R=4
+alpha=6
+[GeometricPatternMatch]
+_SIZE_=72
+position=0
+rotation=8
+scale=12
+score=16
+corner=20
+inverse=52
+occlusion=56
+templateMatchCurveScore=60
+matchTemplateCurveScore=64
+correlationScore=68
+[MatchGeometricPatternAdvancedOptions]
+_SIZE_=80
+minFeaturesUsed=0
+maxFeaturesUsed=4
+subpixelIterations=8
+subpixelTolerance=16
+initialMatchListLength=24
+matchTemplateCurveScore=28
+correlationScore=32
+minMatchSeparationDistance=40
+minMatchSeparationAngle=48
+minMatchSeparationScale=56
+maxMatchOverlap=64
+coarseResult=72
+[MatchGeometricPatternOptions]
+_SIZE_=40
+mode=0
+subpixelAccuracy=4
+angleRanges=8
+numAngleRanges=12
+scaleRange=16
+occlusionRange=24
+numMatchesRequested=32
+minMatchScore=36
+[LearnGeometricPatternAdvancedOptions]
+_SIZE_=40
+minRectLength=0
+minRectAspectRatio=8
+minRadius=16
+minLineLength=20
+minFeatureStrength=24
+maxFeaturesUsed=32
+maxPixelDistanceFromLine=36
+[FitEllipseOptions]
+_SIZE_=32
+rejectOutliers=0
+minScore=8
+pixelRadius=16
+maxIterations=24
+[FitCircleOptions]
+_SIZE_=32
+rejectOutliers=0
+minScore=8
+pixelRadius=16
+maxIterations=24
+[ConstructROIOptions2]
+_SIZE_=24
+windowNumber=0
+windowTitle=4
+type=8
+palette=12
+numColors=16
+maxContours=20
+[HSLValue]
+_SIZE_=4
+L=0
+S=1
+H=2
+alpha=3
+[HSVValue]
+_SIZE_=4
+V=0
+S=1
+H=2
+alpha=3
+[HSIValue]
+_SIZE_=4
+I=0
+S=1
+H=2
+alpha=3
+[CIELabValue]
+_SIZE_=32
+b=0
+a=8
+L=16
+alpha=24
+[CIEXYZValue]
+_SIZE_=32
+Z=0
+Y=8
+X=16
+alpha=24
+[Color2]
+_SIZE_=32
+rgb=0
+hsl=0
+hsv=0
+hsi=0
+cieLab=0
+cieXYZ=0
+rawValue=0
+[BestEllipse2]
+_SIZE_=80
+center=0
+majorAxisStart=8
+majorAxisEnd=16
+minorAxisStart=24
+minorAxisEnd=32
+area=40
+perimeter=48
+error=56
+valid=64
+pointsUsed=68
+numPointsUsed=72
+[LearnPatternAdvancedOptions]
+_SIZE_=8
+shiftOptions=0
+rotationOptions=4
+[AVIInfo]
+_SIZE_=32
+width=0
+height=4
+imageType=8
+numFrames=12
+framesPerSecond=16
+filterName=20
+hasData=24
+maxDataSize=28
+[LearnPatternAdvancedShiftOptions]
+_SIZE_=48
+initialStepSize=0
+initialSampleSize=4
+initialSampleSizeFactor=8
+finalSampleSize=16
+finalSampleSizeFactor=24
+subpixelSampleSize=32
+subpixelSampleSizeFactor=40
+[LearnPatternAdvancedRotationOptions]
+_SIZE_=56
+searchStrategySupport=0
+initialStepSize=4
+initialSampleSize=8
+initialSampleSizeFactor=16
+initialAngularAccuracy=24
+finalSampleSize=28
+finalSampleSizeFactor=32
+finalAngularAccuracy=40
+subpixelSampleSize=44
+subpixelSampleSizeFactor=48
+[MatchPatternAdvancedOptions]
+_SIZE_=40
+subpixelIterations=0
+subpixelTolerance=8
+initialMatchListLength=16
+matchListReductionFactor=20
+initialStepSize=24
+searchStrategy=28
+intermediateAngularAccuracy=32
+[ParticleFilterCriteria2]
+_SIZE_=20
+parameter=0
+lower=4
+upper=8
+calibrated=12
+exclude=16
+[BestCircle2]
+_SIZE_=56
+center=0
+radius=8
+area=16
+perimeter=24
+error=32
+valid=40
+pointsUsed=44
+numPointsUsed=48
+[OCRSpacingOptions]
+_SIZE_=40
+minCharSpacing=0
+minCharSize=4
+maxCharSize=8
+maxHorizontalElementSpacing=12
+maxVerticalElementSpacing=16
+minBoundingRectWidth=20
+maxBoundingRectWidth=24
+minBoundingRectHeight=28
+maxBoundingRectHeight=32
+autoSplit=36
+[OCRProcessingOptions]
+_SIZE_=36
+mode=0
+lowThreshold=4
+highThreshold=8
+blockCount=12
+fastThreshold=16
+biModalCalculation=20
+darkCharacters=24
+removeParticlesTouchingROI=28
+erosionCount=32
+[ReadTextOptions]
+_SIZE_=65304
+validChars=0
+numValidChars=65280
+substitutionChar=65284
+readStrategy=65288
+acceptanceLevel=65292
+aspectRatio=65296
+readResolution=65300
+[CharInfo]
+_SIZE_=12
+charValue=0
+charImage=4
+internalImage=8
+[Rect]
+_SIZE_=16
+top=0
+left=4
+height=8
+width=12
+[CharReport]
+_SIZE_=48
+character=0
+corner=4
+reserved=36
+lowThreshold=40
+highThreshold=44
+[ReadTextReport]
+_SIZE_=12
+readString=0
+characterReport=4
+numCharacterReports=8
+[Point]
+_SIZE_=8
+x=0
+y=4
+[Annulus]
+_SIZE_=32
+center=0
+innerRadius=8
+outerRadius=12
+startAngle=16
+endAngle=24
+[EdgeLocationReport]
+_SIZE_=8
+edges=0
+numEdges=4
+[EdgeOptions]
+_SIZE_=20
+threshold=0
+width=4
+steepness=8
+subpixelType=12
+subpixelDivisions=16
+[EdgeReport]
+_SIZE_=32
+location=0
+contrast=4
+polarity=8
+reserved=16
+coordinate=20
+[ExtremeReport]
+_SIZE_=24
+location=0
+amplitude=8
+secondDerivative=16
+[FitLineOptions]
+_SIZE_=12
+minScore=0
+pixelRadius=4
+numRefinements=8
+[DisplayMapping]
+_SIZE_=16
+method=0
+minimumValue=4
+maximumValue=8
+shiftCount=12
+[DetectExtremesOptions]
+_SIZE_=16
+threshold=0
+width=8
+[ImageInfo]
+_SIZE_=52
+imageUnit=0
+stepX=4
+stepY=8
+imageType=12
+xRes=16
+yRes=20
+xOffset=24
+yOffset=28
+border=32
+pixelsPerLine=36
+reserved0=40
+reserved1=44
+imageStart=48
+[LCDOptions]
+_SIZE_=16
+litSegments=0
+threshold=4
+sign=8
+decimalPoint=12
+[LCDReport]
+_SIZE_=16
+text=0
+segmentInfo=4
+numCharacters=8
+reserved=12
+[LCDSegments]
+_SIZE_=4
+[LearnCalibrationOptions]
+_SIZE_=20
+mode=0
+method=4
+roi=8
+learnMap=12
+learnTable=16
+[LearnColorPatternOptions]
+_SIZE_=24
+learnMode=0
+featureMode=4
+threshold=8
+ignoreMode=12
+colorsToIgnore=16
+numColorsToIgnore=20
+[Line]
+_SIZE_=16
+start=0
+end=8
+[LinearAverages]
+_SIZE_=32
+columnAverages=0
+columnCount=4
+rowAverages=8
+rowCount=12
+risingDiagAverages=16
+risingDiagCount=20
+fallingDiagAverages=24
+fallingDiagCount=28
+[LineProfile]
+_SIZE_=40
+profileData=0
+boundingBox=4
+min=20
+max=24
+mean=28
+stdDev=32
+dataCount=36
+[MatchColorPatternOptions]
+_SIZE_=48
+matchMode=0
+featureMode=4
+minContrast=8
+subpixelAccuracy=12
+angleRanges=16
+numRanges=20
+colorWeight=24
+sensitivity=32
+strategy=36
+numMatchesRequested=40
+minMatchScore=44
+[HistogramReport]
+_SIZE_=36
+histogram=0
+histogramCount=4
+min=8
+max=12
+start=16
+width=20
+mean=24
+stdDev=28
+numPixels=32
+[ArcInfo]
+_SIZE_=32
+boundingBox=0
+startAngle=16
+endAngle=24
+[AxisReport]
+_SIZE_=24
+origin=0
+mainAxisEnd=8
+secondaryAxisEnd=16
+[BarcodeInfo]
+_SIZE_=32
+outputString=0
+size=4
+outputChar1=8
+outputChar2=9
+confidenceLevel=16
+type=24
+[BCGOptions]
+_SIZE_=12
+brightness=0
+contrast=4
+gamma=8
+[BestCircle]
+_SIZE_=40
+center=0
+radius=8
+area=16
+perimeter=24
+error=32
+[BestEllipse]
+_SIZE_=56
+center=0
+majorAxisStart=8
+majorAxisEnd=16
+minorAxisStart=24
+minorAxisEnd=32
+area=40
+perimeter=48
+[BestLine]
+_SIZE_=64
+start=0
+end=8
+equation=16
+valid=40
+error=48
+pointsUsed=56
+numPointsUsed=60
+[BrowserOptions]
+_SIZE_=32
+width=0
+height=4
+imagesPerLine=8
+backgroundColor=12
+frameSize=16
+style=20
+ratio=24
+focusColor=28
+[CoordinateSystem]
+_SIZE_=16
+origin=0
+angle=8
+axisOrientation=12
+[CalibrationInfo]
+_SIZE_=80
+errorMap=0
+mapColumns=4
+mapRows=8
+userRoi=12
+calibrationRoi=16
+options=20
+grid=40
+system=52
+range=68
+quality=76
+[CalibrationPoints]
+_SIZE_=12
+pixelCoordinates=0
+realWorldCoordinates=4
+numCoordinates=8
+[CaliperOptions]
+_SIZE_=12
+polarity=0
+separation=4
+separationDeviation=8
+[CaliperReport]
+_SIZE_=32
+edge1Contrast=0
+edge1Coord=4
+edge2Contrast=12
+edge2Coord=16
+separation=24
+reserved=28
+[DrawTextOptions]
+_SIZE_=60
+fontName=0
+fontSize=32
+bold=36
+italic=40
+underline=44
+strikeout=48
+textAlignment=52
+fontColor=56
+[CircleReport]
+_SIZE_=16
+center=0
+radius=8
+area=12
+[ClosedContour]
+_SIZE_=8
+points=0
+numPoints=4
+[ColorHistogramReport]
+_SIZE_=108
+plane1=0
+plane2=36
+plane3=72
+[ColorInformation]
+_SIZE_=12
+infoCount=0
+saturation=4
+info=8
+[Complex]
+_SIZE_=8
+r=0
+i=4
+[ConcentricRakeReport]
+_SIZE_=36
+rakeArcs=0
+numArcs=4
+firstEdges=8
+numFirstEdges=12
+lastEdges=16
+numLastEdges=20
+allEdges=24
+linesWithEdges=28
+numLinesWithEdges=32
+[ConstructROIOptions]
+_SIZE_=20
+windowNumber=0
+windowTitle=4
+type=8
+palette=12
+numColors=16
+[ContourInfo]
+_SIZE_=16
+type=0
+numPoints=4
+points=8
+contourColor=12
+[ContourUnion]
+_SIZE_=4
+point=0
+line=0
+rect=0
+ovalBoundingBox=0
+closedContour=0
+openContour=0
+annulus=0
+rotatedRect=0
+[ContourInfo2]
+_SIZE_=12
+type=0
+color=4
+structure=8
+[ContourPoint]
+_SIZE_=40
+x=0
+y=8
+curvature=16
+xDisplacement=24
+yDisplacement=32
+[CoordinateTransform]
+_SIZE_=24
+initialOrigin=0
+initialAngle=8
+finalOrigin=12
+finalAngle=20
+[CoordinateTransform2]
+_SIZE_=32
+referenceSystem=0
+measurementSystem=16
+[CannyOptions]
+_SIZE_=16
+sigma=0
+upperThreshold=4
+lowerThreshold=8
+windowSize=12
+[Range]
+_SIZE_=8
+minValue=0
+maxValue=4
+[UserPointSymbol]
+_SIZE_=12
+cols=0
+rows=4
+pixels=8
+[View3DOptions]
+_SIZE_=32
+sizeReduction=0
+maxHeight=4
+direction=8
+alpha=12
+beta=16
+border=20
+background=24
+plane=28
+[MatchPatternOptions]
+_SIZE_=32
+mode=0
+minContrast=4
+subpixelAccuracy=8
+angleRanges=12
+numRanges=16
+numMatchesRequested=20
+matchFactor=24
+minMatchScore=28
+[TIFFFileOptions]
+_SIZE_=12
+rowsPerStrip=0
+photoInterp=4
+compressionType=8
+[Color]
+_SIZE_=4
+rgb=0
+hsl=0
+hsv=0
+hsi=0
+rawValue=0
+[PixelValue]
+_SIZE_=8
+grayscale=0
+rgb=0
+hsl=0
+complex=0
+rgbu64=0
+[OpenContour]
+_SIZE_=8
+points=0
+numPoints=4
+[OverlayTextOptions]
+_SIZE_=48
+fontName=0
+fontSize=4
+bold=8
+italic=12
+underline=16
+strikeout=20
+horizontalTextAlignment=24
+verticalTextAlignment=28
+backgroundColor=32
+angle=40
+[ParticleFilterCriteria]
+_SIZE_=16
+parameter=0
+lower=4
+upper=8
+exclude=12
+[ParticleReport]
+_SIZE_=84
+area=0
+calibratedArea=4
+perimeter=8
+numHoles=12
+areaOfHoles=16
+perimeterOfHoles=20
+boundingBox=24
+sigmaX=40
+sigmaY=44
+sigmaXX=48
+sigmaYY=52
+sigmaXY=56
+longestLength=60
+longestPoint=64
+projectionX=72
+projectionY=76
+connect8=80
+[PatternMatch]
+_SIZE_=52
+position=0
+rotation=8
+scale=12
+score=16
+corner=20
+[QuantifyData]
+_SIZE_=28
+mean=0
+stdDev=4
+min=8
+max=12
+calibratedArea=16
+pixelArea=20
+relativeSize=24
+[QuantifyReport]
+_SIZE_=36
+global=0
+regions=28
+regionCount=32
+[RakeOptions]
+_SIZE_=24
+threshold=0
+width=4
+steepness=8
+subsamplingRatio=12
+subpixelType=16
+subpixelDivisions=20
+[RakeReport]
+_SIZE_=36
+rakeLines=0
+numRakeLines=4
+firstEdges=8
+numFirstEdges=12
+lastEdges=16
+numLastEdges=20
+allEdges=24
+linesWithEdges=28
+numLinesWithEdges=32
+[TransformReport]
+_SIZE_=12
+points=0
+validPoints=4
+numPoints=8
+[ShapeReport]
+_SIZE_=40
+coordinates=0
+centroid=16
+size=24
+score=32
+[MeterArc]
+_SIZE_=20
+needleBase=0
+arcCoordPoints=8
+numOfArcCoordPoints=12
+needleColor=16
+[ThresholdData]
+_SIZE_=16
+rangeMin=0
+rangeMax=4
+newValue=8
+useNewValue=12
+[StructuringElement]
+_SIZE_=16
+matrixCols=0
+matrixRows=4
+hexa=8
+kernel=12
+[SpokeReport]
+_SIZE_=36
+spokeLines=0
+numSpokeLines=4
+firstEdges=8
+numFirstEdges=12
+lastEdges=16
+numLastEdges=20
+allEdges=24
+linesWithEdges=28
+numLinesWithEdges=32
+[SimpleEdgeOptions]
+_SIZE_=20
+type=0
+threshold=4
+hysteresis=8
+process=12
+subpixel=16
+[SelectParticleCriteria]
+_SIZE_=12
+parameter=0
+lower=4
+upper=8
+[SegmentInfo]
+_SIZE_=24
+numberOfPoints=0
+isOpen=4
+weight=8
+points=16
+[RotationAngleRange]
+_SIZE_=8
+lower=0
+upper=4
+[RotatedRect]
+_SIZE_=24
+top=0
+left=4
+height=8
+width=12
+angle=16
+[ROIProfile]
+_SIZE_=44
+report=0
+pixels=40
+[ToolWindowOptions]
+_SIZE_=68
+showSelectionTool=0
+showZoomTool=4
+showPointTool=8
+showLineTool=12
+showRectangleTool=16
+showOvalTool=20
+showPolygonTool=24
+showClosedFreehandTool=28
+showPolyLineTool=32
+showFreehandTool=36
+showAnnulusTool=40
+showRotatedRectangleTool=44
+showPanTool=48
+showZoomOutTool=52
+reserved2=56
+reserved3=60
+reserved4=64
+[SpokeOptions]
+_SIZE_=32
+threshold=0
+width=4
+steepness=8
+subsamplingRatio=16
+subpixelType=24
+subpixelDivisions=28
diff --git a/wpilibj/wpilibJavaJNI/nivision/nivision_parse.py b/wpilibj/wpilibJavaJNI/nivision/nivision_parse.py
new file mode 100644
index 0000000000000000000000000000000000000000..0e01bd51ae7062246381d974579f09fc069060fd
--- /dev/null
+++ b/wpilibj/wpilibJavaJNI/nivision/nivision_parse.py
@@ -0,0 +1,220 @@
+from __future__ import print_function
+import re
+import traceback
+
+__all__ = ["define_after_struct", "defined", "forward_structs", "opaque_structs", "enums", "structs", "prescan_file", "parse_file", "number_re", "constant_re"]
+
+# parser regular expressions
+number_re = re.compile(r'-?[0-9]+')
+constant_re = re.compile(r'[A-Z0-9_]+')
+define_re = re.compile(r'^#define\s+(?P<name>(IMAQ|ERR)_[A-Z0-9_]+)\s+(?P<value>.*)')
+enum_re = re.compile(r'^typedef\s+enum\s+(?P<name>[A-Za-z0-9]+)_enum\s*{')
+enum_value_re = re.compile(r'^\s*(?P<name>[A-Z0-9_]+)\s*=\s*(?P<value>-?[0-9A-Fx]+)\s*,?')
+struct_re = re.compile(r'^typedef\s+struct\s+(?P<name>[A-Za-z0-9]+)_struct\s*{')
+union_re = re.compile(r'^typedef\s+union\s+(?P<name>[A-Za-z0-9]+)_union\s*{')
+func_pointer_re = re.compile(r'(?P<restype>[A-Za-z0-9_*]+)\s*\(\s*[A-Za-z0-9_]*[*]\s*(?P<name>[A-Za-z0-9_]+)\s*\)\s*\((?P<params>[^)]*)\)')
+static_const_re = re.compile(r'^static\s+const\s+(?P<type>[A-Za-z0-9_]+)\s+(?P<name>[A-Za-z0-9_]+)\s*=\s*(?P<value>[^;]+);')
+function_re = re.compile(r'^(IMAQ_FUNC\s+)?(?P<restype>(const\s+)?[A-Za-z0-9_*]+)\s+(IMAQ_STDCALL\s+)?(?P<name>[A-Za-z0-9_]+)\s*\((?P<params>[^)]*)\);')
+
+# defines deferred until after structures
+define_after_struct = []
+defined = set()
+forward_structs = set()
+opaque_structs = set()
+enums = set()
+structs = set()
+
+def parse_cdecl(decl):
+    decl = " ".join(decl.split())
+    ctype, sep, name = decl.rpartition(' ')
+    # look for array[]
+    name, bracket, arr = name.partition('[')
+    if arr:
+        arr = arr[:-1]
+    else:
+        arr = None
+    return name, ctype, arr
+
+def split_comment(line):
+    if line.startswith('/*'):
+        return "", ""
+    parts = line.split('//', 1)
+    code = parts[0].strip()
+    comment = parts[1].strip() if len(parts) > 1 else None
+    return code, comment
+
+def prescan_file(f):
+    for line in f:
+        code, comment = split_comment(line)
+        if not code and not comment:
+            continue
+
+        # typedef struct {
+        m = struct_re.match(code)
+        if m is not None:
+            structs.add(m.group('name'))
+            continue
+
+        # other typedef
+        if code.startswith("typedef"):
+            if '(' in code:
+                continue
+            name, typedef, arr = parse_cdecl(code[8:-1])
+            if typedef.startswith("struct"):
+                forward_structs.add(name)
+            continue
+
+    opaque_structs.update(forward_structs - structs)
+
+def parse_file(emit, f, block_comment_exclude):
+    in_block_comment = False
+    cur_block = ""
+    in_enum = None
+    in_struct = None
+    in_union = None
+
+    for lineno, line in enumerate(f):
+        code, comment = split_comment(line)
+        if not code and not comment:
+            continue
+        #print(comment)
+
+        # in block comment
+        if in_block_comment:
+            if not code and comment is not None and comment[0] == '=':
+                # closing block comment; emit if not excluded
+                if cur_block not in block_comment_exclude:
+                    try:
+                        emit.block_comment(cur_block)
+                    except Exception as e:
+                        print("%d: exception in block_comment():\n%s" % (lineno+1, traceback.format_exc()))
+                in_block_comment = False
+                # emit "after struct" constants in Globals
+                if cur_block == "Globals":
+                    for dname, dtext in define_after_struct:
+                        try:
+                            emit.text(dtext)
+                        except Exception as e:
+                            print("%d: exception in text():\n%s" % (lineno+1, traceback.format_exc()))
+                        defined.add(dname)
+                continue
+            if not code and comment is not None:
+                # remember current block
+                cur_block = comment
+            continue
+
+        # inside enum
+        if in_enum is not None:
+            if code[0] == '}':
+                # closing
+                try:
+                    emit.enum(*in_enum)
+                except Exception as e:
+                    print("%d: exception in enum():\n%s" % (lineno+1, traceback.format_exc()))
+                in_enum = None
+                continue
+            m = enum_value_re.match(code)
+            if m is not None:
+                in_enum[1].append((m.group('name'), m.group('value'), comment))
+            continue
+
+        # inside struct/union
+        if in_struct is not None or in_union is not None:
+            if code[0] == '}':
+                # closing
+                if in_struct is not None:
+                    try:
+                        emit.struct(*in_struct)
+                    except Exception as e:
+                        print("%d: exception in struct(\"%s\"):\n%s" % (lineno+1, in_struct[0], traceback.format_exc()))
+                    in_struct = None
+                if in_union is not None:
+                    try:
+                        emit.union(*in_union)
+                    except Exception as e:
+                        print("%d: exception in union(\"%s\"):\n%s" % (lineno+1, in_union[0], traceback.format_exc()))
+                    in_union = None
+                continue
+            name, ctype, arr = parse_cdecl(code[:-1])
+            # add to fields
+            if in_struct is not None:
+                in_struct[1].append((name, ctype, arr, comment))
+            if in_union is not None:
+                in_union[1].append((name, ctype, arr, comment))
+            continue
+
+        # block comment
+        if not code and comment is not None and comment[0] == '=':
+            in_block_comment = True
+
+        # #define
+        m = define_re.match(code)
+        if m is not None:
+            try:
+                emit.define(m.group('name'), m.group('value').strip(), comment)
+            except Exception as e:
+                print("%d: exception in define():\n%s" % (lineno+1, traceback.format_exc()))
+            continue
+
+        # typedef enum {
+        m = enum_re.match(code)
+        if m is not None:
+            in_enum = (m.group('name'), [])
+            continue
+
+        # typedef struct {
+        m = struct_re.match(code)
+        if m is not None:
+            in_struct = (m.group('name'), [])
+            continue
+
+        # typedef union {
+        m = union_re.match(code)
+        if m is not None:
+            in_union = (m.group('name'), [])
+            continue
+
+        # other typedef
+        if code.startswith("typedef"):
+            # typedef function?
+            m = func_pointer_re.match(code[8:-1])
+            if m is not None:
+                params = [parse_cdecl(param.strip()) for param in m.group('params').strip().split(',') if param.strip()]
+                try:
+                    emit.typedef_function(m.group('name'), m.group('restype'), params)
+                except Exception as e:
+                    print("%d: exception in typedef_function():\n%s" % (lineno+1, traceback.format_exc()))
+                continue
+            if '(' in code:
+                print("Invalid typedef: %s" % code)
+                continue
+            emit.typedef(*parse_cdecl(code[8:-1]))
+            continue
+
+        # function
+        m = function_re.match(code)
+        if m is not None:
+            params = [parse_cdecl(param.strip()) for param in m.group('params').strip().split(',') if param.strip()]
+            try:
+                emit.function(m.group('name'), m.group('restype'), params)
+            except Exception as e:
+                print("%d: exception in function(\"%s\"):\n%s" % (lineno+1, m.group('name'), traceback.format_exc()))
+            continue
+
+        # static const
+        m = static_const_re.match(code)
+        if m is not None:
+            value = m.group('value')
+            if value[0] == '{':
+                value = [v.strip() for v in value[1:-1].strip().split(',') if v.strip()]
+            try:
+                emit.static_const(m.group('name'), m.group('type'), value)
+            except Exception as e:
+                print("%d: exception in static_const():\n%s" % (lineno+1, traceback.format_exc()))
+            continue
+
+        if not code or code[0] == '#':
+            continue
+
+        print("%d: Unrecognized: %s" % (lineno+1, code))
+
