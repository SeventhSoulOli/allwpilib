From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: thomasclark <tjclark@wpi.edu>
Date: Fri, 11 Jul 2014 10:04:50 -0400
Subject: [PATCH 0160/6262] Added generic CAN methods to the HAL

Packing, unpacking, caching, receiving, and sending CAN messages can be done
with a thin wrapper around CANSessionMux now, removing the need for duplicated
code between different CAN devices and languages.

Change-Id: If40181e479f45a443db7a1c264437f7f89ff54d9
---
 hal/include/HAL/CAN.hpp |  35 +++---
 hal/include/HAL/HAL.hpp |   1 +
 hal/lib/Athena/CAN.cpp  | 232 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 256 insertions(+), 12 deletions(-)
 create mode 100644 hal/lib/Athena/CAN.cpp

diff --git a/hal/include/HAL/CAN.hpp b/hal/include/HAL/CAN.hpp
index 6b032a43bdf94aa96f5c19160dc02a7be72ca670..80b589ceee2a1054430a6131d5b07384f703e2a0 100644
--- a/hal/include/HAL/CAN.hpp
+++ b/hal/include/HAL/CAN.hpp
@@ -1,15 +1,26 @@
 #pragma once
 
-#ifdef __vxworks
-#include <vxWorks.h>
-#else
 #include <stdint.h>
-#endif
-
-extern "C"
-{
-	void JaguarCANSendMessage(uint32_t messageID, const uint8_t *data, uint8_t dataSize,
-			int32_t *status);
-	void JaguarCANReceiveMessage(uint32_t *messageID, uint8_t *data, uint8_t *dataSize,
-			uint32_t timeoutMs, int32_t *status);
-}
+#include "NetworkCommunication/CANSessionMux.h"
+
+void canTxSend(uint32_t arbID, uint8_t length, int32_t period = CAN_SEND_PERIOD_NO_REPEAT);
+
+void canTxPackInt8 (uint32_t arbID, uint8_t offset, uint8_t  value);
+void canTxPackInt16(uint32_t arbID, uint8_t offset, uint16_t value);
+void canTxPackInt32(uint32_t arbID, uint8_t offset, uint32_t value);
+void canTxPackFXP16(uint32_t arbID, uint8_t offset, double   value);
+void canTxPackFXP32(uint32_t arbID, uint8_t offset, double   value);
+
+uint8_t  canTxUnpackInt8 (uint32_t arbID, uint8_t offset);
+uint32_t canTxUnpackInt32(uint32_t arbID, uint8_t offset);
+uint16_t canTxUnpackInt16(uint32_t arbID, uint8_t offset);
+double   canTxUnpackFXP16(uint32_t arbID, uint8_t offset);
+double   canTxUnpackFXP32(uint32_t arbID, uint8_t offset);
+
+bool canRxReceive(uint32_t arbID);
+
+uint8_t  canRxUnpackInt8 (uint32_t arbID, uint8_t offset);
+uint16_t canRxUnpackInt16(uint32_t arbID, uint8_t offset);
+uint32_t canRxUnpackInt32(uint32_t arbID, uint8_t offset);
+double   canRxUnpackFXP16(uint32_t arbID, uint8_t offset);
+double   canRxUnpackFXP32(uint32_t arbID, uint8_t offset);
diff --git a/hal/include/HAL/HAL.hpp b/hal/include/HAL/HAL.hpp
index 53179bfa07641f96f9d308d5975c2e1bbfd65e1a..c88122f2d24ade916f832727592741b23c6b7e33 100644
--- a/hal/include/HAL/HAL.hpp
+++ b/hal/include/HAL/HAL.hpp
@@ -13,6 +13,7 @@
 #include <cmath>
 
 #include "Analog.hpp"
+#include "CAN.hpp"
 #include "Compressor.hpp"
 #include "Digital.hpp"
 #include "Solenoid.hpp"
diff --git a/hal/lib/Athena/CAN.cpp b/hal/lib/Athena/CAN.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..c524996b7bb07fa530e3c02ef1a766715ebebab6
--- /dev/null
+++ b/hal/lib/Athena/CAN.cpp
@@ -0,0 +1,232 @@
+#include "HAL/CAN.hpp"
+#include <map>
+
+struct CANMessage
+{
+	uint8_t data[8];
+};
+
+static std::map<uint32_t, CANMessage> outgoingMessages;
+static std::map<uint32_t, CANMessage> incomingMessages;
+
+static const uint32_t kFullMessageIDMask = 0x1fffffff;
+
+/**
+ * Gets the data from the outgoing hashmap and calls
+ * CANSessionMux...sendMessage.
+ */
+void canTxSend(uint32_t arbID, uint8_t length, int32_t period)
+{
+	CANMessage &message = outgoingMessages[arbID];
+
+	int32_t status;
+
+	FRC_NetworkCommunication_CANSessionMux_sendMessage(
+		arbID, message.data, length, period, &status);
+}
+
+/**
+ * Updates a field in the outgoing hashmap.
+ *
+ * This is called every time an single byte field changes in a message.data,
+ * such as when a setter on a CAN device is called.
+ */
+void canTxPackInt8(uint32_t arbID, uint8_t offset, uint8_t value)
+{
+	CANMessage &message = outgoingMessages[arbID];
+
+	message.data[offset] = value;
+}
+
+/**
+ * Updates a field in the outgoing hashmap.
+ *
+ * This is called every time a short integer field changes in a message.data,
+ * such as when a setter on a CAN device is called.
+ */
+void canTxPackInt16(uint32_t arbID, uint8_t offset, uint16_t value)
+{
+	CANMessage &message = outgoingMessages[arbID];
+
+	*(uint16_t *)(message.data + offset) = value;
+}
+
+/**
+ * Updates a field in the outgoing hashmap.
+ *
+ * This is called every time a long integer field changes in a message.data,
+ * such as when a setter on a CAN device is called.
+ */
+void canTxPackInt32(uint32_t arbID, uint8_t offset, uint32_t value)
+{
+	CANMessage &message = outgoingMessages[arbID];
+
+	*(uint32_t *)(message.data + offset) = value;
+}
+
+/**
+ * Updates a field in the outgoing hashmap.
+ *
+ * This is called every time an 8.8 fixed point field changes in a message,
+ * such as when a setter on a CAN device is called.
+ */
+void canTxPackFXP16(uint32_t arbID, uint8_t offset, double value)
+{
+	int16_t raw = value * 255.0;
+
+	canTxPackInt16(arbID, offset, raw);
+}
+
+/**
+ * Updates a field in the outgoing hashmap.
+ *
+ * This is called every time a 16.16 fixed point field changes in a message,
+ * such as when a setter on a CAN device is called.
+ */
+void canTxPackFXP32(uint32_t arbID, uint8_t offset, double value)
+{
+	int32_t raw = value * 65535.0;
+
+	canTxPackInt32(arbID, offset, raw);
+}
+
+/**
+ * Unpack a field from the outgoing hashmap.
+ *
+ * This is called in getters for configuration data.
+ */
+uint8_t canTxUnpackInt8(uint32_t arbID, uint8_t offset)
+{
+	CANMessage &message = outgoingMessages[arbID];
+
+	return message.data[offset];
+}
+
+/**
+ * Unpack a field from the outgoing hashmap.
+ *
+ * This is called in getters for configuration data.
+ */
+uint16_t canTxUnpackInt16(uint32_t arbID, uint8_t offset)
+{
+	CANMessage &message = outgoingMessages[arbID];
+
+	return *reinterpret_cast<uint16_t *>(message.data + offset);
+}
+
+/**
+ * Unpack a field from the outgoing hashmap.
+ *
+ * This is called in getters for configuration data.
+ */
+uint32_t canTxUnpackInt32(uint32_t arbID, uint8_t offset)
+{
+	CANMessage &message = outgoingMessages[arbID];
+
+	return *reinterpret_cast<uint32_t *>(message.data + offset);
+}
+
+/**
+ * Unpack a field from the outgoing hashmap.
+ *
+ * This is called in getters for configuration data.
+ */
+double canTxUnpackFXP16(uint32_t arbID, uint8_t offset)
+{
+	int16_t raw = canTxUnpackInt16(arbID, offset);
+
+	return raw / 255.0;
+}
+
+/**
+ * Unpack a field from the outgoing hashmap.
+ *
+ * This is called in getters for configuration data.
+ */
+double canTxUnpackFXP32(uint32_t arbID, uint8_t offset)
+{
+	int32_t raw = canTxUnpackInt32(arbID, offset);
+
+	return raw / 65535.0;
+}
+
+/**
+ * Get data from CANSessionMux (if it's available) and put it in the incoming
+ * hashmap.
+ *
+ * @return true if there's new data.  Otherwise, the last received value should
+ * still be in the hashmap.
+ */
+bool canRxReceive(uint32_t arbID)
+{
+	CANMessage &message = incomingMessages[arbID];
+
+	uint8_t length;
+	uint32_t timestamp;
+	int32_t status;
+
+	FRC_NetworkCommunication_CANSessionMux_receiveMessage(
+		&arbID, kFullMessageIDMask, message.data, &length, &timestamp, &status);
+
+	return status != ERR_CANSessionMux_MessageNotFound;
+}
+
+/**
+ * Unpack a field from the incoming hashmap.
+ *
+ * This is called in getters for status data.
+ */
+uint8_t canRxUnpackInt8(uint32_t arbID, uint8_t offset)
+{
+	CANMessage &message = incomingMessages[arbID];
+
+	return message.data[offset];
+}
+
+/**
+ * Unpack a field from the incoming hashmap.
+ *
+ * This is called in getters for status data.
+ */
+uint16_t canRxUnpackInt16(uint32_t arbID, uint8_t offset)
+{
+	CANMessage &message = incomingMessages[arbID];
+
+	return *reinterpret_cast<uint16_t *>(message.data + offset);
+}
+
+/**
+ * Unpack a field from the incoming hashmap.
+ *
+ * This is called in getters for status data.
+ */
+uint32_t canRxUnpackInt32(uint32_t arbID, uint8_t offset)
+{
+	CANMessage &message = incomingMessages[arbID];
+
+	return *reinterpret_cast<uint32_t *>(message.data + offset);
+}
+
+/**
+ * Unpack a field from the incoming hashmap.
+ *
+ * This is called in getters for status data.
+ */
+double canRxUnpackFXP16(uint32_t arbID, uint8_t offset)
+{
+	int16_t raw = canRxUnpackInt16(arbID, offset);
+
+	return raw / 255.0;
+}
+
+/**
+ * Unpack a field from the incoming hashmap.
+ *
+ * This is called in getters for status data.
+ */
+double canRxUnpackFXP32(uint32_t arbID, uint8_t offset)
+{
+	int32_t raw = canRxUnpackInt32(arbID, offset);
+
+	return raw / 65535.0;
+}
