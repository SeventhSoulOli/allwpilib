From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jonathan Leitschuh <jlleitschuh@wpi.edu>
Date: Tue, 5 Aug 2014 13:41:50 -0400
Subject: [PATCH 0261/6262] Adds Exception throwing the basic robot systems are
 not properly initialized.

Adds a BaseSystemNotInitalizedException to be thrown in the event that HLUsageRepoting, RobotState or Timer does not have its static implementation set.

Change-Id: I66fde262baa1a9d32d1df9fafa08ba3173bcbb72
---
 .../wpi/first/wpilibj/HLUsageReporting.java   |   8 +
 .../edu/wpi/first/wpilibj/RobotState.java     |  14 +-
 .../java/edu/wpi/first/wpilibj/Timer.java     | 268 +++++++++---------
 .../BaseSystemNotInitializedException.java    |  35 +++
 4 files changed, 188 insertions(+), 137 deletions(-)
 create mode 100644 wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/util/BaseSystemNotInitializedException.java

diff --git a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/HLUsageReporting.java b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/HLUsageReporting.java
index cb022b0d6c99ace6d68c89e92786b753ed33f278..278d13cacd1e5ea11240bef3cbda4079cfae629b 100644
--- a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/HLUsageReporting.java
+++ b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/HLUsageReporting.java
@@ -1,5 +1,7 @@
 package edu.wpi.first.wpilibj;
 
+import edu.wpi.first.wpilibj.util.BaseSystemNotInitializedException;
+
 /**
  * Support for high level usage reporting.
  *
@@ -15,18 +17,24 @@ public class HLUsageReporting {
 	public static void reportScheduler() {
 		if (impl != null) {
 			impl.reportScheduler();
+		} else {
+			throw new BaseSystemNotInitializedException(Interface.class, HLUsageReporting.class);
 		}
 	}
 
 	public static void reportPIDController(int num) {
 		if (impl != null) {
 			impl.reportPIDController(num);
+		} else {
+			throw new BaseSystemNotInitializedException(Interface.class, HLUsageReporting.class);
 		}
 	}
 
 	public static void reportSmartDashboard() {
 		if(impl != null) {
 			impl.reportSmartDashboard();
+		} else {
+			throw new BaseSystemNotInitializedException(Interface.class, HLUsageReporting.class);
 		}
 	}
 
diff --git a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/RobotState.java b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/RobotState.java
index f7ccc55595dc8d03ca202da4b98e2e5bc3e915f7..7b502b75b4971aea05eb0b991b4056a289484186 100644
--- a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/RobotState.java
+++ b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/RobotState.java
@@ -1,5 +1,7 @@
 package edu.wpi.first.wpilibj;
 
+import edu.wpi.first.wpilibj.util.BaseSystemNotInitializedException;
+
 public class RobotState {
 	private static Interface impl;
 
@@ -11,7 +13,7 @@ public class RobotState {
 		if (impl != null) {
 			return impl.isDisabled();
 		} else {
-			return true;
+			throw new BaseSystemNotInitializedException(Interface.class, RobotState.class);
 		}
 	}
 
@@ -19,7 +21,7 @@ public class RobotState {
 		if (impl != null) {
 			return impl.isEnabled();
 		} else {
-			return false;
+			throw new BaseSystemNotInitializedException(Interface.class, RobotState.class);
 		}
 	}
 
@@ -27,7 +29,7 @@ public class RobotState {
 		if (impl != null) {
 			return impl.isOperatorControl();
 		} else {
-			return true;
+			throw new BaseSystemNotInitializedException(Interface.class, RobotState.class);
 		}
 	}
 
@@ -35,7 +37,7 @@ public class RobotState {
 		if (impl != null) {
 			return impl.isAutonomous();
 		} else {
-			return false;
+			throw new BaseSystemNotInitializedException(Interface.class, RobotState.class);
 		}
 	}
 
@@ -43,10 +45,10 @@ public class RobotState {
 		if (impl != null) {
 			return impl.isTest();
 		} else {
-			return false;
+			throw new BaseSystemNotInitializedException(Interface.class, RobotState.class);
 		}
 	}
-	
+
 	interface Interface {
 		boolean isDisabled();
 		boolean isEnabled();
diff --git a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/Timer.java b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/Timer.java
index 3111ca3346d69743f1da541f61273c34f25bd5c4..a35be8c397a67b14325645bd051b3bee82cddf51 100644
--- a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/Timer.java
+++ b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/Timer.java
@@ -1,141 +1,147 @@
 package edu.wpi.first.wpilibj;
 
+import edu.wpi.first.wpilibj.util.BaseSystemNotInitializedException;
+
 public class Timer {
 	private static StaticInterface impl;
 
 	public static void SetImplementation(StaticInterface ti) {
 		impl = ti;
 	}
+
+	/**
+	 * Return the system clock time in seconds. Return the time from the
+	 * FPGA hardware clock in seconds since the FPGA started.
+	 *
+	 * @return Robot running time in seconds.
+	 */
+	public static double getFPGATimestamp() {
+		if (impl != null) {
+			return impl.getFPGATimestamp();
+		} else {
+			throw new BaseSystemNotInitializedException(StaticInterface.class, Timer.class);
+		}
+	}
+
+	/**
+	 * Return the approximate match time
+	 * The FMS does not currently send the official match time to the robots
+	 * This returns the time since the enable signal sent from the Driver Station
+	 * At the beginning of autonomous, the time is reset to 0.0 seconds
+	 * At the beginning of teleop, the time is reset to +15.0 seconds
+	 * If the robot is disabled, this returns 0.0 seconds
+	 * Warning: This is not an official time (so it cannot be used to argue with referees)
+	 * @return Match time in seconds since the beginning of autonomous
+	 */
+	public static double getMatchTime() {
+		if (impl != null) {
+			return impl.getMatchTime();
+		} else {
+			throw new BaseSystemNotInitializedException(StaticInterface.class, Timer.class);
+		}
+	}
+
+	/**
+	 * Pause the thread for a specified time. Pause the execution of the
+	 * thread for a specified period of time given in seconds. Motors will
+	 * continue to run at their last assigned values, and sensors will continue
+	 * to update. Only the task containing the wait will pause until the wait
+	 * time is expired.
+	 *
+	 * @param seconds Length of time to pause
+	 */
+	public static void delay(final double seconds) {
+		if (impl != null) {
+			impl.delay(seconds);
+		} else {
+			throw new BaseSystemNotInitializedException(StaticInterface.class, Timer.class);
+		}
+	}
+
+	public interface StaticInterface {
+		double getFPGATimestamp();
+		double getMatchTime();
+		void delay(final double seconds);
+		Interface newTimer();
+	}
+
+	private final Interface timer;
 	
-    /**
-     * Return the system clock time in seconds. Return the time from the
-     * FPGA hardware clock in seconds since the FPGA started.
-     *
-     * @return Robot running time in seconds.
-     */
-    public static double getFPGATimestamp() {
-    	if (impl != null) {
-    		return impl.getFPGATimestamp();
-    	} else {
-    		return 0; // TODO: Handle error
-    	}
-    }
-    
-    /**
-     * Return the approximate match time
-     * The FMS does not currently send the official match time to the robots
-     * This returns the time since the enable signal sent from the Driver Station
-     * At the beginning of autonomous, the time is reset to 0.0 seconds
-     * At the beginning of teleop, the time is reset to +15.0 seconds
-     * If the robot is disabled, this returns 0.0 seconds
-     * Warning: This is not an official time (so it cannot be used to argue with referees)
-     * @return Match time in seconds since the beginning of autonomous
-     */
-    public static double getMatchTime() {
-    	if (impl != null) {
-    		return impl.getMatchTime();
-    	} else {
-    		return 0; // TODO: Handle error
-    	}
-    }
-    
-    /**
-     * Pause the thread for a specified time. Pause the execution of the
-     * thread for a specified period of time given in seconds. Motors will
-     * continue to run at their last assigned values, and sensors will continue
-     * to update. Only the task containing the wait will pause until the wait
-     * time is expired.
-     *
-     * @param seconds Length of time to pause
-     */
-    public static void delay(final double seconds) {
-    	if (impl != null) {
-    		impl.delay(seconds);
-    	} else {
-    		// TODO: Handle error
-    	}
-    }
-    
-    public interface StaticInterface {
-    	double getFPGATimestamp();
-    	double getMatchTime();
-    	void delay(final double seconds);
-    	Interface newTimer();
-    }
-    
-    private Interface timer;
-    
-    public Timer() {
-    	timer = impl.newTimer();
-    }
-
-    /**
-     * Get the current time from the timer. If the clock is running it is derived from
-     * the current system clock the start time stored in the timer class. If the clock
-     * is not running, then return the time when it was last stopped.
-     *
-     * @return Current time value for this timer in seconds
-     */
-    public double get() {
-    	return timer.get();
-    }
-
-    /**
-     * Reset the timer by setting the time to 0.
-     * Make the timer startTime the current time so new requests will be relative now
-     */
-    public void reset() {
-    	timer.reset();
-    }
-
-    /**
-     * Start the timer running.
-     * Just set the running flag to true indicating that all time requests should be
-     * relative to the system clock.
-     */
-    public void start() {
-    	timer.start();
-    }
-
-    /**
-     * Stop the timer.
-     * This computes the time as of now and clears the running flag, causing all
-     * subsequent time requests to be read from the accumulated time rather than
-     * looking at the system clock.
-     */
-    public void stop() {
-    	timer.stop();
-    }
-    
-    public interface Interface {
-	    /**
-	     * Get the current time from the timer. If the clock is running it is derived from
-	     * the current system clock the start time stored in the timer class. If the clock
-	     * is not running, then return the time when it was last stopped.
-	     *
-	     * @return Current time value for this timer in seconds
-	     */
-	    public double get();
-	
-	    /**
-	     * Reset the timer by setting the time to 0.
-	     * Make the timer startTime the current time so new requests will be relative now
-	     */
-	    public void reset();
-	
-	    /**
-	     * Start the timer running.
-	     * Just set the running flag to true indicating that all time requests should be
-	     * relative to the system clock.
-	     */
-	    public void start();
-	
-	    /**
-	     * Stop the timer.
-	     * This computes the time as of now and clears the running flag, causing all
-	     * subsequent time requests to be read from the accumulated time rather than
-	     * looking at the system clock.
-	     */
-	    public void stop();
-    }
+	public Timer() {
+		if(impl != null){
+			timer = impl.newTimer();
+		} else {
+			throw new BaseSystemNotInitializedException(StaticInterface.class, Timer.class);
+		}
+	}
+
+	/**
+	 * Get the current time from the timer. If the clock is running it is derived from
+	 * the current system clock the start time stored in the timer class. If the clock
+	 * is not running, then return the time when it was last stopped.
+	 *
+	 * @return Current time value for this timer in seconds
+	 */
+	public double get() {
+		return timer.get();
+	}
+
+	/**
+	 * Reset the timer by setting the time to 0.
+	 * Make the timer startTime the current time so new requests will be relative now
+	 */
+	public void reset() {
+		timer.reset();
+	}
+
+	/**
+	 * Start the timer running.
+	 * Just set the running flag to true indicating that all time requests should be
+	 * relative to the system clock.
+	 */
+	public void start() {
+		timer.start();
+	}
+
+	/**
+	 * Stop the timer.
+	 * This computes the time as of now and clears the running flag, causing all
+	 * subsequent time requests to be read from the accumulated time rather than
+	 * looking at the system clock.
+	 */
+	public void stop() {
+		timer.stop();
+	}
+
+	public interface Interface {
+		/**
+		 * Get the current time from the timer. If the clock is running it is derived from
+		 * the current system clock the start time stored in the timer class. If the clock
+		 * is not running, then return the time when it was last stopped.
+		 *
+		 * @return Current time value for this timer in seconds
+		 */
+		public double get();
+
+		/**
+		 * Reset the timer by setting the time to 0.
+		 * Make the timer startTime the current time so new requests will be relative now
+		 */
+		public void reset();
+
+		/**
+		 * Start the timer running.
+		 * Just set the running flag to true indicating that all time requests should be
+		 * relative to the system clock.
+		 */
+		public void start();
+
+		/**
+		 * Stop the timer.
+		 * This computes the time as of now and clears the running flag, causing all
+		 * subsequent time requests to be read from the accumulated time rather than
+		 * looking at the system clock.
+		 */
+		public void stop();
+	}
 }
diff --git a/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/util/BaseSystemNotInitializedException.java b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/util/BaseSystemNotInitializedException.java
new file mode 100644
index 0000000000000000000000000000000000000000..a84761e071ab09d3dd6971eb597c929528f2699d
--- /dev/null
+++ b/wpilibj/wpilibJava/src/main/java/edu/wpi/first/wpilibj/util/BaseSystemNotInitializedException.java
@@ -0,0 +1,35 @@
+/*----------------------------------------------------------------------------*/
+/* Copyright (c) FIRST 2008-2014. All Rights Reserved.                        */
+/* Open Source Software - may be modified and shared by FRC teams. The code   */
+/* must be accompanied by the FIRST BSD license file in the root directory of */
+/* the project.                                                               */
+/*----------------------------------------------------------------------------*/
+package edu.wpi.first.wpilibj.util;
+
+
+/**
+ * Thrown if there is an error caused by a basic system or setting
+ * not being properly initialized before being used.
+ * 
+ * @author Jonathan Leitschuh
+ */
+public class BaseSystemNotInitializedException extends RuntimeException {
+	 /**
+     * Create a new BaseSystemNotInitializedException
+     * @param msg the message to attach to the exception
+     */
+	public BaseSystemNotInitializedException(String message) {
+		super(message);
+	}
+	
+	/**
+	 * Create a new BaseSystemNotInitializedException using the offending class that was not set and the
+	 * class that was affected.
+	 * @param offender The class or interface that was not properly initialized.
+	 * @param affected The class that was was affected by this missing initialization.
+	 */
+	public BaseSystemNotInitializedException(Class<?> offender, Class<?> affected){
+		super("The " + offender.getSimpleName() + " for the " + affected.getSimpleName() + " was never set.");
+	}
+	
+}
