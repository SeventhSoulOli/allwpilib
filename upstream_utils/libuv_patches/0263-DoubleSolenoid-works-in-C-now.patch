From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Thomas Clark <tjclark@wpi.edu>
Date: Tue, 5 Aug 2014 14:42:37 -0400
Subject: [PATCH 0263/6262] DoubleSolenoid works in C++ now

Change-Id: I75130f816efe8ef9c82e936bba834609c470f379
---
 wpilibc/wpilibC++/include/DoubleSolenoid.h |  4 ++--
 wpilibc/wpilibC++/lib/DoubleSolenoid.cpp   | 23 +++++++++++-----------
 2 files changed, 14 insertions(+), 13 deletions(-)

diff --git a/wpilibc/wpilibC++/include/DoubleSolenoid.h b/wpilibc/wpilibC++/include/DoubleSolenoid.h
index 3147028302b7d9f952e9bec0d05605c8c54c3bdf..9fc2e9deaa313a9cff22ab02cb014a76425a8e90 100644
--- a/wpilibc/wpilibC++/include/DoubleSolenoid.h
+++ b/wpilibc/wpilibC++/include/DoubleSolenoid.h
@@ -12,7 +12,7 @@
 /**
  * DoubleSolenoid class for running 2 channels of high voltage Digital Output
  * (9472 module).
- * 
+ *
  * The DoubleSolenoid class is typically used for pneumatics solenoids that
  * have two positions controlled by two separate channels.
  */
@@ -47,6 +47,6 @@ private:
 	uint32_t m_reverseChannel; ///< The reverse channel on the module to control.
 	uint8_t m_forwardMask; ///< The mask for the forward channel.
 	uint8_t m_reverseMask; ///< The mask for the reverse channel.
-	
+
 	ITable *m_table;
 };
diff --git a/wpilibc/wpilibC++/lib/DoubleSolenoid.cpp b/wpilibc/wpilibC++/lib/DoubleSolenoid.cpp
index d97601b6c092384d28b8ec1f374d1117f4afbebd..02e39cebb558e02aa76a01cf4e15a2192ee9a2a2 100644
--- a/wpilibc/wpilibC++/lib/DoubleSolenoid.cpp
+++ b/wpilibc/wpilibC++/lib/DoubleSolenoid.cpp
@@ -7,7 +7,6 @@
 #include "DoubleSolenoid.h"
 //#include "NetworkCommunication/UsageReporting.h"
 #include "WPIErrors.h"
-#include <string.h>
 #include "LiveWindow/LiveWindow.h"
 
 /**
@@ -37,24 +36,26 @@ void DoubleSolenoid::InitSolenoid()
 	}
 	Resource::CreateResourceObject(&m_allocated, solenoid_kNumDO7_0Elements * kSolenoidChannels);
 
-	snprintf(buf, 64, "Solenoid %d (Module %d)", m_forwardChannel, m_moduleNumber);
-	if (m_allocated->Allocate((m_moduleNumber - 1) * kSolenoidChannels + m_forwardChannel - 1, buf) == ~0ul)
+	snprintf(buf, 64, "Solenoid %d (Module: %d)", m_forwardChannel, m_moduleNumber);
+	if (m_allocated->Allocate(m_moduleNumber * kSolenoidChannels + m_forwardChannel, buf) == ~0ul)
 	{
 		CloneError(m_allocated);
 		return;
 	}
-	snprintf(buf, 64, "Solenoid %d (Module %d)", m_reverseChannel, m_moduleNumber);
-	if (m_allocated->Allocate((m_moduleNumber - 1) * kSolenoidChannels + m_reverseChannel - 1, buf) == ~0ul)
+
+	snprintf(buf, 64, "Solenoid %d (Module: %d)", m_reverseChannel, m_moduleNumber);
+	if (m_allocated->Allocate(m_moduleNumber * kSolenoidChannels + m_reverseChannel, buf) == ~0ul)
 	{
 		CloneError(m_allocated);
 		return;
 	}
+
 	m_forwardMask = 1 << (m_forwardChannel - 1);
 	m_reverseMask = 1 << (m_reverseChannel - 1);
 
-	HALReport(HALUsageReporting::kResourceType_Solenoid, m_forwardChannel, m_moduleNumber - 1);
-	HALReport(HALUsageReporting::kResourceType_Solenoid, m_reverseChannel, m_moduleNumber - 1);
-	LiveWindow::GetInstance()->AddActuator("DoubleSolenoid", m_forwardChannel, this);
+	HALReport(HALUsageReporting::kResourceType_Solenoid, m_forwardChannel, m_moduleNumber);
+	HALReport(HALUsageReporting::kResourceType_Solenoid, m_reverseChannel, m_moduleNumber);
+	LiveWindow::GetInstance()->AddActuator("DoubleSolenoid", m_moduleNumber, m_forwardChannel, this);
 }
 
 /**
@@ -74,7 +75,7 @@ DoubleSolenoid::DoubleSolenoid(uint32_t forwardChannel, uint32_t reverseChannel)
 /**
  * Constructor.
  *
- * @param moduleNumber The solenoid module (1 or 2).
+ * @param moduleNumber The CAN ID of the PCM.
  * @param forwardChannel The forward channel on the module to control.
  * @param reverseChannel The reverse channel on the module to control.
  */
@@ -93,8 +94,8 @@ DoubleSolenoid::~DoubleSolenoid()
 {
 	if (CheckSolenoidModule(m_moduleNumber))
 	{
-		m_allocated->Free((m_moduleNumber - 1) * kSolenoidChannels + m_forwardChannel - 1);
-		m_allocated->Free((m_moduleNumber - 1) * kSolenoidChannels + m_reverseChannel - 1);
+		m_allocated->Free(m_moduleNumber * kSolenoidChannels + m_forwardChannel);
+		m_allocated->Free(m_moduleNumber * kSolenoidChannels + m_reverseChannel);
 	}
 }
 
