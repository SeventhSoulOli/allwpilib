From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Peter Johnson <johnson.peter@gmail.com>
Date: Fri, 12 Dec 2014 22:52:31 -0800
Subject: [PATCH 0560/6262] Wrap IMAQdx functions.

Quite a few functions aren't wrapped, but the most critical ones for
vision should be.

This also fixes a couple of issues:
- nivision_arm.ini (and imaqdx_arm.ini) are now generated without need for
  running the output on the RoboRIO.
- enum values are generated even if the value is not directly specified.
---
 .gitignore                                    |    3 +
 .../src/main/java/com/ni/vision/NIVision.java | 1262 ++++++++++-
 wpilibj/wpilibJavaJNI/lib/NIVisionJNI.cpp     |  360 ++++
 wpilibj/wpilibJavaJNI/nivision/gen_java.py    |   91 +-
 .../nivision/gen_struct_sizer.py              |   31 +-
 wpilibj/wpilibJavaJNI/nivision/generateJNI.sh |   21 +-
 .../wpilibJavaJNI/nivision/get_struct_size.py |   14 +
 wpilibj/wpilibJavaJNI/nivision/imaqdx.ini     |   81 +
 .../wpilibJavaJNI/nivision/nivision_arm.ini   | 1863 -----------------
 .../wpilibJavaJNI/nivision/nivision_parse.py  |   14 +-
 10 files changed, 1825 insertions(+), 1915 deletions(-)
 create mode 100644 wpilibj/wpilibJavaJNI/nivision/get_struct_size.py
 create mode 100644 wpilibj/wpilibJavaJNI/nivision/imaqdx.ini
 delete mode 100644 wpilibj/wpilibJavaJNI/nivision/nivision_arm.ini

diff --git a/.gitignore b/.gitignore
index 4919c92565b701c1aafa748ded32b26792bc8446..53eac49064291218922066b2f9bcc8ecc39ad64f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -11,6 +11,9 @@ bin/
 .classpath
 **/dependency-reduced-pom.xml
 wpilibj/wpilibJavaJNI/nivision/*.c
+wpilibj/wpilibJavaJNI/nivision/*.cpp
+wpilibj/wpilibJavaJNI/nivision/*.s
+wpilibj/wpilibJavaJNI/nivision/*_arm.ini
 wpilibj/wpilibJavaJNI/nivision/*.java
 
 # Created by the jenkins test script
diff --git a/wpilibj/wpilibJavaDevices/src/main/java/com/ni/vision/NIVision.java b/wpilibj/wpilibJavaDevices/src/main/java/com/ni/vision/NIVision.java
index 652ded62ea1f23129c49ee147019f39d402dd6bb..3922801187ac542e7b25b9daf8a4ecd14577761b 100644
--- a/wpilibj/wpilibJavaDevices/src/main/java/com/ni/vision/NIVision.java
+++ b/wpilibj/wpilibJavaDevices/src/main/java/com/ni/vision/NIVision.java
@@ -2133,17 +2133,61 @@ public class NIVision {
 
     public static enum QRDimensions {
         QR_DIMENSIONS_AUTO_DETECT(0), // The function will automatically determine the dimensions of the QR code.
+        QR_DIMENSIONS_11x11(11), // Specifies the dimensions of the QR code as 11 x 11.
+        QR_DIMENSIONS_13x13(13), // Specifies the dimensions of the QR code as 13 x 13.
+        QR_DIMENSIONS_15x15(15), // Specifies the dimensions of the QR code as 15 x 15.
+        QR_DIMENSIONS_17x17(17), // Specifies the dimensions of the QR code as 17 x 17.
+        QR_DIMENSIONS_21x21(21), // Specifies the dimensions of the QR code as 21 x 21.
+        QR_DIMENSIONS_25x25(25), // Specifies the dimensions of the QR code as 25 x 25.
+        QR_DIMENSIONS_29x29(29), // Specifies the dimensions of the QR code as 29 x 29.
+        QR_DIMENSIONS_33x33(33), // Specifies the dimensions of the QR code as 33 x 33.
+        QR_DIMENSIONS_37x37(37), // Specifies the dimensions of the QR code as 37 x 37.
+        QR_DIMENSIONS_41x41(41), // Specifies the dimensions of the QR code as 41 x 41.
+        QR_DIMENSIONS_45x45(45), // Specifies the dimensions of the QR code as 45 x 45.
+        QR_DIMENSIONS_49x49(49), // Specifies the dimensions of the QR code as 49 x 49.
+        QR_DIMENSIONS_53x53(53), // Specifies the dimensions of the QR code as 53 x 53.
+        QR_DIMENSIONS_57x57(57), // Specifies the dimensions of the QR code as 57 x 57.
+        QR_DIMENSIONS_61x61(61), // Specifies the dimensions of the QR code as 61 x 61.
+        QR_DIMENSIONS_65x65(65), // Specifies the dimensions of the QR code as 65 x 65.
+        QR_DIMENSIONS_69x69(69), // Specifies the dimensions of the QR code as 69 x 69.
+        QR_DIMENSIONS_73x73(73), // Specifies the dimensions of the QR code as 73 x 73.
+        QR_DIMENSIONS_77x77(77), // Specifies the dimensions of the QR code as 77 x 77.
+        QR_DIMENSIONS_81x81(81), // Specifies the dimensions of the QR code as 81 x 81.
+        QR_DIMENSIONS_85x85(85), // Specifies the dimensions of the QR code as 85 x 85.
+        QR_DIMENSIONS_89x89(89), // Specifies the dimensions of the QR code as 89 x 89.
+        QR_DIMENSIONS_93x93(93), // Specifies the dimensions of the QR code as 93 x 93.
+        QR_DIMENSIONS_97x97(97), // Specifies the dimensions of the QR code as 97 x 97.
+        QR_DIMENSIONS_101x101(101), // Specifies the dimensions of the QR code as 101 x 101.
+        QR_DIMENSIONS_105x105(105), // Specifies the dimensions of the QR code as 105 x 105.
+        QR_DIMENSIONS_109x109(109), // Specifies the dimensions of the QR code as 109 x 109.
+        QR_DIMENSIONS_113x113(113), // Specifies the dimensions of the QR code as 113 x 113.
+        QR_DIMENSIONS_117x117(117), // Specifies the dimensions of the QR code as 117 x 117.
+        QR_DIMENSIONS_121x121(121), // Specifies the dimensions of the QR code as 121 x 121.
+        QR_DIMENSIONS_125x125(125), // Specifies the dimensions of the QR code as 125 x 125.
+        QR_DIMENSIONS_129x129(129), // Specifies the dimensions of the QR code as 129 x 129.
+        QR_DIMENSIONS_133x133(133), // Specifies the dimensions of the QR code as 133 x 133.
+        QR_DIMENSIONS_137x137(137), // Specifies the dimensions of the QR code as 137 x 137.
+        QR_DIMENSIONS_141x141(141), // Specifies the dimensions of the QR code as 141 x 141.
+        QR_DIMENSIONS_145x145(145), // Specifies the dimensions of the QR code as 145 x 145.
+        QR_DIMENSIONS_149x149(149), // Specifies the dimensions of the QR code as 149 x 149.
+        QR_DIMENSIONS_153x153(153), // Specifies the dimensions of the QR code as 153 x 153.
+        QR_DIMENSIONS_157x157(157), // Specifies the dimensions of the QR code as 157 x 1537.
+        QR_DIMENSIONS_161x161(161), // Specifies the dimensions of the QR code as 161 x 161.
+        QR_DIMENSIONS_165x165(165), // Specifies the dimensions of the QR code as 165 x 165.
+        QR_DIMENSIONS_169x169(169), // Specifies the dimensions of the QR code as 169 x 169.
+        QR_DIMENSIONS_173x173(173), // Specifies the dimensions of the QR code as 173 x 173.
+        QR_DIMENSIONS_177x177(177), // Specifies the dimensions of the QR code as 177 x 177.
         ;
         private final int value;
         private QRDimensions(int value) {
             this.value = value;
         }
         public static QRDimensions fromValue(int val) {
-            try {
-                return values()[val];
-            } catch (ArrayIndexOutOfBoundsException e) {
-                return null;
+            for (QRDimensions v : values()) {
+                if (v.value == val)
+                    return v;
             }
+            return null;
         }
         public int getValue() {
             return value;
@@ -3633,6 +3677,13 @@ public class NIVision {
 
     public static enum DataMatrixCellSampleSize {
         AUTO_DETECT_CELL_SAMPLE_SIZE(-2), // The function will try each sample size and use the one which decodes the Data Matrix barcode within the fewest iterations and utilizing the least amount of error correction.
+        C1x1(1), // The function will use a 1x1 sized sample from each cell.
+        C2x2(2), // The function will use a 2x2 sized sample from each cell.
+        C3x3(3), // The function will use a 3x3 sized sample from each cell.
+        C4x4(4), // The function will use a 4x4 sized sample from each cell.
+        C5x5(5), // The function will use a 5x5 sized sample from each cell.
+        C6x6(6), // The function will use a 6x6 sized sample from each cell.
+        C7x7(7), // The function will use a 7x7 sized sample from each cell.
         ;
         private final int value;
         private DataMatrixCellSampleSize(int value) {
@@ -24952,4 +25003,1207 @@ public class NIVision {
         return new RakeReport(jn_rv, true);
     }
     private static native long _imaqRake(long image, long roi, int direction, int process, long options);
+
+    /**
+     * Purpose	  : Include file for NI-IMAQdx library support.
+     */
+    public static final int IMAQDX_MAX_API_STRING_LENGTH = 512;
+
+    /**
+     * Bus Type Enumeration
+     */
+
+    public static enum IMAQdxBusType {
+        BusTypeFireWire(0x31333934),
+        BusTypeEthernet(0x69707634),
+        BusTypeSimulator(0x2073696D),
+        BusTypeDirectShow(0x64736877),
+        BusTypeIP(0x4950636D),
+        BusTypeSmartCam2(0x53436132),
+        BusTypeUSB3Vision(0x55534233),
+        BusTypeUVC(0x55564320),
+        BusTypeGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxBusType(int value) {
+            this.value = value;
+        }
+        public static IMAQdxBusType fromValue(int val) {
+            for (IMAQdxBusType v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Camera Control Mode Enumeration
+     */
+
+    public static enum IMAQdxCameraControlMode {
+        CameraControlModeController(0),
+        CameraControlModeListener(1),
+        CameraControlModeGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxCameraControlMode(int value) {
+            this.value = value;
+        }
+        public static IMAQdxCameraControlMode fromValue(int val) {
+            for (IMAQdxCameraControlMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Buffer Number Mode Enumeration
+     */
+
+    public static enum IMAQdxBufferNumberMode {
+        BufferNumberModeNext(0),
+        BufferNumberModeLast(1),
+        BufferNumberModeBufferNumber(2),
+        BufferNumberModeGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxBufferNumberMode(int value) {
+            this.value = value;
+        }
+        public static IMAQdxBufferNumberMode fromValue(int val) {
+            for (IMAQdxBufferNumberMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Plug n Play Event Enumeration
+     */
+
+    public static enum IMAQdxPnpEvent {
+        PnpEventCameraAttached(0),
+        PnpEventCameraDetached(1),
+        PnpEventBusReset(2),
+        PnpEventGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxPnpEvent(int value) {
+            this.value = value;
+        }
+        public static IMAQdxPnpEvent fromValue(int val) {
+            for (IMAQdxPnpEvent v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Bayer Pattern Enumeration
+     */
+
+    public static enum IMAQdxBayerPattern {
+        BayerPatternNone(0),
+        BayerPatternGB(1),
+        BayerPatternGR(2),
+        BayerPatternBG(3),
+        BayerPatternRG(4),
+        BayerPatternHardware(5),
+        BayerPatternGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxBayerPattern(int value) {
+            this.value = value;
+        }
+        public static IMAQdxBayerPattern fromValue(int val) {
+            for (IMAQdxBayerPattern v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Bayer Decode Algorithm Enumeration
+     */
+
+    public static enum IMAQdxBayerAlgorithm {
+        BayerAlgorithmBilinear(0),
+        BayerAlgorithmVNG(1),
+        BayerAlgorithmGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxBayerAlgorithm(int value) {
+            this.value = value;
+        }
+        public static IMAQdxBayerAlgorithm fromValue(int val) {
+            for (IMAQdxBayerAlgorithm v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Output Image Types -- Values match Vision Development Module image types
+     */
+
+    public static enum IMAQdxOutputImageType {
+        OutputImageTypeU8(0),
+        OutputImageTypeI16(1),
+        OutputImageTypeU16(7),
+        OutputImageTypeRGB32(4),
+        OutputImageTypeRGB64(6),
+        OutputImageTypeAuto(0x7FFFFFFF),
+        OutputImageTypeGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxOutputImageType(int value) {
+            this.value = value;
+        }
+        public static IMAQdxOutputImageType fromValue(int val) {
+            for (IMAQdxOutputImageType v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Controller Destination Mode Enumeration
+     */
+
+    public static enum IMAQdxDestinationMode {
+        DestinationModeUnicast(0),
+        DestinationModeBroadcast(1),
+        DestinationModeMulticast(2),
+        DestinationModeGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxDestinationMode(int value) {
+            this.value = value;
+        }
+        public static IMAQdxDestinationMode fromValue(int val) {
+            for (IMAQdxDestinationMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Attribute Type Enumeration
+     */
+
+    public static enum IMAQdxAttributeType {
+        AttributeTypeU32(0),
+        AttributeTypeI64(1),
+        AttributeTypeF64(2),
+        AttributeTypeString(3),
+        AttributeTypeEnum(4),
+        AttributeTypeBool(5),
+        AttributeTypeCommand(6),
+        AttributeTypeBlob(7),
+        AttributeTypeGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxAttributeType(int value) {
+            this.value = value;
+        }
+        public static IMAQdxAttributeType fromValue(int val) {
+            for (IMAQdxAttributeType v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Value Type Enumeration
+     */
+
+    public static enum IMAQdxValueType {
+        ValueTypeU32(0),
+        ValueTypeI64(1),
+        ValueTypeF64(2),
+        ValueTypeString(3),
+        ValueTypeEnumItem(4),
+        ValueTypeBool(5),
+        ValueTypeDisposableString(6),
+        ValueTypeGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxValueType(int value) {
+            this.value = value;
+        }
+        public static IMAQdxValueType fromValue(int val) {
+            for (IMAQdxValueType v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Interface File Flags Enumeration
+     */
+
+    public static enum IMAQdxInterfaceFileFlags {
+        InterfaceFileFlagsConnected(0x1),
+        InterfaceFileFlagsDirty(0x2),
+        InterfaceFileFlagsGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxInterfaceFileFlags(int value) {
+            this.value = value;
+        }
+        public static IMAQdxInterfaceFileFlags fromValue(int val) {
+            for (IMAQdxInterfaceFileFlags v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Overwrite Mode Enumeration
+     */
+
+    public static enum IMAQdxOverwriteMode {
+        OverwriteModeGetOldest(0x0),
+        OverwriteModeFail(0x2),
+        OverwriteModeGetNewest(0x3),
+        OverwriteModeGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxOverwriteMode(int value) {
+            this.value = value;
+        }
+        public static IMAQdxOverwriteMode fromValue(int val) {
+            for (IMAQdxOverwriteMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Incomplete Buffer Mode Enumeration
+     */
+
+    public static enum IMAQdxIncompleteBufferMode {
+        IncompleteBufferModeIgnore(0),
+        IncompleteBufferModeFail(1),
+        IncompleteBufferModeGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxIncompleteBufferMode(int value) {
+            this.value = value;
+        }
+        public static IMAQdxIncompleteBufferMode fromValue(int val) {
+            for (IMAQdxIncompleteBufferMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Lost Packet Mode Enumeration
+     */
+
+    public static enum IMAQdxLostPacketMode {
+        LostPacketModeIgnore(0),
+        LostPacketModeFail(1),
+        LostPacketModeGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxLostPacketMode(int value) {
+            this.value = value;
+        }
+        public static IMAQdxLostPacketMode fromValue(int val) {
+            for (IMAQdxLostPacketMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Attribute Visibility Enumeration
+     */
+
+    public static enum IMAQdxAttributeVisibility {
+        AttributeVisibilitySimple(0x00001000),
+        AttributeVisibilityIntermediate(0x00002000),
+        AttributeVisibilityAdvanced(0x00004000),
+        AttributeVisibilityGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxAttributeVisibility(int value) {
+            this.value = value;
+        }
+        public static IMAQdxAttributeVisibility fromValue(int val) {
+            for (IMAQdxAttributeVisibility v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Stream Channel Mode Enumeration
+     */
+
+    public static enum IMAQdxStreamChannelMode {
+        StreamChannelModeAutomatic(0),
+        StreamChannelModeManual(1),
+        StreamChannelModeGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxStreamChannelMode(int value) {
+            this.value = value;
+        }
+        public static IMAQdxStreamChannelMode fromValue(int val) {
+            for (IMAQdxStreamChannelMode v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * Pixel Signedness Enumeration
+     */
+
+    public static enum IMAQdxPixelSignedness {
+        PixelSignednessUnsigned(0),
+        PixelSignednessSigned(1),
+        PixelSignednessHardware(2),
+        PixelSignednessGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxPixelSignedness(int value) {
+            this.value = value;
+        }
+        public static IMAQdxPixelSignedness fromValue(int val) {
+            for (IMAQdxPixelSignedness v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * USB Connection Speed Enumeration
+     */
+
+    public static enum IMAQdxUSBConnectionSpeed {
+        USBConnectionSpeedLow(1),
+        USBConnectionSpeedFull(2),
+        USBConnectionSpeedHigh(4),
+        USBConnectionSpeedSuper(8),
+        USBConnectionSpeedGuard(0xFFFFFFFF),
+        ;
+        private final int value;
+        private IMAQdxUSBConnectionSpeed(int value) {
+            this.value = value;
+        }
+        public static IMAQdxUSBConnectionSpeed fromValue(int val) {
+            for (IMAQdxUSBConnectionSpeed v : values()) {
+                if (v.value == val)
+                    return v;
+            }
+            return null;
+        }
+        public int getValue() {
+            return value;
+        }
+    }
+
+    /**
+     * CVI Structures
+     */
+
+    /**
+     * Camera Information Structure
+     */
+
+    public static class IMAQdxCameraInformation extends DisposedStruct {
+        public long Type;
+        public long Version;
+        public long Flags;
+        public long SerialNumberHi;
+        public long SerialNumberLo;
+        public IMAQdxBusType BusType;
+        public String InterfaceName;
+        public String VendorName;
+        public String ModelName;
+        public String CameraFileName;
+        public String CameraAttributeURL;
+
+        private void init() {
+            
+        }
+        public IMAQdxCameraInformation() {
+            super(2584);
+            init();
+        }
+        public IMAQdxCameraInformation(long Type, long Version, long Flags, long SerialNumberHi, long SerialNumberLo, IMAQdxBusType BusType, String InterfaceName, String VendorName, String ModelName, String CameraFileName, String CameraAttributeURL) {
+            super(2584);
+            this.Type = Type;
+            this.Version = Version;
+            this.Flags = Flags;
+            this.SerialNumberHi = SerialNumberHi;
+            this.SerialNumberLo = SerialNumberLo;
+            this.BusType = BusType;
+            this.InterfaceName = InterfaceName;
+            this.VendorName = VendorName;
+            this.ModelName = ModelName;
+            this.CameraFileName = CameraFileName;
+            this.CameraAttributeURL = CameraAttributeURL;
+        }
+        protected IMAQdxCameraInformation(ByteBuffer backing, int offset) {
+            super(backing, offset, 2584);
+            init();
+        }
+        protected IMAQdxCameraInformation(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 2584);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 2584);
+        }
+        public void read() {
+            Type = backing.getLong(0);
+            Version = backing.getLong(4);
+            Flags = backing.getLong(8);
+            SerialNumberHi = backing.getLong(12);
+            SerialNumberLo = backing.getLong(16);
+            BusType = IMAQdxBusType.fromValue(backing.getInt(20));
+            {
+                byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
+                getBytes(backing, bytes, 24, IMAQDX_MAX_API_STRING_LENGTH);
+                int len;
+                for (len=0; len<bytes.length && bytes[len] != 0; len++) {}
+                try {
+                    InterfaceName = new String(bytes, 0, len, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    InterfaceName = "";
+                }
+            }
+            {
+                byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
+                getBytes(backing, bytes, 536, IMAQDX_MAX_API_STRING_LENGTH);
+                int len;
+                for (len=0; len<bytes.length && bytes[len] != 0; len++) {}
+                try {
+                    VendorName = new String(bytes, 0, len, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    VendorName = "";
+                }
+            }
+            {
+                byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
+                getBytes(backing, bytes, 1048, IMAQDX_MAX_API_STRING_LENGTH);
+                int len;
+                for (len=0; len<bytes.length && bytes[len] != 0; len++) {}
+                try {
+                    ModelName = new String(bytes, 0, len, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    ModelName = "";
+                }
+            }
+            {
+                byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
+                getBytes(backing, bytes, 1560, IMAQDX_MAX_API_STRING_LENGTH);
+                int len;
+                for (len=0; len<bytes.length && bytes[len] != 0; len++) {}
+                try {
+                    CameraFileName = new String(bytes, 0, len, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    CameraFileName = "";
+                }
+            }
+            {
+                byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
+                getBytes(backing, bytes, 2072, IMAQDX_MAX_API_STRING_LENGTH);
+                int len;
+                for (len=0; len<bytes.length && bytes[len] != 0; len++) {}
+                try {
+                    CameraAttributeURL = new String(bytes, 0, len, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    CameraAttributeURL = "";
+                }
+            }
+        }
+        public void write() {
+            backing.putLong(0, Type);
+            backing.putLong(4, Version);
+            backing.putLong(8, Flags);
+            backing.putLong(12, SerialNumberHi);
+            backing.putLong(16, SerialNumberLo);
+            if (BusType != null)
+                backing.putInt(20, BusType.getValue());
+            if (InterfaceName != null) {
+                byte[] bytes;
+                try {
+                    bytes = InterfaceName.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    bytes = new byte[0];
+                }
+                putBytes(backing, bytes, 24, bytes.length);
+                for (int i=bytes.length; i<IMAQDX_MAX_API_STRING_LENGTH; i++)
+                    backing.put(i, (byte)0); // fill with zero
+            }
+            if (VendorName != null) {
+                byte[] bytes;
+                try {
+                    bytes = VendorName.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    bytes = new byte[0];
+                }
+                putBytes(backing, bytes, 536, bytes.length);
+                for (int i=bytes.length; i<IMAQDX_MAX_API_STRING_LENGTH; i++)
+                    backing.put(i, (byte)0); // fill with zero
+            }
+            if (ModelName != null) {
+                byte[] bytes;
+                try {
+                    bytes = ModelName.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    bytes = new byte[0];
+                }
+                putBytes(backing, bytes, 1048, bytes.length);
+                for (int i=bytes.length; i<IMAQDX_MAX_API_STRING_LENGTH; i++)
+                    backing.put(i, (byte)0); // fill with zero
+            }
+            if (CameraFileName != null) {
+                byte[] bytes;
+                try {
+                    bytes = CameraFileName.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    bytes = new byte[0];
+                }
+                putBytes(backing, bytes, 1560, bytes.length);
+                for (int i=bytes.length; i<IMAQDX_MAX_API_STRING_LENGTH; i++)
+                    backing.put(i, (byte)0); // fill with zero
+            }
+            if (CameraAttributeURL != null) {
+                byte[] bytes;
+                try {
+                    bytes = CameraAttributeURL.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    bytes = new byte[0];
+                }
+                putBytes(backing, bytes, 2072, bytes.length);
+                for (int i=bytes.length; i<IMAQDX_MAX_API_STRING_LENGTH; i++)
+                    backing.put(i, (byte)0); // fill with zero
+            }
+        }
+        public int size() {
+            return 2584;
+        }
+    }
+
+    /**
+     * Camera File Structure
+     */
+
+    public static class IMAQdxCameraFile extends DisposedStruct {
+        public long Type;
+        public long Version;
+        public String FileName;
+
+        private void init() {
+            
+        }
+        public IMAQdxCameraFile() {
+            super(520);
+            init();
+        }
+        public IMAQdxCameraFile(long Type, long Version, String FileName) {
+            super(520);
+            this.Type = Type;
+            this.Version = Version;
+            this.FileName = FileName;
+        }
+        protected IMAQdxCameraFile(ByteBuffer backing, int offset) {
+            super(backing, offset, 520);
+            init();
+        }
+        protected IMAQdxCameraFile(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 520);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 520);
+        }
+        public void read() {
+            Type = backing.getLong(0);
+            Version = backing.getLong(4);
+            {
+                byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
+                getBytes(backing, bytes, 8, IMAQDX_MAX_API_STRING_LENGTH);
+                int len;
+                for (len=0; len<bytes.length && bytes[len] != 0; len++) {}
+                try {
+                    FileName = new String(bytes, 0, len, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    FileName = "";
+                }
+            }
+        }
+        public void write() {
+            backing.putLong(0, Type);
+            backing.putLong(4, Version);
+            if (FileName != null) {
+                byte[] bytes;
+                try {
+                    bytes = FileName.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    bytes = new byte[0];
+                }
+                putBytes(backing, bytes, 8, bytes.length);
+                for (int i=bytes.length; i<IMAQDX_MAX_API_STRING_LENGTH; i++)
+                    backing.put(i, (byte)0); // fill with zero
+            }
+        }
+        public int size() {
+            return 520;
+        }
+    }
+
+    /**
+     * Attribute Information Structure
+     */
+
+    public static class IMAQdxAttributeInformation extends DisposedStruct {
+        public IMAQdxAttributeType Type;
+        public long Readable;
+        public long Writable;
+        public String Name;
+
+        private void init() {
+            
+        }
+        public IMAQdxAttributeInformation() {
+            super(524);
+            init();
+        }
+        public IMAQdxAttributeInformation(IMAQdxAttributeType Type, long Readable, long Writable, String Name) {
+            super(524);
+            this.Type = Type;
+            this.Readable = Readable;
+            this.Writable = Writable;
+            this.Name = Name;
+        }
+        protected IMAQdxAttributeInformation(ByteBuffer backing, int offset) {
+            super(backing, offset, 524);
+            init();
+        }
+        protected IMAQdxAttributeInformation(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 524);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 524);
+        }
+        public void read() {
+            Type = IMAQdxAttributeType.fromValue(backing.getInt(0));
+            Readable = backing.getLong(4);
+            Writable = backing.getLong(8);
+            {
+                byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
+                getBytes(backing, bytes, 12, IMAQDX_MAX_API_STRING_LENGTH);
+                int len;
+                for (len=0; len<bytes.length && bytes[len] != 0; len++) {}
+                try {
+                    Name = new String(bytes, 0, len, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    Name = "";
+                }
+            }
+        }
+        public void write() {
+            if (Type != null)
+                backing.putInt(0, Type.getValue());
+            backing.putLong(4, Readable);
+            backing.putLong(8, Writable);
+            if (Name != null) {
+                byte[] bytes;
+                try {
+                    bytes = Name.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    bytes = new byte[0];
+                }
+                putBytes(backing, bytes, 12, bytes.length);
+                for (int i=bytes.length; i<IMAQDX_MAX_API_STRING_LENGTH; i++)
+                    backing.put(i, (byte)0); // fill with zero
+            }
+        }
+        public int size() {
+            return 524;
+        }
+    }
+
+    /**
+     * Enumeration Item Structure
+     */
+
+    public static class IMAQdxEnumItem extends DisposedStruct {
+        public long Value;
+        public long Reserved;
+        public String Name;
+
+        private void init() {
+            
+        }
+        public IMAQdxEnumItem() {
+            super(520);
+            init();
+        }
+        public IMAQdxEnumItem(long Value, long Reserved, String Name) {
+            super(520);
+            this.Value = Value;
+            this.Reserved = Reserved;
+            this.Name = Name;
+        }
+        protected IMAQdxEnumItem(ByteBuffer backing, int offset) {
+            super(backing, offset, 520);
+            init();
+        }
+        protected IMAQdxEnumItem(long nativeObj, boolean owned) {
+            super(nativeObj, owned, 520);
+            init();
+        }
+        protected void setBuffer(ByteBuffer backing, int offset) {
+            super.setBuffer(backing, offset, 520);
+        }
+        public void read() {
+            Value = backing.getLong(0);
+            Reserved = backing.getLong(4);
+            {
+                byte[] bytes = new byte[IMAQDX_MAX_API_STRING_LENGTH];
+                getBytes(backing, bytes, 8, IMAQDX_MAX_API_STRING_LENGTH);
+                int len;
+                for (len=0; len<bytes.length && bytes[len] != 0; len++) {}
+                try {
+                    Name = new String(bytes, 0, len, "UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    Name = "";
+                }
+            }
+        }
+        public void write() {
+            backing.putLong(0, Value);
+            backing.putLong(4, Reserved);
+            if (Name != null) {
+                byte[] bytes;
+                try {
+                    bytes = Name.getBytes("UTF-8");
+                } catch (UnsupportedEncodingException e) {
+                    bytes = new byte[0];
+                }
+                putBytes(backing, bytes, 8, bytes.length);
+                for (int i=bytes.length; i<IMAQDX_MAX_API_STRING_LENGTH; i++)
+                    backing.put(i, (byte)0); // fill with zero
+            }
+        }
+        public int size() {
+            return 520;
+        }
+    }
+
+    /**
+     * Camera Information Structure
+     */
+
+    /**
+     * Attributes
+     */
+
+    /**
+     * Functions
+     */
+
+    public static void IMAQdxSnap(long id, Image image) {
+        
+        _IMAQdxSnap(id, image.getAddress());
+        
+    }
+    private static native void _IMAQdxSnap(long id, long image);
+
+    public static void IMAQdxConfigureGrab(long id) {
+        
+        _IMAQdxConfigureGrab(id);
+        
+    }
+    private static native void _IMAQdxConfigureGrab(long id);
+
+    public static long IMAQdxGrab(long id, Image image, long waitForNextBuffer) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _IMAQdxGrab(id, image.getAddress(), waitForNextBuffer, rv_addr+0);
+        long actualBufferNumber;
+        actualBufferNumber = rv_buf.getLong(0);
+        return actualBufferNumber;
+    }
+    private static native long _IMAQdxGrab(long id, long image, long waitForNextBuffer, long actualBufferNumber);
+
+    public static void IMAQdxDiscoverEthernetCameras(String address, long timeout) {
+        ByteBuffer address_buf = null;
+        if (address != null) {
+            byte[] address_bytes;
+            try {
+                address_bytes = address.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                address_bytes = new byte[0];
+            }
+            address_buf = ByteBuffer.allocateDirect(address_bytes.length+1);
+            putBytes(address_buf, address_bytes, 0, address_bytes.length).put(address_bytes.length, (byte)0);
+        }
+        _IMAQdxDiscoverEthernetCameras(address == null ? 0 : getByteBufferAddress(address_buf), timeout);
+        
+    }
+    private static native void _IMAQdxDiscoverEthernetCameras(long address, long timeout);
+
+    public static void IMAQdxResetCamera(String name, long resetAll) {
+        ByteBuffer name_buf = null;
+        if (name != null) {
+            byte[] name_bytes;
+            try {
+                name_bytes = name.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                name_bytes = new byte[0];
+            }
+            name_buf = ByteBuffer.allocateDirect(name_bytes.length+1);
+            putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte)0);
+        }
+        _IMAQdxResetCamera(name == null ? 0 : getByteBufferAddress(name_buf), resetAll);
+        
+    }
+    private static native void _IMAQdxResetCamera(long name, long resetAll);
+
+    public static long IMAQdxOpenCamera(String name, IMAQdxCameraControlMode mode) {
+        ByteBuffer name_buf = null;
+        if (name != null) {
+            byte[] name_bytes;
+            try {
+                name_bytes = name.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                name_bytes = new byte[0];
+            }
+            name_buf = ByteBuffer.allocateDirect(name_bytes.length+1);
+            putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte)0);
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _IMAQdxOpenCamera(name == null ? 0 : getByteBufferAddress(name_buf), mode.getValue(), rv_addr+0);
+        long id;
+        id = rv_buf.getLong(0);
+        return id;
+    }
+    private static native long _IMAQdxOpenCamera(long name, int mode, long id);
+
+    public static void IMAQdxCloseCamera(long id) {
+        
+        _IMAQdxCloseCamera(id);
+        
+    }
+    private static native void _IMAQdxCloseCamera(long id);
+
+    public static void IMAQdxConfigureAcquisition(long id, long continuous, long bufferCount) {
+        
+        _IMAQdxConfigureAcquisition(id, continuous, bufferCount);
+        
+    }
+    private static native void _IMAQdxConfigureAcquisition(long id, long continuous, long bufferCount);
+
+    public static void IMAQdxStartAcquisition(long id) {
+        
+        _IMAQdxStartAcquisition(id);
+        
+    }
+    private static native void _IMAQdxStartAcquisition(long id);
+
+    public static long IMAQdxGetImage(long id, Image image, IMAQdxBufferNumberMode mode, long desiredBufferNumber) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _IMAQdxGetImage(id, image.getAddress(), mode.getValue(), desiredBufferNumber, rv_addr+0);
+        long actualBufferNumber;
+        actualBufferNumber = rv_buf.getLong(0);
+        return actualBufferNumber;
+    }
+    private static native long _IMAQdxGetImage(long id, long image, int mode, long desiredBufferNumber, long actualBufferNumber);
+
+    public static void IMAQdxStopAcquisition(long id) {
+        
+        _IMAQdxStopAcquisition(id);
+        
+    }
+    private static native void _IMAQdxStopAcquisition(long id);
+
+    public static void IMAQdxUnconfigureAcquisition(long id) {
+        
+        _IMAQdxUnconfigureAcquisition(id);
+        
+    }
+    private static native void _IMAQdxUnconfigureAcquisition(long id);
+
+    public static IMAQdxAttributeType IMAQdxGetAttributeType(long id, String name) {
+        ByteBuffer name_buf = null;
+        if (name != null) {
+            byte[] name_bytes;
+            try {
+                name_bytes = name.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                name_bytes = new byte[0];
+            }
+            name_buf = ByteBuffer.allocateDirect(name_bytes.length+1);
+            putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte)0);
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _IMAQdxGetAttributeType(id, name == null ? 0 : getByteBufferAddress(name_buf), rv_addr+0);
+        IMAQdxAttributeType type;
+        type = IMAQdxAttributeType.fromValue(rv_buf.getInt(0));
+        return type;
+    }
+    private static native int _IMAQdxGetAttributeType(long id, long name, long type);
+
+    public static long IMAQdxIsAttributeReadable(long id, String name) {
+        ByteBuffer name_buf = null;
+        if (name != null) {
+            byte[] name_bytes;
+            try {
+                name_bytes = name.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                name_bytes = new byte[0];
+            }
+            name_buf = ByteBuffer.allocateDirect(name_bytes.length+1);
+            putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte)0);
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _IMAQdxIsAttributeReadable(id, name == null ? 0 : getByteBufferAddress(name_buf), rv_addr+0);
+        long readable;
+        readable = rv_buf.getLong(0);
+        return readable;
+    }
+    private static native long _IMAQdxIsAttributeReadable(long id, long name, long readable);
+
+    public static long IMAQdxIsAttributeWritable(long id, String name) {
+        ByteBuffer name_buf = null;
+        if (name != null) {
+            byte[] name_bytes;
+            try {
+                name_bytes = name.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                name_bytes = new byte[0];
+            }
+            name_buf = ByteBuffer.allocateDirect(name_bytes.length+1);
+            putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte)0);
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _IMAQdxIsAttributeWritable(id, name == null ? 0 : getByteBufferAddress(name_buf), rv_addr+0);
+        long writable;
+        writable = rv_buf.getLong(0);
+        return writable;
+    }
+    private static native long _IMAQdxIsAttributeWritable(long id, long name, long writable);
+
+    public static void IMAQdxWriteRegister(long id, long offset, long value) {
+        
+        _IMAQdxWriteRegister(id, offset, value);
+        
+    }
+    private static native void _IMAQdxWriteRegister(long id, long offset, long value);
+
+    public static long IMAQdxReadRegister(long id, long offset) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _IMAQdxReadRegister(id, offset, rv_addr+0);
+        long value;
+        value = rv_buf.getLong(0);
+        return value;
+    }
+    private static native long _IMAQdxReadRegister(long id, long offset, long value);
+
+    public static void IMAQdxWriteAttributes(long id, String filename) {
+        ByteBuffer filename_buf = null;
+        if (filename != null) {
+            byte[] filename_bytes;
+            try {
+                filename_bytes = filename.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                filename_bytes = new byte[0];
+            }
+            filename_buf = ByteBuffer.allocateDirect(filename_bytes.length+1);
+            putBytes(filename_buf, filename_bytes, 0, filename_bytes.length).put(filename_bytes.length, (byte)0);
+        }
+        _IMAQdxWriteAttributes(id, filename == null ? 0 : getByteBufferAddress(filename_buf));
+        
+    }
+    private static native void _IMAQdxWriteAttributes(long id, long filename);
+
+    public static void IMAQdxReadAttributes(long id, String filename) {
+        ByteBuffer filename_buf = null;
+        if (filename != null) {
+            byte[] filename_bytes;
+            try {
+                filename_bytes = filename.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                filename_bytes = new byte[0];
+            }
+            filename_buf = ByteBuffer.allocateDirect(filename_bytes.length+1);
+            putBytes(filename_buf, filename_bytes, 0, filename_bytes.length).put(filename_bytes.length, (byte)0);
+        }
+        _IMAQdxReadAttributes(id, filename == null ? 0 : getByteBufferAddress(filename_buf));
+        
+    }
+    private static native void _IMAQdxReadAttributes(long id, long filename);
+
+    public static void IMAQdxResetEthernetCameraAddress(String name, String address, String subnet, String gateway, long timeout) {
+        ByteBuffer name_buf = null;
+        if (name != null) {
+            byte[] name_bytes;
+            try {
+                name_bytes = name.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                name_bytes = new byte[0];
+            }
+            name_buf = ByteBuffer.allocateDirect(name_bytes.length+1);
+            putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte)0);
+        }
+        ByteBuffer address_buf = null;
+        if (address != null) {
+            byte[] address_bytes;
+            try {
+                address_bytes = address.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                address_bytes = new byte[0];
+            }
+            address_buf = ByteBuffer.allocateDirect(address_bytes.length+1);
+            putBytes(address_buf, address_bytes, 0, address_bytes.length).put(address_bytes.length, (byte)0);
+        }
+        ByteBuffer subnet_buf = null;
+        if (subnet != null) {
+            byte[] subnet_bytes;
+            try {
+                subnet_bytes = subnet.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                subnet_bytes = new byte[0];
+            }
+            subnet_buf = ByteBuffer.allocateDirect(subnet_bytes.length+1);
+            putBytes(subnet_buf, subnet_bytes, 0, subnet_bytes.length).put(subnet_bytes.length, (byte)0);
+        }
+        ByteBuffer gateway_buf = null;
+        if (gateway != null) {
+            byte[] gateway_bytes;
+            try {
+                gateway_bytes = gateway.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                gateway_bytes = new byte[0];
+            }
+            gateway_buf = ByteBuffer.allocateDirect(gateway_bytes.length+1);
+            putBytes(gateway_buf, gateway_bytes, 0, gateway_bytes.length).put(gateway_bytes.length, (byte)0);
+        }
+        _IMAQdxResetEthernetCameraAddress(name == null ? 0 : getByteBufferAddress(name_buf), address == null ? 0 : getByteBufferAddress(address_buf), subnet == null ? 0 : getByteBufferAddress(subnet_buf), gateway == null ? 0 : getByteBufferAddress(gateway_buf), timeout);
+        
+    }
+    private static native void _IMAQdxResetEthernetCameraAddress(long name, long address, long subnet, long gateway, long timeout);
+
+    public static IMAQdxAttributeVisibility IMAQdxGetAttributeVisibility(long id, String name) {
+        ByteBuffer name_buf = null;
+        if (name != null) {
+            byte[] name_bytes;
+            try {
+                name_bytes = name.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                name_bytes = new byte[0];
+            }
+            name_buf = ByteBuffer.allocateDirect(name_bytes.length+1);
+            putBytes(name_buf, name_bytes, 0, name_bytes.length).put(name_bytes.length, (byte)0);
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        int jn_rv = _IMAQdxGetAttributeVisibility(id, name == null ? 0 : getByteBufferAddress(name_buf), rv_addr+0);
+        IMAQdxAttributeVisibility visibility;
+        visibility = IMAQdxAttributeVisibility.fromValue(rv_buf.getInt(0));
+        return visibility;
+    }
+    private static native int _IMAQdxGetAttributeVisibility(long id, long name, long visibility);
 }
diff --git a/wpilibj/wpilibJavaJNI/lib/NIVisionJNI.cpp b/wpilibj/wpilibJavaJNI/lib/NIVisionJNI.cpp
index 2a984ab4ad3a25e1dd58b4969628ff27bed823e9..54afc72d09ea4626ef40b7c3f76714d0bb48a8d3 100644
--- a/wpilibj/wpilibJavaJNI/lib/NIVisionJNI.cpp
+++ b/wpilibj/wpilibJavaJNI/lib/NIVisionJNI.cpp
@@ -8,6 +8,7 @@
 #include <assert.h>
 #include <jni.h>
 #include <nivision.h>
+#include <NIIMAQdx.h>
 
 // throw java exception
 static void throwJavaException(JNIEnv *env) {
@@ -21,6 +22,18 @@ static void throwJavaException(JNIEnv *env) {
     free(full_err_msg);
 }
 
+// throw IMAQdx java exception
+static void dxthrowJavaException(JNIEnv *env, IMAQdxError err) {
+    jclass je = env->FindClass("com/ni/vision/VisionException");
+    char* err_text = (char*)malloc(200);
+    IMAQdxGetErrorString(err, err_text, 200);
+    char* full_err_msg = (char*)malloc(250);
+    sprintf(full_err_msg, "IMAQdxError: %d: %s", err, err_text);
+    free(err_text);
+    env->ThrowNew(je, full_err_msg);
+    free(full_err_msg);
+}
+
 extern "C" {
 
 JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDispose(JNIEnv* , jclass , jlong addr)
@@ -4876,4 +4889,351 @@ JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqRake(JNIEnv* env, jcla
     if (!rv) throwJavaException(env);
     return (jlong)rv;
 }
+
+/*
+ * Purpose	  : Include file for NI-IMAQdx library support.
+ */
+
+/*
+ * Bus Type Enumeration
+ */
+
+/*
+ * Camera Control Mode Enumeration
+ */
+
+/*
+ * Buffer Number Mode Enumeration
+ */
+
+/*
+ * Plug n Play Event Enumeration
+ */
+
+/*
+ * Bayer Pattern Enumeration
+ */
+
+/*
+ * Bayer Decode Algorithm Enumeration
+ */
+
+/*
+ * Output Image Types -- Values match Vision Development Module image types
+ */
+
+/*
+ * Controller Destination Mode Enumeration
+ */
+
+/*
+ * Attribute Type Enumeration
+ */
+
+/*
+ * Value Type Enumeration
+ */
+
+/*
+ * Interface File Flags Enumeration
+ */
+
+/*
+ * Overwrite Mode Enumeration
+ */
+
+/*
+ * Incomplete Buffer Mode Enumeration
+ */
+
+/*
+ * Lost Packet Mode Enumeration
+ */
+
+/*
+ * Attribute Visibility Enumeration
+ */
+
+/*
+ * Stream Channel Mode Enumeration
+ */
+
+/*
+ * Pixel Signedness Enumeration
+ */
+
+/*
+ * USB Connection Speed Enumeration
+ */
+
+/*
+ * CVI Structures
+ */
+
+/*
+ * Camera Information Structure
+ */
+
+/*
+ * Camera File Structure
+ */
+
+/*
+ * Attribute Information Structure
+ */
+
+/*
+ * Enumeration Item Structure
+ */
+
+/*
+ * Camera Information Structure
+ */
+
+/*
+ * Attributes
+ */
+
+/*
+ * Functions
+ */
+
+/* J: void IMAQdxSnap(long id, Image image)
+ * JN: void IMAQdxSnap(long id, long image)
+ * C: IMAQdxError IMAQdxSnap(IMAQdxSession id, Image* image)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxSnap(JNIEnv* env, jclass , jlong id, jlong image)
+{
+    IMAQdxError rv = IMAQdxSnap((IMAQdxSession)id, (Image*)image);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+}
+
+/* J: void IMAQdxConfigureGrab(long id)
+ * JN: void IMAQdxConfigureGrab(long id)
+ * C: IMAQdxError IMAQdxConfigureGrab(IMAQdxSession id)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxConfigureGrab(JNIEnv* env, jclass , jlong id)
+{
+    IMAQdxError rv = IMAQdxConfigureGrab((IMAQdxSession)id);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+}
+
+/* J: long IMAQdxGrab(long id, Image image, long waitForNextBuffer)
+ * JN: long IMAQdxGrab(long id, long image, long waitForNextBuffer, long actualBufferNumber)
+ * C: IMAQdxError IMAQdxGrab(IMAQdxSession id, Image* image, bool32 waitForNextBuffer, uInt32* actualBufferNumber)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1IMAQdxGrab(JNIEnv* env, jclass , jlong id, jlong image, jlong waitForNextBuffer, jlong actualBufferNumber)
+{
+    IMAQdxError rv = IMAQdxGrab((IMAQdxSession)id, (Image*)image, (bool32)waitForNextBuffer, (uInt32*)actualBufferNumber);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+    return (jlong)rv;
+}
+
+/* J: void IMAQdxDiscoverEthernetCameras(String address, long timeout)
+ * JN: void IMAQdxDiscoverEthernetCameras(long address, long timeout)
+ * C: IMAQdxError IMAQdxDiscoverEthernetCameras(const char* address, uInt32 timeout)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxDiscoverEthernetCameras(JNIEnv* env, jclass , jlong address, jlong timeout)
+{
+    IMAQdxError rv = IMAQdxDiscoverEthernetCameras((const char*)address, (uInt32)timeout);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+}
+
+/* J: void IMAQdxResetCamera(String name, long resetAll)
+ * JN: void IMAQdxResetCamera(long name, long resetAll)
+ * C: IMAQdxError IMAQdxResetCamera(const char* name, bool32 resetAll)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxResetCamera(JNIEnv* env, jclass , jlong name, jlong resetAll)
+{
+    IMAQdxError rv = IMAQdxResetCamera((const char*)name, (bool32)resetAll);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+}
+
+/* J: long IMAQdxOpenCamera(String name, IMAQdxCameraControlMode mode)
+ * JN: long IMAQdxOpenCamera(long name, int mode, long id)
+ * C: IMAQdxError IMAQdxOpenCamera(const char* name, IMAQdxCameraControlMode mode, IMAQdxSession* id)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1IMAQdxOpenCamera(JNIEnv* env, jclass , jlong name, jint mode, jlong id)
+{
+    IMAQdxError rv = IMAQdxOpenCamera((const char*)name, (IMAQdxCameraControlMode)mode, (IMAQdxSession*)id);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+    return (jlong)rv;
+}
+
+/* J: void IMAQdxCloseCamera(long id)
+ * JN: void IMAQdxCloseCamera(long id)
+ * C: IMAQdxError IMAQdxCloseCamera(IMAQdxSession id)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxCloseCamera(JNIEnv* env, jclass , jlong id)
+{
+    IMAQdxError rv = IMAQdxCloseCamera((IMAQdxSession)id);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+}
+
+/* J: void IMAQdxConfigureAcquisition(long id, long continuous, long bufferCount)
+ * JN: void IMAQdxConfigureAcquisition(long id, long continuous, long bufferCount)
+ * C: IMAQdxError IMAQdxConfigureAcquisition(IMAQdxSession id, bool32 continuous, uInt32 bufferCount)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxConfigureAcquisition(JNIEnv* env, jclass , jlong id, jlong continuous, jlong bufferCount)
+{
+    IMAQdxError rv = IMAQdxConfigureAcquisition((IMAQdxSession)id, (bool32)continuous, (uInt32)bufferCount);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+}
+
+/* J: void IMAQdxStartAcquisition(long id)
+ * JN: void IMAQdxStartAcquisition(long id)
+ * C: IMAQdxError IMAQdxStartAcquisition(IMAQdxSession id)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxStartAcquisition(JNIEnv* env, jclass , jlong id)
+{
+    IMAQdxError rv = IMAQdxStartAcquisition((IMAQdxSession)id);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+}
+
+/* J: long IMAQdxGetImage(long id, Image image, IMAQdxBufferNumberMode mode, long desiredBufferNumber)
+ * JN: long IMAQdxGetImage(long id, long image, int mode, long desiredBufferNumber, long actualBufferNumber)
+ * C: IMAQdxError IMAQdxGetImage(IMAQdxSession id, Image* image, IMAQdxBufferNumberMode mode, uInt32 desiredBufferNumber, uInt32* actualBufferNumber)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetImage(JNIEnv* env, jclass , jlong id, jlong image, jint mode, jlong desiredBufferNumber, jlong actualBufferNumber)
+{
+    IMAQdxError rv = IMAQdxGetImage((IMAQdxSession)id, (Image*)image, (IMAQdxBufferNumberMode)mode, (uInt32)desiredBufferNumber, (uInt32*)actualBufferNumber);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+    return (jlong)rv;
+}
+
+/* J: void IMAQdxStopAcquisition(long id)
+ * JN: void IMAQdxStopAcquisition(long id)
+ * C: IMAQdxError IMAQdxStopAcquisition(IMAQdxSession id)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxStopAcquisition(JNIEnv* env, jclass , jlong id)
+{
+    IMAQdxError rv = IMAQdxStopAcquisition((IMAQdxSession)id);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+}
+
+/* J: void IMAQdxUnconfigureAcquisition(long id)
+ * JN: void IMAQdxUnconfigureAcquisition(long id)
+ * C: IMAQdxError IMAQdxUnconfigureAcquisition(IMAQdxSession id)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxUnconfigureAcquisition(JNIEnv* env, jclass , jlong id)
+{
+    IMAQdxError rv = IMAQdxUnconfigureAcquisition((IMAQdxSession)id);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+}
+
+/* J: IMAQdxAttributeType IMAQdxGetAttributeType(long id, String name)
+ * JN: int IMAQdxGetAttributeType(long id, long name, long type)
+ * C: IMAQdxError IMAQdxGetAttributeType(IMAQdxSession id, const char* name, IMAQdxAttributeType* type)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeType(JNIEnv* env, jclass , jlong id, jlong name, jlong type)
+{
+    IMAQdxError rv = IMAQdxGetAttributeType((IMAQdxSession)id, (const char*)name, (IMAQdxAttributeType*)type);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+    return (jint)rv;
+}
+
+/* J: long IMAQdxIsAttributeReadable(long id, String name)
+ * JN: long IMAQdxIsAttributeReadable(long id, long name, long readable)
+ * C: IMAQdxError IMAQdxIsAttributeReadable(IMAQdxSession id, const char* name, bool32* readable)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1IMAQdxIsAttributeReadable(JNIEnv* env, jclass , jlong id, jlong name, jlong readable)
+{
+    IMAQdxError rv = IMAQdxIsAttributeReadable((IMAQdxSession)id, (const char*)name, (bool32*)readable);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+    return (jlong)rv;
+}
+
+/* J: long IMAQdxIsAttributeWritable(long id, String name)
+ * JN: long IMAQdxIsAttributeWritable(long id, long name, long writable)
+ * C: IMAQdxError IMAQdxIsAttributeWritable(IMAQdxSession id, const char* name, bool32* writable)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1IMAQdxIsAttributeWritable(JNIEnv* env, jclass , jlong id, jlong name, jlong writable)
+{
+    IMAQdxError rv = IMAQdxIsAttributeWritable((IMAQdxSession)id, (const char*)name, (bool32*)writable);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+    return (jlong)rv;
+}
+
+/* J: void IMAQdxWriteRegister(long id, long offset, long value)
+ * JN: void IMAQdxWriteRegister(long id, long offset, long value)
+ * C: IMAQdxError IMAQdxWriteRegister(IMAQdxSession id, uInt32 offset, uInt32 value)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxWriteRegister(JNIEnv* env, jclass , jlong id, jlong offset, jlong value)
+{
+    IMAQdxError rv = IMAQdxWriteRegister((IMAQdxSession)id, (uInt32)offset, (uInt32)value);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+}
+
+/* J: long IMAQdxReadRegister(long id, long offset)
+ * JN: long IMAQdxReadRegister(long id, long offset, long value)
+ * C: IMAQdxError IMAQdxReadRegister(IMAQdxSession id, uInt32 offset, uInt32* value)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1IMAQdxReadRegister(JNIEnv* env, jclass , jlong id, jlong offset, jlong value)
+{
+    IMAQdxError rv = IMAQdxReadRegister((IMAQdxSession)id, (uInt32)offset, (uInt32*)value);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+    return (jlong)rv;
+}
+
+/* J: void IMAQdxWriteAttributes(long id, String filename)
+ * JN: void IMAQdxWriteAttributes(long id, long filename)
+ * C: IMAQdxError IMAQdxWriteAttributes(IMAQdxSession id, const char* filename)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxWriteAttributes(JNIEnv* env, jclass , jlong id, jlong filename)
+{
+    IMAQdxError rv = IMAQdxWriteAttributes((IMAQdxSession)id, (const char*)filename);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+}
+
+/* J: void IMAQdxReadAttributes(long id, String filename)
+ * JN: void IMAQdxReadAttributes(long id, long filename)
+ * C: IMAQdxError IMAQdxReadAttributes(IMAQdxSession id, const char* filename)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxReadAttributes(JNIEnv* env, jclass , jlong id, jlong filename)
+{
+    IMAQdxError rv = IMAQdxReadAttributes((IMAQdxSession)id, (const char*)filename);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+}
+
+/* J: void IMAQdxResetEthernetCameraAddress(String name, String address, String subnet, String gateway, long timeout)
+ * JN: void IMAQdxResetEthernetCameraAddress(long name, long address, long subnet, long gateway, long timeout)
+ * C: IMAQdxError IMAQdxResetEthernetCameraAddress(const char* name, const char* address, const char* subnet, const char* gateway, uInt32 timeout)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1IMAQdxResetEthernetCameraAddress(JNIEnv* env, jclass , jlong name, jlong address, jlong subnet, jlong gateway, jlong timeout)
+{
+    IMAQdxError rv = IMAQdxResetEthernetCameraAddress((const char*)name, (const char*)address, (const char*)subnet, (const char*)gateway, (uInt32)timeout);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+}
+
+/* J: IMAQdxAttributeVisibility IMAQdxGetAttributeVisibility(long id, String name)
+ * JN: int IMAQdxGetAttributeVisibility(long id, long name, long visibility)
+ * C: IMAQdxError IMAQdxGetAttributeVisibility(IMAQdxSession id, const char* name, IMAQdxAttributeVisibility* visibility)
+ */
+
+JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1IMAQdxGetAttributeVisibility(JNIEnv* env, jclass , jlong id, jlong name, jlong visibility)
+{
+    IMAQdxError rv = IMAQdxGetAttributeVisibility((IMAQdxSession)id, (const char*)name, (IMAQdxAttributeVisibility*)visibility);
+    if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);
+    return (jint)rv;
+}
 }
diff --git a/wpilibj/wpilibJavaJNI/nivision/gen_java.py b/wpilibj/wpilibJavaJNI/nivision/gen_java.py
index 117e64cd92e55782c13fced45c63743d2593edef..30deb5217969cf7eddbdb2eac7cfeb18326c11c7 100644
--- a/wpilibj/wpilibJavaJNI/nivision/gen_java.py
+++ b/wpilibj/wpilibJavaJNI/nivision/gen_java.py
@@ -17,6 +17,7 @@ java_accessor_map = {
         "J": "Long",
         "F": "Float",
         "D": "Double",
+        "Z": "Boolean",
         }
 
 java_size_map = {
@@ -27,6 +28,7 @@ java_size_map = {
         "J": 8,
         "F": 4,
         "D": 8,
+        "Z": 1,
         }
 
 class JavaType:
@@ -66,6 +68,9 @@ java_types_map = {
         ("unsigned short", None): JavaType("int", "int", "jint", "I"),
         ("unsigned", None): JavaType("int", "int", "jint", "I"),
         ("unsigned int", None): JavaType("int", "int", "jint", "I"),
+        ("uInt32", None): JavaType("int", "int", "jint", "I"),
+        ("IMAQdxSession", None): JavaType("int", "int", "jint", "I"),
+        ("bool32", None): JavaType("boolean", "boolean", "jboolean", "Z"),
         ("long", None): JavaType("long", "long", "jlong", "J"),
         ("unsigned long", None): JavaType("long", "long", "jlong", "J"),
         ("__int64", None): JavaType("long", "long", "jlong", "J"),
@@ -88,6 +93,7 @@ java_types_map = {
         ("short", ""): JavaType("short[]", "short[]", "jshortArray", "[S"),
         ("int", ""): JavaType("int[]", "int[]", "jintArray", "[I"),
         ("unsigned int", ""): JavaType("int[]", "int[]", "jintArray", "[I"),
+        ("uInt32", ""): JavaType("int[]", "int[]", "jintArray", "[I"),
         ("long", ""): JavaType("long[]", "long[]", "jlongArray", "[J"),
         ("float", ""): JavaType("float[]", "float[]", "jfloatArray", "[F"),
         ("double", ""): JavaType("double[]", "double[]", "jdoubleArray", "[D"),
@@ -1117,6 +1123,7 @@ public class {classname} {{
 #include <assert.h>
 #include <jni.h>
 #include <nivision.h>
+#include <NIIMAQdx.h>
 
 // throw java exception
 static void throwJavaException(JNIEnv *env) {{
@@ -1130,6 +1137,18 @@ static void throwJavaException(JNIEnv *env) {{
     free(full_err_msg);
 }}
 
+// throw IMAQdx java exception
+static void dxthrowJavaException(JNIEnv *env, IMAQdxError err) {{
+    jclass je = env->FindClass("{packagepath}/VisionException");
+    char* err_text = (char*)malloc(200);
+    IMAQdxGetErrorString(err, err_text, 200);
+    char* full_err_msg = (char*)malloc(250);
+    sprintf(full_err_msg, "IMAQdxError: %d: %s", err, err_text);
+    free(err_text);
+    env->ThrowNew(je, full_err_msg);
+    free(full_err_msg);
+}}
+
 extern "C" {{
 
 JNIEXPORT void JNICALL Java_{package}_{classname}__1imaqDispose(JNIEnv* , jclass , jlong addr)
@@ -1260,8 +1279,13 @@ JNIEXPORT void JNICALL Java_{package}_{classname}__1imaqDispose(JNIEnv* , jclass
                 continue
             if vname.startswith("IMAQ_"):
                 vname = vname[5:]
+            if vname.startswith("IMAQdx"):
+                vname = vname[6:]
             if vname[0] in "0123456789":
                 vname = "C" + vname
+            if value is None:
+                # auto-increment
+                value = "%d" % (prev_value + 1)
             valuestrs.append("%s(%s),%s" % (vname, value, " // %s" % comment if comment else ""))
             defined.add(vname)
             value_i = int(value, 0)
@@ -1344,6 +1368,10 @@ JNIEXPORT void JNICALL Java_{package}_{classname}__1imaqDispose(JNIEnv* , jclass
             functype = "STDFUNC"
             rettype = c_to_jtype("void", None)
             exceptioncheck = "if (rv == 0) throwJavaException(env);"
+        elif restype == "IMAQdxError":
+            functype = "STDFUNC"
+            rettype = c_to_jtype("void", None)
+            exceptioncheck = "if (rv != IMAQdxErrorSuccess) dxthrowJavaException(env, rv);"
         else:
             if restype[-1] == "*":
                 functype = "STDPTRFUNC"
@@ -1680,36 +1708,45 @@ JNIEXPORT {rettype} JNICALL Java_{package}_{classname}__1{name}({args})
     def union(self, name, fields):
         self.unions[name] = fields
 
-def generate(srcdir, outdir, config_struct_path, configpath, nivisionhpath):
-    # read config files
-    config_struct = configparser.ConfigParser()
-    config_struct.read(config_struct_path)
-    config = configparser.ConfigParser()
-    config.read(configpath)
-    block_comment_exclude = set(x.strip() for x in
-            config.get("Block Comment", "exclude").splitlines())
-
-    # open input file
-    inf = open(nivisionhpath)
-
-    # prescan for undefined structures
-    prescan_file(inf)
-    inf.seek(0)
-
-    # generate
-    emit = JavaEmitter(outdir, config, config_struct)
-    parse_file(emit, inf, block_comment_exclude)
+def generate(srcdir, outdir, inputs):
+    emit = None
+
+    for fname, config_struct_path, configpath in inputs:
+        # read config files
+        config_struct = configparser.ConfigParser()
+        config_struct.read(config_struct_path)
+        config = configparser.ConfigParser()
+        config.read(configpath)
+        block_comment_exclude = set(x.strip() for x in
+                config.get("Block Comment", "exclude").splitlines())
+
+        # open input file
+        with open(fname) as inf:
+            # prescan for undefined structures
+            prescan_file(inf)
+            inf.seek(0)
+
+            if emit is None:
+                emit = JavaEmitter(outdir, config, config_struct)
+            else:
+                emit.config = config
+                emit.config_struct = config_struct
+
+            # generate
+            parse_file(emit, inf, block_comment_exclude)
+
     emit.finish()
 
 if __name__ == "__main__":
-    if len(sys.argv) < 3:
-        print("Usage: gen_wrap.py <nivision.h> config_struct.ini [config.ini]")
+    if len(sys.argv) < 4 or ((len(sys.argv)-1) % 3) != 0:
+        print("Usage: gen_wrap.py <header.h config_struct.ini config.ini>...")
         exit(0)
 
-    fname = sys.argv[1]
-    config_struct_name = sys.argv[2]
-    configname = "nivision_2011.ini"
-    if len(sys.argv) >= 4:
-        configname = sys.argv[3]
+    inputs = []
+    for i in range(1, len(sys.argv), 3):
+        fname = sys.argv[i]
+        config_struct_name = sys.argv[i+1]
+        configname = sys.argv[i+2]
+        inputs.append((fname, config_struct_name, configname))
 
-    generate("", "", config_struct_name, configname, fname)
+    generate("", "", inputs)
diff --git a/wpilibj/wpilibJavaJNI/nivision/gen_struct_sizer.py b/wpilibj/wpilibJavaJNI/nivision/gen_struct_sizer.py
index d7c73c3a7484eb5f12e5bd2486982f3d15913dc2..0e64fb3d8b362d2077c5bd1e55e2c0f45d5edddd 100644
--- a/wpilibj/wpilibJavaJNI/nivision/gen_struct_sizer.py
+++ b/wpilibj/wpilibJavaJNI/nivision/gen_struct_sizer.py
@@ -10,16 +10,18 @@ except ImportError:
 from nivision_parse import *
 
 class StructSizerEmitter:
-    def __init__(self, out, config):
+    def __init__(self, out, config, hname):
         self.out = out
         self.config = config
         print("""#include <stdio.h>
-#include <nivision.h>
+#include <stddef.h>
+#include <{hname}>
 
 int main()
-{
-    printf("[_platform_]\\npointer=%d\\n", (int)sizeof(void*));
-""", file=self.out)
+{{
+    asm("#STRUCT_SIZER [_platform_]\\n");
+    asm("#STRUCT_SIZER pointer=%0\\n" : : "n"((int)sizeof(void*)));
+""".format(hname=hname), file=self.out)
 
     def finish(self):
         print("}", file=self.out)
@@ -67,12 +69,13 @@ int main()
         if name in opaque_structs:
             return
 
-        print('printf("[{name}]\\n_SIZE_=%d\\n", (int)sizeof({name}));'.format(name=name), file=self.out)
+        print('asm("#STRUCT_SIZER [{name}]\\n");'.format(name=name), file=self.out)
+        print('asm("#STRUCT_SIZER _SIZE_=%0\\n" : : "n"((int)sizeof({name})));'.format(name=name), file=self.out)
 
         for fname, ftype, arr, comment in fields:
             if ':' in fname:
                 continue # can't handle bitfields
-            print('printf("{field}=%d\\n", (int)offsetof({name}, {field}));'.format(name=name, field=fname), file=self.out)
+            print('asm("#STRUCT_SIZER {field}=%0\\n" : : "n"((int)offsetof({name}, {field})));'.format(name=name, field=fname), file=self.out)
 
     def struct(self, name, fields):
         self.structunion("Structure", name, fields)
@@ -80,7 +83,7 @@ int main()
     def union(self, name, fields):
         self.structunion("Union", name, fields)
 
-def generate(srcdir, configpath=None, nivisionhpath=None):
+def generate(srcdir, configpath=None, hpath=None):
     # read config file
     config = configparser.ConfigParser()
     config.read(configpath)
@@ -88,7 +91,7 @@ def generate(srcdir, configpath=None, nivisionhpath=None):
             config.get("Block Comment", "exclude").splitlines())
 
     # open input file
-    inf = open(nivisionhpath)
+    inf = open(hpath)
 
     # prescan for undefined structures
     prescan_file(inf)
@@ -96,18 +99,16 @@ def generate(srcdir, configpath=None, nivisionhpath=None):
 
     # generate
     with open("struct_sizer.c", "wt") as out:
-        emit = StructSizerEmitter(out, config)
+        emit = StructSizerEmitter(out, config, os.path.basename(hpath))
         parse_file(emit, inf, block_comment_exclude)
         emit.finish()
 
 if __name__ == "__main__":
-    if len(sys.argv) < 2:
-        print("Usage: gen_struct_sizer.py <nivision.h> [config.ini]")
+    if len(sys.argv) != 3:
+        print("Usage: gen_struct_sizer.py <header.h> <config.ini>")
         exit(0)
 
     fname = sys.argv[1]
-    configname = "nivision_2011.ini"
-    if len(sys.argv) >= 3:
-        configname = sys.argv[2]
+    configname = sys.argv[2]
 
     generate("", configname, fname)
diff --git a/wpilibj/wpilibJavaJNI/nivision/generateJNI.sh b/wpilibj/wpilibJavaJNI/nivision/generateJNI.sh
index 6c68013c2f84a8c0daa2d4b1bd6d761204129709..85ec8b2d994159c69c2cc9844a60e3085f9f0040 100755
--- a/wpilibj/wpilibJavaJNI/nivision/generateJNI.sh
+++ b/wpilibj/wpilibJavaJNI/nivision/generateJNI.sh
@@ -3,9 +3,26 @@
 #   bindings for NIVision.  At some point,
 #   it should be integrated into the build system.
 # Assumes running from allwpilib/wpilibj/wpilibJavaJNI/nivision
-# Get files that we node to generate from.
+
+# Get structure sizes.
+python gen_struct_sizer.py ../../../wpilibc/wpilibC++Devices/include/nivision.h nivision_2011.ini
+arm-frc-linux-gnueabi-gcc -I../../../wpilibc/wpilibC++Devices/include -S struct_sizer.c
+cat struct_sizer.s | python get_struct_size.py > nivision_arm.ini
+
+python gen_struct_sizer.py ../../../wpilibc/wpilibC++Devices/include/NIIMAQdx.h imaqdx.ini
+arm-frc-linux-gnueabi-gcc -I../../../wpilibc/wpilibC++Devices/include -S struct_sizer.c
+cat struct_sizer.s | python get_struct_size.py > imaqdx_arm.ini
+
 # Run python generator.
-python gen_java.py ../../../wpilibc/wpilibC++Devices/include/nivision.h nivision_arm.ini nivision_2011.ini
+python gen_java.py \
+    ../../../wpilibc/wpilibC++Devices/include/nivision.h \
+    nivision_arm.ini \
+    nivision_2011.ini \
+    \
+    ../../../wpilibc/wpilibC++Devices/include/NIIMAQdx.h \
+    imaqdx_arm.ini \
+    imaqdx.ini
+
 # Stick generated files into appropriate places.
 cp NIVision.cpp ../lib/NIVisionJNI.cpp
 mkdir -p ../../wpilibJavaDevices/src/main/java/com/ni/vision
diff --git a/wpilibj/wpilibJavaJNI/nivision/get_struct_size.py b/wpilibj/wpilibJavaJNI/nivision/get_struct_size.py
new file mode 100644
index 0000000000000000000000000000000000000000..004d9b08c099a6cf0d58fd5a2c1b970bfd6fcbe1
--- /dev/null
+++ b/wpilibj/wpilibJavaJNI/nivision/get_struct_size.py
@@ -0,0 +1,14 @@
+from __future__ import print_function
+import sys
+
+def main():
+    for line in sys.stdin:
+        line = line.strip()
+        if not line.startswith("#STRUCT_SIZER"):
+            continue
+        line = line[14:]
+        line = line.replace("#", "")
+        print(line)
+
+if __name__ == "__main__":
+    main()
diff --git a/wpilibj/wpilibJavaJNI/nivision/imaqdx.ini b/wpilibj/wpilibJavaJNI/nivision/imaqdx.ini
new file mode 100644
index 0000000000000000000000000000000000000000..7694739e3dd1cbb50fbe148eb83aa0710b35259f
--- /dev/null
+++ b/wpilibj/wpilibJavaJNI/nivision/imaqdx.ini
@@ -0,0 +1,81 @@
+[Block Comment]
+exclude=
+ Typedefs
+ Forward Declare Data Structures
+ Error Codes Enumeration
+ Callbacks
+
+; Error Codes Enumeration
+[IMAQdxError]
+exclude=True
+
+; Callbacks
+[FrameDoneEventCallbackPtr]
+exclude=True
+[PnpEventCallbackPtr]
+exclude=True
+[AttributeUpdatedEventCallbackPtr]
+exclude=True
+
+; Functions
+[IMAQdxSequence]
+arraysize=images:count
+exclude=True
+[IMAQdxEnumerateCameras]
+arraysize=cameraInformationArray:count
+exclude=True
+[IMAQdxGetImageData]
+#arraysize=buffer:bufferSize
+[IMAQdxEnumerateVideoModes]
+arraysize=videoModeArray:count
+exclude=True
+[IMAQdxEnumerateAttributes]
+arraysize=attributeInformationArray:count
+exclude=True
+[IMAQdxGetAttribute]
+exclude=True
+[IMAQdxSetAttribute]
+# has to be manual due to "..."
+exclude=True
+[IMAQdxGetAttributeMinimum]
+exclude=True
+[IMAQdxGetAttributeMaximum]
+exclude=True
+[IMAQdxGetAttributeIncrement]
+exclude=True
+[IMAQdxEnumerateAttributeValues]
+arraysize=list:size
+exclude=True
+[IMAQdxGetAttributeTooltip]
+exclude=True
+[IMAQdxGetAttributeUnits]
+exclude=True
+[IMAQdxRegisterFrameDoneEvent]
+# callback
+exclude=True
+[IMAQdxRegisterPnpEvent]
+# callback
+exclude=True
+[IMAQdxWriteMemory]
+arraysize=values:count
+exclude=True
+[IMAQdxReadMemory]
+arraysize=values:count
+exclude=True
+[IMAQdxGetErrorString]
+exclude=True
+[IMAQdxEnumerateAttributes2]
+arraysize=attributeInformationArray:count
+exclude=True
+[IMAQdxGetAttributeDescription]
+exclude=True
+[IMAQdxGetAttributeDisplayName]
+exclude=True
+[IMAQdxDispose]
+exclude=True
+[IMAQdxRegisterAttributeUpdatedEvent]
+# callback
+exclude=True
+[IMAQdxEnumerateAttributes3]
+arraysize=attributeInformationArray:count
+exclude=True
diff --git a/wpilibj/wpilibJavaJNI/nivision/nivision_arm.ini b/wpilibj/wpilibJavaJNI/nivision/nivision_arm.ini
deleted file mode 100644
index 08ea2e0abd07cf78e7c71b1099c222fe665c73c8..0000000000000000000000000000000000000000
--- a/wpilibj/wpilibJavaJNI/nivision/nivision_arm.ini
+++ /dev/null
@@ -1,1863 +0,0 @@
-[_platform_]
-pointer=4
-[DivisionModel]
-_SIZE_=4
-kappa=0
-[FocalLength]
-_SIZE_=8
-fx=0
-fy=4
-[PolyModel]
-_SIZE_=16
-kCoeffs=0
-numKCoeffs=4
-p1=8
-p2=12
-[DistortionModelParams]
-_SIZE_=24
-distortionModel=0
-polyModel=4
-divisionModel=20
-[PointFloat]
-_SIZE_=8
-x=0
-y=4
-[InternalParameters]
-_SIZE_=20
-isInsufficientData=0
-focalLength=4
-opticalCenter=12
-[MaxGridSize]
-_SIZE_=8
-xMax=0
-yMax=4
-[ImageSize]
-_SIZE_=8
-xRes=0
-yRes=4
-[CalibrationReferencePoints]
-_SIZE_=28
-pixelCoords=0
-numPixelCoords=4
-realCoords=8
-numRealCoords=12
-units=16
-imageSize=20
-[GetCameraParametersReport]
-_SIZE_=56
-projectionMatrix=0
-projectionMatrixRows=4
-projectionMatrixCols=8
-distortion=12
-internalParams=36
-[CalibrationAxisInfo]
-_SIZE_=16
-center=0
-rotationAngle=8
-axisDirection=12
-[CalibrationLearnSetupInfo]
-_SIZE_=20
-calibrationMethod=0
-distortionModel=4
-scaleMode=8
-roiMode=12
-learnCorrectionTable=16
-[GridDescriptor]
-_SIZE_=12
-xStep=0
-yStep=4
-unit=8
-[ErrorStatistics]
-_SIZE_=32
-mean=0
-maximum=8
-standardDeviation=16
-distortion=24
-[GetCalibrationInfoReport]
-_SIZE_=104
-userRoi=0
-calibrationRoi=4
-axisInfo=8
-learnSetupInfo=24
-gridDescriptor=44
-errorMap=56
-errorMapRows=60
-errorMapCols=64
-errorStatistics=72
-[EdgePolarity]
-_SIZE_=8
-start=0
-end=4
-[ClampSettings]
-_SIZE_=16
-angleRange=0
-edgePolarity=8
-[PointDouble]
-_SIZE_=16
-x=0
-y=8
-[PointDoublePair]
-_SIZE_=32
-start=0
-end=16
-[ClampResults]
-_SIZE_=32
-distancePix=0
-distanceRealWorld=8
-angleAbs=16
-angleRelative=24
-[ClampPoints]
-_SIZE_=64
-pixel=0
-realWorld=32
-[RGBValue]
-_SIZE_=4
-B=0
-G=1
-R=2
-alpha=3
-[ClampOverlaySettings]
-_SIZE_=36
-showSearchArea=0
-showCurves=4
-showClampLocation=8
-showResult=12
-searchAreaColor=16
-curvesColor=20
-clampLocationsColor=24
-resultColor=28
-overlayGroupName=32
-[ClampMax2Report]
-_SIZE_=104
-clampResults=0
-clampPoints=32
-calibrationValid=96
-[ContourFitSplineReport]
-_SIZE_=8
-points=0
-numberOfPoints=4
-[LineFloat]
-_SIZE_=16
-start=0
-end=8
-[LineEquation]
-_SIZE_=24
-a=0
-b=8
-c=16
-[ContourFitLineReport]
-_SIZE_=40
-lineSegment=0
-lineEquation=16
-[ContourFitPolynomialReport]
-_SIZE_=16
-bestFit=0
-numberOfPoints=4
-polynomialCoefficients=8
-numberOfCoefficients=12
-[PartialCircle]
-_SIZE_=32
-center=0
-radius=8
-startAngle=16
-endAngle=24
-[PartialEllipse]
-_SIZE_=48
-center=0
-angle=8
-majorRadius=16
-minorRadius=24
-startAngle=32
-endAngle=40
-[SetupMatchPatternData]
-_SIZE_=8
-matchSetupData=0
-numMatchSetupData=4
-[RangeSettingDouble]
-_SIZE_=24
-settingType=0
-min=8
-max=16
-[GeometricAdvancedSetupDataOption]
-_SIZE_=16
-type=0
-value=8
-[ContourInfoReport]
-_SIZE_=56
-pointsPixel=0
-numPointsPixel=4
-pointsReal=8
-numPointsReal=12
-curvaturePixel=16
-numCurvaturePixel=20
-curvatureReal=24
-numCurvatureReal=28
-length=32
-lengthReal=40
-hasEquation=48
-[ROILabel]
-_SIZE_=8
-className=0
-label=4
-[SupervisedColorSegmentationReport]
-_SIZE_=8
-labelOut=0
-numLabelOut=4
-[LabelToROIReport]
-_SIZE_=24
-roiArray=0
-numOfROIs=4
-labelsOutArray=8
-numOfLabels=12
-isTooManyVectorsArray=16
-isTooManyVectorsArraySize=20
-[ColorSegmenationOptions]
-_SIZE_=24
-windowX=0
-windowY=4
-stepSize=8
-minParticleArea=12
-maxParticleArea=16
-isFineSegment=20
-[ClassifiedCurve]
-_SIZE_=48
-length=0
-lengthReal=8
-maxCurvature=16
-maxCurvatureReal=24
-label=32
-curvePoints=36
-numCurvePoints=40
-[RangeDouble]
-_SIZE_=16
-minValue=0
-maxValue=8
-[RangeLabel]
-_SIZE_=24
-range=0
-label=16
-[CurvatureAnalysisReport]
-_SIZE_=8
-curves=0
-numCurves=4
-[Disparity]
-_SIZE_=40
-current=0
-reference=16
-distance=32
-[ComputeDistancesReport]
-_SIZE_=16
-distances=0
-numDistances=4
-distancesReal=8
-numDistancesReal=12
-[MatchMode]
-_SIZE_=12
-rotation=0
-scale=4
-occlusion=8
-[ClassifiedDisparity]
-_SIZE_=56
-length=0
-lengthReal=8
-maxDistance=16
-maxDistanceReal=24
-label=32
-templateSubsection=36
-numTemplateSubsection=40
-targetSubsection=44
-numTargetSubsection=48
-[ClassifyDistancesReport]
-_SIZE_=8
-classifiedDistances=0
-numClassifiedDistances=4
-[ContourComputeCurvatureReport]
-_SIZE_=16
-curvaturePixel=0
-numCurvaturePixel=4
-curvatureReal=8
-numCurvatureReal=12
-[ContourOverlaySettings]
-_SIZE_=16
-overlay=0
-color=4
-width=8
-maintainWidth=12
-[CurveParameters]
-_SIZE_=28
-extractionMode=0
-threshold=4
-filterSize=8
-minLength=12
-searchStep=16
-maxEndPointGap=20
-subpixel=24
-[ExtractContourReport]
-_SIZE_=16
-contourPoints=0
-numContourPoints=4
-sourcePoints=8
-numSourcePoints=12
-[ConnectionConstraint]
-_SIZE_=24
-constraintType=0
-range=8
-[ExtractTextureFeaturesReport]
-_SIZE_=20
-waveletBands=0
-numWaveletBands=4
-textureFeatures=8
-textureFeaturesRows=12
-textureFeaturesCols=16
-[WaveletBandsReport]
-_SIZE_=40
-LLBand=0
-LHBand=4
-HLBand=8
-HHBand=12
-LLLBand=16
-LLHBand=20
-LHLBand=24
-LHHBand=28
-rows=32
-cols=36
-[CircleFitOptions]
-_SIZE_=24
-maxRadius=0
-stepSize=8
-processType=16
-[EdgeOptions2]
-_SIZE_=24
-polarity=0
-kernelSize=4
-width=8
-minThreshold=12
-interpolationType=16
-columnProcessingMode=20
-[FindCircularEdgeOptions]
-_SIZE_=64
-direction=0
-showSearchArea=4
-showSearchLines=8
-showEdgesFound=12
-showResult=16
-searchAreaColor=20
-searchLinesColor=24
-searchEdgesColor=28
-resultColor=32
-overlayGroupName=36
-edgeOptions=40
-[FindConcentricEdgeOptions]
-_SIZE_=64
-direction=0
-showSearchArea=4
-showSearchLines=8
-showEdgesFound=12
-showResult=16
-searchAreaColor=20
-searchLinesColor=24
-searchEdgesColor=28
-resultColor=32
-overlayGroupName=36
-edgeOptions=40
-[ConcentricEdgeFitOptions]
-_SIZE_=24
-maxRadius=0
-stepSize=8
-processType=16
-[FindConcentricEdgeReport]
-_SIZE_=80
-startPt=0
-endPt=8
-startPtCalibrated=16
-endPtCalibrated=24
-angle=32
-angleCalibrated=40
-straightness=48
-avgStrength=56
-avgSNR=64
-lineFound=72
-[FindCircularEdgeReport]
-_SIZE_=64
-centerCalibrated=0
-radiusCalibrated=8
-center=16
-radius=24
-roundness=32
-avgStrength=40
-avgSNR=48
-circleFound=56
-[WindowSize]
-_SIZE_=12
-x=0
-y=4
-stepSize=8
-[DisplacementVector]
-_SIZE_=8
-x=0
-y=4
-[WaveletOptions]
-_SIZE_=8
-typeOfWavelet=0
-minEnergy=4
-[CooccurrenceOptions]
-_SIZE_=12
-level=0
-displacement=4
-[ParticleClassifierLocalThresholdOptions]
-_SIZE_=24
-method=0
-particleType=4
-windowWidth=8
-windowHeight=12
-deviationWeight=16
-[RangeFloat]
-_SIZE_=8
-minValue=0
-maxValue=4
-[ParticleClassifierAutoThresholdOptions]
-_SIZE_=16
-method=0
-particleType=4
-limits=8
-[ParticleClassifierPreprocessingOptions2]
-_SIZE_=64
-thresholdType=0
-manualThresholdRange=4
-autoThresholdOptions=12
-localThresholdOptions=32
-rejectBorder=56
-numErosions=60
-[MeasureParticlesReport]
-_SIZE_=16
-pixelMeasurements=0
-calibratedMeasurements=4
-numParticles=8
-numMeasurements=12
-[GeometricPatternMatch3]
-_SIZE_=116
-position=0
-rotation=8
-scale=12
-score=16
-corner=20
-inverse=52
-occlusion=56
-templateMatchCurveScore=60
-matchTemplateCurveScore=64
-correlationScore=68
-calibratedPosition=72
-calibratedRotation=80
-calibratedCorner=84
-[MatchGeometricPatternAdvancedOptions3]
-_SIZE_=88
-subpixelIterations=0
-subpixelTolerance=8
-initialMatchListLength=16
-targetTemplateCurveScore=20
-correlationScore=24
-minMatchSeparationDistance=32
-minMatchSeparationAngle=40
-minMatchSeparationScale=48
-maxMatchOverlap=56
-coarseResult=64
-enableCalibrationSupport=68
-enableContrastReversal=72
-matchStrategy=76
-refineMatchFactor=80
-subpixelMatchFactor=84
-[ColorOptions]
-_SIZE_=12
-colorClassificationResolution=0
-useLuminance=4
-colorMode=8
-[SampleScore]
-_SIZE_=12
-className=0
-distance=4
-index=8
-[ClassifierReportAdvanced]
-_SIZE_=28
-bestClassName=0
-classificationScore=4
-identificationScore=8
-allScores=12
-allScoresSize=16
-sampleScores=20
-sampleScoresSize=24
-[LearnGeometricPatternAdvancedOptions2]
-_SIZE_=40
-minScaleFactor=0
-maxScaleFactor=8
-minRotationAngleValue=16
-maxRotationAngleValue=24
-imageSamplingFactor=32
-[ParticleFilterOptions2]
-_SIZE_=16
-rejectMatches=0
-rejectBorder=4
-fillHoles=8
-connectivity8=12
-[FindEdgeOptions2]
-_SIZE_=64
-direction=0
-showSearchArea=4
-showSearchLines=8
-showEdgesFound=12
-showResult=16
-searchAreaColor=20
-searchLinesColor=24
-searchEdgesColor=28
-resultColor=32
-overlayGroupName=36
-edgeOptions=40
-[FindEdgeReport]
-_SIZE_=8
-straightEdges=0
-numStraightEdges=4
-[FindTransformRectOptions2]
-_SIZE_=64
-direction=0
-showSearchArea=4
-showSearchLines=8
-showEdgesFound=12
-showResult=16
-searchAreaColor=20
-searchLinesColor=24
-searchEdgesColor=28
-resultColor=32
-overlayGroupName=36
-edgeOptions=40
-[FindTransformRectsOptions2]
-_SIZE_=88
-direction=0
-showSearchArea=4
-showSearchLines=8
-showEdgesFound=12
-showResult=16
-searchAreaColor=20
-searchLinesColor=24
-searchEdgesColor=28
-resultColor=32
-overlayGroupName=36
-primaryEdgeOptions=40
-secondaryEdgeOptions=64
-[ReadTextReport3]
-_SIZE_=16
-readString=0
-characterReport=4
-numCharacterReports=8
-roiBoundingCharacters=12
-[CharacterStatistics]
-_SIZE_=20
-left=0
-top=4
-width=8
-height=12
-characterSize=16
-[CharReport3]
-_SIZE_=44
-character=0
-classificationScore=4
-verificationScore=8
-verified=12
-lowThreshold=16
-highThreshold=20
-characterStats=24
-[ArcInfo2]
-_SIZE_=32
-center=0
-radius=8
-startAngle=16
-endAngle=24
-[EdgeReport2]
-_SIZE_=20
-edges=0
-numEdges=4
-gradientInfo=8
-numGradientInfo=12
-calibrationValid=16
-[SearchArcInfo]
-_SIZE_=56
-arcCoordinates=0
-edgeReport=32
-[ConcentricRakeReport2]
-_SIZE_=24
-firstEdges=0
-numFirstEdges=4
-lastEdges=8
-numLastEdges=12
-searchArcs=16
-numSearchArcs=20
-[SpokeReport2]
-_SIZE_=24
-firstEdges=0
-numFirstEdges=4
-lastEdges=8
-numLastEdges=12
-searchLines=16
-numSearchLines=20
-[EdgeInfo]
-_SIZE_=56
-position=0
-calibratedPosition=8
-distance=16
-calibratedDistance=24
-magnitude=32
-noisePeak=40
-rising=48
-[SearchLineInfo]
-_SIZE_=36
-lineCoordinates=0
-edgeReport=16
-[RakeReport2]
-_SIZE_=24
-firstEdges=0
-numFirstEdges=4
-lastEdges=8
-numLastEdges=12
-searchLines=16
-numSearchLines=20
-[TransformBehaviors]
-_SIZE_=16
-ShiftBehavior=0
-ScaleBehavior=4
-RotateBehavior=8
-SymmetryBehavior=12
-[QRCodeDataToken]
-_SIZE_=16
-mode=0
-modeData=4
-data=8
-dataLength=12
-[ParticleFilterOptions]
-_SIZE_=12
-rejectMatches=0
-rejectBorder=4
-connectivity8=8
-[StraightEdgeReport2]
-_SIZE_=16
-straightEdges=0
-numStraightEdges=4
-searchLines=8
-numSearchLines=12
-[StraightEdgeOptions]
-_SIZE_=80
-numLines=0
-searchMode=4
-minScore=8
-maxScore=16
-orientation=24
-angleRange=32
-angleTolerance=40
-stepSize=48
-minSignalToNoiseRatio=56
-minCoverage=64
-houghIterations=72
-[StraightEdge]
-_SIZE_=88
-straightEdgeCoordinates=0
-calibratedStraightEdgeCoordinates=16
-angle=32
-calibratedAngle=40
-score=48
-straightness=56
-averageSignalToNoiseRatio=64
-calibrationValid=72
-usedEdges=76
-numUsedEdges=80
-[QRCodeSearchOptions]
-_SIZE_=48
-rotationMode=0
-skipLocation=4
-edgeThreshold=8
-demodulationMode=16
-cellSampleSize=24
-cellFilterMode=32
-skewDegreesAllowed=40
-[QRCodeSizeOptions]
-_SIZE_=8
-minSize=0
-maxSize=4
-[QRCodeDescriptionOptions]
-_SIZE_=32
-dimensions=0
-polarity=8
-mirror=16
-modelType=24
-[QRCodeReport]
-_SIZE_=136
-found=0
-data=4
-dataLength=8
-boundingBox=12
-tokenizedData=44
-sizeOfTokenizedData=48
-numErrorsCorrected=52
-dimensions=56
-version=60
-modelType=64
-streamMode=68
-matrixPolarity=72
-mirrored=80
-positionInAppendStream=84
-sizeOfAppendStream=88
-firstEAN128ApplicationID=92
-firstECIDesignator=96
-appendStreamIdentifier=100
-minimumEdgeStrength=104
-demodulationMode=112
-cellSampleSize=120
-cellFilterMode=128
-[AIMGradeReport]
-_SIZE_=40
-overallGrade=0
-decodingGrade=4
-symbolContrastGrade=8
-symbolContrast=12
-printGrowthGrade=16
-printGrowth=20
-axialNonuniformityGrade=24
-axialNonuniformity=28
-unusedErrorCorrectionGrade=32
-unusedErrorCorrection=36
-[DataMatrixSizeOptions]
-_SIZE_=12
-minSize=0
-maxSize=4
-quietZoneWidth=8
-[DataMatrixDescriptionOptions]
-_SIZE_=56
-aspectRatio=0
-rows=4
-columns=8
-rectangle=12
-ecc=16
-polarity=24
-cellFill=32
-minBorderIntegrity=40
-mirrorMode=48
-[DataMatrixSearchOptions]
-_SIZE_=56
-rotationMode=0
-skipLocation=4
-edgeThreshold=8
-demodulationMode=16
-cellSampleSize=24
-cellFilterMode=32
-skewDegreesAllowed=40
-maxIterations=44
-initialSearchVectorWidth=48
-[DataMatrixReport]
-_SIZE_=144
-found=0
-binary=4
-data=8
-dataLength=12
-boundingBox=16
-numErrorsCorrected=48
-numErasuresCorrected=52
-aspectRatio=56
-rows=60
-columns=64
-ecc=72
-polarity=80
-cellFill=88
-borderIntegrity=96
-mirrored=100
-minimumEdgeStrength=104
-demodulationMode=112
-cellSampleSize=120
-cellFilterMode=128
-iterations=136
-[JPEG2000FileAdvancedOptions]
-_SIZE_=16
-waveletMode=0
-useMultiComponentTransform=4
-maxWaveletTransformLevel=8
-quantizationStepSize=12
-[MatchGeometricPatternAdvancedOptions2]
-_SIZE_=88
-minFeaturesUsed=0
-maxFeaturesUsed=4
-subpixelIterations=8
-subpixelTolerance=16
-initialMatchListLength=24
-matchTemplateCurveScore=28
-correlationScore=32
-minMatchSeparationDistance=40
-minMatchSeparationAngle=48
-minMatchSeparationScale=56
-maxMatchOverlap=64
-coarseResult=72
-smoothContours=76
-enableCalibrationSupport=80
-[InspectionAlignment]
-_SIZE_=16
-position=0
-rotation=8
-scale=12
-[InspectionOptions]
-_SIZE_=24
-registrationMethod=0
-normalizationMethod=4
-edgeThicknessToIgnore=8
-brightThreshold=12
-darkThreshold=16
-binary=20
-[CharReport2]
-_SIZE_=56
-character=0
-corner=4
-lowThreshold=36
-highThreshold=40
-classificationScore=44
-verificationScore=48
-verified=52
-[CharInfo2]
-_SIZE_=16
-charValue=0
-charImage=4
-internalImage=8
-isReferenceChar=12
-[ReadTextReport2]
-_SIZE_=12
-readString=0
-characterReport=4
-numCharacterReports=8
-[EllipseFeature]
-_SIZE_=32
-position=0
-rotation=8
-minorRadius=16
-majorRadius=24
-[CircleFeature]
-_SIZE_=16
-position=0
-radius=8
-[ConstCurveFeature]
-_SIZE_=32
-position=0
-radius=8
-startAngle=16
-endAngle=24
-[RectangleFeature]
-_SIZE_=64
-position=0
-corner=8
-rotation=40
-width=48
-height=56
-[LegFeature]
-_SIZE_=64
-position=0
-corner=8
-rotation=40
-width=48
-height=56
-[CornerFeature]
-_SIZE_=32
-position=0
-rotation=8
-enclosedAngle=16
-isVirtual=24
-[LineFeature]
-_SIZE_=32
-startPoint=0
-endPoint=8
-length=16
-rotation=24
-[ParallelLinePairFeature]
-_SIZE_=48
-firstStartPoint=0
-firstEndPoint=8
-secondStartPoint=16
-secondEndPoint=24
-rotation=32
-distance=40
-[PairOfParallelLinePairsFeature]
-_SIZE_=112
-firstParallelLinePair=0
-secondParallelLinePair=48
-rotation=96
-distance=104
-[GeometricFeature]
-_SIZE_=4
-circle=0
-ellipse=0
-constCurve=0
-rectangle=0
-leg=0
-corner=0
-parallelLinePair=0
-pairOfParallelLinePairs=0
-line=0
-closedCurve=0
-[FeatureData]
-_SIZE_=16
-type=0
-contourPoints=4
-numContourPoints=8
-feature=12
-[GeometricPatternMatch2]
-_SIZE_=380
-position=0
-rotation=8
-scale=12
-score=16
-corner=20
-inverse=52
-occlusion=56
-templateMatchCurveScore=60
-matchTemplateCurveScore=64
-correlationScore=68
-label=72
-featureData=328
-numFeatureData=332
-calibratedPosition=336
-calibratedRotation=344
-calibratedCorner=348
-[ClosedCurveFeature]
-_SIZE_=16
-position=0
-arcLength=8
-[LineMatch]
-_SIZE_=40
-startPoint=0
-endPoint=8
-length=16
-rotation=24
-score=32
-[LineDescriptor]
-_SIZE_=16
-minLength=0
-maxLength=8
-[RectangleDescriptor]
-_SIZE_=32
-minWidth=0
-maxWidth=8
-minHeight=16
-maxHeight=24
-[RectangleMatch]
-_SIZE_=64
-corner=0
-rotation=32
-width=40
-height=48
-score=56
-[EllipseDescriptor]
-_SIZE_=32
-minMajorRadius=0
-maxMajorRadius=8
-minMinorRadius=16
-maxMinorRadius=24
-[EllipseMatch]
-_SIZE_=40
-position=0
-rotation=8
-majorRadius=16
-minorRadius=24
-score=32
-[CircleMatch]
-_SIZE_=24
-position=0
-radius=8
-score=16
-[CircleDescriptor]
-_SIZE_=16
-minRadius=0
-maxRadius=8
-[ShapeDetectionOptions]
-_SIZE_=32
-mode=0
-angleRanges=4
-numAngleRanges=8
-scaleRange=12
-minMatchScore=24
-[Curve]
-_SIZE_=48
-points=0
-numPoints=4
-closed=8
-curveLength=16
-minEdgeStrength=24
-maxEdgeStrength=32
-averageEdgeStrength=40
-[CurveOptions]
-_SIZE_=36
-extractionMode=0
-threshold=4
-filterSize=8
-minLength=12
-rowStepSize=16
-columnStepSize=20
-maxEndPointGap=24
-onlyClosed=28
-subpixelAccuracy=32
-[Barcode2DInfo]
-_SIZE_=64
-type=0
-binary=4
-data=8
-dataLength=12
-boundingBox=16
-numErrorsCorrected=48
-numErasuresCorrected=52
-rows=56
-columns=60
-[DataMatrixOptions]
-_SIZE_=20
-searchMode=0
-contrast=4
-cellShape=8
-barcodeShape=12
-subtype=16
-[ClassifierAccuracyReport]
-_SIZE_=24
-size=0
-accuracy=4
-classNames=8
-classAccuracy=12
-classPredictiveValue=16
-classificationDistribution=20
-[NearestNeighborClassResult]
-_SIZE_=12
-className=0
-standardDeviation=4
-count=8
-[NearestNeighborTrainingReport]
-_SIZE_=12
-classDistancesTable=0
-allScores=4
-allScoresSize=8
-[ParticleClassifierPreprocessingOptions]
-_SIZE_=36
-manualThreshold=0
-manualThresholdRange=4
-autoThresholdMethod=12
-limits=16
-particleType=24
-rejectBorder=28
-numErosions=32
-[ClassifierSampleInfo]
-_SIZE_=16
-className=0
-featureVector=4
-featureVectorSize=8
-thumbnail=12
-[ClassScore]
-_SIZE_=8
-className=0
-distance=4
-[ClassifierReport]
-_SIZE_=20
-bestClassName=0
-classificationScore=4
-identificationScore=8
-allScores=12
-allScoresSize=16
-[NearestNeighborOptions]
-_SIZE_=12
-method=0
-metric=4
-k=8
-[ParticleClassifierOptions]
-_SIZE_=8
-scaleDependence=0
-mirrorDependence=4
-[RGBU64Value]
-_SIZE_=8
-B=0
-G=2
-R=4
-alpha=6
-[GeometricPatternMatch]
-_SIZE_=72
-position=0
-rotation=8
-scale=12
-score=16
-corner=20
-inverse=52
-occlusion=56
-templateMatchCurveScore=60
-matchTemplateCurveScore=64
-correlationScore=68
-[MatchGeometricPatternAdvancedOptions]
-_SIZE_=80
-minFeaturesUsed=0
-maxFeaturesUsed=4
-subpixelIterations=8
-subpixelTolerance=16
-initialMatchListLength=24
-matchTemplateCurveScore=28
-correlationScore=32
-minMatchSeparationDistance=40
-minMatchSeparationAngle=48
-minMatchSeparationScale=56
-maxMatchOverlap=64
-coarseResult=72
-[MatchGeometricPatternOptions]
-_SIZE_=40
-mode=0
-subpixelAccuracy=4
-angleRanges=8
-numAngleRanges=12
-scaleRange=16
-occlusionRange=24
-numMatchesRequested=32
-minMatchScore=36
-[LearnGeometricPatternAdvancedOptions]
-_SIZE_=40
-minRectLength=0
-minRectAspectRatio=8
-minRadius=16
-minLineLength=20
-minFeatureStrength=24
-maxFeaturesUsed=32
-maxPixelDistanceFromLine=36
-[FitEllipseOptions]
-_SIZE_=32
-rejectOutliers=0
-minScore=8
-pixelRadius=16
-maxIterations=24
-[FitCircleOptions]
-_SIZE_=32
-rejectOutliers=0
-minScore=8
-pixelRadius=16
-maxIterations=24
-[ConstructROIOptions2]
-_SIZE_=24
-windowNumber=0
-windowTitle=4
-type=8
-palette=12
-numColors=16
-maxContours=20
-[HSLValue]
-_SIZE_=4
-L=0
-S=1
-H=2
-alpha=3
-[HSVValue]
-_SIZE_=4
-V=0
-S=1
-H=2
-alpha=3
-[HSIValue]
-_SIZE_=4
-I=0
-S=1
-H=2
-alpha=3
-[CIELabValue]
-_SIZE_=32
-b=0
-a=8
-L=16
-alpha=24
-[CIEXYZValue]
-_SIZE_=32
-Z=0
-Y=8
-X=16
-alpha=24
-[Color2]
-_SIZE_=32
-rgb=0
-hsl=0
-hsv=0
-hsi=0
-cieLab=0
-cieXYZ=0
-rawValue=0
-[BestEllipse2]
-_SIZE_=80
-center=0
-majorAxisStart=8
-majorAxisEnd=16
-minorAxisStart=24
-minorAxisEnd=32
-area=40
-perimeter=48
-error=56
-valid=64
-pointsUsed=68
-numPointsUsed=72
-[LearnPatternAdvancedOptions]
-_SIZE_=8
-shiftOptions=0
-rotationOptions=4
-[AVIInfo]
-_SIZE_=32
-width=0
-height=4
-imageType=8
-numFrames=12
-framesPerSecond=16
-filterName=20
-hasData=24
-maxDataSize=28
-[LearnPatternAdvancedShiftOptions]
-_SIZE_=48
-initialStepSize=0
-initialSampleSize=4
-initialSampleSizeFactor=8
-finalSampleSize=16
-finalSampleSizeFactor=24
-subpixelSampleSize=32
-subpixelSampleSizeFactor=40
-[LearnPatternAdvancedRotationOptions]
-_SIZE_=56
-searchStrategySupport=0
-initialStepSize=4
-initialSampleSize=8
-initialSampleSizeFactor=16
-initialAngularAccuracy=24
-finalSampleSize=28
-finalSampleSizeFactor=32
-finalAngularAccuracy=40
-subpixelSampleSize=44
-subpixelSampleSizeFactor=48
-[MatchPatternAdvancedOptions]
-_SIZE_=40
-subpixelIterations=0
-subpixelTolerance=8
-initialMatchListLength=16
-matchListReductionFactor=20
-initialStepSize=24
-searchStrategy=28
-intermediateAngularAccuracy=32
-[ParticleFilterCriteria2]
-_SIZE_=20
-parameter=0
-lower=4
-upper=8
-calibrated=12
-exclude=16
-[BestCircle2]
-_SIZE_=56
-center=0
-radius=8
-area=16
-perimeter=24
-error=32
-valid=40
-pointsUsed=44
-numPointsUsed=48
-[OCRSpacingOptions]
-_SIZE_=40
-minCharSpacing=0
-minCharSize=4
-maxCharSize=8
-maxHorizontalElementSpacing=12
-maxVerticalElementSpacing=16
-minBoundingRectWidth=20
-maxBoundingRectWidth=24
-minBoundingRectHeight=28
-maxBoundingRectHeight=32
-autoSplit=36
-[OCRProcessingOptions]
-_SIZE_=36
-mode=0
-lowThreshold=4
-highThreshold=8
-blockCount=12
-fastThreshold=16
-biModalCalculation=20
-darkCharacters=24
-removeParticlesTouchingROI=28
-erosionCount=32
-[ReadTextOptions]
-_SIZE_=65304
-validChars=0
-numValidChars=65280
-substitutionChar=65284
-readStrategy=65288
-acceptanceLevel=65292
-aspectRatio=65296
-readResolution=65300
-[CharInfo]
-_SIZE_=12
-charValue=0
-charImage=4
-internalImage=8
-[Rect]
-_SIZE_=16
-top=0
-left=4
-height=8
-width=12
-[CharReport]
-_SIZE_=48
-character=0
-corner=4
-reserved=36
-lowThreshold=40
-highThreshold=44
-[ReadTextReport]
-_SIZE_=12
-readString=0
-characterReport=4
-numCharacterReports=8
-[Point]
-_SIZE_=8
-x=0
-y=4
-[Annulus]
-_SIZE_=32
-center=0
-innerRadius=8
-outerRadius=12
-startAngle=16
-endAngle=24
-[EdgeLocationReport]
-_SIZE_=8
-edges=0
-numEdges=4
-[EdgeOptions]
-_SIZE_=20
-threshold=0
-width=4
-steepness=8
-subpixelType=12
-subpixelDivisions=16
-[EdgeReport]
-_SIZE_=32
-location=0
-contrast=4
-polarity=8
-reserved=16
-coordinate=20
-[ExtremeReport]
-_SIZE_=24
-location=0
-amplitude=8
-secondDerivative=16
-[FitLineOptions]
-_SIZE_=12
-minScore=0
-pixelRadius=4
-numRefinements=8
-[DisplayMapping]
-_SIZE_=16
-method=0
-minimumValue=4
-maximumValue=8
-shiftCount=12
-[DetectExtremesOptions]
-_SIZE_=16
-threshold=0
-width=8
-[ImageInfo]
-_SIZE_=52
-imageUnit=0
-stepX=4
-stepY=8
-imageType=12
-xRes=16
-yRes=20
-xOffset=24
-yOffset=28
-border=32
-pixelsPerLine=36
-reserved0=40
-reserved1=44
-imageStart=48
-[LCDOptions]
-_SIZE_=16
-litSegments=0
-threshold=4
-sign=8
-decimalPoint=12
-[LCDReport]
-_SIZE_=16
-text=0
-segmentInfo=4
-numCharacters=8
-reserved=12
-[LCDSegments]
-_SIZE_=4
-[LearnCalibrationOptions]
-_SIZE_=20
-mode=0
-method=4
-roi=8
-learnMap=12
-learnTable=16
-[LearnColorPatternOptions]
-_SIZE_=24
-learnMode=0
-featureMode=4
-threshold=8
-ignoreMode=12
-colorsToIgnore=16
-numColorsToIgnore=20
-[Line]
-_SIZE_=16
-start=0
-end=8
-[LinearAverages]
-_SIZE_=32
-columnAverages=0
-columnCount=4
-rowAverages=8
-rowCount=12
-risingDiagAverages=16
-risingDiagCount=20
-fallingDiagAverages=24
-fallingDiagCount=28
-[LineProfile]
-_SIZE_=40
-profileData=0
-boundingBox=4
-min=20
-max=24
-mean=28
-stdDev=32
-dataCount=36
-[MatchColorPatternOptions]
-_SIZE_=48
-matchMode=0
-featureMode=4
-minContrast=8
-subpixelAccuracy=12
-angleRanges=16
-numRanges=20
-colorWeight=24
-sensitivity=32
-strategy=36
-numMatchesRequested=40
-minMatchScore=44
-[HistogramReport]
-_SIZE_=36
-histogram=0
-histogramCount=4
-min=8
-max=12
-start=16
-width=20
-mean=24
-stdDev=28
-numPixels=32
-[ArcInfo]
-_SIZE_=32
-boundingBox=0
-startAngle=16
-endAngle=24
-[AxisReport]
-_SIZE_=24
-origin=0
-mainAxisEnd=8
-secondaryAxisEnd=16
-[BarcodeInfo]
-_SIZE_=32
-outputString=0
-size=4
-outputChar1=8
-outputChar2=9
-confidenceLevel=16
-type=24
-[BCGOptions]
-_SIZE_=12
-brightness=0
-contrast=4
-gamma=8
-[BestCircle]
-_SIZE_=40
-center=0
-radius=8
-area=16
-perimeter=24
-error=32
-[BestEllipse]
-_SIZE_=56
-center=0
-majorAxisStart=8
-majorAxisEnd=16
-minorAxisStart=24
-minorAxisEnd=32
-area=40
-perimeter=48
-[BestLine]
-_SIZE_=64
-start=0
-end=8
-equation=16
-valid=40
-error=48
-pointsUsed=56
-numPointsUsed=60
-[BrowserOptions]
-_SIZE_=32
-width=0
-height=4
-imagesPerLine=8
-backgroundColor=12
-frameSize=16
-style=20
-ratio=24
-focusColor=28
-[CoordinateSystem]
-_SIZE_=16
-origin=0
-angle=8
-axisOrientation=12
-[CalibrationInfo]
-_SIZE_=80
-errorMap=0
-mapColumns=4
-mapRows=8
-userRoi=12
-calibrationRoi=16
-options=20
-grid=40
-system=52
-range=68
-quality=76
-[CalibrationPoints]
-_SIZE_=12
-pixelCoordinates=0
-realWorldCoordinates=4
-numCoordinates=8
-[CaliperOptions]
-_SIZE_=12
-polarity=0
-separation=4
-separationDeviation=8
-[CaliperReport]
-_SIZE_=32
-edge1Contrast=0
-edge1Coord=4
-edge2Contrast=12
-edge2Coord=16
-separation=24
-reserved=28
-[DrawTextOptions]
-_SIZE_=60
-fontName=0
-fontSize=32
-bold=36
-italic=40
-underline=44
-strikeout=48
-textAlignment=52
-fontColor=56
-[CircleReport]
-_SIZE_=16
-center=0
-radius=8
-area=12
-[ClosedContour]
-_SIZE_=8
-points=0
-numPoints=4
-[ColorHistogramReport]
-_SIZE_=108
-plane1=0
-plane2=36
-plane3=72
-[ColorInformation]
-_SIZE_=12
-infoCount=0
-saturation=4
-info=8
-[Complex]
-_SIZE_=8
-r=0
-i=4
-[ConcentricRakeReport]
-_SIZE_=36
-rakeArcs=0
-numArcs=4
-firstEdges=8
-numFirstEdges=12
-lastEdges=16
-numLastEdges=20
-allEdges=24
-linesWithEdges=28
-numLinesWithEdges=32
-[ConstructROIOptions]
-_SIZE_=20
-windowNumber=0
-windowTitle=4
-type=8
-palette=12
-numColors=16
-[ContourInfo]
-_SIZE_=16
-type=0
-numPoints=4
-points=8
-contourColor=12
-[ContourUnion]
-_SIZE_=4
-point=0
-line=0
-rect=0
-ovalBoundingBox=0
-closedContour=0
-openContour=0
-annulus=0
-rotatedRect=0
-[ContourInfo2]
-_SIZE_=12
-type=0
-color=4
-structure=8
-[ContourPoint]
-_SIZE_=40
-x=0
-y=8
-curvature=16
-xDisplacement=24
-yDisplacement=32
-[CoordinateTransform]
-_SIZE_=24
-initialOrigin=0
-initialAngle=8
-finalOrigin=12
-finalAngle=20
-[CoordinateTransform2]
-_SIZE_=32
-referenceSystem=0
-measurementSystem=16
-[CannyOptions]
-_SIZE_=16
-sigma=0
-upperThreshold=4
-lowerThreshold=8
-windowSize=12
-[Range]
-_SIZE_=8
-minValue=0
-maxValue=4
-[UserPointSymbol]
-_SIZE_=12
-cols=0
-rows=4
-pixels=8
-[View3DOptions]
-_SIZE_=32
-sizeReduction=0
-maxHeight=4
-direction=8
-alpha=12
-beta=16
-border=20
-background=24
-plane=28
-[MatchPatternOptions]
-_SIZE_=32
-mode=0
-minContrast=4
-subpixelAccuracy=8
-angleRanges=12
-numRanges=16
-numMatchesRequested=20
-matchFactor=24
-minMatchScore=28
-[TIFFFileOptions]
-_SIZE_=12
-rowsPerStrip=0
-photoInterp=4
-compressionType=8
-[Color]
-_SIZE_=4
-rgb=0
-hsl=0
-hsv=0
-hsi=0
-rawValue=0
-[PixelValue]
-_SIZE_=8
-grayscale=0
-rgb=0
-hsl=0
-complex=0
-rgbu64=0
-[OpenContour]
-_SIZE_=8
-points=0
-numPoints=4
-[OverlayTextOptions]
-_SIZE_=48
-fontName=0
-fontSize=4
-bold=8
-italic=12
-underline=16
-strikeout=20
-horizontalTextAlignment=24
-verticalTextAlignment=28
-backgroundColor=32
-angle=40
-[ParticleFilterCriteria]
-_SIZE_=16
-parameter=0
-lower=4
-upper=8
-exclude=12
-[ParticleReport]
-_SIZE_=84
-area=0
-calibratedArea=4
-perimeter=8
-numHoles=12
-areaOfHoles=16
-perimeterOfHoles=20
-boundingBox=24
-sigmaX=40
-sigmaY=44
-sigmaXX=48
-sigmaYY=52
-sigmaXY=56
-longestLength=60
-longestPoint=64
-projectionX=72
-projectionY=76
-connect8=80
-[PatternMatch]
-_SIZE_=52
-position=0
-rotation=8
-scale=12
-score=16
-corner=20
-[QuantifyData]
-_SIZE_=28
-mean=0
-stdDev=4
-min=8
-max=12
-calibratedArea=16
-pixelArea=20
-relativeSize=24
-[QuantifyReport]
-_SIZE_=36
-global=0
-regions=28
-regionCount=32
-[RakeOptions]
-_SIZE_=24
-threshold=0
-width=4
-steepness=8
-subsamplingRatio=12
-subpixelType=16
-subpixelDivisions=20
-[RakeReport]
-_SIZE_=36
-rakeLines=0
-numRakeLines=4
-firstEdges=8
-numFirstEdges=12
-lastEdges=16
-numLastEdges=20
-allEdges=24
-linesWithEdges=28
-numLinesWithEdges=32
-[TransformReport]
-_SIZE_=12
-points=0
-validPoints=4
-numPoints=8
-[ShapeReport]
-_SIZE_=40
-coordinates=0
-centroid=16
-size=24
-score=32
-[MeterArc]
-_SIZE_=20
-needleBase=0
-arcCoordPoints=8
-numOfArcCoordPoints=12
-needleColor=16
-[ThresholdData]
-_SIZE_=16
-rangeMin=0
-rangeMax=4
-newValue=8
-useNewValue=12
-[StructuringElement]
-_SIZE_=16
-matrixCols=0
-matrixRows=4
-hexa=8
-kernel=12
-[SpokeReport]
-_SIZE_=36
-spokeLines=0
-numSpokeLines=4
-firstEdges=8
-numFirstEdges=12
-lastEdges=16
-numLastEdges=20
-allEdges=24
-linesWithEdges=28
-numLinesWithEdges=32
-[SimpleEdgeOptions]
-_SIZE_=20
-type=0
-threshold=4
-hysteresis=8
-process=12
-subpixel=16
-[SelectParticleCriteria]
-_SIZE_=12
-parameter=0
-lower=4
-upper=8
-[SegmentInfo]
-_SIZE_=24
-numberOfPoints=0
-isOpen=4
-weight=8
-points=16
-[RotationAngleRange]
-_SIZE_=8
-lower=0
-upper=4
-[RotatedRect]
-_SIZE_=24
-top=0
-left=4
-height=8
-width=12
-angle=16
-[ROIProfile]
-_SIZE_=44
-report=0
-pixels=40
-[ToolWindowOptions]
-_SIZE_=68
-showSelectionTool=0
-showZoomTool=4
-showPointTool=8
-showLineTool=12
-showRectangleTool=16
-showOvalTool=20
-showPolygonTool=24
-showClosedFreehandTool=28
-showPolyLineTool=32
-showFreehandTool=36
-showAnnulusTool=40
-showRotatedRectangleTool=44
-showPanTool=48
-showZoomOutTool=52
-reserved2=56
-reserved3=60
-reserved4=64
-[SpokeOptions]
-_SIZE_=32
-threshold=0
-width=4
-steepness=8
-subsamplingRatio=16
-subpixelType=24
-subpixelDivisions=28
diff --git a/wpilibj/wpilibJavaJNI/nivision/nivision_parse.py b/wpilibj/wpilibJavaJNI/nivision/nivision_parse.py
index 0e01bd51ae7062246381d974579f09fc069060fd..8e303b997c07b9ad1ba21b7c69532a435f9d7eb2 100644
--- a/wpilibj/wpilibJavaJNI/nivision/nivision_parse.py
+++ b/wpilibj/wpilibJavaJNI/nivision/nivision_parse.py
@@ -7,14 +7,14 @@ __all__ = ["define_after_struct", "defined", "forward_structs", "opaque_structs"
 # parser regular expressions
 number_re = re.compile(r'-?[0-9]+')
 constant_re = re.compile(r'[A-Z0-9_]+')
-define_re = re.compile(r'^#define\s+(?P<name>(IMAQ|ERR)_[A-Z0-9_]+)\s+(?P<value>.*)')
+define_re = re.compile(r'^#define\s+(?P<name>(IMAQ|ERR)[A-Z0-9_]+)\s+(?P<value>.*)')
 enum_re = re.compile(r'^typedef\s+enum\s+(?P<name>[A-Za-z0-9]+)_enum\s*{')
-enum_value_re = re.compile(r'^\s*(?P<name>[A-Z0-9_]+)\s*=\s*(?P<value>-?[0-9A-Fx]+)\s*,?')
+enum_value_re = re.compile(r'^\s*(?P<name>[A-Za-z0-9_]+)\s*(=\s*(?P<value>-?[0-9A-Fx]+))?\s*,?')
 struct_re = re.compile(r'^typedef\s+struct\s+(?P<name>[A-Za-z0-9]+)_struct\s*{')
 union_re = re.compile(r'^typedef\s+union\s+(?P<name>[A-Za-z0-9]+)_union\s*{')
-func_pointer_re = re.compile(r'(?P<restype>[A-Za-z0-9_*]+)\s*\(\s*[A-Za-z0-9_]*[*]\s*(?P<name>[A-Za-z0-9_]+)\s*\)\s*\((?P<params>[^)]*)\)')
+func_pointer_re = re.compile(r'\s*(?P<restype>[A-Za-z0-9_*]+)\s*\(\s*[A-Za-z0-9_]*\s*[*]\s*(?P<name>[A-Za-z0-9_]+)\s*\)\s*\((?P<params>[^)]*)\)')
 static_const_re = re.compile(r'^static\s+const\s+(?P<type>[A-Za-z0-9_]+)\s+(?P<name>[A-Za-z0-9_]+)\s*=\s*(?P<value>[^;]+);')
-function_re = re.compile(r'^(IMAQ_FUNC\s+)?(?P<restype>(const\s+)?[A-Za-z0-9_*]+)\s+(IMAQ_STDCALL\s+)?(?P<name>[A-Za-z0-9_]+)\s*\((?P<params>[^)]*)\);')
+function_re = re.compile(r'^((IMAQ|NI)_FUNC\s+)?(?P<restype>(const\s+)?[A-Za-z0-9_*]+)\s+((IMAQ_STDCALL|NI_FUNC[C]?)\s+)?(?P<name>[A-Za-z0-9_]+)\s*\((?P<params>[^)]*)\);')
 
 # defines deferred until after structures
 define_after_struct = []
@@ -216,5 +216,11 @@ def parse_file(emit, f, block_comment_exclude):
         if not code or code[0] == '#':
             continue
 
+        if not code or code[0] == '#':
+            continue
+
+        if code == 'extern "C" {' or code == "}":
+            continue
+
         print("%d: Unrecognized: %s" % (lineno+1, code))
 
