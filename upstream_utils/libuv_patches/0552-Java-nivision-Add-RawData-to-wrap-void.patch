From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Peter Johnson <johnson.peter@gmail.com>
Date: Thu, 11 Dec 2014 22:19:08 -0800
Subject: [PATCH 0552/6262] Java nivision: Add RawData to wrap void*.

Change-Id: I8a5dc2a208a39b3c0a26a1a9f906a5c19738628d
---
 .../src/main/java/com/ni/vision/NIVision.java | 408 +++++++++++++++++-
 wpilibj/wpilibJavaJNI/lib/NIVisionJNI.cpp     | 162 +++++++
 wpilibj/wpilibJavaJNI/nivision/gen_java.py    |  81 +++-
 .../wpilibJavaJNI/nivision/nivision_2011.ini  |  24 +-
 4 files changed, 648 insertions(+), 27 deletions(-)

diff --git a/wpilibj/wpilibJavaDevices/src/main/java/com/ni/vision/NIVision.java b/wpilibj/wpilibJavaDevices/src/main/java/com/ni/vision/NIVision.java
index bc549d0d0a7ac111e8fadea4bed740f0421196fd..652ded62ea1f23129c49ee147019f39d402dd6bb 100644
--- a/wpilibj/wpilibJavaDevices/src/main/java/com/ni/vision/NIVision.java
+++ b/wpilibj/wpilibJavaDevices/src/main/java/com/ni/vision/NIVision.java
@@ -116,11 +116,11 @@ public class NIVision {
     private static abstract class OpaqueStruct {
         private long nativeObj;
         private boolean owned;
-        private OpaqueStruct() {
-            this.nativeObj = 0;
-            this.owned = false;
+        protected OpaqueStruct() {
+            nativeObj = 0;
+            owned = false;
         }
-        private OpaqueStruct(long nativeObj, boolean owned) {
+        protected OpaqueStruct(long nativeObj, boolean owned) {
             this.nativeObj = nativeObj;
             this.owned = owned;
         }
@@ -142,6 +142,48 @@ public class NIVision {
         }
     }
 
+    public static class RawData {
+        private ByteBuffer buf;
+        private boolean owned;
+        public RawData() {
+            owned = false;
+        }
+        public RawData(ByteBuffer buf) {
+            this.buf = buf;
+            owned = false;
+        }
+        private RawData(long nativeObj, boolean owned, int size) {
+            buf = newDirectByteBuffer(nativeObj, size);
+            this.owned = owned;
+        }
+        public void free() {
+            if (owned) {
+                imaqDispose(getByteBufferAddress(buf));
+                owned = false;
+                buf = null;
+            }
+        }
+        @Override
+        protected void finalize() throws Throwable {
+            if (owned)
+                imaqDispose(getByteBufferAddress(buf));
+            super.finalize();
+        }
+        public long getAddress() {
+            if (buf == null)
+                return 0;
+            return getByteBufferAddress(buf);
+        }
+        public ByteBuffer getBuffer() {
+            return buf;
+        }
+        public void setBuffer(ByteBuffer buf) {
+            if (owned)
+                free();
+            this.buf = buf;
+        }
+    }
+
     private static long getPointer(ByteBuffer bb, int offset) {
         return (long)bb.getInt(offset);
     }
@@ -20120,6 +20162,52 @@ public class NIVision {
      * Image Information functions
      */
 
+    public static class EnumerateCustomKeysResult {
+        public String[] array;
+        private long array_addr;
+        private EnumerateCustomKeysResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_size;
+            array_size = rv_buf.getInt(0);
+            array = new String[array_size];
+            if (array_size > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_size*4);
+                for (int i=0, off=0; i<array_size; i++, off += 4) {
+                    long addr = getPointer(bb, off);
+                    if (addr == 0)
+                        array[i] = null;
+                    else {
+                        ByteBuffer bb2 = newDirectByteBuffer(addr, 1000); // FIXME
+                        while (bb2.get() != 0) {}
+                        byte[] bytes = new byte[bb2.position()-1];
+                        bb2.rewind();
+                        getBytes(bb2, bytes, 0, bytes.length);
+                        try {
+                            array[i] = new String(bytes, "UTF-8");
+                        } catch (UnsupportedEncodingException e) {
+                            array[i] = "";
+                        }
+                    }
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static EnumerateCustomKeysResult imaqEnumerateCustomKeys(Image image) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqEnumerateCustomKeys(image.getAddress(), rv_addr+0);
+        EnumerateCustomKeysResult rv = new EnumerateCustomKeysResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqEnumerateCustomKeys(long image, long size);
+
     public static int imaqGetBitDepth(Image image) {
         ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
         long rv_addr = getByteBufferAddress(rv_buf);
@@ -20210,6 +20298,29 @@ public class NIVision {
     }
     private static native int _imaqIsImageEmpty(long image, long empty);
 
+    public static RawData imaqReadCustomData(Image image, String key) {
+        ByteBuffer key_buf = null;
+        if (key != null) {
+            byte[] key_bytes;
+            try {
+                key_bytes = key.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                key_bytes = new byte[0];
+            }
+            key_buf = ByteBuffer.allocateDirect(key_bytes.length+1);
+            putBytes(key_buf, key_bytes, 0, key_bytes.length).put(key_bytes.length, (byte)0);
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqReadCustomData(image.getAddress(), key == null ? 0 : getByteBufferAddress(key_buf), rv_addr+0);
+        int size;
+        RawData val;
+        size = rv_buf.getInt(0);
+        val = new RawData(jn_rv, false, size);
+        return val;
+    }
+    private static native long _imaqReadCustomData(long image, long key, long size);
+
     public static void imaqRemoveCustomData(Image image, String key) {
         ByteBuffer key_buf = null;
         if (key != null) {
@@ -20255,6 +20366,23 @@ public class NIVision {
     }
     private static native void _imaqSetMaskOffset(long image, long offset);
 
+    public static void imaqWriteCustomData(Image image, String key, RawData data, int size) {
+        ByteBuffer key_buf = null;
+        if (key != null) {
+            byte[] key_bytes;
+            try {
+                key_bytes = key.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                key_bytes = new byte[0];
+            }
+            key_buf = ByteBuffer.allocateDirect(key_bytes.length+1);
+            putBytes(key_buf, key_bytes, 0, key_bytes.length).put(key_bytes.length, (byte)0);
+        }
+        _imaqWriteCustomData(image.getAddress(), key == null ? 0 : getByteBufferAddress(key_buf), data.getAddress(), size);
+        
+    }
+    private static native void _imaqWriteCustomData(long image, long key, long data, int size);
+
     /**
      * Display functions
      */
@@ -20346,6 +20474,18 @@ public class NIVision {
     }
     private static native void _imaqDuplicate(long dest, long source);
 
+    public static RawData imaqFlatten(Image image, FlattenType type, CompressionType compression, int quality) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqFlatten(image.getAddress(), type.getValue(), compression.getValue(), quality, rv_addr+0);
+        int size;
+        RawData val;
+        size = rv_buf.getInt(0);
+        val = new RawData(jn_rv, true, size);
+        return val;
+    }
+    private static native long _imaqFlatten(long image, int type, int compression, int quality, long size);
+
     public static void imaqFlip(Image dest, Image source, FlipAxis axis) {
         
         _imaqFlip(dest.getAddress(), source.getAddress(), axis.getValue());
@@ -20381,6 +20521,13 @@ public class NIVision {
     }
     private static native void _imaqTranspose(long dest, long source);
 
+    public static void imaqUnflatten(Image image, RawData data, int size) {
+        
+        _imaqUnflatten(image.getAddress(), data.getAddress(), size);
+        
+    }
+    private static native void _imaqUnflatten(long image, long data, int size);
+
     public static void imaqUnwrapImage(Image dest, Image source, Annulus annulus, RectOrientation orientation, InterpolationMethod method) {
         
         _imaqUnwrapImage(dest.getAddress(), source.getAddress(), annulus.getAddress(), orientation.getValue(), method.getValue());
@@ -20529,6 +20676,98 @@ public class NIVision {
     }
     private static native long _imaqGetFilterNames(long numFilters);
 
+    public static class LoadImagePopupResult {
+        public int cancelled;
+        public String[] array;
+        private long array_addr;
+        private LoadImagePopupResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            cancelled = rv_buf.getInt(0);
+            int array_numPaths;
+            array_numPaths = rv_buf.getInt(8);
+            array = new String[array_numPaths];
+            if (array_numPaths > 0 && array_addr != 0) {
+                ByteBuffer bb = newDirectByteBuffer(array_addr, array_numPaths*4);
+                for (int i=0, off=0; i<array_numPaths; i++, off += 4) {
+                    long addr = getPointer(bb, off);
+                    if (addr == 0)
+                        array[i] = null;
+                    else {
+                        ByteBuffer bb2 = newDirectByteBuffer(addr, 1000); // FIXME
+                        while (bb2.get() != 0) {}
+                        byte[] bytes = new byte[bb2.position()-1];
+                        bb2.rewind();
+                        getBytes(bb2, bytes, 0, bytes.length);
+                        try {
+                            array[i] = new String(bytes, "UTF-8");
+                        } catch (UnsupportedEncodingException e) {
+                            array[i] = "";
+                        }
+                    }
+                }
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static LoadImagePopupResult imaqLoadImagePopup(String defaultDirectory, String defaultFileSpec, String fileTypeList, String title, int allowMultiplePaths, ButtonLabel buttonLabel, int restrictDirectory, int restrictExtension, int allowCancel, int allowMakeDirectory) {
+        ByteBuffer defaultDirectory_buf = null;
+        if (defaultDirectory != null) {
+            byte[] defaultDirectory_bytes;
+            try {
+                defaultDirectory_bytes = defaultDirectory.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                defaultDirectory_bytes = new byte[0];
+            }
+            defaultDirectory_buf = ByteBuffer.allocateDirect(defaultDirectory_bytes.length+1);
+            putBytes(defaultDirectory_buf, defaultDirectory_bytes, 0, defaultDirectory_bytes.length).put(defaultDirectory_bytes.length, (byte)0);
+        }
+        ByteBuffer defaultFileSpec_buf = null;
+        if (defaultFileSpec != null) {
+            byte[] defaultFileSpec_bytes;
+            try {
+                defaultFileSpec_bytes = defaultFileSpec.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                defaultFileSpec_bytes = new byte[0];
+            }
+            defaultFileSpec_buf = ByteBuffer.allocateDirect(defaultFileSpec_bytes.length+1);
+            putBytes(defaultFileSpec_buf, defaultFileSpec_bytes, 0, defaultFileSpec_bytes.length).put(defaultFileSpec_bytes.length, (byte)0);
+        }
+        ByteBuffer fileTypeList_buf = null;
+        if (fileTypeList != null) {
+            byte[] fileTypeList_bytes;
+            try {
+                fileTypeList_bytes = fileTypeList.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileTypeList_bytes = new byte[0];
+            }
+            fileTypeList_buf = ByteBuffer.allocateDirect(fileTypeList_bytes.length+1);
+            putBytes(fileTypeList_buf, fileTypeList_bytes, 0, fileTypeList_bytes.length).put(fileTypeList_bytes.length, (byte)0);
+        }
+        ByteBuffer title_buf = null;
+        if (title != null) {
+            byte[] title_bytes;
+            try {
+                title_bytes = title.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                title_bytes = new byte[0];
+            }
+            title_buf = ByteBuffer.allocateDirect(title_bytes.length+1);
+            putBytes(title_buf, title_bytes, 0, title_bytes.length).put(title_bytes.length, (byte)0);
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(24);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqLoadImagePopup(defaultDirectory == null ? 0 : getByteBufferAddress(defaultDirectory_buf), defaultFileSpec == null ? 0 : getByteBufferAddress(defaultFileSpec_buf), fileTypeList == null ? 0 : getByteBufferAddress(fileTypeList_buf), title == null ? 0 : getByteBufferAddress(title_buf), allowMultiplePaths, buttonLabel.getValue(), restrictDirectory, restrictExtension, allowCancel, allowMakeDirectory, rv_addr+0, rv_addr+8);
+        LoadImagePopupResult rv = new LoadImagePopupResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqLoadImagePopup(long defaultDirectory, long defaultFileSpec, long fileTypeList, long title, int allowMultiplePaths, int buttonLabel, int restrictDirectory, int restrictExtension, int allowCancel, int allowMakeDirectory, long cancelled, long numPaths);
+
     public static int imaqOpenAVI(String fileName) {
         ByteBuffer fileName_buf = null;
         if (fileName != null) {
@@ -20607,6 +20846,13 @@ public class NIVision {
     }
     private static native void _imaqReadVisionFile(long image, long fileName, long colorTable, long numColors);
 
+    public static void imaqWriteAVIFrame(Image image, int session, RawData data, int dataLength) {
+        
+        _imaqWriteAVIFrame(image.getAddress(), session, data.getAddress(), dataLength);
+        
+    }
+    private static native void _imaqWriteAVIFrame(long image, int session, long data, int dataLength);
+
     public static void imaqWriteBMPFile(Image image, String fileName, int compress, RGBValue colorTable) {
         ByteBuffer fileName_buf = null;
         if (fileName != null) {
@@ -20641,6 +20887,23 @@ public class NIVision {
     }
     private static native void _imaqWriteFile(long image, long fileName, long colorTable);
 
+    public static void imaqWriteJPEGFile(Image image, String fileName, int quality, RawData colorTable) {
+        ByteBuffer fileName_buf = null;
+        if (fileName != null) {
+            byte[] fileName_bytes;
+            try {
+                fileName_bytes = fileName.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                fileName_bytes = new byte[0];
+            }
+            fileName_buf = ByteBuffer.allocateDirect(fileName_bytes.length+1);
+            putBytes(fileName_buf, fileName_bytes, 0, fileName_bytes.length).put(fileName_bytes.length, (byte)0);
+        }
+        _imaqWriteJPEGFile(image.getAddress(), fileName == null ? 0 : getByteBufferAddress(fileName_buf), quality, colorTable == null ? 0 : colorTable.getAddress());
+        
+    }
+    private static native void _imaqWriteJPEGFile(long image, long fileName, int quality, long colorTable);
+
     public static void imaqWriteJPEG2000File(Image image, String fileName, int lossless, float compressionRatio, JPEG2000FileAdvancedOptions advancedOptions, RGBValue colorTable) {
         ByteBuffer fileName_buf = null;
         if (fileName != null) {
@@ -20935,6 +21198,42 @@ public class NIVision {
     }
     private static native float _imaqGetPolygonArea(long points, int numPoints, long area);
 
+    public static class InterpolatePointsResult {
+        public float[] array;
+        private long array_addr;
+        private InterpolatePointsResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_interpCount;
+            array_interpCount = rv_buf.getInt(0);
+            array = new float[array_interpCount];
+            if (array_interpCount > 0 && array_addr != 0) {
+                newDirectByteBuffer(array_addr, array_interpCount*4).asFloatBuffer().get(array);
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static InterpolatePointsResult imaqInterpolatePoints(Image image, Point[] points, InterpolationMethod method, int subpixel) {
+        int numPoints = points.length;
+        ByteBuffer points_buf = null;
+        points_buf = ByteBuffer.allocateDirect(points.length*8);
+        for (int i=0, off=0; i<points.length; i++, off += 8) {
+            points[i].setBuffer(points_buf, off);
+            points[i].write();
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqInterpolatePoints(image.getAddress(), getByteBufferAddress(points_buf), numPoints, method.getValue(), subpixel, rv_addr+0);
+        InterpolatePointsResult rv = new InterpolatePointsResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqInterpolatePoints(long image, long points, int numPoints, int method, int subpixel, long interpCount);
+
     /**
      * Clipboard functions
      */
@@ -20989,6 +21288,13 @@ public class NIVision {
      * Image Management functions
      */
 
+    public static void imaqArrayToImage(Image image, RawData array, int numCols, int numRows) {
+        
+        _imaqArrayToImage(image.getAddress(), array.getAddress(), numCols, numRows);
+        
+    }
+    private static native void _imaqArrayToImage(long image, long array, int numCols, int numRows);
+
     public static Image imaqCreateImage(ImageType type, int borderSize) {
         
         long jn_rv = _imaqCreateImage(type.getValue(), borderSize);
@@ -21708,6 +22014,35 @@ public class NIVision {
     }
     private static native long _imaqLearnColor(long image, long roi, int sensitivity, int saturation);
 
+    public static class MatchColorResult {
+        public int[] array;
+        private long array_addr;
+        private MatchColorResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numScores;
+            array_numScores = rv_buf.getInt(0);
+            array = new int[array_numScores];
+            if (array_numScores > 0 && array_addr != 0) {
+                newDirectByteBuffer(array_addr, array_numScores*4).asIntBuffer().get(array);
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static MatchColorResult imaqMatchColor(Image image, ColorInformation info, ROI roi) {
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqMatchColor(image.getAddress(), info.getAddress(), roi == null ? 0 : roi.getAddress(), rv_addr+0);
+        MatchColorResult rv = new MatchColorResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqMatchColor(long image, long info, long roi, long numScores);
+
     /**
      * Frequency Domain Analysis functions
      */
@@ -22914,6 +23249,23 @@ public class NIVision {
     }
     private static native void _imaqOverlayLine(long image, long start, long end, long color, long group);
 
+    public static void imaqOverlayMetafile(Image image, RawData metafile, Rect rect, String group) {
+        ByteBuffer group_buf = null;
+        if (group != null) {
+            byte[] group_bytes;
+            try {
+                group_bytes = group.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                group_bytes = new byte[0];
+            }
+            group_buf = ByteBuffer.allocateDirect(group_bytes.length+1);
+            putBytes(group_buf, group_bytes, 0, group_bytes.length).put(group_bytes.length, (byte)0);
+        }
+        _imaqOverlayMetafile(image.getAddress(), metafile.getAddress(), rect.getAddress(), group == null ? 0 : getByteBufferAddress(group_buf));
+        
+    }
+    private static native void _imaqOverlayMetafile(long image, long metafile, long rect, long group);
+
     public static void imaqOverlayOpenContour(Image image, Point[] points, RGBValue color, String group) {
         int numPoints = points.length;
         ByteBuffer points_buf = null;
@@ -23192,6 +23544,46 @@ public class NIVision {
     }
     private static native void _imaqTrainChars(long image, long set, int index, long charValue, long roi, long processingOptions, long spacingOptions);
 
+    public static class VerifyTextResult {
+        public int[] array;
+        private long array_addr;
+        private VerifyTextResult(ByteBuffer rv_buf, long jn_rv) {
+            array_addr = jn_rv;
+            int array_numScores;
+            array_numScores = rv_buf.getInt(0);
+            array = new int[array_numScores];
+            if (array_numScores > 0 && array_addr != 0) {
+                newDirectByteBuffer(array_addr, array_numScores*4).asIntBuffer().get(array);
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            imaqDispose(array_addr);
+            super.finalize();
+        }
+    }
+
+    public static VerifyTextResult imaqVerifyText(Image image, CharSet set, String expectedString, ROI roi) {
+        ByteBuffer expectedString_buf = null;
+        if (expectedString != null) {
+            byte[] expectedString_bytes;
+            try {
+                expectedString_bytes = expectedString.getBytes("UTF-8");
+            } catch (UnsupportedEncodingException e) {
+                expectedString_bytes = new byte[0];
+            }
+            expectedString_buf = ByteBuffer.allocateDirect(expectedString_bytes.length+1);
+            putBytes(expectedString_buf, expectedString_bytes, 0, expectedString_bytes.length).put(expectedString_bytes.length, (byte)0);
+        }
+        ByteBuffer rv_buf = ByteBuffer.allocateDirect(16);
+        long rv_addr = getByteBufferAddress(rv_buf);
+        long jn_rv = _imaqVerifyText(image.getAddress(), set.getAddress(), expectedString == null ? 0 : getByteBufferAddress(expectedString_buf), roi.getAddress(), rv_addr+0);
+        VerifyTextResult rv = new VerifyTextResult(rv_buf, jn_rv);
+        return rv;
+    }
+    private static native long _imaqVerifyText(long image, long set, long expectedString, long roi, long numScores);
+
     public static void imaqWriteOCRFile(String fileName, CharSet set, String setDescription, ReadTextOptions readOptions, OCRProcessingOptions processingOptions, OCRSpacingOptions spacingOptions) {
         ByteBuffer fileName_buf = null;
         if (fileName != null) {
@@ -24185,6 +24577,14 @@ public class NIVision {
     }
     private static native long _imaqCreateOverlayFromROI(long roi);
 
+    public static Overlay imaqCreateOverlayFromMetafile(RawData metafile) {
+        
+        long jn_rv = _imaqCreateOverlayFromMetafile(metafile.getAddress());
+        
+        return new Overlay(jn_rv, true);
+    }
+    private static native long _imaqCreateOverlayFromMetafile(long metafile);
+
     public static void imaqSetCalibrationInfo(Image image, CalibrationUnit unit, float xDistance, float yDistance) {
         
         _imaqSetCalibrationInfo(image.getAddress(), unit.getValue(), xDistance, yDistance);
diff --git a/wpilibj/wpilibJavaJNI/lib/NIVisionJNI.cpp b/wpilibj/wpilibJavaJNI/lib/NIVisionJNI.cpp
index 55846f9e2811c5b23d966775cbd9ca3408350973..2a984ab4ad3a25e1dd58b4969628ff27bed823e9 100644
--- a/wpilibj/wpilibJavaJNI/lib/NIVisionJNI.cpp
+++ b/wpilibj/wpilibJavaJNI/lib/NIVisionJNI.cpp
@@ -890,6 +890,18 @@ JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqInterlaceSeparate(JNIEn
  * Image Information functions
  */
 
+/* J: EnumerateCustomKeysResult imaqEnumerateCustomKeys(Image image)
+ * JN: long imaqEnumerateCustomKeys(long image, long size)
+ * C: char** imaqEnumerateCustomKeys(const Image* image, unsigned int* size)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqEnumerateCustomKeys(JNIEnv* env, jclass , jlong image, jlong size)
+{
+    char** rv = imaqEnumerateCustomKeys((const Image*)image, (unsigned int*)size);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
 /* J: int imaqGetBitDepth(Image image)
  * JN: int imaqGetBitDepth(long image, long bitDepth)
  * C: int imaqGetBitDepth(const Image* image, unsigned int* bitDepth)
@@ -985,6 +997,18 @@ JNIEXPORT jint JNICALL Java_com_ni_vision_NIVision__1imaqIsImageEmpty(JNIEnv* en
     return (jint)rv;
 }
 
+/* J: RawData imaqReadCustomData(Image image, String key)
+ * JN: long imaqReadCustomData(long image, long key, long size)
+ * C: void* imaqReadCustomData(const Image* image, const char* key, unsigned int* size)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqReadCustomData(JNIEnv* env, jclass , jlong image, jlong key, jlong size)
+{
+    void* rv = imaqReadCustomData((const Image*)image, (const char*)key, (unsigned int*)size);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
 /* J: void imaqRemoveCustomData(Image image, String key)
  * JN: void imaqRemoveCustomData(long image, long key)
  * C: int imaqRemoveCustomData(Image* image, const char* key)
@@ -1040,6 +1064,17 @@ JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetMaskOffset(JNIEnv* e
     if (rv == 0) throwJavaException(env);
 }
 
+/* J: void imaqWriteCustomData(Image image, String key, RawData data, int size)
+ * JN: void imaqWriteCustomData(long image, long key, long data, int size)
+ * C: int imaqWriteCustomData(Image* image, const char* key, const void* data, unsigned int size)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteCustomData(JNIEnv* env, jclass , jlong image, jlong key, jlong data, jint size)
+{
+    int rv = imaqWriteCustomData((Image*)image, (const char*)key, (const void*)data, (unsigned int)size);
+    if (rv == 0) throwJavaException(env);
+}
+
 /*
  * Display functions
  */
@@ -1149,6 +1184,18 @@ JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqDuplicate(JNIEnv* env,
     if (rv == 0) throwJavaException(env);
 }
 
+/* J: RawData imaqFlatten(Image image, FlattenType type, CompressionType compression, int quality)
+ * JN: long imaqFlatten(long image, int type, int compression, int quality, long size)
+ * C: void* imaqFlatten(const Image* image, FlattenType type, CompressionType compression, int quality, unsigned int* size)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqFlatten(JNIEnv* env, jclass , jlong image, jint type, jint compression, jint quality, jlong size)
+{
+    void* rv = imaqFlatten((const Image*)image, (FlattenType)type, (CompressionType)compression, (int)quality, (unsigned int*)size);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
 /* J: void imaqFlip(Image dest, Image source, FlipAxis axis)
  * JN: void imaqFlip(long dest, long source, int axis)
  * C: int imaqFlip(Image* dest, const Image* source, FlipAxis axis)
@@ -1204,6 +1251,17 @@ JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqTranspose(JNIEnv* env,
     if (rv == 0) throwJavaException(env);
 }
 
+/* J: void imaqUnflatten(Image image, RawData data, int size)
+ * JN: void imaqUnflatten(long image, long data, int size)
+ * C: int imaqUnflatten(Image* image, const void* data, unsigned int size)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqUnflatten(JNIEnv* env, jclass , jlong image, jlong data, jint size)
+{
+    int rv = imaqUnflatten((Image*)image, (const void*)data, (unsigned int)size);
+    if (rv == 0) throwJavaException(env);
+}
+
 /* J: void imaqUnwrapImage(Image dest, Image source, Annulus annulus, RectOrientation orientation, InterpolationMethod method)
  * JN: void imaqUnwrapImage(long dest, long source, long annulus, int orientation, int method)
  * C: int imaqUnwrapImage(Image* dest, const Image* source, Annulus annulus, RectOrientation orientation, InterpolationMethod method)
@@ -1288,6 +1346,18 @@ JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqGetFilterNames(JNIEnv*
     return (jlong)rv;
 }
 
+/* J: LoadImagePopupResult imaqLoadImagePopup(String defaultDirectory, String defaultFileSpec, String fileTypeList, String title, int allowMultiplePaths, ButtonLabel buttonLabel, int restrictDirectory, int restrictExtension, int allowCancel, int allowMakeDirectory)
+ * JN: long imaqLoadImagePopup(long defaultDirectory, long defaultFileSpec, long fileTypeList, long title, int allowMultiplePaths, int buttonLabel, int restrictDirectory, int restrictExtension, int allowCancel, int allowMakeDirectory, long cancelled, long numPaths)
+ * C: char** imaqLoadImagePopup(const char* defaultDirectory, const char* defaultFileSpec, const char* fileTypeList, const char* title, int allowMultiplePaths, ButtonLabel buttonLabel, int restrictDirectory, int restrictExtension, int allowCancel, int allowMakeDirectory, int* cancelled, int* numPaths)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqLoadImagePopup(JNIEnv* env, jclass , jlong defaultDirectory, jlong defaultFileSpec, jlong fileTypeList, jlong title, jint allowMultiplePaths, jint buttonLabel, jint restrictDirectory, jint restrictExtension, jint allowCancel, jint allowMakeDirectory, jlong cancelled, jlong numPaths)
+{
+    char** rv = imaqLoadImagePopup((const char*)defaultDirectory, (const char*)defaultFileSpec, (const char*)fileTypeList, (const char*)title, (int)allowMultiplePaths, (ButtonLabel)buttonLabel, (int)restrictDirectory, (int)restrictExtension, (int)allowCancel, (int)allowMakeDirectory, (int*)cancelled, (int*)numPaths);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
 /* J: int imaqOpenAVI(String fileName)
  * JN: int imaqOpenAVI(long fileName)
  * C: AVISession imaqOpenAVI(const char* fileName)
@@ -1322,6 +1392,17 @@ JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqReadVisionFile(JNIEnv*
     if (rv == 0) throwJavaException(env);
 }
 
+/* J: void imaqWriteAVIFrame(Image image, int session, RawData data, int dataLength)
+ * JN: void imaqWriteAVIFrame(long image, int session, long data, int dataLength)
+ * C: int imaqWriteAVIFrame(Image* image, AVISession session, const void* data, unsigned int dataLength)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteAVIFrame(JNIEnv* env, jclass , jlong image, jint session, jlong data, jint dataLength)
+{
+    int rv = imaqWriteAVIFrame((Image*)image, (AVISession)session, (const void*)data, (unsigned int)dataLength);
+    if (rv == 0) throwJavaException(env);
+}
+
 /* J: void imaqWriteBMPFile(Image image, String fileName, int compress, RGBValue colorTable)
  * JN: void imaqWriteBMPFile(long image, long fileName, int compress, long colorTable)
  * C: int imaqWriteBMPFile(const Image* image, const char* fileName, int compress, const RGBValue* colorTable)
@@ -1344,6 +1425,17 @@ JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteFile(JNIEnv* env,
     if (rv == 0) throwJavaException(env);
 }
 
+/* J: void imaqWriteJPEGFile(Image image, String fileName, int quality, RawData colorTable)
+ * JN: void imaqWriteJPEGFile(long image, long fileName, int quality, long colorTable)
+ * C: int imaqWriteJPEGFile(const Image* image, const char* fileName, unsigned int quality, void* colorTable)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqWriteJPEGFile(JNIEnv* env, jclass , jlong image, jlong fileName, jint quality, jlong colorTable)
+{
+    int rv = imaqWriteJPEGFile((const Image*)image, (const char*)fileName, (unsigned int)quality, (void*)colorTable);
+    if (rv == 0) throwJavaException(env);
+}
+
 /* J: void imaqWriteJPEG2000File(Image image, String fileName, int lossless, float compressionRatio, JPEG2000FileAdvancedOptions advancedOptions, RGBValue colorTable)
  * JN: void imaqWriteJPEG2000File(long image, long fileName, int lossless, float compressionRatio, long advancedOptions, long colorTable)
  * C: int imaqWriteJPEG2000File(const Image* image, const char* fileName, int lossless, float compressionRatio, const JPEG2000FileAdvancedOptions* advancedOptions, const RGBValue* colorTable)
@@ -1545,6 +1637,18 @@ JNIEXPORT jfloat JNICALL Java_com_ni_vision_NIVision__1imaqGetPolygonArea(JNIEnv
     return (jfloat)rv;
 }
 
+/* J: InterpolatePointsResult imaqInterpolatePoints(Image image, Point[] points, InterpolationMethod method, int subpixel)
+ * JN: long imaqInterpolatePoints(long image, long points, int numPoints, int method, int subpixel, long interpCount)
+ * C: float* imaqInterpolatePoints(const Image* image, const Point* points, int numPoints, InterpolationMethod method, int subpixel, int* interpCount)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqInterpolatePoints(JNIEnv* env, jclass , jlong image, jlong points, jint numPoints, jint method, jint subpixel, jlong interpCount)
+{
+    float* rv = imaqInterpolatePoints((const Image*)image, (const Point*)points, (int)numPoints, (InterpolationMethod)method, (int)subpixel, (int*)interpCount);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
 /*
  * Clipboard functions
  */
@@ -1614,6 +1718,17 @@ JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqSetBorderSize(JNIEnv* e
  * Image Management functions
  */
 
+/* J: void imaqArrayToImage(Image image, RawData array, int numCols, int numRows)
+ * JN: void imaqArrayToImage(long image, long array, int numCols, int numRows)
+ * C: int imaqArrayToImage(Image* image, const void* array, int numCols, int numRows)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqArrayToImage(JNIEnv* env, jclass , jlong image, jlong array, jint numCols, jint numRows)
+{
+    int rv = imaqArrayToImage((Image*)image, (const void*)array, (int)numCols, (int)numRows);
+    if (rv == 0) throwJavaException(env);
+}
+
 /* J: Image imaqCreateImage(ImageType type, int borderSize)
  * JN: long imaqCreateImage(int type, int borderSize)
  * C: Image* imaqCreateImage(ImageType type, int borderSize)
@@ -2469,6 +2584,18 @@ JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqLearnColor(JNIEnv* env
     return (jlong)rv;
 }
 
+/* J: MatchColorResult imaqMatchColor(Image image, ColorInformation info, ROI roi)
+ * JN: long imaqMatchColor(long image, long info, long roi, long numScores)
+ * C: int* imaqMatchColor(const Image* image, const ColorInformation* info, const ROI* roi, int* numScores)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqMatchColor(JNIEnv* env, jclass , jlong image, jlong info, jlong roi, jlong numScores)
+{
+    int* rv = imaqMatchColor((const Image*)image, (const ColorInformation*)info, (const ROI*)roi, (int*)numScores);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
 /*
  * Frequency Domain Analysis functions
  */
@@ -3384,6 +3511,17 @@ JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayLine(JNIEnv* env
     if (rv == 0) throwJavaException(env);
 }
 
+/* J: void imaqOverlayMetafile(Image image, RawData metafile, Rect rect, String group)
+ * JN: void imaqOverlayMetafile(long image, long metafile, long rect, long group)
+ * C: int imaqOverlayMetafile(Image* image, const void* metafile, Rect rect, const char* group)
+ */
+
+JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqOverlayMetafile(JNIEnv* env, jclass , jlong image, jlong metafile, jlong rect, jlong group)
+{
+    int rv = imaqOverlayMetafile((Image*)image, (const void*)metafile, *((Rect*)rect), (const char*)group);
+    if (rv == 0) throwJavaException(env);
+}
+
 /* J: void imaqOverlayOpenContour(Image image, Point[] points, RGBValue color, String group)
  * JN: void imaqOverlayOpenContour(long image, long points, int numPoints, long color, long group)
  * C: int imaqOverlayOpenContour(Image* image, const Point* points, int numPoints, const RGBValue* color, const char* group)
@@ -3569,6 +3707,18 @@ JNIEXPORT void JNICALL Java_com_ni_vision_NIVision__1imaqTrainChars(JNIEnv* env,
     if (rv == 0) throwJavaException(env);
 }
 
+/* J: VerifyTextResult imaqVerifyText(Image image, CharSet set, String expectedString, ROI roi)
+ * JN: long imaqVerifyText(long image, long set, long expectedString, long roi, long numScores)
+ * C: int* imaqVerifyText(const Image* image, const CharSet* set, const char* expectedString, const ROI* roi, int* numScores)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqVerifyText(JNIEnv* env, jclass , jlong image, jlong set, jlong expectedString, jlong roi, jlong numScores)
+{
+    int* rv = imaqVerifyText((const Image*)image, (const CharSet*)set, (const char*)expectedString, (const ROI*)roi, (int*)numScores);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
 /* J: void imaqWriteOCRFile(String fileName, CharSet set, String setDescription, ReadTextOptions readOptions, OCRProcessingOptions processingOptions, OCRSpacingOptions spacingOptions)
  * JN: void imaqWriteOCRFile(long fileName, long set, long setDescription, long readOptions, long processingOptions, long spacingOptions)
  * C: int imaqWriteOCRFile(const char* fileName, const CharSet* set, const char* setDescription, const ReadTextOptions* readOptions, const OCRProcessingOptions* processingOptions, const OCRSpacingOptions* spacingOptions)
@@ -4388,6 +4538,18 @@ JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCreateOverlayFromROI(J
     return (jlong)rv;
 }
 
+/* J: Overlay imaqCreateOverlayFromMetafile(RawData metafile)
+ * JN: long imaqCreateOverlayFromMetafile(long metafile)
+ * C: Overlay* imaqCreateOverlayFromMetafile(const void* metafile)
+ */
+
+JNIEXPORT jlong JNICALL Java_com_ni_vision_NIVision__1imaqCreateOverlayFromMetafile(JNIEnv* env, jclass , jlong metafile)
+{
+    Overlay* rv = imaqCreateOverlayFromMetafile((const void*)metafile);
+    if (!rv) throwJavaException(env);
+    return (jlong)rv;
+}
+
 /* J: void imaqSetCalibrationInfo(Image image, CalibrationUnit unit, float xDistance, float yDistance)
  * JN: void imaqSetCalibrationInfo(long image, int unit, float xDistance, float yDistance)
  * C: int imaqSetCalibrationInfo(Image* image, CalibrationUnit unit, float xDistance, float yDistance)
diff --git a/wpilibj/wpilibJavaJNI/nivision/gen_java.py b/wpilibj/wpilibJavaJNI/nivision/gen_java.py
index 465413f1755a8d227295c2a2354e8941d8bec05b..117e64cd92e55782c13fced45c63743d2593edef 100644
--- a/wpilibj/wpilibJavaJNI/nivision/gen_java.py
+++ b/wpilibj/wpilibJavaJNI/nivision/gen_java.py
@@ -78,7 +78,7 @@ java_types_map = {
         ("long double", None): JavaType("double", "double", "jdouble", "D"),
         ("unsigned char*", None): JavaType("String", "String", "jstring", "Ljava/lang/String;"),
         ("char*", None): JavaType("String", "String", "jstring", "Ljava/lang/String;"),
-        #("void*", None): JavaType("c_void_p", "long", "jlong", "J"),
+        ("void*", None): JavaType("RawData", "long", "jlong", "J", is_opaque=True),
         #("size_t", None): JavaType("long", "long", "jlong", "J"),
         ("String255", None): JavaType("String", "String", "jstring", "Ljava/lang/String;", string_array=True, array_size="256"),
         ("String255", ""): JavaType("String[]", "String[]", "jstringArray", "[Ljava/lang/String;", string_array=True, array_size="256"),
@@ -981,11 +981,11 @@ public class {classname} {{
     private static abstract class OpaqueStruct {{
         private long nativeObj;
         private boolean owned;
-        private OpaqueStruct() {{
-            this.nativeObj = 0;
-            this.owned = false;
+        protected OpaqueStruct() {{
+            nativeObj = 0;
+            owned = false;
         }}
-        private OpaqueStruct(long nativeObj, boolean owned) {{
+        protected OpaqueStruct(long nativeObj, boolean owned) {{
             this.nativeObj = nativeObj;
             this.owned = owned;
         }}
@@ -1005,11 +1005,52 @@ public class {classname} {{
         public long getAddress() {{
             return nativeObj;
         }}
+    }}
+
+    public static class RawData {{
+        private ByteBuffer buf;
+        private boolean owned;
+        public RawData() {{
+            owned = false;
+        }}
+        public RawData(ByteBuffer buf) {{
+            this.buf = buf;
+            owned = false;
+        }}
+        private RawData(long nativeObj, boolean owned, int size) {{
+            buf = newDirectByteBuffer(nativeObj, size);
+            this.owned = owned;
+        }}
+        public void free() {{
+            if (owned) {{
+                imaqDispose(getByteBufferAddress(buf));
+                owned = false;
+                buf = null;
+            }}
+        }}
+        @Override
+        protected void finalize() throws Throwable {{
+            if (owned)
+                imaqDispose(getByteBufferAddress(buf));
+            super.finalize();
+        }}
+        public long getAddress() {{
+            if (buf == null)
+                return 0;
+            return getByteBufferAddress(buf);
+        }}
+        public ByteBuffer getBuffer() {{
+            return buf;
+        }}
+        public void setBuffer(ByteBuffer buf) {{
+            if (owned)
+                free();
+            this.buf = buf;
+        }}
     }}""".format(package=self.package, classname=self.classname), file=self.out)
 
         if int(self.config_struct.get("_platform_", "pointer")) == 4:
             # 32-bit addressing
-            java_types_map[("void*", None)] = JavaType("c_void_p", "int", "jint", "I")
             java_types_map[("size_t", None)] = JavaType("int", "int", "jint", "I")
             print("""
     private static long getPointer(ByteBuffer bb, int offset) {
@@ -1038,7 +1079,6 @@ public class {classname} {{
     }""", file=self.out)
         else:
             # 64-bit addressing
-            java_types_map[("void*", None)] = JavaType("c_void_p", "long", "jlong", "J")
             java_types_map[("size_t", None)] = JavaType("long", "long", "jlong", "J")
             print("""
     private static long getPointer(ByteBuffer bb, int offset) {
@@ -1346,6 +1386,12 @@ JNIEXPORT void JNICALL Java_{package}_{classname}__1imaqDispose(JNIEnv* , jclass
             if retarraysize not in outparams:
                 outparams.append(retarraysize)
 
+        retsize = self.config_get(name, "retsize", "").strip()
+        if retsize:
+            size_params.add(retsize)
+            if retsize not in outparams:
+                outparams.append(retsize)
+
         retowned = not self.config_getboolean(name, "retunowned", False)
 
         # Input and output parameter code is generated with the help of
@@ -1385,9 +1431,6 @@ JNIEXPORT void JNICALL Java_{package}_{classname}__1imaqDispose(JNIEnv* , jclass
             is_pointer = field["is_pointer"]
             to_arg = field["to_arg"]
 
-            if jtype.j_type == "c_void_p":
-                raise NotImplementedError("void pointer not implemented")
-
             # input parameter generation
             if fname not in size_params:
                 j_funcargs.append((fname, jtype))
@@ -1434,14 +1477,11 @@ JNIEXPORT void JNICALL Java_{package}_{classname}__1imaqDispose(JNIEnv* , jclass
             else:
                 raise ValueError("unrecognized jni signature '%s'" % jtype.jni_sig)
 
-        if rettype.j_type == "c_void_p":
-            raise NotImplementedError("%s: void pointer not implemented")
-
         jrettype = rettype.j_type
 
         outstruct_name = None
-        #print(name, outparams, retarraysize)
-        if outparams or retarraysize:
+        #print(name, jrettype, outparams, retarraysize, retsize)
+        if outparams or retarraysize or retsize:
             # create a return buffer (TODO: optimize size)
             jinit.append("ByteBuffer rv_buf = ByteBuffer.allocateDirect(%d);" % ((len(outparams)+1)*8))
             jinit.append("long rv_addr = getByteBufferAddress(rv_buf);")
@@ -1473,8 +1513,6 @@ JNIEXPORT void JNICALL Java_{package}_{classname}__1imaqDispose(JNIEnv* , jclass
             off = 0
             for fname, ftype, arr, comment in helper.fields:
                 field = helper.get_field_java_code(fname, ftype, arr, off, jfielddefs_private, backing="rv_buf")
-                if field["type"].j_type == "c_void_p":
-                    raise NotImplementedError("void pointer not implemented")
                 if fname == retarraysize:
                     jconstruct.append(field["fielddef"].replace("public ", "").replace(fname, "array_%s" % fname))
                     jconstruct.extend(x.replace(fname, "array_%s" % fname) for x in field["backing_read"])
@@ -1503,10 +1541,17 @@ JNIEXPORT void JNICALL Java_{package}_{classname}__1imaqDispose(JNIEnv* , jclass
                 jretc = "return %s;" % outparams[0]
                 jrettype = paramtypes[outparams[0]][2].j_type
                 rettype = paramtypes[outparams[0]][2]
+            elif len(outparams) == 1 and retsize:
+                jfini.extend(x.replace("public ", "") for x in jfielddefs)
+                jfini.extend(jconstruct)
+                jfini.append("val = new {type}(jn_rv, {owned}, {size});".format(type=rettype.j_type, owned="true" if retowned else "false", size=retsize))
+                jretc = "return val;"
             else:
                 defined.add(outstruct_name)
                 jfini.append("{struct_name} rv = new {struct_name}({args});".format(struct_name=outstruct_name, args=", ".join(x[0] for x in jconstruct_args)))
-                if not retarraysize and functype != "STDFUNC":
+                if retsize:
+                    jfini.append("rv.val = new {type}(jn_rv, {owned}, rv.{size});".format(type=rettype.j_type, owned="true" if retowned else "false", size=retsize))
+                elif not retarraysize and functype != "STDFUNC":
                     jfini.append("rv.val = new {type}(jn_rv, {owned});".format(type=rettype.j_type, owned="true" if retowned else "false"))
 
                 jrettype = outstruct_name
diff --git a/wpilibj/wpilibJavaJNI/nivision/nivision_2011.ini b/wpilibj/wpilibJavaJNI/nivision/nivision_2011.ini
index bf0f51fb2d6453985e17bf504da5c72db7bdd3a3..848cd21007e7ea269642cc4279432219e8cad378 100644
--- a/wpilibj/wpilibJavaJNI/nivision/nivision_2011.ini
+++ b/wpilibj/wpilibJavaJNI/nivision/nivision_2011.ini
@@ -347,12 +347,18 @@ retarraysize=size
 nullok=width,height
 [imaqGetPixelAddress]
 underscored=True
+exclude=True
 [imaqReadCustomData]
-underscored=True
+retsize=size
+retunowned=True
+[imaqWriteCustomData]
+size=data:size
 
 ; Display functions
 [imaqGetLastKey]
 nullok=keyPressed,windowNumber,modifiers
+[imaqGetSystemWindowHandle]
+exclude=True
 [imaqGetWindowCenterPos]
 outparams=centerPosition
 
@@ -361,8 +367,7 @@ outparams=centerPosition
 nullok=lookup
 exclude=True
 [imaqFlatten]
-underscored=True
-exclude=True
+retsize=size
 [imaqRotate2]
 # TODO because of PixelValue
 exclude=True
@@ -370,8 +375,7 @@ exclude=True
 # TODO because of PixelValue
 exclude=True
 [imaqUnflatten]
-underscored=True
-exclude=True
+size=data:size
 
 ; File I/O functions
 [imaqGetAVIInfo]
@@ -383,9 +387,13 @@ retarraysize=numFilters
 [imaqLoadImagePopup]
 retarraysize=numPaths
 [imaqReadAVIFrame]
+size=data:dataSize
+# unclear whether dataSize is input or output parameter
 exclude=True
 [imaqReadFile]
 nullok=colorTable,numColors
+[imaqWriteAVIFrame]
+size=data:dataLength
 [imaqWriteBMPFile]
 nullok=colorTable
 defaults=colorTable:null
@@ -488,6 +496,8 @@ nullok=palette
 
 ; Utilities functions
 ; Many Make* functions are faster in native Python
+[imaqGetKernel]
+exclude=True
 [imaqMakeAnnulus]
 exclude=True
 [imaqMakePoint]
@@ -509,6 +519,8 @@ underscored=True
 [imaqGetLastEvent]
 nullok=windowNumber,tool,rect
 outparams=type,tool,rect
+[imaqGetToolWindowHandle]
+exclude=True
 [imaqGetToolWindowPos]
 outparams=position
 [imaqSetEventCallback]
@@ -704,6 +716,8 @@ arraysize=points:numOfPoints
 arraysize=points:numOfPoints
 
 ; Texture functions
+[imaqClassificationTextureDefectOptions]
+exclude=True
 [imaqCooccurrenceMatrix]
 exclude=True
 [imaqExtractTextureFeatures]
