From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: James Kuszmaul <jabukuszmaul+collab@gmail.com>
Date: Mon, 1 Dec 2014 14:05:26 -0500
Subject: [PATCH 0527/6262] Added support for basic PID in java Talon SRX.

Tested analog PID in Java and C++.
Changed to default to controlEnabled.
Loosely wrapped a bunch of CanTalonSRX functions in Java.

Change-Id: I9da380e2368d9a72f08be4434ac63b5710a9f90f
---
 hal/lib/Athena/ctre/CanTalonSRX.cpp           |  63 +-
 hal/lib/Athena/ctre/CanTalonSRX.h             |  48 +-
 wpilibc/wpilibC++Devices/include/CANTalon.h   |  23 +-
 .../include/ctre/CanTalonSRX.h                |  52 +-
 wpilibc/wpilibC++Devices/src/CANTalon.cpp     | 147 +++-
 .../src/CANJaguarTest.cpp                     |  10 +-
 .../src/CANTalonTest.cpp                      |  37 +-
 .../java/edu/wpi/first/wpilibj/CANTalon.java  | 550 +++++++++++++-
 .../edu/wpi/first/wpilibj/CanTalonSRX.java    | 101 +--
 .../wpi/first/wpilibj/hal/CanTalonJNI.java    |  40 +-
 .../edu/wpi/first/wpilibj/CANTalonTest.java   |  90 ++-
 wpilibj/wpilibJavaJNI/lib/CanTalonSRXJNI.cpp  | 678 +++++++++++++-----
 wpilibj/wpilibJavaJNI/swigTalon/CanTalonSRX.i |   4 +
 13 files changed, 1438 insertions(+), 405 deletions(-)

diff --git a/hal/lib/Athena/ctre/CanTalonSRX.cpp b/hal/lib/Athena/ctre/CanTalonSRX.cpp
index 4d946576cbaa000315a61e5edf1cbb52d9200c6a..654a4b7d63a6b45907d496e4edb57e6d181022a4 100644
--- a/hal/lib/Athena/ctre/CanTalonSRX.cpp
+++ b/hal/lib/Athena/ctre/CanTalonSRX.cpp
@@ -241,7 +241,7 @@ typedef struct _TALON_Param_Response_t {
 } TALON_Param_Response_t ;
 
 
-CanTalonSRX::CanTalonSRX(UINT8 deviceNumber,UINT8 controlPeriodMs): CtreCanNode(deviceNumber), _can_h(0), _can_stat(0)
+CanTalonSRX::CanTalonSRX(int deviceNumber,int controlPeriodMs): CtreCanNode(deviceNumber), _can_h(0), _can_stat(0)
 {
 	RegisterRx(STATUS_1 | (UINT8)deviceNumber );
 	RegisterRx(STATUS_2 | (UINT8)deviceNumber );
@@ -250,7 +250,7 @@ CanTalonSRX::CanTalonSRX(UINT8 deviceNumber,UINT8 controlPeriodMs): CtreCanNode(
 	RegisterRx(STATUS_5 | (UINT8)deviceNumber );
 	RegisterRx(STATUS_6 | (UINT8)deviceNumber );
 	RegisterRx(STATUS_7 | (UINT8)deviceNumber );
-	RegisterTx(CONTROL_1 | (UINT8)deviceNumber, controlPeriodMs);
+	RegisterTx(CONTROL_1 | (UINT8)deviceNumber, (UINT8)controlPeriodMs);
 	/* default our frame rate table to what firmware defaults to. */
 	_statusRateMs[0] = 10;	/* 	TALON_Status_1_General_10ms_t 		*/
 	_statusRateMs[1] = 20;	/* 	TALON_Status_2_Feedback_20ms_t 		*/
@@ -334,7 +334,7 @@ void CanTalonSRX::Set(double value)
  * -Default brake and limit switch signals... eOnBoot_XXXs.  Avoid doing this, use the override signals in the control frame.
  * Talon will automatically send a PARAM_RESPONSE after the set, so GetParamResponse will catch the latest value after a couple ms.
  */
-CTR_Code CanTalonSRX::SetParamRaw(uint32_t paramEnum, int32_t rawBits)
+CTR_Code CanTalonSRX::SetParamRaw(unsigned paramEnum, int rawBits)
 {
 	/* caller is using param API.  Open session if it hasn'T been done. */
 	if(0 == _can_h)
@@ -355,7 +355,7 @@ CTR_Code CanTalonSRX::SetParamRaw(uint32_t paramEnum, int32_t rawBits)
 /**
  * Checks cached CAN frames and updating solicited signals.
  */
-CTR_Code CanTalonSRX::GetParamResponseRaw(uint32_t paramEnum, int32_t & rawBits)
+CTR_Code CanTalonSRX::GetParamResponseRaw(unsigned paramEnum, int & rawBits)
 {
 	CTR_Code retval = CTR_OKAY;
 	/* process received param events. We don't expect many since this API is not used often. */
@@ -441,7 +441,7 @@ CTR_Code CanTalonSRX::GetParamResponse(param_t paramEnum, double & value)
 	}
 	return retval;
 }
-CTR_Code CanTalonSRX::GetParamResponseInt32(param_t paramEnum, int32_t & value)
+CTR_Code CanTalonSRX::GetParamResponseInt32(param_t paramEnum, int & value)
 {
 	double dvalue = 0;
 	CTR_Code retval = GetParamResponse(paramEnum, dvalue);
@@ -452,134 +452,135 @@ CTR_Code CanTalonSRX::GetParamResponseInt32(param_t paramEnum, int32_t & value)
 /*----- If your application requires changing these values consider using both slots and switch between slot0 <=> slot1. ------------------*/
 /*----- If your application requires changing these signals frequently then it makes sense to leverage this API. --------------------------*/
 /*----- Getters don't block, so it may require several calls to get the latest value. --------------------------*/
-CTR_Code CanTalonSRX::SetPgain(uint32_t slotIdx,double gain)
+CTR_Code CanTalonSRX::SetPgain(unsigned slotIdx,double gain)
 {
 	if(slotIdx == 0)
 		return SetParam(eProfileParamSlot0_P, gain);
 	return SetParam(eProfileParamSlot1_P, gain);
 }
-CTR_Code CanTalonSRX::SetIgain(uint32_t slotIdx,double gain)
+CTR_Code CanTalonSRX::SetIgain(unsigned slotIdx,double gain)
 {
 	if(slotIdx == 0)
 		return SetParam(eProfileParamSlot0_I, gain);
 	return SetParam(eProfileParamSlot1_I, gain);
 }
-CTR_Code CanTalonSRX::SetDgain(uint32_t slotIdx,double gain)
+CTR_Code CanTalonSRX::SetDgain(unsigned slotIdx,double gain)
 {
 	if(slotIdx == 0)
 		return SetParam(eProfileParamSlot0_D, gain);
 	return SetParam(eProfileParamSlot1_D, gain);
 }
-CTR_Code CanTalonSRX::SetFgain(uint32_t slotIdx,double gain)
+CTR_Code CanTalonSRX::SetFgain(unsigned slotIdx,double gain)
 {
 	if(slotIdx == 0)
 		return SetParam(eProfileParamSlot0_F, gain);
 	return SetParam(eProfileParamSlot1_F, gain);
 }
-CTR_Code CanTalonSRX::SetIzone(uint32_t slotIdx,int32_t zone)
+CTR_Code CanTalonSRX::SetIzone(unsigned slotIdx,int zone)
 {
 	if(slotIdx == 0)
 		return SetParam(eProfileParamSlot0_IZone, zone);
 	return SetParam(eProfileParamSlot1_IZone, zone);
 }
-CTR_Code CanTalonSRX::SetCloseLoopRampRate(uint32_t slotIdx,int32_t closeLoopRampRate)
+CTR_Code CanTalonSRX::SetCloseLoopRampRate(unsigned slotIdx,int closeLoopRampRate)
 {
 	if(slotIdx == 0)
 		return SetParam(eProfileParamSlot0_CloseLoopRampRate, closeLoopRampRate);
 	return SetParam(eProfileParamSlot1_CloseLoopRampRate, closeLoopRampRate);
 }
-CTR_Code CanTalonSRX::GetPgain(uint32_t slotIdx,double & gain)
+CTR_Code CanTalonSRX::GetPgain(unsigned slotIdx,double & gain)
 {
 	if(slotIdx == 0)
 		return GetParamResponse(eProfileParamSlot0_P, gain);
 	return GetParamResponse(eProfileParamSlot1_P, gain);
 }
-CTR_Code CanTalonSRX::GetIgain(uint32_t slotIdx,double & gain)
+CTR_Code CanTalonSRX::GetIgain(unsigned slotIdx,double & gain)
 {
 	if(slotIdx == 0)
 		return GetParamResponse(eProfileParamSlot0_I, gain);
 	return GetParamResponse(eProfileParamSlot1_I, gain);
 }
-CTR_Code CanTalonSRX::GetDgain(uint32_t slotIdx,double & gain)
+CTR_Code CanTalonSRX::GetDgain(unsigned slotIdx,double & gain)
 {
 	if(slotIdx == 0)
 		return GetParamResponse(eProfileParamSlot0_D, gain);
 	return GetParamResponse(eProfileParamSlot1_D, gain);
 }
-CTR_Code CanTalonSRX::GetFgain(uint32_t slotIdx,double & gain)
+CTR_Code CanTalonSRX::GetFgain(unsigned slotIdx,double & gain)
 {
 	if(slotIdx == 0)
 		return GetParamResponse(eProfileParamSlot0_F, gain);
 	return GetParamResponse(eProfileParamSlot1_F, gain);
 }
-CTR_Code CanTalonSRX::GetIzone(uint32_t slotIdx,int32_t & zone)
+CTR_Code CanTalonSRX::GetIzone(unsigned slotIdx,int & zone)
 {
 	if(slotIdx == 0)
 		return GetParamResponseInt32(eProfileParamSlot0_IZone, zone);
 	return GetParamResponseInt32(eProfileParamSlot1_IZone, zone);
 }
-CTR_Code CanTalonSRX::GetCloseLoopRampRate(uint32_t slotIdx,int32_t & closeLoopRampRate)
+CTR_Code CanTalonSRX::GetCloseLoopRampRate(unsigned slotIdx,int & closeLoopRampRate)
 {
 	if(slotIdx == 0)
 		return GetParamResponseInt32(eProfileParamSlot0_CloseLoopRampRate, closeLoopRampRate);
 	return GetParamResponseInt32(eProfileParamSlot1_CloseLoopRampRate, closeLoopRampRate);
 }
 
-CTR_Code CanTalonSRX::SetSensorPosition(int32_t pos)
+CTR_Code CanTalonSRX::SetSensorPosition(int pos)
 {
 	return SetParam(eSensorPosition, pos);
 }
-CTR_Code CanTalonSRX::SetForwardSoftLimit(int32_t forwardLimit)
+CTR_Code CanTalonSRX::SetForwardSoftLimit(int forwardLimit)
 {
 	return SetParam(eProfileParamSoftLimitForThreshold, forwardLimit);
 }
-CTR_Code CanTalonSRX::SetReverseSoftLimit(int32_t reverseLimit)
+CTR_Code CanTalonSRX::SetReverseSoftLimit(int reverseLimit)
 {
 	return SetParam(eProfileParamSoftLimitRevThreshold, reverseLimit);
 }
-CTR_Code CanTalonSRX::SetForwardSoftEnable(int32_t enable)
+CTR_Code CanTalonSRX::SetForwardSoftEnable(int enable)
 {
 	return SetParam(eProfileParamSoftLimitForEnable, enable);
 }
-CTR_Code CanTalonSRX::SetReverseSoftEnable(int32_t enable)
+CTR_Code CanTalonSRX::SetReverseSoftEnable(int enable)
 {
 	return SetParam(eProfileParamSoftLimitRevEnable, enable);
 }
-CTR_Code CanTalonSRX::GetForwardSoftLimit(int32_t & forwardLimit)
+CTR_Code CanTalonSRX::GetForwardSoftLimit(int & forwardLimit)
 {
 	return GetParamResponseInt32(eProfileParamSoftLimitForThreshold, forwardLimit);
 }
-CTR_Code CanTalonSRX::GetReverseSoftLimit(int32_t & reverseLimit)
+CTR_Code CanTalonSRX::GetReverseSoftLimit(int & reverseLimit)
 {
 	return GetParamResponseInt32(eProfileParamSoftLimitRevThreshold, reverseLimit);
 }
-CTR_Code CanTalonSRX::GetForwardSoftEnable(int32_t & enable)
+CTR_Code CanTalonSRX::GetForwardSoftEnable(int & enable)
 {
 	return GetParamResponseInt32(eProfileParamSoftLimitForEnable, enable);
 }
-CTR_Code CanTalonSRX::GetReverseSoftEnable(int32_t & enable)
+CTR_Code CanTalonSRX::GetReverseSoftEnable(int & enable)
 {
 	return GetParamResponseInt32(eProfileParamSoftLimitRevEnable, enable);
 }
 /**
  * Change the periodMs of a TALON's status frame.  See kStatusFrame_* enums for what's available.
  */
-CTR_Code CanTalonSRX::SetStatusFrameRate(uint32_t frameEnum, uint8_t periodMs)
+CTR_Code CanTalonSRX::SetStatusFrameRate(unsigned frameEnum, unsigned periodMs)
 {
 	int32_t status = 0;
+  uint8_t period = (uint8_t)periodMs;
 	/* tweak just the status messsage rate the caller cares about */
 	switch(frameEnum){
 		case kStatusFrame_General:
-			_statusRateMs[0] = periodMs;
+			_statusRateMs[0] = period;
 			break;
 		case kStatusFrame_Feedback:
-			_statusRateMs[1] = periodMs;
+			_statusRateMs[1] = period;
 			break;
 		case kStatusFrame_Encoder:
-			_statusRateMs[2] = periodMs;
+			_statusRateMs[2] = period;
 			break;
 		case kStatusFrame_AnalogTempVbat:
-			_statusRateMs[3] = periodMs;
+			_statusRateMs[3] = period;
 			break;
 	}
 	/* build our request frame */
diff --git a/hal/lib/Athena/ctre/CanTalonSRX.h b/hal/lib/Athena/ctre/CanTalonSRX.h
index 486d39282218373189b2f050c2ca7b9db426d43e..2ed5c61d00a1128edffffd7d9e9bde97846eb613 100644
--- a/hal/lib/Athena/ctre/CanTalonSRX.h
+++ b/hal/lib/Athena/ctre/CanTalonSRX.h
@@ -107,7 +107,7 @@ private:
 	CTR_Code GetParamResponseRaw(uint32_t paramEnum, int32_t & rawBits);
 public:
 	static const int kDefaultControlPeriodMs = 10; //!< default control update rate is 10ms.
-	CanTalonSRX(UINT8 deviceNumber = 0,UINT8 controlPeriodMs = kDefaultControlPeriodMs);
+	CanTalonSRX(int deviceNumber = 0,int controlPeriodMs = kDefaultControlPeriodMs);
 	~CanTalonSRX();
 	void Set(double value);
 	/* mode select enumerations */
@@ -229,36 +229,36 @@ public:
 	 */
 	CTR_Code RequestParam(param_t paramEnum);
 	CTR_Code GetParamResponse(param_t paramEnum, double & value);
-	CTR_Code GetParamResponseInt32(param_t paramEnum, int32_t & value);
+	CTR_Code GetParamResponseInt32(param_t paramEnum, int & value);
     /*----- getters and setters that use param request/response. These signals are backed up in flash and will survive a power cycle. ---------*/
 	/*----- If your application requires changing these values consider using both slots and switch between slot0 <=> slot1. ------------------*/
 	/*----- If your application requires changing these signals frequently then it makes sense to leverage this API. --------------------------*/
 	/*----- Getters don't block, so it may require several calls to get the latest value. --------------------------*/
-	CTR_Code SetPgain(uint32_t slotIdx,double gain);
-	CTR_Code SetIgain(uint32_t slotIdx,double gain);
-	CTR_Code SetDgain(uint32_t slotIdx,double gain);
-	CTR_Code SetFgain(uint32_t slotIdx,double gain);
-	CTR_Code SetIzone(uint32_t slotIdx,int32_t zone);
-	CTR_Code SetCloseLoopRampRate(uint32_t slotIdx,int32_t closeLoopRampRate);
-	CTR_Code SetSensorPosition(int32_t pos);
-	CTR_Code SetForwardSoftLimit(int32_t forwardLimit);
-	CTR_Code SetReverseSoftLimit(int32_t reverseLimit);
-	CTR_Code SetForwardSoftEnable(int32_t enable);
-	CTR_Code SetReverseSoftEnable(int32_t enable);
-	CTR_Code GetPgain(uint32_t slotIdx,double & gain);
-	CTR_Code GetIgain(uint32_t slotIdx,double & gain);
-	CTR_Code GetDgain(uint32_t slotIdx,double & gain);
-	CTR_Code GetFgain(uint32_t slotIdx,double & gain);
-	CTR_Code GetIzone(uint32_t slotIdx,int32_t & zone);
-	CTR_Code GetCloseLoopRampRate(uint32_t slotIdx,int32_t & closeLoopRampRate);
-	CTR_Code GetForwardSoftLimit(int32_t & forwardLimit);
-	CTR_Code GetReverseSoftLimit(int32_t & reverseLimit);
-	CTR_Code GetForwardSoftEnable(int32_t & enable);
-	CTR_Code GetReverseSoftEnable(int32_t & enable);
+	CTR_Code SetPgain(unsigned slotIdx,double gain);
+	CTR_Code SetIgain(unsigned slotIdx,double gain);
+	CTR_Code SetDgain(unsigned slotIdx,double gain);
+	CTR_Code SetFgain(unsigned slotIdx,double gain);
+	CTR_Code SetIzone(unsigned slotIdx,int zone);
+	CTR_Code SetCloseLoopRampRate(unsigned slotIdx,int closeLoopRampRate);
+	CTR_Code SetSensorPosition(int pos);
+	CTR_Code SetForwardSoftLimit(int forwardLimit);
+	CTR_Code SetReverseSoftLimit(int reverseLimit);
+	CTR_Code SetForwardSoftEnable(int enable);
+	CTR_Code SetReverseSoftEnable(int enable);
+	CTR_Code GetPgain(unsigned slotIdx,double & gain);
+	CTR_Code GetIgain(unsigned slotIdx,double & gain);
+	CTR_Code GetDgain(unsigned slotIdx,double & gain);
+	CTR_Code GetFgain(unsigned slotIdx,double & gain);
+	CTR_Code GetIzone(unsigned slotIdx,int & zone);
+	CTR_Code GetCloseLoopRampRate(unsigned slotIdx,int & closeLoopRampRate);
+	CTR_Code GetForwardSoftLimit(int & forwardLimit);
+	CTR_Code GetReverseSoftLimit(int & reverseLimit);
+	CTR_Code GetForwardSoftEnable(int & enable);
+	CTR_Code GetReverseSoftEnable(int & enable);
 	/**
 	 * Change the periodMs of a TALON's status frame.  See kStatusFrame_* enums for what's available.
 	 */
-	CTR_Code SetStatusFrameRate(uint32_t frameEnum, uint8_t periodMs);
+	CTR_Code SetStatusFrameRate(unsigned frameEnum, unsigned periodMs);
 	/**
 	 * Clear all sticky faults in TALON.
 	 */
diff --git a/wpilibc/wpilibC++Devices/include/CANTalon.h b/wpilibc/wpilibC++Devices/include/CANTalon.h
index 931fa552c9532803c619c6f1f877680a156f1257..41ee85489ccd11fd0c3139ef0c5f3ff13a8405ce 100644
--- a/wpilibc/wpilibC++Devices/include/CANTalon.h
+++ b/wpilibc/wpilibC++Devices/include/CANTalon.h
@@ -20,6 +20,13 @@ class CANTalon : public MotorSafety,
                  public ErrorBase
 {
 public:
+  enum FeedbackDevice {
+    QuadEncoder=0,
+    AnalogPot=2,
+    AnalogEncoder=3,
+    EncRising=4,
+    EncFalling=5
+  };
 	explicit CANTalon(int deviceNumber);
 	virtual ~CANTalon();
 
@@ -53,6 +60,11 @@ public:
 	virtual float GetTemperature() override;
 	virtual double GetPosition() override;
 	virtual double GetSpeed() override;
+  virtual int GetClosedLoopError();
+  virtual int GetAnalogIn();
+  virtual int GetAnalogInVel();
+  virtual int GetEncPosition();
+  virtual int GetEncVel();
 	virtual bool GetForwardLimitOK() override;
 	virtual bool GetReverseLimitOK() override;
 	virtual uint16_t GetFaults() override;
@@ -69,17 +81,18 @@ public:
 	virtual void ConfigMaxOutputVoltage(double voltage) override;
 	virtual void ConfigFaultTime(float faultTime) override;
 	virtual void SetControlMode(ControlMode mode);
+  void SetFeedbackDevice(FeedbackDevice device);
 	virtual ControlMode GetControlMode();
 
 private:
   // Values for various modes as is sent in the CAN packets for the Talon.
   enum TalonControlMode {
 		kThrottle=0,
-    kFollowerMode=1,
-		kVoltageMode=2,
-		kPositionMode=3,
-		kSpeedMode=4,
-		kCurrentMode=5,
+    kFollowerMode=5,
+		kVoltageMode=4,
+		kPositionMode=1,
+		kSpeedMode=2,
+		kCurrentMode=3,
     kDisabled=15
   };
 
diff --git a/wpilibc/wpilibC++Devices/include/ctre/CanTalonSRX.h b/wpilibc/wpilibC++Devices/include/ctre/CanTalonSRX.h
index 215413b46bdf7f9a62d6ed0cbaa8fa5cb4598971..2ed5c61d00a1128edffffd7d9e9bde97846eb613 100644
--- a/wpilibc/wpilibC++Devices/include/ctre/CanTalonSRX.h
+++ b/wpilibc/wpilibC++Devices/include/ctre/CanTalonSRX.h
@@ -107,9 +107,9 @@ private:
 	CTR_Code GetParamResponseRaw(uint32_t paramEnum, int32_t & rawBits);
 public:
 	static const int kDefaultControlPeriodMs = 10; //!< default control update rate is 10ms.
-	CanTalonSRX(UINT8 deviceNumber = 0,UINT8 controlPeriodMs = kDefaultControlPeriodMs);
-    ~CanTalonSRX();
-    void Set(double value);
+	CanTalonSRX(int deviceNumber = 0,int controlPeriodMs = kDefaultControlPeriodMs);
+	~CanTalonSRX();
+	void Set(double value);
 	/* mode select enumerations */
 	static const int kMode_DutyCycle = 0; //!< Demand is 11bit signed duty cycle [-1023,1023].
 	static const int kMode_PositionCloseLoop = 1; //!< Position PIDF.
@@ -229,36 +229,36 @@ public:
 	 */
 	CTR_Code RequestParam(param_t paramEnum);
 	CTR_Code GetParamResponse(param_t paramEnum, double & value);
-	CTR_Code GetParamResponseInt32(param_t paramEnum, int32_t & value);
+	CTR_Code GetParamResponseInt32(param_t paramEnum, int & value);
     /*----- getters and setters that use param request/response. These signals are backed up in flash and will survive a power cycle. ---------*/
 	/*----- If your application requires changing these values consider using both slots and switch between slot0 <=> slot1. ------------------*/
 	/*----- If your application requires changing these signals frequently then it makes sense to leverage this API. --------------------------*/
 	/*----- Getters don't block, so it may require several calls to get the latest value. --------------------------*/
-	CTR_Code SetPgain(uint32_t slotIdx,double gain);
-	CTR_Code SetIgain(uint32_t slotIdx,double gain);
-	CTR_Code SetDgain(uint32_t slotIdx,double gain);
-	CTR_Code SetFgain(uint32_t slotIdx,double gain);
-	CTR_Code SetIzone(uint32_t slotIdx,int32_t zone);
-	CTR_Code SetCloseLoopRampRate(uint32_t slotIdx,int32_t closeLoopRampRate);
-	CTR_Code SetSensorPosition(int32_t pos);
-	CTR_Code SetForwardSoftLimit(int32_t forwardLimit);
-	CTR_Code SetReverseSoftLimit(int32_t reverseLimit);
-	CTR_Code SetForwardSoftEnable(int32_t enable);
-	CTR_Code SetReverseSoftEnable(int32_t enable);
-	CTR_Code GetPgain(uint32_t slotIdx,double & gain);
-	CTR_Code GetIgain(uint32_t slotIdx,double & gain);
-	CTR_Code GetDgain(uint32_t slotIdx,double & gain);
-	CTR_Code GetFgain(uint32_t slotIdx,double & gain);
-	CTR_Code GetIzone(uint32_t slotIdx,int32_t & zone);
-	CTR_Code GetCloseLoopRampRate(uint32_t slotIdx,int32_t & closeLoopRampRate);
-	CTR_Code GetForwardSoftLimit(int32_t & forwardLimit);
-	CTR_Code GetReverseSoftLimit(int32_t & reverseLimit);
-	CTR_Code GetForwardSoftEnable(int32_t & enable);
-	CTR_Code GetReverseSoftEnable(int32_t & enable);
+	CTR_Code SetPgain(unsigned slotIdx,double gain);
+	CTR_Code SetIgain(unsigned slotIdx,double gain);
+	CTR_Code SetDgain(unsigned slotIdx,double gain);
+	CTR_Code SetFgain(unsigned slotIdx,double gain);
+	CTR_Code SetIzone(unsigned slotIdx,int zone);
+	CTR_Code SetCloseLoopRampRate(unsigned slotIdx,int closeLoopRampRate);
+	CTR_Code SetSensorPosition(int pos);
+	CTR_Code SetForwardSoftLimit(int forwardLimit);
+	CTR_Code SetReverseSoftLimit(int reverseLimit);
+	CTR_Code SetForwardSoftEnable(int enable);
+	CTR_Code SetReverseSoftEnable(int enable);
+	CTR_Code GetPgain(unsigned slotIdx,double & gain);
+	CTR_Code GetIgain(unsigned slotIdx,double & gain);
+	CTR_Code GetDgain(unsigned slotIdx,double & gain);
+	CTR_Code GetFgain(unsigned slotIdx,double & gain);
+	CTR_Code GetIzone(unsigned slotIdx,int & zone);
+	CTR_Code GetCloseLoopRampRate(unsigned slotIdx,int & closeLoopRampRate);
+	CTR_Code GetForwardSoftLimit(int & forwardLimit);
+	CTR_Code GetReverseSoftLimit(int & reverseLimit);
+	CTR_Code GetForwardSoftEnable(int & enable);
+	CTR_Code GetReverseSoftEnable(int & enable);
 	/**
 	 * Change the periodMs of a TALON's status frame.  See kStatusFrame_* enums for what's available.
 	 */
-	CTR_Code SetStatusFrameRate(uint32_t frameEnum, uint8_t periodMs);
+	CTR_Code SetStatusFrameRate(unsigned frameEnum, unsigned periodMs);
 	/**
 	 * Clear all sticky faults in TALON.
 	 */
diff --git a/wpilibc/wpilibC++Devices/src/CANTalon.cpp b/wpilibc/wpilibC++Devices/src/CANTalon.cpp
index fd3c4044626c778f64c451dc347a7667d4ae4f66..112da2b399b270f8cf38e1cfb634994bda7277cc 100644
--- a/wpilibc/wpilibC++Devices/src/CANTalon.cpp
+++ b/wpilibc/wpilibC++Devices/src/CANTalon.cpp
@@ -22,11 +22,14 @@ CANTalon::CANTalon(int deviceNumber)
 	: m_deviceNumber(deviceNumber)
 	, m_impl(new CanTalonSRX(deviceNumber))
 	, m_safetyHelper(new MotorSafetyHelper(this))
-  , m_controlEnabled(false)
+  , m_profile(0)
+  , m_controlEnabled(true)
+  , m_controlMode(kPercentVbus)
 {
   // The control mode may already have been set; GetControlMode will reset
   // m_controlMode to match the Talon.
   GetControlMode();
+  m_impl->SetProfileSlotSelect(m_profile);
 }
 
 CANTalon::~CANTalon() {
@@ -60,9 +63,6 @@ float CANTalon::Get()
 {
   int value;
   switch(m_controlMode) {
-    case kPercentVbus:
-      m_impl->GetAppliedThrottle(value);
-      return 1.0 - (float)value / 1023.0;
     case kVoltage:
       return GetOutputVoltage();
     case kCurrent:
@@ -73,14 +73,24 @@ float CANTalon::Get()
     case kPosition:
       m_impl->GetSensorPosition(value);
       return value;
+    case kPercentVbus:
     default:
-      break;
+      m_impl->GetAppliedThrottle(value);
+      return (float)value / 1023.0;
   }
-  return 0.0f;
 }
 
 /**
- * Sets the output set-point value.
+ * Sets the appropriate output on the talon, depending on the mode.
+ *
+ * In PercentVbus, the output is between -1.0 and 1.0, with 0.0 as stopped.
+ * In Voltage mode, outputValue is in volts.
+ * In Current mode, outputValue is in amperes.
+ * In Speed mode, outputValue is in position change / 10ms.
+ * In Position mode, outputValue is in encoder ticks or an analog value,
+ *   depending on the sensor.
+ *
+ * @param outputValue The setpoint value, as described above.
  */
 void CANTalon::Set(float value, uint8_t syncGroup)
 {
@@ -112,8 +122,6 @@ void CANTalon::Set(float value, uint8_t syncGroup)
         status = m_impl->SetDemand(value);
         break;
       default:
-        // TODO: Add support for other modes. Need to figure out what format
-        // SetDemand needs.
         break;
     }
     if (status != CTR_OKAY) {
@@ -128,8 +136,7 @@ void CANTalon::Set(float value, uint8_t syncGroup)
 void CANTalon::Disable()
 {
   // Until Modes other than throttle work, just disable by setting throttle to 0.0.
-  //m_impl->Set(0.0); // TODO when firmware is updated, remove this.
-  m_impl->SetModeSelect(kDisabled); // TODO when firmware is updated, uncomment this.
+  m_impl->SetModeSelect((int)CANTalon::kDisabled);
   m_controlEnabled = false;
 }
 
@@ -142,7 +149,7 @@ void CANTalon::EnableControl() {
 }
 
 /**
- * @param 
+ * @param p Proportional constant to use in PID loop.
  */
 void CANTalon::SetP(double p)
 {
@@ -184,13 +191,31 @@ void CANTalon::SetPID(double p, double i, double d)
 	SetD(d);
 }
 
+/**
+ * Select the feedback device to use in closed-loop
+ */
+void CANTalon::SetFeedbackDevice(FeedbackDevice device)
+{
+  CTR_Code status = m_impl->SetFeedbackDeviceSelect((int)device);
+
+	if(status != CTR_OKAY) {
+		wpi_setErrorWithContext(status, getHALErrorMessage(status));
+  }
+}
+
 /**
  * TODO documentation (see CANJaguar.cpp)
  */
 double CANTalon::GetP()
 {
+  // Update the info in m_impl.
+  CTR_Code status = m_impl->RequestParam(CanTalonSRX::eProfileParamSlot0_P);
+	if(status != CTR_OKAY) {
+		wpi_setErrorWithContext(status, getHALErrorMessage(status));
+  }
+
   double p;
-  CTR_Code status = m_impl->GetPgain(m_profile, p);
+  status = m_impl->GetPgain(m_profile, p);
 	if(status != CTR_OKAY) {
 		wpi_setErrorWithContext(status, getHALErrorMessage(status));
 	}
@@ -202,8 +227,14 @@ double CANTalon::GetP()
  */
 double CANTalon::GetI()
 {
+  // Update the info in m_impl.
+  CTR_Code status = m_impl->RequestParam(CanTalonSRX::eProfileParamSlot0_I);
+	if(status != CTR_OKAY) {
+		wpi_setErrorWithContext(status, getHALErrorMessage(status));
+  }
+
   double i;
-  CTR_Code status = m_impl->GetIgain(m_profile, i);
+  status = m_impl->GetIgain(m_profile, i);
 	if(status != CTR_OKAY) {
 		wpi_setErrorWithContext(status, getHALErrorMessage(status));
 	}
@@ -215,8 +246,14 @@ double CANTalon::GetI()
  */
 double CANTalon::GetD()
 {
+  // Update the info in m_impl.
+  CTR_Code status = m_impl->RequestParam(CanTalonSRX::eProfileParamSlot0_D);
+	if(status != CTR_OKAY) {
+		wpi_setErrorWithContext(status, getHALErrorMessage(status));
+  }
+
   double d;
-  CTR_Code status = m_impl->GetDgain(m_profile, d);
+  status = m_impl->GetDgain(m_profile, d);
 	if(status != CTR_OKAY) {
 		wpi_setErrorWithContext(status, getHALErrorMessage(status));
 	}
@@ -245,7 +282,7 @@ float CANTalon::GetOutputVoltage()
 {
   int throttle11;
   CTR_Code status = m_impl->GetAppliedThrottle(throttle11);
-  float voltage = GetBusVoltage() * (float(throttle11) / 1023.0 - 1.0);
+  float voltage = GetBusVoltage() * (float(throttle11) / 1023.0);
 	if(status != CTR_OKAY) {
 		wpi_setErrorWithContext(status, getHALErrorMessage(status));
 	}
@@ -299,6 +336,20 @@ double CANTalon::GetPosition()
 	return (double)postition;
 }
 
+/**
+ * Returns the current error in the controller.
+ *
+ * @return the difference between the setpoint and the sensor value.
+ */
+int CANTalon::GetClosedLoopError() {
+  int error;
+  CTR_Code status = m_impl->GetCloseLoopErr(error);
+	if(status != CTR_OKAY) {
+		wpi_setErrorWithContext(status, getHALErrorMessage(status));
+	}
+  return error;
+}
+
 /**
  * TODO documentation (see CANJaguar.cpp)
  *
@@ -316,6 +367,70 @@ double CANTalon::GetSpeed()
 	return (double)speed;
 }
 
+/**
+ * Get the position of whatever is in the analog pin of the Talon, regardless of
+ * whether it is actually being used for feedback.
+ *
+ * @returns The value (0 - 1023) on the analog pin of the Talon.
+ */
+int CANTalon::GetAnalogIn()
+{
+  int position;
+  CTR_Code status = m_impl->GetAnalogInWithOv(position);
+	if(status != CTR_OKAY) {
+		wpi_setErrorWithContext(status, getHALErrorMessage(status));
+	}
+  return position;
+}
+
+/**
+ * Get the position of whatever is in the analog pin of the Talon, regardless of
+ * whether it is actually being used for feedback.
+ *
+ * @returns The value (0 - 1023) on the analog pin of the Talon.
+ */
+int CANTalon::GetAnalogInVel()
+{
+  int vel;
+  CTR_Code status = m_impl->GetAnalogInVel(vel);
+	if(status != CTR_OKAY) {
+		wpi_setErrorWithContext(status, getHALErrorMessage(status));
+	}
+  return vel;
+}
+
+/**
+ * Get the position of whatever is in the analog pin of the Talon, regardless of
+ * whether it is actually being used for feedback.
+ *
+ * @returns The value (0 - 1023) on the analog pin of the Talon.
+ */
+int CANTalon::GetEncPosition()
+{
+  int position;
+  CTR_Code status = m_impl->GetEncPosition(position);
+	if(status != CTR_OKAY) {
+		wpi_setErrorWithContext(status, getHALErrorMessage(status));
+	}
+  return position;
+}
+
+/**
+ * Get the position of whatever is in the analog pin of the Talon, regardless of
+ * whether it is actually being used for feedback.
+ *
+ * @returns The value (0 - 1023) on the analog pin of the Talon.
+ */
+int CANTalon::GetEncVel()
+{
+  int vel;
+  CTR_Code status = m_impl->GetEncVel(vel);
+	if(status != CTR_OKAY) {
+		wpi_setErrorWithContext(status, getHALErrorMessage(status));
+	}
+  return vel;
+}
+
 /**
  * TODO documentation (see CANJaguar.cpp)
  */
diff --git a/wpilibc/wpilibC++IntegrationTests/src/CANJaguarTest.cpp b/wpilibc/wpilibC++IntegrationTests/src/CANJaguarTest.cpp
index 32470ee534a9f2e4aeae3970155dd76d06893c9c..33bed1c1ab0d65215291bb56c2f09b15bcc6574b 100644
--- a/wpilibc/wpilibC++IntegrationTests/src/CANJaguarTest.cpp
+++ b/wpilibc/wpilibC++IntegrationTests/src/CANJaguarTest.cpp
@@ -161,12 +161,12 @@ TEST_F(CANJaguarTest, Disable) {
  * behaves like it should in that control mode.
  */
 TEST_F(CANJaguarTest, BrownOut) {
-	double setpoint = 10.0;
 
 	/* Set the jaguar to quad encoder position mode */
-	m_jaguar->SetPositionMode(CANJaguar::QuadEncoder, 360, 10.0f, 0.1f, 0.0f);
+	m_jaguar->SetPositionMode(CANJaguar::QuadEncoder, 360, 20.0f, 0.01f, 0.0f);
 	m_jaguar->EnableControl();
 	SetJaguar(kMotorTime, 0.0);
+	double setpoint = m_jaguar->GetPosition() + 1.0f;
 
 	/* Turn the spike off and on again */
 	m_spike->Set(Relay::kOff);
@@ -274,7 +274,7 @@ TEST_F(CANJaguarTest, SpeedModeWorks) {
 	m_jaguar->SetSpeedMode(CANJaguar::QuadEncoder, 360, 0.1f, 0.003f, 0.01f);
 	m_jaguar->EnableControl();
 
-	constexpr float speed = 200.0f;
+	constexpr float speed = 100.0f;
 
 	SetJaguar(kMotorTime, speed);
 	EXPECT_NEAR(speed, m_jaguar->GetSpeed(), kEncoderSpeedTolerance);
@@ -285,9 +285,9 @@ TEST_F(CANJaguarTest, SpeedModeWorks) {
  * the Jaguar.
  */
 TEST_F(CANJaguarTest, PositionModeWorks) {
-	m_jaguar->SetPositionMode(CANJaguar::QuadEncoder, 360, 10.0f, 0.1f, 0.0f);
+	m_jaguar->SetPositionMode(CANJaguar::QuadEncoder, 360, 15.0f, 0.02f, 0.0f);
 
-	double setpoint = m_jaguar->GetPosition() + 10.0f;
+	double setpoint = m_jaguar->GetPosition() + 1.0f;
 
 	m_jaguar->EnableControl();
 
diff --git a/wpilibc/wpilibC++IntegrationTests/src/CANTalonTest.cpp b/wpilibc/wpilibC++IntegrationTests/src/CANTalonTest.cpp
index 1513d23c73df40f83ec5b3637128af04daa94f02..afaf5e5e1274c4ccf4daabd72b7ff4b4a43194d0 100644
--- a/wpilibc/wpilibC++IntegrationTests/src/CANTalonTest.cpp
+++ b/wpilibc/wpilibC++IntegrationTests/src/CANTalonTest.cpp
@@ -7,21 +7,25 @@
 #include "WPILib.h"
 #include "gtest/gtest.h"
 #include "TestBench.h"
+#include "ctre/CanTalonSRX.h"
 
 const int deviceId = 0;
 
 TEST(CANTalonTest, QuickTest) {
+  double throttle = 0.1;
 	CANTalon talon(deviceId);
   talon.SetControlMode(CANSpeedController::kPercentVbus);
   talon.EnableControl();
-  talon.Set(0.5);
+  talon.Set(throttle);
   Wait(0.25);
-  EXPECT_NEAR(talon.Get(), 0.5, 5e-3);
-  talon.Set(-0.5);
+  EXPECT_NEAR(talon.Get(), throttle, 5e-3);
+  talon.Set(-throttle);
   Wait(0.25);
-  EXPECT_NEAR(talon.Get(), -0.5, 5e-3);
+  EXPECT_NEAR(talon.Get(), -throttle, 5e-3);
 
   talon.Disable();
+  Wait(0.1);
+  EXPECT_FLOAT_EQ(talon.Get(), 0.0);
 }
 
 TEST(CANTalonTest, SetGetPID) {
@@ -29,7 +33,7 @@ TEST(CANTalonTest, SetGetPID) {
   CANTalon talon(deviceId);
   double p = 0.05, i = 0.098, d = 1.23;
   talon.SetPID(p, i , d);
-  Wait(0.1);
+  // Wait(0.03);
   EXPECT_NEAR(p, talon.GetP(), 1e-5);
   EXPECT_NEAR(i, talon.GetI(), 1e-5);
   EXPECT_NEAR(d, talon.GetD(), 1e-5);
@@ -38,7 +42,7 @@ TEST(CANTalonTest, SetGetPID) {
   i = 0.198;
   d = 1.03;
   talon.SetPID(p, i , d);
-  Wait(0.1);
+  // Wait(0.03);
   EXPECT_NEAR(p, talon.GetP(), 1e-5);
   EXPECT_NEAR(i, talon.GetI(), 1e-5);
   EXPECT_NEAR(d, talon.GetD(), 1e-5);
@@ -46,14 +50,19 @@ TEST(CANTalonTest, SetGetPID) {
 
 TEST(CANTalonTest, DISABLED_PositionModeWorks) {
   CANTalon talon(deviceId);
-  double p = 1;
-  double i = 0.05;
-  double d = 0.01;
-  talon.SetPID(p, i, d);
+  talon.SetFeedbackDevice(CANTalon::AnalogPot);
   talon.SetControlMode(CANSpeedController::kPosition);
-  talon.Set(1000);
-  talon.EnableControl();
-  Wait(10.0);
+  Wait(0.1);
+  double p = 2;
+  double i = 0.00;
+  double d = 0.00;
+  Wait(0.2);
+  talon.SetControlMode(CANSpeedController::kPosition);
+  talon.SetFeedbackDevice(CANTalon::AnalogPot);
+  talon.SetPID(p, i, d);
+  Wait(0.2);
+  talon.Set(100);
+  Wait(100);
   talon.Disable();
-  EXPECT_NEAR(talon.Get(), 1000, 100);
+  EXPECT_NEAR(talon.Get(), 500, 1000);
 }
diff --git a/wpilibj/wpilibJavaDevices/src/main/java/edu/wpi/first/wpilibj/CANTalon.java b/wpilibj/wpilibJavaDevices/src/main/java/edu/wpi/first/wpilibj/CANTalon.java
index 3e9b037907c8dd541b693881d635f8cb129273fa..6fb46ad2b5f9202a2d35057f4311199039c164b1 100644
--- a/wpilibj/wpilibJavaDevices/src/main/java/edu/wpi/first/wpilibj/CANTalon.java
+++ b/wpilibj/wpilibJavaDevices/src/main/java/edu/wpi/first/wpilibj/CANTalon.java
@@ -11,11 +11,14 @@ package edu.wpi.first.wpilibj;
 import edu.wpi.first.wpilibj.hal.CanTalonSRX;
 import edu.wpi.first.wpilibj.hal.CanTalonJNI;
 import edu.wpi.first.wpilibj.hal.SWIGTYPE_p_double;
+import edu.wpi.first.wpilibj.hal.SWIGTYPE_p_int;
+import edu.wpi.first.wpilibj.hal.SWIGTYPE_p_uint32_t;
+import edu.wpi.first.wpilibj.hal.SWIGTYPE_p_CTR_Code;
 
 public class CANTalon implements MotorSafety, PIDOutput, SpeedController {
 	private MotorSafetyHelper m_safetyHelper;
 	public enum ControlMode {
-		PercentVbus(0), Follower(1), Voltage(2), Position(3), Speed(4), Current(5), Disabled(15);
+		PercentVbus(0), Follower(5), Voltage(4), Position(1), Speed(2), Current(3), Disabled(15);
 
     public int value;
 
@@ -34,35 +37,225 @@ public class CANTalon implements MotorSafety, PIDOutput, SpeedController {
     }
 	}
 
+  public enum FeedbackDevice {
+		QuadEncoder(0), AnalogPot(2), AnalogEncoder(3), EncRising(4), EncFalling(5);
+
+    public int value;
+
+    public static FeedbackDevice valueOf(int value) {
+			for(FeedbackDevice mode : values()) {
+				if(mode.value == value) {
+					return mode;
+				}
+			}
+
+			return null;
+    }
+
+    private FeedbackDevice(int value) {
+      this.value = value;
+    }
+	}
+
   private CanTalonSRX m_impl;
+  ControlMode m_controlMode;
 
   int m_deviceNumber;
   boolean m_controlEnabled;
+  int m_profile;
 
   public CANTalon(int deviceNumber) {
     m_deviceNumber = deviceNumber;
     m_impl = new CanTalonSRX(deviceNumber);
     m_safetyHelper = new MotorSafetyHelper(this);
-    m_controlEnabled = false;
+    m_controlEnabled = true;
+    m_profile = 0;
+    setProfile(m_profile);
+    changeControlMode(ControlMode.PercentVbus);
   }
 
   @Override
   public void pidWrite(double output) {
-    set(output);
+    if (getControlMode() == ControlMode.PercentVbus) {
+      set(output);
+    }
+    else {
+			throw new IllegalStateException("PID only supported in PercentVbus mode");
+    }
   }
 
+  public void delete() {
+    m_impl.delete();
+  }
+
+  /**
+   * Sets the appropriate output on the talon, depending on the mode.
+   *
+   * In PercentVbus, the output is between -1.0 and 1.0, with 0.0 as stopped.
+   * In Follower mode, the output is the integer device ID of the talon to duplicate.
+   * In Voltage mode, outputValue is in volts.
+   * In Current mode, outputValue is in amperes.
+   * In Speed mode, outputValue is in position change / 10ms.
+   * In Position mode, outputValue is in encoder ticks or an analog value,
+   *   depending on the sensor.
+   *
+   * @param outputValue The setpoint value, as described above.
+   */
   public void set(double outputValue) {
-    m_impl.Set(outputValue);
+    System.out.println("Enabled: " + m_controlEnabled + " Mode: " + m_controlMode);
+    m_controlMode = ControlMode.PercentVbus;
+    if (m_controlEnabled) {
+      switch (getControlMode()) {
+        case PercentVbus:
+          m_impl.Set(outputValue);
+          break;
+        case Follower:
+          m_impl.SetDemand((int)outputValue);
+          break;
+        case Voltage:
+          // Voltage is an 8.8 fixed point number.
+          int volts = (int)(outputValue * 256);
+          m_impl.SetDemand(volts);
+          break;
+        case Speed:
+          m_impl.SetDemand((int)outputValue);
+          break;
+        case Position:
+          m_impl.SetDemand((int)outputValue);
+          break;
+        default:
+          break;
+      }
+    }
+    System.out.println("Enabled: " + m_controlEnabled + " Mode: " + m_controlMode);
   }
 
+  /**
+   * Sets the output of the Talon.
+   *
+   * @param outputValue See set().
+   * @param thisValueDoesNotDoAnything corresponds to syncGroup from Jaguar; not relevant here.
+   */
   @Override
   public void set(double outputValue, byte thisValueDoesNotDoAnything) {
     set(outputValue);
   }
 
+  /**
+   * Flips the sign (multiplies by negative one) the sensor values going into
+   *the talon.
+   *
+   * This only affects position and velocity closed loop control. Allows for
+   *   situations where you may have a sensor flipped and going in the wrong
+   *   direction.
+   *
+   * @param flip True if sensor input should be flipped; False if not.
+   */
+  public void reverseSensor(boolean flip) {
+    m_impl.SetRevFeedbackSensor(flip ? 1 : 0);
+  }
+
+   /**
+    * Flips the sign (multiplies by negative one) the throttle values going into
+    *  the motor on the talon in closed loop modes.
+    *
+    * @param flip True if motor output should be flipped; False if not.
+    */
+  public void reverseOutput(boolean flip) {
+    m_impl.SetRevMotDuringCloseLoopEn(flip ? 1 : 0);
+  }
+
+  /**
+   * Gets the current status of the Talon (usually a sensor value).
+   *
+   * In Current mode: returns output current.
+   * In Speed mode: returns current speed.
+   * In Position omde: returns current sensor position.
+   * In Throttle and Follower modes: returns current applied throttle.
+   *
+   * @return The current sensor value of the Talon.
+   */
   public double get() {
-    // TODO
-    return 0.0f;
+    long valuep = CanTalonJNI.new_intp();
+    SWIGTYPE_p_int swigp = new SWIGTYPE_p_int(valuep, true);
+    switch (m_controlMode) {
+      case Voltage:
+        return getOutputVoltage();
+      case Current:
+        return getOutputCurrent();
+      case Speed:
+        m_impl.GetSensorVelocity(swigp);
+        return (double)CanTalonJNI.intp_value(valuep);
+      case Position:
+        m_impl.GetSensorPosition(swigp);
+        return (double)CanTalonJNI.intp_value(valuep);
+      case PercentVbus:
+      default:
+        m_impl.GetAppliedThrottle(swigp);
+        return (double)CanTalonJNI.intp_value(valuep) / 1023.0;
+    }
+  }
+
+  /**
+   * Get the current encoder position, regardless of whether it is the current feedback device.
+   *
+   * @return The current position of the encoder.
+   */
+  public int getEncPosition() {
+    long valuep = CanTalonJNI.new_intp();
+    SWIGTYPE_p_int swigp = new SWIGTYPE_p_int(valuep, true);
+    m_impl.GetEncPosition(swigp);
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+  /**
+   * Get the current encoder velocity, regardless of whether it is the current feedback device.
+   *
+   * @return The current speed of the encoder.
+   */
+  public int getEncVelocity() {
+    long valuep = CanTalonJNI.new_intp();
+    SWIGTYPE_p_int swigp = new SWIGTYPE_p_int(valuep, true);
+    m_impl.GetEncVel(swigp);
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+  /**
+   * Get the current analog in position, regardless of whether it is the current
+   * feedback device.
+   *
+   * @return The current value from the analog in (0 - 1023).
+   */
+  public int getAnalogInPosition() {
+    long valuep = CanTalonJNI.new_intp();
+    SWIGTYPE_p_int swigp = new SWIGTYPE_p_int(valuep, true);
+    m_impl.GetAnalogInWithOv(swigp);
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+  /**
+   * Get the current encoder velocity, regardless of whether it is the current
+   * feedback device.
+   *
+   * @return The current speed of the analog in device.
+   */
+  public int getAnalogInVelocity() {
+    long valuep = CanTalonJNI.new_intp();
+    SWIGTYPE_p_int swigp = new SWIGTYPE_p_int(valuep, true);
+    m_impl.GetAnalogInVel(swigp);
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+  /**
+   * Get the current difference between the setpoint and the sensor value.
+   *
+   * @return The error, in whatever units are appropriate.
+   */
+  public int getClosedLoopError() {
+    long valuep = CanTalonJNI.new_intp();
+    SWIGTYPE_p_int swigp = new SWIGTYPE_p_int(valuep, true);
+    m_impl.GetCloseLoopErr(swigp);
+    return CanTalonJNI.intp_value(valuep);
   }
 
   // Returns temperature of Talon, in degrees Celsius.
@@ -72,9 +265,75 @@ public class CANTalon implements MotorSafety, PIDOutput, SpeedController {
     return CanTalonJNI.doublep_value(tempp);
   }
 
-  // Only supports kPercentVbus mode for now.
+  // Returns the current going through the Talon, in Amperes.
+  public double getOutputCurrent() {
+    long curp = CanTalonJNI.new_doublep(); // Create a new swig pointer.
+    m_impl.GetCurrent(new SWIGTYPE_p_double(curp, true));
+    return CanTalonJNI.doublep_value(curp);
+  }
+
+  /**
+   * @return The voltage being output by the Talon, in Volts.
+   */
+  public double getOutputVoltage() {
+    long throttlep = CanTalonJNI.new_intp();
+    m_impl.GetAppliedThrottle(new SWIGTYPE_p_int(throttlep, true));
+    double voltage = getBusVoltage() * (double)CanTalonJNI.intp_value(throttlep) / 1023.0;
+    return voltage;
+  }
+
+  /**
+   * @return The voltage at the battery terminals of the Talon, in Volts.
+   */
+  public double getBusVoltage() {
+    long voltagep = CanTalonJNI.new_doublep();
+    SWIGTYPE_p_CTR_Code status = m_impl.GetBatteryV(new SWIGTYPE_p_double(voltagep, true));
+    /* Note: This section needs the JNI bindings regenerated with
+     pointer_functions for CTR_Code included in order to be able to catch notice
+     and throw errors.
+     if (CanTalonJNI.CTR_Codep_value(status) != 0) {
+       // TODO throw an error.
+     }*/
+
+    return CanTalonJNI.doublep_value(voltagep);
+  }
+
+  public double getPosition() {
+    long positionp = CanTalonJNI.new_intp();
+    m_impl.GetSensorPosition(new SWIGTYPE_p_int(positionp, true));
+    return CanTalonJNI.intp_value(positionp);
+  }
+
+  public double getSpeed() {
+    long speedp = CanTalonJNI.new_intp();
+    m_impl.GetSensorVelocity(new SWIGTYPE_p_int(speedp, true));
+    return CanTalonJNI.intp_value(speedp);
+  }
+
+  public ControlMode getControlMode() {
+    long tempp = CanTalonJNI.new_intp();
+    m_impl.GetModeSelect(new SWIGTYPE_p_int(tempp, true));
+    ControlMode mode = ControlMode.valueOf(CanTalonJNI.intp_value(tempp));
+    if (mode == ControlMode.Disabled) {
+      m_controlEnabled = false;
+    }
+    else {
+      m_controlMode = mode;
+    }
+    return mode;
+  }
+
+  public void changeControlMode(ControlMode controlMode) {
+    m_controlMode = controlMode;
+    m_impl.SetModeSelect(controlMode.value);
+  }
+
+  public void setFeedbackDevice(FeedbackDevice device) {
+    m_impl.SetFeedbackDeviceSelect(device.value);
+  }
+
   public void enableControl() {
-    m_impl.SetModeSelect(ControlMode.PercentVbus.value);
+    changeControlMode(m_controlMode);
 		m_controlEnabled = true;
   }
 
@@ -83,7 +342,171 @@ public class CANTalon implements MotorSafety, PIDOutput, SpeedController {
 		m_controlEnabled = false;
   }
 
-	/**
+  public double getP() {
+		if(!(m_controlMode.equals(ControlMode.Position) || m_controlMode.equals(ControlMode.Speed))) {
+			throw new IllegalStateException("PID mode only applies in Position and Speed modes.");
+		}
+
+    // Update the information that we have.
+    if (m_profile == 0)
+      m_impl.RequestParam(CanTalonSRX.param_t.eProfileParamSlot0_P);
+    else
+      m_impl.RequestParam(CanTalonSRX.param_t.eProfileParamSlot1_P);
+
+    long pp = CanTalonJNI.new_doublep();
+    m_impl.GetPgain(m_profile, new SWIGTYPE_p_double(pp, true));
+    return CanTalonJNI.doublep_value(pp);
+  }
+
+  public double getI() {
+		if(!(m_controlMode.equals(ControlMode.Position) || m_controlMode.equals(ControlMode.Speed))) {
+			throw new IllegalStateException("PID mode only applies in Position and Speed modes.");
+		}
+
+    // Update the information that we have.
+    if (m_profile == 0)
+      m_impl.RequestParam(CanTalonSRX.param_t.eProfileParamSlot0_I);
+    else
+      m_impl.RequestParam(CanTalonSRX.param_t.eProfileParamSlot1_I);
+
+    long ip = CanTalonJNI.new_doublep();
+    m_impl.GetIgain(m_profile, new SWIGTYPE_p_double(ip, true));
+    return CanTalonJNI.doublep_value(ip);
+  }
+
+  public double getD() {
+		if(!(m_controlMode.equals(ControlMode.Position) || m_controlMode.equals(ControlMode.Speed))) {
+			throw new IllegalStateException("PID mode only applies in Position and Speed modes.");
+		}
+
+    // Update the information that we have.
+    if (m_profile == 0)
+      m_impl.RequestParam(CanTalonSRX.param_t.eProfileParamSlot0_D);
+    else
+      m_impl.RequestParam(CanTalonSRX.param_t.eProfileParamSlot1_D);
+
+    long dp = CanTalonJNI.new_doublep();
+    m_impl.GetDgain(m_profile, new SWIGTYPE_p_double(dp, true));
+    return CanTalonJNI.doublep_value(dp);
+  }
+
+  public double getF() {
+		if(!(m_controlMode.equals(ControlMode.Position) || m_controlMode.equals(ControlMode.Speed))) {
+			throw new IllegalStateException("PID mode only applies in Position and Speed modes.");
+		}
+
+    // Update the information that we have.
+    if (m_profile == 0)
+      m_impl.RequestParam(CanTalonSRX.param_t.eProfileParamSlot0_F);
+    else
+      m_impl.RequestParam(CanTalonSRX.param_t.eProfileParamSlot1_F);
+
+    long fp = CanTalonJNI.new_doublep();
+    m_impl.GetFgain(m_profile, new SWIGTYPE_p_double(fp, true));
+    return CanTalonJNI.doublep_value(fp);
+  }
+
+  public double getIZone() {
+		if(!(m_controlMode.equals(ControlMode.Position) || m_controlMode.equals(ControlMode.Speed))) {
+			throw new IllegalStateException("PID mode only applies in Position and Speed modes.");
+		}
+
+    // Update the information that we have.
+    if (m_profile == 0)
+      m_impl.RequestParam(CanTalonSRX.param_t.eProfileParamSlot0_IZone);
+    else
+      m_impl.RequestParam(CanTalonSRX.param_t.eProfileParamSlot1_IZone);
+
+    long fp = CanTalonJNI.new_intp();
+    m_impl.GetIzone(m_profile, new SWIGTYPE_p_int(fp, true));
+    return CanTalonJNI.intp_value(fp);
+  }
+
+  public double getRampRate() {
+		if(!(m_controlMode.equals(ControlMode.Position) || m_controlMode.equals(ControlMode.Speed))) {
+			throw new IllegalStateException("PID mode only applies in Position and Speed modes.");
+		}
+
+    // Update the information that we have.
+    if (m_profile == 0)
+      m_impl.RequestParam(CanTalonSRX.param_t.eProfileParamSlot0_CloseLoopRampRate);
+    else
+      m_impl.RequestParam(CanTalonSRX.param_t.eProfileParamSlot1_CloseLoopRampRate);
+
+    long fp = CanTalonJNI.new_intp();
+    m_impl.GetCloseLoopRampRate(m_profile, new SWIGTYPE_p_int(fp, true));
+    return CanTalonJNI.intp_value(fp);
+  }
+
+
+  public void setP(double p) {
+    m_impl.SetPgain(m_profile, p);
+  }
+
+  public void setI(double i) {
+    m_impl.SetIgain(m_profile, i);
+  }
+
+  public void setD(double d) {
+    m_impl.SetDgain(m_profile, d);
+  }
+
+  public void setF(double f) {
+    m_impl.SetFgain(m_profile, f);
+  }
+
+  public void setIZone(int izone) {
+    m_impl.SetIzone(m_profile, izone);
+  }
+
+  public void setRampRate(int rampRate) {
+    m_impl.SetCloseLoopRampRate(m_profile, rampRate);
+  }
+
+  /**
+   * Sets control values for closed loop control.
+   *
+   * @param p Proportional constant.
+   * @param i Integration constant.
+   * @param d Differential constant.
+   * @param f Feedforward constant.
+   * @param izone Integration zone -- prevents accumulation of integration error
+   *   with large errors. Setting this to zero will ignore any izone stuff.
+   * @param ramprate Closed loop ramp rate. Represents maximum change in
+   *   throttle every 10ms.
+   * @param profile which profile to set the pid constants for. You can have two
+   *   profiles, with values of 0 or 1, allowing you to keep a second set of values
+   *   on hand in the talon. In order to switch profiles without recalling setPID,
+   *   you must call setProfile().
+   */
+  public void setPID(double p, double i, double d, double f, int izone, int ramprate, int profile) {
+    if (profile != 0 && profile != 1)
+      throw new IllegalArgumentException("Talon PID profile must be 0 or 1.");
+    m_profile = profile;
+    setProfile(profile);
+    setP(p);
+    setI(i);
+    setD(d);
+    setF(f);
+    setIZone(izone);
+    setRampRate(ramprate);
+  }
+  public void setPID(double p, double i, double d) {
+    setPID(p, i, d, 0, 0, 0, m_profile);
+  }
+
+  /**
+   * Select which closed loop profile to use, and uses whatever PIDF gains and
+   * the such that are already there.
+   */
+  public void setProfile(int profile) {
+    if (profile != 0 && profile != 1)
+      throw new IllegalArgumentException("Talon PID profile must be 0 or 1.");
+    m_profile = profile;
+    m_impl.SetProfileSlotSelect(m_profile);
+  }
+
+        /**
 	* Common interface for stopping a motor.
 	*
 	* @deprecated Use disableControl instead.
@@ -103,6 +526,115 @@ public class CANTalon implements MotorSafety, PIDOutput, SpeedController {
 		return m_deviceNumber;
 	}
 
+  // TODO: Documentation for all these accessors/setters for misc. stuff.
+  public void setForwardSoftLimit(int forwardLimit) {
+    m_impl.SetForwardSoftLimit(forwardLimit);
+  }
+  
+  public void enableForwardSoftLimit(boolean enable) {
+    m_impl.SetForwardSoftEnable(enable ? 1 : 0);
+  }
+
+  public void setReverseSoftLimit(int forwardLimit) {
+    m_impl.SetReverseSoftLimit(forwardLimit);
+  }
+  
+  public void enableReverseSoftLimit(boolean enable) {
+    m_impl.SetReverseSoftEnable(enable ? 1 : 0);
+  }
+
+  public void clearStickyFaults() {
+    m_impl.ClearStickyFaults();
+  }
+
+  public void enableLimitSwitch(boolean forward, boolean reverse) {
+    int mask = 4 + (forward ? 1 : 0) * 2 + (reverse ? 1 : 0);
+    m_impl.SetOverrideLimitSwitchEn(mask);
+  }
+
+  public void enableBrakeMode(boolean brake) {
+    m_impl.SetOverrideBrakeType(brake ? 2 : 1);
+  }
+
+  public int getFaultOverTemp() {
+    long valuep = CanTalonJNI.new_intp();
+    m_impl.GetFault_OverTemp(new SWIGTYPE_p_int(valuep, true));
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+  public int getFaultUnderVoltage() {
+    long valuep = CanTalonJNI.new_intp();
+    m_impl.GetFault_UnderVoltage(new SWIGTYPE_p_int(valuep, true));
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+  public int getFaultForLim() {
+    long valuep = CanTalonJNI.new_intp();
+    m_impl.GetFault_ForLim(new SWIGTYPE_p_int(valuep, true));
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+  public int getFaultRevLim() {
+    long valuep = CanTalonJNI.new_intp();
+    m_impl.GetFault_RevLim(new SWIGTYPE_p_int(valuep, true));
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+  public int getFaultHardwareFailure() {
+    long valuep = CanTalonJNI.new_intp();
+    m_impl.GetFault_HardwareFailure(new SWIGTYPE_p_int(valuep, true));
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+  public int getFaultForSoftLim() {
+    long valuep = CanTalonJNI.new_intp();
+    m_impl.GetFault_ForSoftLim(new SWIGTYPE_p_int(valuep, true));
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+  public int getFaultRevSoftLim() {
+    long valuep = CanTalonJNI.new_intp();
+    m_impl.GetFault_RevSoftLim(new SWIGTYPE_p_int(valuep, true));
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+  public int getStickyFaultOverTemp() {
+    long valuep = CanTalonJNI.new_intp();
+    m_impl.GetStckyFault_OverTemp(new SWIGTYPE_p_int(valuep, true));
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+  public int getStickyFaultUnderVoltage() {
+    long valuep = CanTalonJNI.new_intp();
+    m_impl.GetStckyFault_UnderVoltage(new SWIGTYPE_p_int(valuep, true));
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+  public int getStickyFaultForLim() {
+    long valuep = CanTalonJNI.new_intp();
+    m_impl.GetStckyFault_ForLim(new SWIGTYPE_p_int(valuep, true));
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+  public int getStickyFaultRevLim() {
+    long valuep = CanTalonJNI.new_intp();
+    m_impl.GetStckyFault_RevLim(new SWIGTYPE_p_int(valuep, true));
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+  public int getStickyFaultForSoftLim() {
+    long valuep = CanTalonJNI.new_intp();
+    m_impl.GetStckyFault_ForSoftLim(new SWIGTYPE_p_int(valuep, true));
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+  public int getStickyFaultRevSoftLim() {
+    long valuep = CanTalonJNI.new_intp();
+    m_impl.GetStckyFault_RevSoftLim(new SWIGTYPE_p_int(valuep, true));
+    return CanTalonJNI.intp_value(valuep);
+  }
+
+
 	@Override
 	public void setExpiration(double timeout) {
 		m_safetyHelper.setExpiration(timeout);
diff --git a/wpilibj/wpilibJavaDevices/src/main/java/edu/wpi/first/wpilibj/CanTalonSRX.java b/wpilibj/wpilibJavaDevices/src/main/java/edu/wpi/first/wpilibj/CanTalonSRX.java
index 2cbb12da250ac86701ffdc81b48cd57a468523d0..43d9e4f8abf0c8179d11a49dbcbf0fe19c02691a 100644
--- a/wpilibj/wpilibJavaDevices/src/main/java/edu/wpi/first/wpilibj/CanTalonSRX.java
+++ b/wpilibj/wpilibJavaDevices/src/main/java/edu/wpi/first/wpilibj/CanTalonSRX.java
@@ -35,12 +35,16 @@ public class CanTalonSRX extends CtreCanNode {
     super.delete();
   }
 
+  public CanTalonSRX(int deviceNumber, int controlPeriodMs) {
+    this(CanTalonJNI.new_CanTalonSRX__SWIG_0(deviceNumber, controlPeriodMs), true);
+  }
+
   public CanTalonSRX(int deviceNumber) {
-    this(CanTalonJNI.new_CanTalonSRX__SWIG_0(deviceNumber), true);
+    this(CanTalonJNI.new_CanTalonSRX__SWIG_1(deviceNumber), true);
   }
 
   public CanTalonSRX() {
-    this(CanTalonJNI.new_CanTalonSRX__SWIG_1(), true);
+    this(CanTalonJNI.new_CanTalonSRX__SWIG_2(), true);
   }
 
   public void Set(double value) {
@@ -59,96 +63,96 @@ public class CanTalonSRX extends CtreCanNode {
     return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetParamResponse(swigCPtr, this, paramEnum.swigValue(), SWIGTYPE_p_double.getCPtr(value)), true);
   }
 
-  public SWIGTYPE_p_CTR_Code GetParamResponseInt32(CanTalonSRX.param_t paramEnum, SWIGTYPE_p_int32_t value) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetParamResponseInt32(swigCPtr, this, paramEnum.swigValue(), SWIGTYPE_p_int32_t.getCPtr(value)), true);
+  public SWIGTYPE_p_CTR_Code GetParamResponseInt32(CanTalonSRX.param_t paramEnum, SWIGTYPE_p_int value) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetParamResponseInt32(swigCPtr, this, paramEnum.swigValue(), SWIGTYPE_p_int.getCPtr(value)), true);
   }
 
-  public SWIGTYPE_p_CTR_Code SetPgain(SWIGTYPE_p_uint32_t slotIdx, double gain) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetPgain(swigCPtr, this, SWIGTYPE_p_uint32_t.getCPtr(slotIdx), gain), true);
+  public SWIGTYPE_p_CTR_Code SetPgain(long slotIdx, double gain) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetPgain(swigCPtr, this, slotIdx, gain), true);
   }
 
-  public SWIGTYPE_p_CTR_Code SetIgain(SWIGTYPE_p_uint32_t slotIdx, double gain) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetIgain(swigCPtr, this, SWIGTYPE_p_uint32_t.getCPtr(slotIdx), gain), true);
+  public SWIGTYPE_p_CTR_Code SetIgain(long slotIdx, double gain) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetIgain(swigCPtr, this, slotIdx, gain), true);
   }
 
-  public SWIGTYPE_p_CTR_Code SetDgain(SWIGTYPE_p_uint32_t slotIdx, double gain) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetDgain(swigCPtr, this, SWIGTYPE_p_uint32_t.getCPtr(slotIdx), gain), true);
+  public SWIGTYPE_p_CTR_Code SetDgain(long slotIdx, double gain) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetDgain(swigCPtr, this, slotIdx, gain), true);
   }
 
-  public SWIGTYPE_p_CTR_Code SetFgain(SWIGTYPE_p_uint32_t slotIdx, double gain) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetFgain(swigCPtr, this, SWIGTYPE_p_uint32_t.getCPtr(slotIdx), gain), true);
+  public SWIGTYPE_p_CTR_Code SetFgain(long slotIdx, double gain) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetFgain(swigCPtr, this, slotIdx, gain), true);
   }
 
-  public SWIGTYPE_p_CTR_Code SetIzone(SWIGTYPE_p_uint32_t slotIdx, SWIGTYPE_p_int32_t zone) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetIzone(swigCPtr, this, SWIGTYPE_p_uint32_t.getCPtr(slotIdx), SWIGTYPE_p_int32_t.getCPtr(zone)), true);
+  public SWIGTYPE_p_CTR_Code SetIzone(long slotIdx, int zone) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetIzone(swigCPtr, this, slotIdx, zone), true);
   }
 
-  public SWIGTYPE_p_CTR_Code SetCloseLoopRampRate(SWIGTYPE_p_uint32_t slotIdx, SWIGTYPE_p_int32_t closeLoopRampRate) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetCloseLoopRampRate(swigCPtr, this, SWIGTYPE_p_uint32_t.getCPtr(slotIdx), SWIGTYPE_p_int32_t.getCPtr(closeLoopRampRate)), true);
+  public SWIGTYPE_p_CTR_Code SetCloseLoopRampRate(long slotIdx, int closeLoopRampRate) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetCloseLoopRampRate(swigCPtr, this, slotIdx, closeLoopRampRate), true);
   }
 
-  public SWIGTYPE_p_CTR_Code SetSensorPosition(SWIGTYPE_p_int32_t pos) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetSensorPosition(swigCPtr, this, SWIGTYPE_p_int32_t.getCPtr(pos)), true);
+  public SWIGTYPE_p_CTR_Code SetSensorPosition(int pos) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetSensorPosition(swigCPtr, this, pos), true);
   }
 
-  public SWIGTYPE_p_CTR_Code SetForwardSoftLimit(SWIGTYPE_p_int32_t forwardLimit) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetForwardSoftLimit(swigCPtr, this, SWIGTYPE_p_int32_t.getCPtr(forwardLimit)), true);
+  public SWIGTYPE_p_CTR_Code SetForwardSoftLimit(int forwardLimit) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetForwardSoftLimit(swigCPtr, this, forwardLimit), true);
   }
 
-  public SWIGTYPE_p_CTR_Code SetReverseSoftLimit(SWIGTYPE_p_int32_t reverseLimit) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetReverseSoftLimit(swigCPtr, this, SWIGTYPE_p_int32_t.getCPtr(reverseLimit)), true);
+  public SWIGTYPE_p_CTR_Code SetReverseSoftLimit(int reverseLimit) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetReverseSoftLimit(swigCPtr, this, reverseLimit), true);
   }
 
-  public SWIGTYPE_p_CTR_Code SetForwardSoftEnable(SWIGTYPE_p_int32_t enable) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetForwardSoftEnable(swigCPtr, this, SWIGTYPE_p_int32_t.getCPtr(enable)), true);
+  public SWIGTYPE_p_CTR_Code SetForwardSoftEnable(int enable) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetForwardSoftEnable(swigCPtr, this, enable), true);
   }
 
-  public SWIGTYPE_p_CTR_Code SetReverseSoftEnable(SWIGTYPE_p_int32_t enable) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetReverseSoftEnable(swigCPtr, this, SWIGTYPE_p_int32_t.getCPtr(enable)), true);
+  public SWIGTYPE_p_CTR_Code SetReverseSoftEnable(int enable) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetReverseSoftEnable(swigCPtr, this, enable), true);
   }
 
-  public SWIGTYPE_p_CTR_Code GetPgain(SWIGTYPE_p_uint32_t slotIdx, SWIGTYPE_p_double gain) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetPgain(swigCPtr, this, SWIGTYPE_p_uint32_t.getCPtr(slotIdx), SWIGTYPE_p_double.getCPtr(gain)), true);
+  public SWIGTYPE_p_CTR_Code GetPgain(long slotIdx, SWIGTYPE_p_double gain) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetPgain(swigCPtr, this, slotIdx, SWIGTYPE_p_double.getCPtr(gain)), true);
   }
 
-  public SWIGTYPE_p_CTR_Code GetIgain(SWIGTYPE_p_uint32_t slotIdx, SWIGTYPE_p_double gain) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetIgain(swigCPtr, this, SWIGTYPE_p_uint32_t.getCPtr(slotIdx), SWIGTYPE_p_double.getCPtr(gain)), true);
+  public SWIGTYPE_p_CTR_Code GetIgain(long slotIdx, SWIGTYPE_p_double gain) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetIgain(swigCPtr, this, slotIdx, SWIGTYPE_p_double.getCPtr(gain)), true);
   }
 
-  public SWIGTYPE_p_CTR_Code GetDgain(SWIGTYPE_p_uint32_t slotIdx, SWIGTYPE_p_double gain) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetDgain(swigCPtr, this, SWIGTYPE_p_uint32_t.getCPtr(slotIdx), SWIGTYPE_p_double.getCPtr(gain)), true);
+  public SWIGTYPE_p_CTR_Code GetDgain(long slotIdx, SWIGTYPE_p_double gain) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetDgain(swigCPtr, this, slotIdx, SWIGTYPE_p_double.getCPtr(gain)), true);
   }
 
-  public SWIGTYPE_p_CTR_Code GetFgain(SWIGTYPE_p_uint32_t slotIdx, SWIGTYPE_p_double gain) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetFgain(swigCPtr, this, SWIGTYPE_p_uint32_t.getCPtr(slotIdx), SWIGTYPE_p_double.getCPtr(gain)), true);
+  public SWIGTYPE_p_CTR_Code GetFgain(long slotIdx, SWIGTYPE_p_double gain) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetFgain(swigCPtr, this, slotIdx, SWIGTYPE_p_double.getCPtr(gain)), true);
   }
 
-  public SWIGTYPE_p_CTR_Code GetIzone(SWIGTYPE_p_uint32_t slotIdx, SWIGTYPE_p_int32_t zone) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetIzone(swigCPtr, this, SWIGTYPE_p_uint32_t.getCPtr(slotIdx), SWIGTYPE_p_int32_t.getCPtr(zone)), true);
+  public SWIGTYPE_p_CTR_Code GetIzone(long slotIdx, SWIGTYPE_p_int zone) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetIzone(swigCPtr, this, slotIdx, SWIGTYPE_p_int.getCPtr(zone)), true);
   }
 
-  public SWIGTYPE_p_CTR_Code GetCloseLoopRampRate(SWIGTYPE_p_uint32_t slotIdx, SWIGTYPE_p_int32_t closeLoopRampRate) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetCloseLoopRampRate(swigCPtr, this, SWIGTYPE_p_uint32_t.getCPtr(slotIdx), SWIGTYPE_p_int32_t.getCPtr(closeLoopRampRate)), true);
+  public SWIGTYPE_p_CTR_Code GetCloseLoopRampRate(long slotIdx, SWIGTYPE_p_int closeLoopRampRate) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetCloseLoopRampRate(swigCPtr, this, slotIdx, SWIGTYPE_p_int.getCPtr(closeLoopRampRate)), true);
   }
 
-  public SWIGTYPE_p_CTR_Code GetForwardSoftLimit(SWIGTYPE_p_int32_t forwardLimit) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetForwardSoftLimit(swigCPtr, this, SWIGTYPE_p_int32_t.getCPtr(forwardLimit)), true);
+  public SWIGTYPE_p_CTR_Code GetForwardSoftLimit(SWIGTYPE_p_int forwardLimit) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetForwardSoftLimit(swigCPtr, this, SWIGTYPE_p_int.getCPtr(forwardLimit)), true);
   }
 
-  public SWIGTYPE_p_CTR_Code GetReverseSoftLimit(SWIGTYPE_p_int32_t reverseLimit) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetReverseSoftLimit(swigCPtr, this, SWIGTYPE_p_int32_t.getCPtr(reverseLimit)), true);
+  public SWIGTYPE_p_CTR_Code GetReverseSoftLimit(SWIGTYPE_p_int reverseLimit) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetReverseSoftLimit(swigCPtr, this, SWIGTYPE_p_int.getCPtr(reverseLimit)), true);
   }
 
-  public SWIGTYPE_p_CTR_Code GetForwardSoftEnable(SWIGTYPE_p_int32_t enable) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetForwardSoftEnable(swigCPtr, this, SWIGTYPE_p_int32_t.getCPtr(enable)), true);
+  public SWIGTYPE_p_CTR_Code GetForwardSoftEnable(SWIGTYPE_p_int enable) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetForwardSoftEnable(swigCPtr, this, SWIGTYPE_p_int.getCPtr(enable)), true);
   }
 
-  public SWIGTYPE_p_CTR_Code GetReverseSoftEnable(SWIGTYPE_p_int32_t enable) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetReverseSoftEnable(swigCPtr, this, SWIGTYPE_p_int32_t.getCPtr(enable)), true);
+  public SWIGTYPE_p_CTR_Code GetReverseSoftEnable(SWIGTYPE_p_int enable) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_GetReverseSoftEnable(swigCPtr, this, SWIGTYPE_p_int.getCPtr(enable)), true);
   }
 
-  public SWIGTYPE_p_CTR_Code SetStatusFrameRate(SWIGTYPE_p_uint32_t frameEnum, SWIGTYPE_p_uint8_t periodMs) {
-    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetStatusFrameRate(swigCPtr, this, SWIGTYPE_p_uint32_t.getCPtr(frameEnum), SWIGTYPE_p_uint8_t.getCPtr(periodMs)), true);
+  public SWIGTYPE_p_CTR_Code SetStatusFrameRate(long frameEnum, long periodMs) {
+    return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetStatusFrameRate(swigCPtr, this, frameEnum, periodMs), true);
   }
 
   public SWIGTYPE_p_CTR_Code ClearStickyFaults() {
@@ -339,6 +343,7 @@ public class CanTalonSRX extends CtreCanNode {
     return new SWIGTYPE_p_CTR_Code(CanTalonJNI.CanTalonSRX_SetRevFeedbackSensor(swigCPtr, this, param), true);
   }
 
+  public final static int kDefaultControlPeriodMs = CanTalonJNI.CanTalonSRX_kDefaultControlPeriodMs_get();
   public final static int kMode_DutyCycle = CanTalonJNI.CanTalonSRX_kMode_DutyCycle_get();
   public final static int kMode_PositionCloseLoop = CanTalonJNI.CanTalonSRX_kMode_PositionCloseLoop_get();
   public final static int kMode_VelocityCloseLoop = CanTalonJNI.CanTalonSRX_kMode_VelocityCloseLoop_get();
diff --git a/wpilibj/wpilibJavaDevices/src/main/java/edu/wpi/first/wpilibj/hal/CanTalonJNI.java b/wpilibj/wpilibJavaDevices/src/main/java/edu/wpi/first/wpilibj/hal/CanTalonJNI.java
index 030312e9f7841b441899a501e5cb06b7cad9b2d4..0267615689293c63c9e861cd3f362d3e378fba55 100644
--- a/wpilibj/wpilibJavaDevices/src/main/java/edu/wpi/first/wpilibj/hal/CanTalonJNI.java
+++ b/wpilibj/wpilibJavaDevices/src/main/java/edu/wpi/first/wpilibj/hal/CanTalonJNI.java
@@ -19,6 +19,26 @@ public class CanTalonJNI {
   public final static native void delete_intp(long jarg1);
   public final static native void intp_assign(long jarg1, int jarg2);
   public final static native int intp_value(long jarg1);
+  public final static native long new_uint32_tp();
+  public final static native long copy_uint32_tp(long jarg1);
+  public final static native void delete_uint32_tp(long jarg1);
+  public final static native void uint32_tp_assign(long jarg1, long jarg2);
+  public final static native long uint32_tp_value(long jarg1);
+  public final static native long new_int32_tp();
+  public final static native long copy_int32_tp(long jarg1);
+  public final static native void delete_int32_tp(long jarg1);
+  public final static native void int32_tp_assign(long jarg1, long jarg2);
+  public final static native long int32_tp_value(long jarg1);
+  public final static native long new_uint8_tp();
+  public final static native long copy_uint8_tp(long jarg1);
+  public final static native void delete_uint8_tp(long jarg1);
+  public final static native void uint8_tp_assign(long jarg1, long jarg2);
+  public final static native long uint8_tp_value(long jarg1);
+  public final static native long new_CTR_Codep();
+  public final static native long copy_CTR_Codep(long jarg1);
+  public final static native void delete_CTR_Codep(long jarg1);
+  public final static native void CTR_Codep_assign(long jarg1, long jarg2);
+  public final static native long CTR_Codep_value(long jarg1);
   public final static native long new_floatp();
   public final static native long copy_floatp(float jarg1);
   public final static native void delete_floatp(long jarg1);
@@ -27,8 +47,10 @@ public class CanTalonJNI {
   public final static native long new_CtreCanNode(long jarg1);
   public final static native void delete_CtreCanNode(long jarg1);
   public final static native long CtreCanNode_GetDeviceNumber(long jarg1, CtreCanNode jarg1_);
-  public final static native long new_CanTalonSRX__SWIG_0(int jarg1);
-  public final static native long new_CanTalonSRX__SWIG_1();
+  public final static native int CanTalonSRX_kDefaultControlPeriodMs_get();
+  public final static native long new_CanTalonSRX__SWIG_0(int jarg1, int jarg2);
+  public final static native long new_CanTalonSRX__SWIG_1(int jarg1);
+  public final static native long new_CanTalonSRX__SWIG_2();
   public final static native void delete_CanTalonSRX(long jarg1);
   public final static native void CanTalonSRX_Set(long jarg1, CanTalonSRX jarg1_, double jarg2);
   public final static native int CanTalonSRX_kMode_DutyCycle_get();
@@ -129,13 +151,13 @@ public class CanTalonJNI {
   public final static native long CanTalonSRX_SetIgain(long jarg1, CanTalonSRX jarg1_, long jarg2, double jarg3);
   public final static native long CanTalonSRX_SetDgain(long jarg1, CanTalonSRX jarg1_, long jarg2, double jarg3);
   public final static native long CanTalonSRX_SetFgain(long jarg1, CanTalonSRX jarg1_, long jarg2, double jarg3);
-  public final static native long CanTalonSRX_SetIzone(long jarg1, CanTalonSRX jarg1_, long jarg2, long jarg3);
-  public final static native long CanTalonSRX_SetCloseLoopRampRate(long jarg1, CanTalonSRX jarg1_, long jarg2, long jarg3);
-  public final static native long CanTalonSRX_SetSensorPosition(long jarg1, CanTalonSRX jarg1_, long jarg2);
-  public final static native long CanTalonSRX_SetForwardSoftLimit(long jarg1, CanTalonSRX jarg1_, long jarg2);
-  public final static native long CanTalonSRX_SetReverseSoftLimit(long jarg1, CanTalonSRX jarg1_, long jarg2);
-  public final static native long CanTalonSRX_SetForwardSoftEnable(long jarg1, CanTalonSRX jarg1_, long jarg2);
-  public final static native long CanTalonSRX_SetReverseSoftEnable(long jarg1, CanTalonSRX jarg1_, long jarg2);
+  public final static native long CanTalonSRX_SetIzone(long jarg1, CanTalonSRX jarg1_, long jarg2, int jarg3);
+  public final static native long CanTalonSRX_SetCloseLoopRampRate(long jarg1, CanTalonSRX jarg1_, long jarg2, int jarg3);
+  public final static native long CanTalonSRX_SetSensorPosition(long jarg1, CanTalonSRX jarg1_, int jarg2);
+  public final static native long CanTalonSRX_SetForwardSoftLimit(long jarg1, CanTalonSRX jarg1_, int jarg2);
+  public final static native long CanTalonSRX_SetReverseSoftLimit(long jarg1, CanTalonSRX jarg1_, int jarg2);
+  public final static native long CanTalonSRX_SetForwardSoftEnable(long jarg1, CanTalonSRX jarg1_, int jarg2);
+  public final static native long CanTalonSRX_SetReverseSoftEnable(long jarg1, CanTalonSRX jarg1_, int jarg2);
   public final static native long CanTalonSRX_GetPgain(long jarg1, CanTalonSRX jarg1_, long jarg2, long jarg3);
   public final static native long CanTalonSRX_GetIgain(long jarg1, CanTalonSRX jarg1_, long jarg2, long jarg3);
   public final static native long CanTalonSRX_GetDgain(long jarg1, CanTalonSRX jarg1_, long jarg2, long jarg3);
diff --git a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/CANTalonTest.java b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/CANTalonTest.java
index 7e9f1358d5adad33ca3c650d232c043f8d82fd24..d17d17dd942e58b50dbdbfe61cb0ef72dbb8e432 100644
--- a/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/CANTalonTest.java
+++ b/wpilibj/wpilibJavaIntegrationTests/src/main/java/edu/wpi/first/wpilibj/CANTalonTest.java
@@ -52,32 +52,82 @@ public class CANTalonTest extends AbstractComsSetup {
 		fixture.teardown();
 	}
 
+  private String errorMessage(double actual, double expected) {
+    String start = "Actual value was: ";
+    start += actual;
+    start += " Expected: ";
+    start += expected;
+    return start;
+  }
+
 	/**
    * Briefly run a CAN Talon and assert true.
 	 */
 	@Test
-	public void test() {
-    // The constructor takes a device ID (settable in roboRIO web interface).
-    CanTalonSRX talon = new CanTalonSRX(0);
-    // Make sure that the Talon is in the basic throttle mode.
-    talon.SetModeSelect(0);
-    // Set Talon to 50% forwards throttle.
-    talon.Set(0.5);
-    long currentp = CanTalonJNI.new_doublep();//new SWIGTYPE_p_double(, true);
-    talon.GetTemp(new SWIGTYPE_p_double(currentp, true));
-    System.out.println(CanTalonJNI.doublep_value(currentp));
-    Timer.delay(1.5);
-    // Turn Talon off.
-    talon.Set(0.0);
-		assertTrue(true);
-
-    Timer.delay(2);
+	public void throttle() {
+    double throttle = 0.1;
     CANTalon tal = new CANTalon(0);
-    tal.enableControl();
-    tal.set(0.5);
-    System.out.println(tal.getTemp());
-    Timer.delay(1.0);
+    tal.set(throttle);
+    Timer.delay(5.0);
+    assertTrue(errorMessage(tal.get(), throttle), Math.abs(throttle - tal.get()) < 1e-2);
+
+    tal.set(-throttle);
+    Timer.delay(1.25);
+    assertTrue(errorMessage(tal.get(), -throttle), Math.abs(throttle + tal.get()) < 1e-2);
+    tal.reverseOutput(true);
+    tal.set(-throttle);
+    Timer.delay(1.25);
+    assertTrue(errorMessage(tal.get(), -throttle), Math.abs(throttle + tal.get()) < 1e-2);
+
     tal.disable();
+    Timer.delay(0.2);
+    assertTrue(errorMessage(tal.get(), 0.0), Math.abs(tal.get()) < 1e-10);
 	}
 
+  @Test
+  public void SetGetPID() {
+    CANTalon talon = new CANTalon(0);
+    talon.changeControlMode(CANTalon.ControlMode.Position);
+    double p = 0.05, i = 0.098, d = 1.23;
+    talon.setPID(p, i , d);
+    assertTrue(errorMessage(talon.getP(), p), Math.abs(p - talon.getP()) < 1e-5);
+    assertTrue(errorMessage(talon.getI(), i), Math.abs(i - talon.getI()) < 1e-5);
+    assertTrue(errorMessage(talon.getD(), d), Math.abs(d - talon.getD()) < 1e-5);
+    // Test with new values in case the talon was already set to the previous ones.
+    p = 0.15;
+    i = 0.198;
+    d = 1.03;
+    talon.setPID(p, i , d);
+    assertTrue(errorMessage(talon.getP(), p), Math.abs(p - talon.getP()) < 1e-5);
+    assertTrue(errorMessage(talon.getI(), i), Math.abs(i - talon.getI()) < 1e-5);
+    assertTrue(errorMessage(talon.getD(), d), Math.abs(d - talon.getD()) < 1e-5);
+  }
+
+  @Test
+  public void positionModeWorks() {
+    CANTalon talon = new CANTalon(0);
+    talon.changeControlMode(CANTalon.ControlMode.Position);
+    talon.setFeedbackDevice(CANTalon.FeedbackDevice.AnalogPot);
+    Timer.delay(0.2);
+    double p = 1.0, i = 0.0, d = 0.00;
+    talon.setPID(p, i , d);
+    talon.set(100);
+    Timer.delay(5.0);
+    talon.reverseOutput(true);
+    Timer.delay(5.0);
+    //assertTrue(errorMessage(talon.get(), 100), Math.abs(100 - talon.get()) < 10);
+    assertTrue(true);
+  }
+
+  @Test
+  public void testBrake() {
+    CANTalon talon = new CANTalon(0);
+    for (int i = 0; i < 5; i++) {
+      talon.enableBrakeMode(true);
+      Timer.delay(0.5);
+      talon.enableBrakeMode(false);
+      Timer.delay(0.5);
+    }
+  }
+
 }
diff --git a/wpilibj/wpilibJavaJNI/lib/CanTalonSRXJNI.cpp b/wpilibj/wpilibJavaJNI/lib/CanTalonSRXJNI.cpp
index d8e0ee9f0fc034bc99a40137b5832a15ad11528b..539f2ff6e9724c50001f2bdc1b694b96b0fe7a2b 100644
--- a/wpilibj/wpilibJavaJNI/lib/CanTalonSRXJNI.cpp
+++ b/wpilibj/wpilibJavaJNI/lib/CanTalonSRXJNI.cpp
@@ -256,6 +256,90 @@ static int intp_value(int *obj) {
 }
 
 
+static uint32_t *new_uint32_tp() { 
+  return new uint32_t(); 
+}
+
+static uint32_t *copy_uint32_tp(uint32_t value) { 
+  return new uint32_t(value); 
+}
+
+static void delete_uint32_tp(uint32_t *obj) { 
+  if (obj) delete obj; 
+}
+
+static void uint32_tp_assign(uint32_t *obj, uint32_t value) {
+  *obj = value;
+}
+
+static uint32_t uint32_tp_value(uint32_t *obj) {
+  return *obj;
+}
+
+
+static int32_t *new_int32_tp() { 
+  return new int32_t(); 
+}
+
+static int32_t *copy_int32_tp(int32_t value) { 
+  return new int32_t(value); 
+}
+
+static void delete_int32_tp(int32_t *obj) { 
+  if (obj) delete obj; 
+}
+
+static void int32_tp_assign(int32_t *obj, int32_t value) {
+  *obj = value;
+}
+
+static int32_t int32_tp_value(int32_t *obj) {
+  return *obj;
+}
+
+
+static uint8_t *new_uint8_tp() { 
+  return new uint8_t(); 
+}
+
+static uint8_t *copy_uint8_tp(uint8_t value) { 
+  return new uint8_t(value); 
+}
+
+static void delete_uint8_tp(uint8_t *obj) { 
+  if (obj) delete obj; 
+}
+
+static void uint8_tp_assign(uint8_t *obj, uint8_t value) {
+  *obj = value;
+}
+
+static uint8_t uint8_tp_value(uint8_t *obj) {
+  return *obj;
+}
+
+
+static CTR_Code *new_CTR_Codep() { 
+  return new CTR_Code(); 
+}
+
+static CTR_Code *copy_CTR_Codep(CTR_Code value) { 
+  return new CTR_Code(value); 
+}
+
+static void delete_CTR_Codep(CTR_Code *obj) { 
+  if (obj) delete obj; 
+}
+
+static void CTR_Codep_assign(CTR_Code *obj, CTR_Code value) {
+  *obj = value;
+}
+
+static CTR_Code CTR_Codep_value(CTR_Code *obj) {
+  return *obj;
+}
+
+
 static float *new_floatp() { 
   return new float(); 
 }
@@ -405,6 +489,302 @@ SWIGEXPORT jint JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_intp_1value(J
 }
 
 
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_new_1uint32_1tp(JNIEnv *jenv, jclass jcls) {
+  jlong jresult = 0 ;
+  uint32_t *result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  result = (uint32_t *)new_uint32_tp();
+  *(uint32_t **)&jresult = result; 
+  return jresult;
+}
+
+
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_copy_1uint32_1tp(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+  jlong jresult = 0 ;
+  uint32_t arg1 ;
+  uint32_t *argp1 ;
+  uint32_t *result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  argp1 = *(uint32_t **)&jarg1; 
+  if (!argp1) {
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint32_t");
+    return 0;
+  }
+  arg1 = *argp1; 
+  result = (uint32_t *)copy_uint32_tp(arg1);
+  *(uint32_t **)&jresult = result; 
+  return jresult;
+}
+
+
+SWIGEXPORT void JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_delete_1uint32_1tp(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+  uint32_t *arg1 = (uint32_t *) 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  arg1 = *(uint32_t **)&jarg1; 
+  delete_uint32_tp(arg1);
+}
+
+
+SWIGEXPORT void JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_uint32_1tp_1assign(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2) {
+  uint32_t *arg1 = (uint32_t *) 0 ;
+  uint32_t arg2 ;
+  uint32_t *argp2 ;
+  
+  (void)jenv;
+  (void)jcls;
+  arg1 = *(uint32_t **)&jarg1; 
+  argp2 = *(uint32_t **)&jarg2; 
+  if (!argp2) {
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint32_t");
+    return ;
+  }
+  arg2 = *argp2; 
+  uint32_tp_assign(arg1,arg2);
+}
+
+
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_uint32_1tp_1value(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+  jlong jresult = 0 ;
+  uint32_t *arg1 = (uint32_t *) 0 ;
+  uint32_t result;
+  
+  (void)jenv;
+  (void)jcls;
+  arg1 = *(uint32_t **)&jarg1; 
+  result = uint32_tp_value(arg1);
+  *(uint32_t **)&jresult = new uint32_t((const uint32_t &)result); 
+  return jresult;
+}
+
+
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_new_1int32_1tp(JNIEnv *jenv, jclass jcls) {
+  jlong jresult = 0 ;
+  int32_t *result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  result = (int32_t *)new_int32_tp();
+  *(int32_t **)&jresult = result; 
+  return jresult;
+}
+
+
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_copy_1int32_1tp(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+  jlong jresult = 0 ;
+  int32_t arg1 ;
+  int32_t *argp1 ;
+  int32_t *result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  argp1 = *(int32_t **)&jarg1; 
+  if (!argp1) {
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null int32_t");
+    return 0;
+  }
+  arg1 = *argp1; 
+  result = (int32_t *)copy_int32_tp(arg1);
+  *(int32_t **)&jresult = result; 
+  return jresult;
+}
+
+
+SWIGEXPORT void JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_delete_1int32_1tp(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+  int32_t *arg1 = (int32_t *) 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  arg1 = *(int32_t **)&jarg1; 
+  delete_int32_tp(arg1);
+}
+
+
+SWIGEXPORT void JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_int32_1tp_1assign(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2) {
+  int32_t *arg1 = (int32_t *) 0 ;
+  int32_t arg2 ;
+  int32_t *argp2 ;
+  
+  (void)jenv;
+  (void)jcls;
+  arg1 = *(int32_t **)&jarg1; 
+  argp2 = *(int32_t **)&jarg2; 
+  if (!argp2) {
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null int32_t");
+    return ;
+  }
+  arg2 = *argp2; 
+  int32_tp_assign(arg1,arg2);
+}
+
+
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_int32_1tp_1value(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+  jlong jresult = 0 ;
+  int32_t *arg1 = (int32_t *) 0 ;
+  int32_t result;
+  
+  (void)jenv;
+  (void)jcls;
+  arg1 = *(int32_t **)&jarg1; 
+  result = int32_tp_value(arg1);
+  *(int32_t **)&jresult = new int32_t((const int32_t &)result); 
+  return jresult;
+}
+
+
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_new_1uint8_1tp(JNIEnv *jenv, jclass jcls) {
+  jlong jresult = 0 ;
+  uint8_t *result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  result = (uint8_t *)new_uint8_tp();
+  *(uint8_t **)&jresult = result; 
+  return jresult;
+}
+
+
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_copy_1uint8_1tp(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+  jlong jresult = 0 ;
+  uint8_t arg1 ;
+  uint8_t *argp1 ;
+  uint8_t *result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  argp1 = *(uint8_t **)&jarg1; 
+  if (!argp1) {
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint8_t");
+    return 0;
+  }
+  arg1 = *argp1; 
+  result = (uint8_t *)copy_uint8_tp(arg1);
+  *(uint8_t **)&jresult = result; 
+  return jresult;
+}
+
+
+SWIGEXPORT void JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_delete_1uint8_1tp(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+  uint8_t *arg1 = (uint8_t *) 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  arg1 = *(uint8_t **)&jarg1; 
+  delete_uint8_tp(arg1);
+}
+
+
+SWIGEXPORT void JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_uint8_1tp_1assign(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2) {
+  uint8_t *arg1 = (uint8_t *) 0 ;
+  uint8_t arg2 ;
+  uint8_t *argp2 ;
+  
+  (void)jenv;
+  (void)jcls;
+  arg1 = *(uint8_t **)&jarg1; 
+  argp2 = *(uint8_t **)&jarg2; 
+  if (!argp2) {
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint8_t");
+    return ;
+  }
+  arg2 = *argp2; 
+  uint8_tp_assign(arg1,arg2);
+}
+
+
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_uint8_1tp_1value(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+  jlong jresult = 0 ;
+  uint8_t *arg1 = (uint8_t *) 0 ;
+  uint8_t result;
+  
+  (void)jenv;
+  (void)jcls;
+  arg1 = *(uint8_t **)&jarg1; 
+  result = uint8_tp_value(arg1);
+  *(uint8_t **)&jresult = new uint8_t((const uint8_t &)result); 
+  return jresult;
+}
+
+
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_new_1CTR_1Codep(JNIEnv *jenv, jclass jcls) {
+  jlong jresult = 0 ;
+  CTR_Code *result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  result = (CTR_Code *)new_CTR_Codep();
+  *(CTR_Code **)&jresult = result; 
+  return jresult;
+}
+
+
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_copy_1CTR_1Codep(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+  jlong jresult = 0 ;
+  CTR_Code arg1 ;
+  CTR_Code *argp1 ;
+  CTR_Code *result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  argp1 = *(CTR_Code **)&jarg1; 
+  if (!argp1) {
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null CTR_Code");
+    return 0;
+  }
+  arg1 = *argp1; 
+  result = (CTR_Code *)copy_CTR_Codep(arg1);
+  *(CTR_Code **)&jresult = result; 
+  return jresult;
+}
+
+
+SWIGEXPORT void JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_delete_1CTR_1Codep(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+  CTR_Code *arg1 = (CTR_Code *) 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  arg1 = *(CTR_Code **)&jarg1; 
+  delete_CTR_Codep(arg1);
+}
+
+
+SWIGEXPORT void JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CTR_1Codep_1assign(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2) {
+  CTR_Code *arg1 = (CTR_Code *) 0 ;
+  CTR_Code arg2 ;
+  CTR_Code *argp2 ;
+  
+  (void)jenv;
+  (void)jcls;
+  arg1 = *(CTR_Code **)&jarg1; 
+  argp2 = *(CTR_Code **)&jarg2; 
+  if (!argp2) {
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null CTR_Code");
+    return ;
+  }
+  arg2 = *argp2; 
+  CTR_Codep_assign(arg1,arg2);
+}
+
+
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CTR_1Codep_1value(JNIEnv *jenv, jclass jcls, jlong jarg1) {
+  jlong jresult = 0 ;
+  CTR_Code *arg1 = (CTR_Code *) 0 ;
+  CTR_Code result;
+  
+  (void)jenv;
+  (void)jcls;
+  arg1 = *(CTR_Code **)&jarg1; 
+  result = CTR_Codep_value(arg1);
+  *(CTR_Code **)&jresult = new CTR_Code((const CTR_Code &)result); 
+  return jresult;
+}
+
+
 SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_new_1floatp(JNIEnv *jenv, jclass jcls) {
   jlong jresult = 0 ;
   float *result = 0 ;
@@ -512,7 +892,35 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CtreCanNode_
 }
 
 
-SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_new_1CanTalonSRX_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jint jarg1) {
+SWIGEXPORT jint JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1kDefaultControlPeriodMs_1get(JNIEnv *jenv, jclass jcls) {
+  jint jresult = 0 ;
+  int result;
+  
+  (void)jenv;
+  (void)jcls;
+  result = (int)CanTalonSRX::kDefaultControlPeriodMs;
+  jresult = (jint)result; 
+  return jresult;
+}
+
+
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_new_1CanTalonSRX_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jint jarg1, jint jarg2) {
+  jlong jresult = 0 ;
+  int arg1 ;
+  int arg2 ;
+  CanTalonSRX *result = 0 ;
+  
+  (void)jenv;
+  (void)jcls;
+  arg1 = (int)jarg1; 
+  arg2 = (int)jarg2; 
+  result = (CanTalonSRX *)new CanTalonSRX(arg1,arg2);
+  *(CanTalonSRX **)&jresult = result; 
+  return jresult;
+}
+
+
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_new_1CanTalonSRX_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jint jarg1) {
   jlong jresult = 0 ;
   int arg1 ;
   CanTalonSRX *result = 0 ;
@@ -526,7 +934,7 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_new_1CanTalo
 }
 
 
-SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_new_1CanTalonSRX_1_1SWIG_11(JNIEnv *jenv, jclass jcls) {
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_new_1CanTalonSRX_1_1SWIG_12(JNIEnv *jenv, jclass jcls) {
   jlong jresult = 0 ;
   CanTalonSRX *result = 0 ;
   
@@ -1704,7 +2112,7 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
   CanTalonSRX::param_t arg2 ;
-  int32_t *arg3 = 0 ;
+  int *arg3 = 0 ;
   CTR_Code result;
   
   (void)jenv;
@@ -1712,9 +2120,9 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
   arg2 = (CanTalonSRX::param_t)jarg2; 
-  arg3 = *(int32_t **)&jarg3;
+  arg3 = *(int **)&jarg3;
   if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int32_t & reference is null");
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int & reference is null");
     return 0;
   } 
   result = (arg1)->GetParamResponseInt32(arg2,*arg3);
@@ -1726,21 +2134,15 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
 SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetPgain(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jdouble jarg3) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  uint32_t arg2 ;
+  unsigned int arg2 ;
   double arg3 ;
-  uint32_t *argp2 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(uint32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
+  arg2 = (unsigned int)jarg2; 
   arg3 = (double)jarg3; 
   result = (arg1)->SetPgain(arg2,arg3);
   *(CTR_Code **)&jresult = new CTR_Code((const CTR_Code &)result); 
@@ -1751,21 +2153,15 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
 SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetIgain(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jdouble jarg3) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  uint32_t arg2 ;
+  unsigned int arg2 ;
   double arg3 ;
-  uint32_t *argp2 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(uint32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
+  arg2 = (unsigned int)jarg2; 
   arg3 = (double)jarg3; 
   result = (arg1)->SetIgain(arg2,arg3);
   *(CTR_Code **)&jresult = new CTR_Code((const CTR_Code &)result); 
@@ -1776,21 +2172,15 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
 SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetDgain(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jdouble jarg3) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  uint32_t arg2 ;
+  unsigned int arg2 ;
   double arg3 ;
-  uint32_t *argp2 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(uint32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
+  arg2 = (unsigned int)jarg2; 
   arg3 = (double)jarg3; 
   result = (arg1)->SetDgain(arg2,arg3);
   *(CTR_Code **)&jresult = new CTR_Code((const CTR_Code &)result); 
@@ -1801,21 +2191,15 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
 SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetFgain(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jdouble jarg3) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  uint32_t arg2 ;
+  unsigned int arg2 ;
   double arg3 ;
-  uint32_t *argp2 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(uint32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
+  arg2 = (unsigned int)jarg2; 
   arg3 = (double)jarg3; 
   result = (arg1)->SetFgain(arg2,arg3);
   *(CTR_Code **)&jresult = new CTR_Code((const CTR_Code &)result); 
@@ -1823,177 +2207,123 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
 }
 
 
-SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetIzone(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3) {
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetIzone(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jint jarg3) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  uint32_t arg2 ;
-  int32_t arg3 ;
-  uint32_t *argp2 ;
-  int32_t *argp3 ;
+  unsigned int arg2 ;
+  int arg3 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(uint32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
-  argp3 = *(int32_t **)&jarg3; 
-  if (!argp3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null int32_t");
-    return 0;
-  }
-  arg3 = *argp3; 
+  arg2 = (unsigned int)jarg2; 
+  arg3 = (int)jarg3; 
   result = (arg1)->SetIzone(arg2,arg3);
   *(CTR_Code **)&jresult = new CTR_Code((const CTR_Code &)result); 
   return jresult;
 }
 
 
-SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetCloseLoopRampRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3) {
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetCloseLoopRampRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jint jarg3) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  uint32_t arg2 ;
-  int32_t arg3 ;
-  uint32_t *argp2 ;
-  int32_t *argp3 ;
+  unsigned int arg2 ;
+  int arg3 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(uint32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
-  argp3 = *(int32_t **)&jarg3; 
-  if (!argp3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null int32_t");
-    return 0;
-  }
-  arg3 = *argp3; 
+  arg2 = (unsigned int)jarg2; 
+  arg3 = (int)jarg3; 
   result = (arg1)->SetCloseLoopRampRate(arg2,arg3);
   *(CTR_Code **)&jresult = new CTR_Code((const CTR_Code &)result); 
   return jresult;
 }
 
 
-SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetSensorPosition(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetSensorPosition(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  int32_t arg2 ;
-  int32_t *argp2 ;
+  int arg2 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(int32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null int32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
+  arg2 = (int)jarg2; 
   result = (arg1)->SetSensorPosition(arg2);
   *(CTR_Code **)&jresult = new CTR_Code((const CTR_Code &)result); 
   return jresult;
 }
 
 
-SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetForwardSoftLimit(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetForwardSoftLimit(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  int32_t arg2 ;
-  int32_t *argp2 ;
+  int arg2 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(int32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null int32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
+  arg2 = (int)jarg2; 
   result = (arg1)->SetForwardSoftLimit(arg2);
   *(CTR_Code **)&jresult = new CTR_Code((const CTR_Code &)result); 
   return jresult;
 }
 
 
-SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetReverseSoftLimit(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetReverseSoftLimit(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  int32_t arg2 ;
-  int32_t *argp2 ;
+  int arg2 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(int32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null int32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
+  arg2 = (int)jarg2; 
   result = (arg1)->SetReverseSoftLimit(arg2);
   *(CTR_Code **)&jresult = new CTR_Code((const CTR_Code &)result); 
   return jresult;
 }
 
 
-SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetForwardSoftEnable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetForwardSoftEnable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  int32_t arg2 ;
-  int32_t *argp2 ;
+  int arg2 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(int32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null int32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
+  arg2 = (int)jarg2; 
   result = (arg1)->SetForwardSoftEnable(arg2);
   *(CTR_Code **)&jresult = new CTR_Code((const CTR_Code &)result); 
   return jresult;
 }
 
 
-SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetReverseSoftEnable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
+SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetReverseSoftEnable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  int32_t arg2 ;
-  int32_t *argp2 ;
+  int arg2 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(int32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null int32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
+  arg2 = (int)jarg2; 
   result = (arg1)->SetReverseSoftEnable(arg2);
   *(CTR_Code **)&jresult = new CTR_Code((const CTR_Code &)result); 
   return jresult;
@@ -2003,21 +2333,15 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
 SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1GetPgain(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  uint32_t arg2 ;
+  unsigned int arg2 ;
   double *arg3 = 0 ;
-  uint32_t *argp2 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(uint32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
+  arg2 = (unsigned int)jarg2; 
   arg3 = *(double **)&jarg3;
   if (!arg3) {
     SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "double & reference is null");
@@ -2032,21 +2356,15 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
 SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1GetIgain(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  uint32_t arg2 ;
+  unsigned int arg2 ;
   double *arg3 = 0 ;
-  uint32_t *argp2 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(uint32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
+  arg2 = (unsigned int)jarg2; 
   arg3 = *(double **)&jarg3;
   if (!arg3) {
     SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "double & reference is null");
@@ -2061,21 +2379,15 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
 SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1GetDgain(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  uint32_t arg2 ;
+  unsigned int arg2 ;
   double *arg3 = 0 ;
-  uint32_t *argp2 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(uint32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
+  arg2 = (unsigned int)jarg2; 
   arg3 = *(double **)&jarg3;
   if (!arg3) {
     SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "double & reference is null");
@@ -2090,21 +2402,15 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
 SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1GetFgain(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  uint32_t arg2 ;
+  unsigned int arg2 ;
   double *arg3 = 0 ;
-  uint32_t *argp2 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(uint32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
+  arg2 = (unsigned int)jarg2; 
   arg3 = *(double **)&jarg3;
   if (!arg3) {
     SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "double & reference is null");
@@ -2119,24 +2425,18 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
 SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1GetIzone(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  uint32_t arg2 ;
-  int32_t *arg3 = 0 ;
-  uint32_t *argp2 ;
+  unsigned int arg2 ;
+  int *arg3 = 0 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(uint32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
-  arg3 = *(int32_t **)&jarg3;
+  arg2 = (unsigned int)jarg2; 
+  arg3 = *(int **)&jarg3;
   if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int32_t & reference is null");
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int & reference is null");
     return 0;
   } 
   result = (arg1)->GetIzone(arg2,*arg3);
@@ -2148,24 +2448,18 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
 SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1GetCloseLoopRampRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  uint32_t arg2 ;
-  int32_t *arg3 = 0 ;
-  uint32_t *argp2 ;
+  unsigned int arg2 ;
+  int *arg3 = 0 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(uint32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
-  arg3 = *(int32_t **)&jarg3;
+  arg2 = (unsigned int)jarg2; 
+  arg3 = *(int **)&jarg3;
   if (!arg3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int32_t & reference is null");
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int & reference is null");
     return 0;
   } 
   result = (arg1)->GetCloseLoopRampRate(arg2,*arg3);
@@ -2177,16 +2471,16 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
 SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1GetForwardSoftLimit(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  int32_t *arg2 = 0 ;
+  int *arg2 = 0 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  arg2 = *(int32_t **)&jarg2;
+  arg2 = *(int **)&jarg2;
   if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int32_t & reference is null");
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int & reference is null");
     return 0;
   } 
   result = (arg1)->GetForwardSoftLimit(*arg2);
@@ -2198,16 +2492,16 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
 SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1GetReverseSoftLimit(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  int32_t *arg2 = 0 ;
+  int *arg2 = 0 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  arg2 = *(int32_t **)&jarg2;
+  arg2 = *(int **)&jarg2;
   if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int32_t & reference is null");
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int & reference is null");
     return 0;
   } 
   result = (arg1)->GetReverseSoftLimit(*arg2);
@@ -2219,16 +2513,16 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
 SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1GetForwardSoftEnable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  int32_t *arg2 = 0 ;
+  int *arg2 = 0 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  arg2 = *(int32_t **)&jarg2;
+  arg2 = *(int **)&jarg2;
   if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int32_t & reference is null");
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int & reference is null");
     return 0;
   } 
   result = (arg1)->GetForwardSoftEnable(*arg2);
@@ -2240,16 +2534,16 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
 SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1GetReverseSoftEnable(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  int32_t *arg2 = 0 ;
+  int *arg2 = 0 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  arg2 = *(int32_t **)&jarg2;
+  arg2 = *(int **)&jarg2;
   if (!arg2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int32_t & reference is null");
+    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int & reference is null");
     return 0;
   } 
   result = (arg1)->GetReverseSoftEnable(*arg2);
@@ -2261,28 +2555,16 @@ SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_
 SWIGEXPORT jlong JNICALL Java_edu_wpi_first_wpilibj_hal_CanTalonJNI_CanTalonSRX_1SetStatusFrameRate(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jlong jarg3) {
   jlong jresult = 0 ;
   CanTalonSRX *arg1 = (CanTalonSRX *) 0 ;
-  uint32_t arg2 ;
-  uint8_t arg3 ;
-  uint32_t *argp2 ;
-  uint8_t *argp3 ;
+  unsigned int arg2 ;
+  unsigned int arg3 ;
   CTR_Code result;
   
   (void)jenv;
   (void)jcls;
   (void)jarg1_;
   arg1 = *(CanTalonSRX **)&jarg1; 
-  argp2 = *(uint32_t **)&jarg2; 
-  if (!argp2) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint32_t");
-    return 0;
-  }
-  arg2 = *argp2; 
-  argp3 = *(uint8_t **)&jarg3; 
-  if (!argp3) {
-    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Attempt to dereference null uint8_t");
-    return 0;
-  }
-  arg3 = *argp3; 
+  arg2 = (unsigned int)jarg2; 
+  arg3 = (unsigned int)jarg3; 
   result = (arg1)->SetStatusFrameRate(arg2,arg3);
   *(CTR_Code **)&jresult = new CTR_Code((const CTR_Code &)result); 
   return jresult;
diff --git a/wpilibj/wpilibJavaJNI/swigTalon/CanTalonSRX.i b/wpilibj/wpilibJavaJNI/swigTalon/CanTalonSRX.i
index 0100efe0bfee7243cbab6d5d1e74d5f742339187..8d8f0da8dafe37e12b90924e136fffe414f3bd54 100644
--- a/wpilibj/wpilibJavaJNI/swigTalon/CanTalonSRX.i
+++ b/wpilibj/wpilibJavaJNI/swigTalon/CanTalonSRX.i
@@ -6,6 +6,10 @@
 %include "cpointer.i"
 %pointer_functions(double, doublep);
 %pointer_functions(int, intp);
+%pointer_functions(uint32_t, uint32_tp);
+%pointer_functions(int32_t, int32_tp);
+%pointer_functions(uint8_t, uint8_tp);
+%pointer_functions(CTR_Code, CTR_Codep);
 %pointer_functions(float, floatp);
 %include "CtreCanNode.h"
 %include "CanTalonSRX.h"
