From eb50b258366fcfeddf81f7c2e35a402a7592a2f8 Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Tue, 3 May 2022 20:07:25 -0400
Subject: [PATCH 04/36] Fix warnings for casting, wrap min/max for windows

---
 llvm/include/llvm/ADT/DenseMap.h       |  4 ++--
 llvm/include/llvm/ADT/DenseMapInfo.h   |  2 +-
 llvm/include/llvm/ADT/SmallVector.h    |  8 ++++----
 llvm/include/llvm/Support/ConvertUTF.h |  2 +-
 llvm/include/llvm/Support/MathExtras.h | 20 ++++++++++----------
 5 files changed, 18 insertions(+), 18 deletions(-)

diff --git a/llvm/include/llvm/ADT/DenseMap.h b/llvm/include/llvm/ADT/DenseMap.h
index dbecf3c658d8..13ac6c508536 100644
--- a/llvm/include/llvm/ADT/DenseMap.h
+++ b/llvm/include/llvm/ADT/DenseMap.h
@@ -381,7 +381,7 @@ protected:
       return 0;
     // +1 is required because of the strict equality.
     // For example if NumEntries is 48, we need to return 401.
-    return NextPowerOf2(NumEntries * 4 / 3 + 1);
+    return static_cast<unsigned>(NextPowerOf2(NumEntries * 4 / 3 + 1));
   }
 
   void moveFromOldBuckets(BucketT *OldBucketsBegin, BucketT *OldBucketsEnd) {
@@ -807,7 +807,7 @@ public:
     // Reduce the number of buckets.
     unsigned NewNumBuckets = 0;
     if (OldNumEntries)
-      NewNumBuckets = std::max(64, 1 << (Log2_32_Ceil(OldNumEntries) + 1));
+      NewNumBuckets = (std::max)(64, 1 << (Log2_32_Ceil(OldNumEntries) + 1));
     if (NewNumBuckets == NumBuckets) {
       this->BaseT::initEmpty();
       return;
diff --git a/llvm/include/llvm/ADT/DenseMapInfo.h b/llvm/include/llvm/ADT/DenseMapInfo.h
index 5ef6f3ad1b04..99af567d4ef4 100644
--- a/llvm/include/llvm/ADT/DenseMapInfo.h
+++ b/llvm/include/llvm/ADT/DenseMapInfo.h
@@ -265,7 +265,7 @@ template <typename T> struct DenseMapInfo<ArrayRef<T>> {
 template <> struct DenseMapInfo<hash_code> {
   static inline hash_code getEmptyKey() { return hash_code(-1); }
   static inline hash_code getTombstoneKey() { return hash_code(-2); }
-  static unsigned getHashValue(hash_code val) { return val; }
+  static unsigned getHashValue(hash_code val) { return static_cast<unsigned>(val); }
   static bool isEqual(hash_code LHS, hash_code RHS) { return LHS == RHS; }
 };
 
diff --git a/llvm/include/llvm/ADT/SmallVector.h b/llvm/include/llvm/ADT/SmallVector.h
index 17586904d212..004958a4b321 100644
--- a/llvm/include/llvm/ADT/SmallVector.h
+++ b/llvm/include/llvm/ADT/SmallVector.h
@@ -42,7 +42,7 @@ protected:
 
   SmallVectorBase() = delete;
   SmallVectorBase(void *FirstEl, size_t TotalCapacity)
-      : BeginX(FirstEl), Capacity(TotalCapacity) {}
+      : BeginX(FirstEl), Capacity(static_cast<unsigned>(TotalCapacity)) {}
 
   /// This is an implementation of the grow() method which only works
   /// on POD-like data types and is out of line to reduce code duplication.
@@ -65,7 +65,7 @@ public:
   /// which will only be overwritten.
   void set_size(size_t N) {
     assert(N <= capacity());
-    Size = N;
+    Size = static_cast<unsigned>(N);
   }
 };
 
@@ -236,7 +236,7 @@ void SmallVectorTemplateBase<T, TriviallyCopyable>::grow(size_t MinSize) {
 
   // Always grow, even from zero.
   size_t NewCapacity = size_t(NextPowerOf2(this->capacity() + 2));
-  NewCapacity = std::min(std::max(NewCapacity, MinSize), size_t(UINT32_MAX));
+  NewCapacity = (std::min)((std::max)(NewCapacity, MinSize), size_t(UINT32_MAX));
   T *NewElts = static_cast<T*>(llvm::safe_malloc(NewCapacity*sizeof(T)));
 
   // Move the elements over.
@@ -250,7 +250,7 @@ void SmallVectorTemplateBase<T, TriviallyCopyable>::grow(size_t MinSize) {
     free(this->begin());
 
   this->BeginX = NewElts;
-  this->Capacity = NewCapacity;
+  this->Capacity = static_cast<unsigned>(NewCapacity);
 }
 
 /// SmallVectorTemplateBase<TriviallyCopyable = true> - This is where we put
diff --git a/llvm/include/llvm/Support/ConvertUTF.h b/llvm/include/llvm/Support/ConvertUTF.h
index 1add185330fa..c83ba81fa2e2 100644
--- a/llvm/include/llvm/Support/ConvertUTF.h
+++ b/llvm/include/llvm/Support/ConvertUTF.h
@@ -109,7 +109,7 @@ namespace llvm {
 typedef unsigned int    UTF32;  /* at least 32 bits */
 typedef unsigned short  UTF16;  /* at least 16 bits */
 typedef unsigned char   UTF8;   /* typically 8 bits */
-typedef unsigned char   Boolean; /* 0 or 1 */
+typedef bool   Boolean; /* 0 or 1 */
 
 /* Some fundamental constants */
 #define UNI_REPLACEMENT_CHAR (UTF32)0x0000FFFD
diff --git a/llvm/include/llvm/Support/MathExtras.h b/llvm/include/llvm/Support/MathExtras.h
index 249139e824b5..e20f0dc8b774 100644
--- a/llvm/include/llvm/Support/MathExtras.h
+++ b/llvm/include/llvm/Support/MathExtras.h
@@ -60,7 +60,7 @@ template <typename T, std::size_t SizeOfT> struct TrailingZerosCounter {
     // Bisection method.
     unsigned ZeroBits = 0;
     T Shift = std::numeric_limits<T>::digits >> 1;
-    T Mask = std::numeric_limits<T>::max() >> Shift;
+    T Mask = (std::numeric_limits<T>::max)() >> Shift;
     while (Shift) {
       if ((Val & Mask) == 0) {
         Val >>= Shift;
@@ -201,7 +201,7 @@ unsigned countLeadingZeros(T Val, ZeroBehavior ZB = ZB_Width) {
 ///   valid arguments.
 template <typename T> T findFirstSet(T Val, ZeroBehavior ZB = ZB_Max) {
   if (ZB == ZB_Max && Val == 0)
-    return std::numeric_limits<T>::max();
+    return (std::numeric_limits<T>::max)();
 
   return countTrailingZeros(Val, ZB_Undefined);
 }
@@ -242,7 +242,7 @@ template <typename T> T maskLeadingZeros(unsigned N) {
 ///   valid arguments.
 template <typename T> T findLastSet(T Val, ZeroBehavior ZB = ZB_Max) {
   if (ZB == ZB_Max && Val == 0)
-    return std::numeric_limits<T>::max();
+    return (std::numeric_limits<T>::max)();
 
   // Use ^ instead of - because both gcc and llvm can remove the associated ^
   // in the __builtin_clz intrinsic on x86.
@@ -536,26 +536,26 @@ inline double Log2(double Value) {
 /// (32 bit edition.)
 /// Ex. Log2_32(32) == 5, Log2_32(1) == 0, Log2_32(0) == -1, Log2_32(6) == 2
 inline unsigned Log2_32(uint32_t Value) {
-  return 31 - countLeadingZeros(Value);
+  return static_cast<unsigned>(31 - countLeadingZeros(Value));
 }
 
 /// Return the floor log base 2 of the specified value, -1 if the value is zero.
 /// (64 bit edition.)
 inline unsigned Log2_64(uint64_t Value) {
-  return 63 - countLeadingZeros(Value);
+  return static_cast<unsigned>(63 - countLeadingZeros(Value));
 }
 
 /// Return the ceil log base 2 of the specified value, 32 if the value is zero.
 /// (32 bit edition).
 /// Ex. Log2_32_Ceil(32) == 5, Log2_32_Ceil(1) == 0, Log2_32_Ceil(6) == 3
 inline unsigned Log2_32_Ceil(uint32_t Value) {
-  return 32 - countLeadingZeros(Value - 1);
+  return static_cast<unsigned>(32 - countLeadingZeros(Value - 1));
 }
 
 /// Return the ceil log base 2 of the specified value, 64 if the value is zero.
 /// (64 bit edition.)
 inline unsigned Log2_64_Ceil(uint64_t Value) {
-  return 64 - countLeadingZeros(Value - 1);
+  return static_cast<unsigned>(64 - countLeadingZeros(Value - 1));
 }
 
 /// Return the greatest common divisor of the values using Euclid's algorithm.
@@ -769,7 +769,7 @@ inline int64_t SignExtend64(uint64_t X, unsigned B) {
 template <typename T>
 typename std::enable_if<std::is_unsigned<T>::value, T>::type
 AbsoluteDifference(T X, T Y) {
-  return std::max(X, Y) - std::min(X, Y);
+  return (std::max)(X, Y) - (std::min)(X, Y);
 }
 
 /// Add two unsigned integers, X and Y, of type T.  Clamp the result to the
@@ -784,7 +784,7 @@ SaturatingAdd(T X, T Y, bool *ResultOverflowed = nullptr) {
   T Z = X + Y;
   Overflowed = (Z < X || Z < Y);
   if (Overflowed)
-    return std::numeric_limits<T>::max();
+    return (std::numeric_limits<T>::max)();
   else
     return Z;
 }
@@ -809,7 +809,7 @@ SaturatingMultiply(T X, T Y, bool *ResultOverflowed = nullptr) {
   // Special case: if X or Y is 0, Log2_64 gives -1, and Log2Z
   // will necessarily be less than Log2Max as desired.
   int Log2Z = Log2_64(X) + Log2_64(Y);
-  const T Max = std::numeric_limits<T>::max();
+  const T Max = (std::numeric_limits<T>::max)();
   int Log2Max = Log2_64(Max);
   if (Log2Z < Log2Max) {
     return X * Y;
-- 
2.20.1.windows.1

