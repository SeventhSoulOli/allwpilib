From 2c813ab84f51ebcac8d995adbd1cd18cdb9e4722 Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Tue, 3 May 2022 22:07:37 -0400
Subject: [PATCH 14/37] Prefer uint8_t for buffers

---
 llvm/include/llvm/Support/MemoryBuffer.h      | 30 +++++++++----------
 .../llvm/Support/SmallVectorMemoryBuffer.h    |  6 ++--
 llvm/lib/Support/MemoryBuffer.cpp             | 14 ++++-----
 3 files changed, 25 insertions(+), 25 deletions(-)

diff --git a/llvm/include/llvm/Support/MemoryBuffer.h b/llvm/include/llvm/Support/MemoryBuffer.h
index 7b763e344546..1111c34f0d6c 100644
--- a/llvm/include/llvm/Support/MemoryBuffer.h
+++ b/llvm/include/llvm/Support/MemoryBuffer.h
@@ -38,13 +38,13 @@ class MemoryBufferRef;
 /// reading when they encounter a '\0' than to continually check the file
 /// position to see if it has reached the end of the file.
 class MemoryBuffer {
-  const char *BufferStart; // Start of the buffer.
-  const char *BufferEnd;   // End of the buffer.
+  const uint8_t *BufferStart; // Start of the buffer.
+  const uint8_t *BufferEnd;   // End of the buffer.
 
 protected:
   MemoryBuffer() = default;
 
-  void init(const char *BufStart, const char *BufEnd,
+  void init(const uint8_t *BufStart, const uint8_t *BufEnd,
             bool RequiresNullTerminator);
 
   static constexpr sys::fs::mapped_file_region::mapmode Mapmode =
@@ -55,8 +55,8 @@ public:
   MemoryBuffer &operator=(const MemoryBuffer &) = delete;
   virtual ~MemoryBuffer();
 
-  const char *getBufferStart() const { return BufferStart; }
-  const char *getBufferEnd() const   { return BufferEnd; }
+  const uint8_t *getBufferStart() const { return BufferStart; }
+  const uint8_t *getBufferEnd() const   { return BufferEnd; }
   size_t getBufferSize() const { return BufferEnd-BufferStart; }
 
   span<const uint8_t> getBuffer() const {
@@ -165,11 +165,11 @@ public:
 
   // const_cast is well-defined here, because the underlying buffer is
   // guaranteed to have been initialized with a mutable buffer.
-  char *getBufferStart() {
-    return const_cast<char *>(MemoryBuffer::getBufferStart());
+  uint8_t *getBufferStart() {
+    return const_cast<uint8_t *>(MemoryBuffer::getBufferStart());
   }
-  char *getBufferEnd() {
-    return const_cast<char *>(MemoryBuffer::getBufferEnd());
+  uint8_t *getBufferEnd() {
+    return const_cast<uint8_t *>(MemoryBuffer::getBufferEnd());
   }
   span<uint8_t> getBuffer() {
     return {getBufferStart(), getBufferEnd()};
@@ -227,11 +227,11 @@ public:
 
   // const_cast is well-defined here, because the underlying buffer is
   // guaranteed to have been initialized with a mutable buffer.
-  char *getBufferStart() {
-    return const_cast<char *>(MemoryBuffer::getBufferStart());
+  uint8_t *getBufferStart() {
+    return const_cast<uint8_t *>(MemoryBuffer::getBufferStart());
   }
-  char *getBufferEnd() {
-    return const_cast<char *>(MemoryBuffer::getBufferEnd());
+  uint8_t *getBufferEnd() {
+    return const_cast<uint8_t *>(MemoryBuffer::getBufferEnd());
   }
   span<uint8_t> getBuffer() {
     return {getBufferStart(), getBufferEnd()};
@@ -272,8 +272,8 @@ public:
 
   std::string_view getBufferIdentifier() const { return Identifier; }
 
-  const char *getBufferStart() const { return Buffer.begin(); }
-  const char *getBufferEnd() const { return Buffer.end(); }
+  const uint8_t *getBufferStart() const { return Buffer.begin(); }
+  const uint8_t *getBufferEnd() const { return Buffer.end(); }
   size_t getBufferSize() const { return Buffer.size(); }
 };
 
diff --git a/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h b/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
index a824e601115e..9a74851fe514 100644
--- a/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
+++ b/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
@@ -37,14 +37,14 @@ public:
   /// but SmallVector's move-construction/assignment currently only take
   /// SmallVectors. If/when that is fixed we can simplify this constructor and
   /// the following one.
-  SmallVectorMemoryBuffer(SmallVectorImpl<char> &&SV)
+  SmallVectorMemoryBuffer(SmallVectorImpl<uint8_t> &&SV)
       : SV(std::move(SV)), BufferName("<in-memory object>") {
     init(this->SV.begin(), this->SV.end(), false);
   }
 
   /// Construct a named SmallVectorMemoryBuffer from the given
   /// SmallVector r-value and std::string_view.
-  SmallVectorMemoryBuffer(SmallVectorImpl<char> &&SV, std::string_view Name)
+  SmallVectorMemoryBuffer(SmallVectorImpl<uint8_t> &&SV, std::string_view Name)
       : SV(std::move(SV)), BufferName(Name) {
     init(this->SV.begin(), this->SV.end(), false);
   }
@@ -57,7 +57,7 @@ public:
   BufferKind getBufferKind() const override { return MemoryBuffer_Malloc; }
 
 private:
-  SmallVector<char, 0> SV;
+  SmallVector<uint8_t, 0> SV;
   std::string BufferName;
 };
 
diff --git a/llvm/lib/Support/MemoryBuffer.cpp b/llvm/lib/Support/MemoryBuffer.cpp
index baa6ef9ce50d..4a87be65256f 100644
--- a/llvm/lib/Support/MemoryBuffer.cpp
+++ b/llvm/lib/Support/MemoryBuffer.cpp
@@ -43,7 +43,7 @@ MemoryBuffer::~MemoryBuffer() { }
 
 /// init - Initialize this MemoryBuffer as a reference to externally allocated
 /// memory, memory that we know is already null terminated.
-void MemoryBuffer::init(const char *BufStart, const char *BufEnd,
+void MemoryBuffer::init(const uint8_t *BufStart, const uint8_t *BufEnd,
                         bool RequiresNullTerminator) {
   assert((!RequiresNullTerminator || BufEnd[0] == 0) &&
          "Buffer is not null terminated!");
@@ -57,7 +57,7 @@ void MemoryBuffer::init(const char *BufStart, const char *BufEnd,
 
 /// CopyStringView - Copies contents of a std::string_view into a block of memory and
 /// null-terminates it.
-static void CopyStringView(char *Memory, std::string_view Data) {
+static void CopyStringView(uint8_t *Memory, std::string_view Data) {
   if (!Data.empty())
     memcpy(Memory, Data.data(), Data.size());
   Memory[Data.size()] = 0; // Null terminate string.
@@ -178,7 +178,7 @@ class MemoryBufferMMapFile : public MB {
     return Len + (Offset - getLegalMapOffset(Offset));
   }
 
-  const char *getStart(uint64_t Len, uint64_t Offset) {
+  const uint8_t *getStart(uint64_t Len, uint64_t Offset) {
     return MFR.const_data() + (Offset - getLegalMapOffset(Offset));
   }
 
@@ -188,7 +188,7 @@ public:
       : MFR(FD, MB::Mapmode, getLegalMapSize(Len, Offset),
             getLegalMapOffset(Offset), EC) {
     if (!EC) {
-      const char *Start = getStart(Len, Offset);
+      const uint8_t *Start = getStart(Len, Offset);
       MemoryBuffer::init(Start, Start + Len, RequiresNullTerminator);
     }
   }
@@ -281,7 +281,7 @@ WritableMemoryBuffer::getNewUninitMemBuffer(size_t Size, std::string_view Buffer
   std::string_view NameRef = BufferName.tostd::string_view(NameBuf);
   size_t AlignedStringLen = alignTo(sizeof(MemBuffer) + NameRef.size() + 1, 16);
   size_t RealLen = AlignedStringLen + Size + 1;
-  char *Mem = static_cast<char*>(operator new(RealLen, std::nothrow));
+  uint8_t *Mem = static_cast<uint8_t*>(operator new(RealLen, std::nothrow));
   if (!Mem)
     return nullptr;
 
@@ -289,7 +289,7 @@ WritableMemoryBuffer::getNewUninitMemBuffer(size_t Size, std::string_view Buffer
   CopyStringView(Mem + sizeof(MemBuffer), NameRef);
 
   // The buffer begins after the name and must be aligned.
-  char *Buf = Mem + AlignedStringLen;
+  uint8_t *Buf = Mem + AlignedStringLen;
   Buf[Size] = 0; // Null terminate buffer.
 
   auto *Ret = new (Mem) MemBuffer({Buf, Size}, true);
@@ -460,7 +460,7 @@ getOpenFileImpl(int FD, std::string_view Filename, uint64_t FileSize,
     return make_error_code(errc::not_enough_memory);
   }
 
-  char *BufPtr = Buf.get()->getBufferStart();
+  uint8_t *BufPtr = Buf.get()->getBufferStart();
 
   size_t BytesLeft = MapSize;
 #ifndef HAVE_PREAD
-- 
2.20.1.windows.1

