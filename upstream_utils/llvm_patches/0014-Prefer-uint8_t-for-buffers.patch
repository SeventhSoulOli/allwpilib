From 18b830cc382fa0422097c54818579fa1a922b0f4 Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Tue, 3 May 2022 22:07:37 -0400
Subject: [PATCH 14/37] Prefer uint8_t for buffers

---
 llvm/include/llvm/Support/MemoryBuffer.h      | 30 +++++++++----------
 .../llvm/Support/SmallVectorMemoryBuffer.h    |  6 ++--
 llvm/lib/Support/MemoryBuffer.cpp             | 12 ++++----
 3 files changed, 24 insertions(+), 24 deletions(-)

diff --git a/llvm/include/llvm/Support/MemoryBuffer.h b/llvm/include/llvm/Support/MemoryBuffer.h
index 07db11788512..4b9b5086fb5e 100644
--- a/llvm/include/llvm/Support/MemoryBuffer.h
+++ b/llvm/include/llvm/Support/MemoryBuffer.h
@@ -48,13 +48,13 @@ using file_t = int;
 /// reading when they encounter a '\0' than to continually check the file
 /// position to see if it has reached the end of the file.
 class MemoryBuffer {
-  const char *BufferStart; // Start of the buffer.
-  const char *BufferEnd;   // End of the buffer.
+  const uint8_t *BufferStart; // Start of the buffer.
+  const uint8_t *BufferEnd;   // End of the buffer.
 
 protected:
   MemoryBuffer() = default;
 
-  void init(const char *BufStart, const char *BufEnd,
+  void init(const uint8_t *BufStart, const uint8_t *BufEnd,
             bool RequiresNullTerminator);
 
 public:
@@ -62,8 +62,8 @@ public:
   MemoryBuffer &operator=(const MemoryBuffer &) = delete;
   virtual ~MemoryBuffer();
 
-  const char *getBufferStart() const { return BufferStart; }
-  const char *getBufferEnd() const   { return BufferEnd; }
+  const uint8_t *getBufferStart() const { return BufferStart; }
+  const uint8_t *getBufferEnd() const   { return BufferEnd; }
   size_t getBufferSize() const { return BufferEnd-BufferStart; }
 
   span<const uint8_t> getBuffer() const {
@@ -169,11 +169,11 @@ public:
 
   // const_cast is well-defined here, because the underlying buffer is
   // guaranteed to have been initialized with a mutable buffer.
-  char *getBufferStart() {
-    return const_cast<char *>(MemoryBuffer::getBufferStart());
+  uint8_t *getBufferStart() {
+    return const_cast<uint8_t *>(MemoryBuffer::getBufferStart());
   }
-  char *getBufferEnd() {
-    return const_cast<char *>(MemoryBuffer::getBufferEnd());
+  uint8_t *getBufferEnd() {
+    return const_cast<uint8_t *>(MemoryBuffer::getBufferEnd());
   }
   span<uint8_t> getBuffer() {
     return {getBufferStart(), getBufferEnd()};
@@ -228,11 +228,11 @@ public:
 
   // const_cast is well-defined here, because the underlying buffer is
   // guaranteed to have been initialized with a mutable buffer.
-  char *getBufferStart() {
-    return const_cast<char *>(MemoryBuffer::getBufferStart());
+  uint8_t *getBufferStart() {
+    return const_cast<uint8_t *>(MemoryBuffer::getBufferStart());
   }
-  char *getBufferEnd() {
-    return const_cast<char *>(MemoryBuffer::getBufferEnd());
+  uint8_t *getBufferEnd() {
+    return const_cast<uint8_t *>(MemoryBuffer::getBufferEnd());
   }
   span<uint8_t> getBuffer() {
     return {getBufferStart(), getBufferEnd()};
@@ -273,8 +273,8 @@ public:
 
   std::string_view getBufferIdentifier() const { return Identifier; }
 
-  const char *getBufferStart() const { return Buffer.begin(); }
-  const char *getBufferEnd() const { return Buffer.end(); }
+  const uint8_t *getBufferStart() const { return Buffer.begin(); }
+  const uint8_t *getBufferEnd() const { return Buffer.end(); }
   size_t getBufferSize() const { return Buffer.size(); }
 };
 
diff --git a/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h b/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
index fe9bf46d12a5..89fa409f94ba 100644
--- a/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
+++ b/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
@@ -36,14 +36,14 @@ public:
   /// but SmallVector's move-construction/assignment currently only take
   /// SmallVectors. If/when that is fixed we can simplify this constructor and
   /// the following one.
-  SmallVectorMemoryBuffer(SmallVectorImpl<char> &&SV)
+  SmallVectorMemoryBuffer(SmallVectorImpl<uint8_t> &&SV)
       : SV(std::move(SV)), BufferName("<in-memory object>") {
     init(this->SV.begin(), this->SV.end(), false);
   }
 
   /// Construct a named SmallVectorMemoryBuffer from the given
   /// SmallVector r-value and std::string_view.
-  SmallVectorMemoryBuffer(SmallVectorImpl<char> &&SV, std::string_view Name)
+  SmallVectorMemoryBuffer(SmallVectorImpl<uint8_t> &&SV, std::string_view Name)
       : SV(std::move(SV)), BufferName(std::string(Name)) {
     init(this->SV.begin(), this->SV.end(), false);
   }
@@ -56,7 +56,7 @@ public:
   BufferKind getBufferKind() const override { return MemoryBuffer_Malloc; }
 
 private:
-  SmallVector<char, 0> SV;
+  SmallVector<uint8_t, 0> SV;
   std::string BufferName;
 };
 
diff --git a/llvm/lib/Support/MemoryBuffer.cpp b/llvm/lib/Support/MemoryBuffer.cpp
index 9d0050aebfad..59b3b703d76a 100644
--- a/llvm/lib/Support/MemoryBuffer.cpp
+++ b/llvm/lib/Support/MemoryBuffer.cpp
@@ -42,7 +42,7 @@ MemoryBuffer::~MemoryBuffer() { }
 
 /// init - Initialize this MemoryBuffer as a reference to externally allocated
 /// memory, memory that we know is already null terminated.
-void MemoryBuffer::init(const char *BufStart, const char *BufEnd,
+void MemoryBuffer::init(const uint8_t *BufStart, const uint8_t *BufEnd,
                         bool RequiresNullTerminator) {
   assert((!RequiresNullTerminator || BufEnd[0] == 0) &&
          "Buffer is not null terminated!");
@@ -56,7 +56,7 @@ void MemoryBuffer::init(const char *BufStart, const char *BufEnd,
 
 /// CopyStringView - Copies contents of a std::string_view into a block of memory and
 /// null-terminates it.
-static void CopyStringView(char *Memory, std::string_view Data) {
+static void CopyStringView(uint8_t *Memory, std::string_view Data) {
   if (!Data.empty())
     memcpy(Memory, Data.data(), Data.size());
   Memory[Data.size()] = 0; // Null terminate string.
@@ -191,7 +191,7 @@ class MemoryBufferMMapFile : public MB {
     return Len + (Offset - getLegalMapOffset(Offset));
   }
 
-  const char *getStart(uint64_t Len, uint64_t Offset) {
+  const uint8_t *getStart(uint64_t Len, uint64_t Offset) {
     return MFR.const_data() + (Offset - getLegalMapOffset(Offset));
   }
 
@@ -201,7 +201,7 @@ public:
       : MFR(FD, Mapmode<MB>, getLegalMapSize(Len, Offset),
             getLegalMapOffset(Offset), EC) {
     if (!EC) {
-      const char *Start = getStart(Len, Offset);
+      const uint8_t *Start = getStart(Len, Offset);
       MemoryBuffer::init(Start, Start + Len, RequiresNullTerminator);
     }
   }
@@ -295,7 +295,7 @@ WritableMemoryBuffer::getNewUninitMemBuffer(size_t Size, std::string_view Buffer
   std::string_view NameRef = BufferName.tostd::string_view(NameBuf);
   size_t AlignedStringLen = alignTo(sizeof(MemBuffer) + NameRef.size() + 1, 16);
   size_t RealLen = AlignedStringLen + Size + 1;
-  char *Mem = static_cast<char*>(operator new(RealLen, std::nothrow));
+  uint8_t *Mem = static_cast<uint8_t*>(operator new(RealLen, std::nothrow));
   if (!Mem)
     return nullptr;
 
@@ -303,7 +303,7 @@ WritableMemoryBuffer::getNewUninitMemBuffer(size_t Size, std::string_view Buffer
   CopyStringView(Mem + sizeof(MemBuffer), NameRef);
 
   // The buffer begins after the name and must be aligned.
-  char *Buf = Mem + AlignedStringLen;
+  uint8_t *Buf = Mem + AlignedStringLen;
   Buf[Size] = 0; // Null terminate buffer.
 
   auto *Ret = new (Mem) MemBuffer({Buf, Size}, true);
-- 
2.20.1.windows.1

