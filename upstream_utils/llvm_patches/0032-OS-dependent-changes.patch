From 293ca22959173fdec536262fbc7167ed14927684 Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Wed, 4 May 2022 00:59:50 -0400
Subject: [PATCH 32/37] OS dependent changes

---
 llvm/lib/Support/ErrorHandling.cpp |   4 ++
 llvm/lib/Support/MemoryBuffer.cpp  |  83 +++++++++++++++++-------
 llvm/lib/Support/raw_ostream.cpp   | 100 ++++++++++++++++++++++++-----
 3 files changed, 148 insertions(+), 39 deletions(-)

diff --git a/llvm/lib/Support/ErrorHandling.cpp b/llvm/lib/Support/ErrorHandling.cpp
index 89fbdcad4da9..fa990745159a 100644
--- a/llvm/lib/Support/ErrorHandling.cpp
+++ b/llvm/lib/Support/ErrorHandling.cpp
@@ -132,7 +132,11 @@ void llvm::report_bad_alloc_error(const char *Reason, bool GenCrashDiag) {
   // Don't call the normal error handler. It may allocate memory. Directly write
   // an OOM to stderr and abort.
   char OOMMessage[] = "LLVM ERROR: out of memory\n";
+#ifdef _WIN32
+  int written = ::_write(2, OOMMessage, strlen(OOMMessage));
+#else
   ssize_t written = ::write(2, OOMMessage, strlen(OOMMessage));
+#endif
   (void)written;
   abort();
 }
diff --git a/llvm/lib/Support/MemoryBuffer.cpp b/llvm/lib/Support/MemoryBuffer.cpp
index 11670cc2bcc8..83ddd51fe406 100644
--- a/llvm/lib/Support/MemoryBuffer.cpp
+++ b/llvm/lib/Support/MemoryBuffer.cpp
@@ -223,13 +223,23 @@ static ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
 getMemoryBufferForStream(fs::file_t FD, std::string_view BufferName) {
   const ssize_t ChunkSize = 4096*4;
   SmallString<ChunkSize> Buffer;
+#ifdef _WIN32
+  DWORD ReadBytes;
+#else
   ssize_t ReadBytes;
+#endif
   // Read into Buffer until we hit EOF.
   do {
     Buffer.reserve(Buffer.size() + ChunkSize);
+#ifdef _WIN32
+    if (!ReadFile(FD, Buffer.end(), ChunkSize, &ReadBytes, nullptr)) {
+      return mapWindowsError(GetLastError());
+    }
+#else
     ReadBytes = sys::RetryAfterSignal(-1, ::read, FD, Buffer.end(), ChunkSize);
     if (ReadBytes == -1)
       return std::error_code(errno, std::generic_category());
+#endif
     Buffer.set_size(Buffer.size() + ReadBytes);
   } while (ReadBytes != 0);
 
@@ -331,19 +341,32 @@ getReadWriteFile(std::string_view Filename, uint64_t FileSize, uint64_t MapSize,
     // If we don't know the file size, use fstat to find out.  fstat on an open
     // file descriptor is cheaper than stat on a random path.
     if (FileSize == uint64_t(-1)) {
-      sys::fs::file_status Status;
-      std::error_code EC = sys::fs::status(FD, Status);
-      if (EC)
-        return EC;
+#ifdef _WIN32
+      // If this not a file or a block device (e.g. it's a named pipe
+      // or character device), we can't mmap it, so error out.
+      if (GetFileType(FD) != FILE_TYPE_DISK) {
+        return std::error_code(errno, std::generic_category());
+      }
+
+      LARGE_INTEGER fileSizeWin;
+      if (!GetFileSizeEx(FD, &fileSizeWin)) {
+        return wpi::mapWindowsError(GetLastError());
+      }
+      FileSize = fileSizeWin.QuadPart;
+#else
+      struct stat status;
+      if (fstat(FD, &status) < 0) {
+        return std::error_code(errno, std::generic_category());
+      }
 
       // If this not a file or a block device (e.g. it's a named pipe
       // or character device), we can't mmap it, so error out.
-      sys::fs::file_type Type = Status.type();
-      if (Type != sys::fs::file_type::regular_file &&
-          Type != sys::fs::file_type::block_file)
+      if (status.st_mode != S_IFREG && status.st_mode != S_IFBLK) {
         return make_error_code(errc::invalid_argument);
+      }
 
-      FileSize = Status.getSize();
+      FileSize = status.st_size;
+#endif
     }
     MapSize = FileSize;
   }
@@ -379,20 +402,30 @@ getOpenFileImpl(fs::file_t FD, std::string_view Filename, uint64_t FileSize,
     // If we don't know the file size, use fstat to find out.  fstat on an open
     // file descriptor is cheaper than stat on a random path.
     if (FileSize == uint64_t(-1)) {
-      sys::fs::file_status Status;
-      std::error_code EC = sys::fs::status(FD, Status);
-      if (EC)
-        return EC;
+#ifdef _WIN32
+      // If this not a file or a block device (e.g. it's a named pipe
+      // or character device), we can't trust the size. Create the memory
+      // buffer by copying off the stream.
+      LARGE_INTEGER fileSizeWin;
+      if (GetFileType(FD) != FILE_TYPE_DISK || !GetFileSizeEx(FD, &fileSizeWin)) {
+        return getMemoryBufferForStream(FD, Filename);
+      }
+      FileSize = fileSizeWin.QuadPart;
+#else
+      struct stat status;
+      if (fstat(FD, &status) < 0) {
+        return std::error_code(errno, std::generic_category());
+      }
 
       // If this not a file or a block device (e.g. it's a named pipe
       // or character device), we can't trust the size. Create the memory
       // buffer by copying off the stream.
-      sys::fs::file_type Type = Status.type();
-      if (Type != sys::fs::file_type::regular_file &&
-          Type != sys::fs::file_type::block_file)
+      if (status.st_mode != S_IFREG && status.st_mode != S_IFBLK) {
         return getMemoryBufferForStream(FD, Filename);
+      }
 
-      FileSize = Status.getSize();
+      FileSize = status.st_size;
+#endif
     }
     MapSize = FileSize;
   }
@@ -417,17 +450,19 @@ getOpenFileImpl(fs::file_t FD, std::string_view Filename, uint64_t FileSize,
   uint8_t *BufPtr = Buf.get()->getBufferStart();
 
   size_t BytesLeft = MapSize;
-#ifndef HAVE_PREAD
-  if (lseek(FD, Offset, SEEK_SET) == -1)
-    return std::error_code(errno, std::generic_category());
-#endif
-
   while (BytesLeft) {
-#ifdef HAVE_PREAD
+#ifdef _WIN32
+    LARGE_INTEGER offsetWin;
+    offsetWin.QuadPart = Offset;
+    DWORD NumRead;
+    if (!SetFilePointerEx(FD, offsetWin, nullptr, FILE_BEGIN) ||
+        !ReadFile(FD, BufPtr, BytesLeft, &NumRead, nullptr)) {
+      return mapWindowsError(GetLastError());
+    }
+// TODO
+#else
     ssize_t NumRead = sys::RetryAfterSignal(-1, ::pread, FD, BufPtr, BytesLeft,
                                             MapSize - BytesLeft + Offset);
-#else
-    ssize_t NumRead = sys::RetryAfterSignal(-1, ::read, FD, BufPtr, BytesLeft);
 #endif
     if (NumRead == -1) {
       // Error while reading.
diff --git a/llvm/lib/Support/raw_ostream.cpp b/llvm/lib/Support/raw_ostream.cpp
index 351323194c27..b93c0f7c1a37 100644
--- a/llvm/lib/Support/raw_ostream.cpp
+++ b/llvm/lib/Support/raw_ostream.cpp
@@ -294,8 +294,11 @@ static int getFD(std::string_view Filename, std::error_code &EC,
     EC = std::error_code();
     // If user requested binary then put stdout into binary mode if
     // possible.
-    if (!(Flags & sys::fs::OF_Text))
-      sys::ChangeStdoutToBinary();
+    if (!(Flags & sys::fs::OF_Text)) {
+#if defined(_WIN32)
+      _setmode(_fileno(stdout), _O_BINARY);
+#endif
+    }
     return STDOUT_FILENO;
   }
 
@@ -355,13 +358,17 @@ raw_fd_ostream::raw_fd_ostream(int fd, bool shouldClose, bool unbuffered)
   if (FD <= STDERR_FILENO)
     ShouldClose = false;
 
+#ifdef _WIN32
+  // Check if this is a console device. This is not equivalent to isatty.
+  IsWindowsConsole =
+      ::GetFileType((HANDLE)::_get_osfhandle(fd)) == FILE_TYPE_CHAR;
+#endif
+
+
   // Get the starting position.
   off_t loc = ::lseek(FD, 0, SEEK_CUR);
 #ifdef _WIN32
-  // MSVCRT's _lseek(SEEK_CUR) doesn't return -1 for pipes.
-  sys::fs::file_status Status;
-  std::error_code EC = status(FD, Status);
-  SupportsSeeking = !EC && Status.type() == sys::fs::file_type::regular_file;
+  SupportsSeeking = loc != (off_t)-1 && ::GetFileType(reinterpret_cast<HANDLE>(::_get_osfhandle(FD))) != FILE_TYPE_PIPE;
 #else
   SupportsSeeking = loc != (off_t)-1;
 #endif
@@ -395,10 +402,68 @@ raw_fd_ostream::~raw_fd_ostream() {
                        /*GenCrashDiag=*/false);
 }
 
+#if defined(_WIN32)
+// The most reliable way to print unicode in a Windows console is with
+// WriteConsoleW. To use that, first transcode from UTF-8 to UTF-16. This
+// assumes that LLVM programs always print valid UTF-8 to the console. The data
+// might not be UTF-8 for two major reasons:
+// 1. The program is printing binary (-filetype=obj -o -), in which case it
+// would have been gibberish anyway.
+// 2. The program is printing text in a semi-ascii compatible codepage like
+// shift-jis or cp1252.
+//
+// Most LLVM programs don't produce non-ascii text unless they are quoting
+// user source input. A well-behaved LLVM program should either validate that
+// the input is UTF-8 or transcode from the local codepage to UTF-8 before
+// quoting it. If they don't, this may mess up the encoding, but this is still
+// probably the best compromise we can make.
+static bool write_console_impl(int FD, std::string_view Data) {
+  SmallVector<wchar_t, 256> WideText;
+
+  // Fall back to ::write if it wasn't valid UTF-8.
+  if (auto EC = sys::windows::UTF8ToUTF16(Data, WideText))
+    return false;
+
+  // On Windows 7 and earlier, WriteConsoleW has a low maximum amount of data
+  // that can be written to the console at a time.
+  size_t MaxWriteSize = WideText.size();
+  if (!RunningWindows8OrGreater())
+    MaxWriteSize = 32767;
+
+  size_t WCharsWritten = 0;
+  do {
+    size_t WCharsToWrite =
+        std::min(MaxWriteSize, WideText.size() - WCharsWritten);
+    DWORD ActuallyWritten;
+    bool Success =
+        ::WriteConsoleW((HANDLE)::_get_osfhandle(FD), &WideText[WCharsWritten],
+                        WCharsToWrite, &ActuallyWritten,
+                        /*Reserved=*/nullptr);
+
+    // The most likely reason for WriteConsoleW to fail is that FD no longer
+    // points to a console. Fall back to ::write. If this isn't the first loop
+    // iteration, something is truly wrong.
+    if (!Success)
+      return false;
+
+    WCharsWritten += ActuallyWritten;
+  } while (WCharsWritten != WideText.size());
+  return true;
+}
+#endif
+
 void raw_fd_ostream::write_impl(const char *Ptr, size_t Size) {
   assert(FD >= 0 && "File already closed.");
   pos += Size;
 
+#if defined(_WIN32)
+  // If this is a Windows console device, try re-encoding from UTF-8 to UTF-16
+  // and using WriteConsoleW. If that fails, fall back to plain write().
+  if (IsWindowsConsole)
+    if (write_console_impl(FD, std::string_view(Ptr, Size)))
+      return;
+#endif
+
   // The maximum write size is limited to SSIZE_MAX because a write
   // greater than SSIZE_MAX is implementation-defined in POSIX.
   // Since SSIZE_MAX is not portable, we use SIZE_MAX >> 1 instead.
@@ -408,17 +473,15 @@ void raw_fd_ostream::write_impl(const char *Ptr, size_t Size) {
   // It is observed that Linux returns EINVAL for a very large write (>2G).
   // Make it a reasonably small value.
   MaxWriteSize = 1024 * 1024 * 1024;
-#elif defined(_WIN32)
-  // Writing a large size of output to Windows console returns ENOMEM. It seems
-  // that, prior to Windows 8, WriteFile() is redirecting to WriteConsole(), and
-  // the latter has a size limit (66000 bytes or less, depending on heap usage).
-  if (::_isatty(FD) && !RunningWindows8OrGreater())
-    MaxWriteSize = 32767;
 #endif
 
   do {
     size_t ChunkSize = std::min(Size, MaxWriteSize);
+#ifdef _WIN32
+    int ret = ::_write(FD, Ptr, ChunkSize);
+#else
     ssize_t ret = ::write(FD, Ptr, ChunkSize);
+#endif
 
     if (ret < 0) {
       // If it's a recoverable error, swallow it and retry the write.
@@ -463,8 +526,6 @@ uint64_t raw_fd_ostream::seek(uint64_t off) {
   flush();
 #ifdef _WIN32
   pos = ::_lseeki64(FD, off, SEEK_SET);
-#elif defined(HAVE_LSEEK64)
-  pos = ::lseek64(FD, off, SEEK_SET);
 #else
   pos = ::lseek(FD, off, SEEK_SET);
 #endif
@@ -482,7 +543,16 @@ void raw_fd_ostream::pwrite_impl(const char *Ptr, size_t Size,
 }
 
 size_t raw_fd_ostream::preferred_buffer_size() const {
-#if !defined(_MSC_VER) && !defined(__MINGW32__) && !defined(__minix)
+#if defined(_WIN32)
+  // Disable buffering for console devices. Console output is re-encoded from
+  // UTF-8 to UTF-16 on Windows, and buffering it would require us to split the
+  // buffer on a valid UTF-8 codepoint boundary. Terminal buffering is disabled
+  // below on most other OSs, so do the same thing on Windows and avoid that
+  // complexity.
+  if (IsWindowsConsole)
+    return 0;
+  return raw_ostream::preferred_buffer_size();
+#elif !defined(__minix)
   // Windows and Minix have no st_blksize.
   assert(FD >= 0 && "File not yet open!");
   struct stat statbuf;
-- 
2.20.1.windows.1

