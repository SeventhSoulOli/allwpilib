From 81b9ec70d13e272c023b8f3ca18cfd75a2aabd4c Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Wed, 4 May 2022 00:59:50 -0400
Subject: [PATCH 32/37] OS dependent changes

---
 llvm/lib/Support/ErrorHandling.cpp |  4 ++
 llvm/lib/Support/MemoryBuffer.cpp  | 83 +++++++++++++++++++++---------
 llvm/lib/Support/raw_ostream.cpp   | 20 +++----
 3 files changed, 74 insertions(+), 33 deletions(-)

diff --git a/llvm/lib/Support/ErrorHandling.cpp b/llvm/lib/Support/ErrorHandling.cpp
index 89fbdcad4da9..fa990745159a 100644
--- a/llvm/lib/Support/ErrorHandling.cpp
+++ b/llvm/lib/Support/ErrorHandling.cpp
@@ -132,7 +132,11 @@ void llvm::report_bad_alloc_error(const char *Reason, bool GenCrashDiag) {
   // Don't call the normal error handler. It may allocate memory. Directly write
   // an OOM to stderr and abort.
   char OOMMessage[] = "LLVM ERROR: out of memory\n";
+#ifdef _WIN32
+  int written = ::_write(2, OOMMessage, strlen(OOMMessage));
+#else
   ssize_t written = ::write(2, OOMMessage, strlen(OOMMessage));
+#endif
   (void)written;
   abort();
 }
diff --git a/llvm/lib/Support/MemoryBuffer.cpp b/llvm/lib/Support/MemoryBuffer.cpp
index 11670cc2bcc8..83ddd51fe406 100644
--- a/llvm/lib/Support/MemoryBuffer.cpp
+++ b/llvm/lib/Support/MemoryBuffer.cpp
@@ -223,13 +223,23 @@ static ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
 getMemoryBufferForStream(fs::file_t FD, std::string_view BufferName) {
   const ssize_t ChunkSize = 4096*4;
   SmallString<ChunkSize> Buffer;
+#ifdef _WIN32
+  DWORD ReadBytes;
+#else
   ssize_t ReadBytes;
+#endif
   // Read into Buffer until we hit EOF.
   do {
     Buffer.reserve(Buffer.size() + ChunkSize);
+#ifdef _WIN32
+    if (!ReadFile(FD, Buffer.end(), ChunkSize, &ReadBytes, nullptr)) {
+      return mapWindowsError(GetLastError());
+    }
+#else
     ReadBytes = sys::RetryAfterSignal(-1, ::read, FD, Buffer.end(), ChunkSize);
     if (ReadBytes == -1)
       return std::error_code(errno, std::generic_category());
+#endif
     Buffer.set_size(Buffer.size() + ReadBytes);
   } while (ReadBytes != 0);
 
@@ -331,19 +341,32 @@ getReadWriteFile(std::string_view Filename, uint64_t FileSize, uint64_t MapSize,
     // If we don't know the file size, use fstat to find out.  fstat on an open
     // file descriptor is cheaper than stat on a random path.
     if (FileSize == uint64_t(-1)) {
-      sys::fs::file_status Status;
-      std::error_code EC = sys::fs::status(FD, Status);
-      if (EC)
-        return EC;
+#ifdef _WIN32
+      // If this not a file or a block device (e.g. it's a named pipe
+      // or character device), we can't mmap it, so error out.
+      if (GetFileType(FD) != FILE_TYPE_DISK) {
+        return std::error_code(errno, std::generic_category());
+      }
+
+      LARGE_INTEGER fileSizeWin;
+      if (!GetFileSizeEx(FD, &fileSizeWin)) {
+        return wpi::mapWindowsError(GetLastError());
+      }
+      FileSize = fileSizeWin.QuadPart;
+#else
+      struct stat status;
+      if (fstat(FD, &status) < 0) {
+        return std::error_code(errno, std::generic_category());
+      }
 
       // If this not a file or a block device (e.g. it's a named pipe
       // or character device), we can't mmap it, so error out.
-      sys::fs::file_type Type = Status.type();
-      if (Type != sys::fs::file_type::regular_file &&
-          Type != sys::fs::file_type::block_file)
+      if (status.st_mode != S_IFREG && status.st_mode != S_IFBLK) {
         return make_error_code(errc::invalid_argument);
+      }
 
-      FileSize = Status.getSize();
+      FileSize = status.st_size;
+#endif
     }
     MapSize = FileSize;
   }
@@ -379,20 +402,30 @@ getOpenFileImpl(fs::file_t FD, std::string_view Filename, uint64_t FileSize,
     // If we don't know the file size, use fstat to find out.  fstat on an open
     // file descriptor is cheaper than stat on a random path.
     if (FileSize == uint64_t(-1)) {
-      sys::fs::file_status Status;
-      std::error_code EC = sys::fs::status(FD, Status);
-      if (EC)
-        return EC;
+#ifdef _WIN32
+      // If this not a file or a block device (e.g. it's a named pipe
+      // or character device), we can't trust the size. Create the memory
+      // buffer by copying off the stream.
+      LARGE_INTEGER fileSizeWin;
+      if (GetFileType(FD) != FILE_TYPE_DISK || !GetFileSizeEx(FD, &fileSizeWin)) {
+        return getMemoryBufferForStream(FD, Filename);
+      }
+      FileSize = fileSizeWin.QuadPart;
+#else
+      struct stat status;
+      if (fstat(FD, &status) < 0) {
+        return std::error_code(errno, std::generic_category());
+      }
 
       // If this not a file or a block device (e.g. it's a named pipe
       // or character device), we can't trust the size. Create the memory
       // buffer by copying off the stream.
-      sys::fs::file_type Type = Status.type();
-      if (Type != sys::fs::file_type::regular_file &&
-          Type != sys::fs::file_type::block_file)
+      if (status.st_mode != S_IFREG && status.st_mode != S_IFBLK) {
         return getMemoryBufferForStream(FD, Filename);
+      }
 
-      FileSize = Status.getSize();
+      FileSize = status.st_size;
+#endif
     }
     MapSize = FileSize;
   }
@@ -417,17 +450,19 @@ getOpenFileImpl(fs::file_t FD, std::string_view Filename, uint64_t FileSize,
   uint8_t *BufPtr = Buf.get()->getBufferStart();
 
   size_t BytesLeft = MapSize;
-#ifndef HAVE_PREAD
-  if (lseek(FD, Offset, SEEK_SET) == -1)
-    return std::error_code(errno, std::generic_category());
-#endif
-
   while (BytesLeft) {
-#ifdef HAVE_PREAD
+#ifdef _WIN32
+    LARGE_INTEGER offsetWin;
+    offsetWin.QuadPart = Offset;
+    DWORD NumRead;
+    if (!SetFilePointerEx(FD, offsetWin, nullptr, FILE_BEGIN) ||
+        !ReadFile(FD, BufPtr, BytesLeft, &NumRead, nullptr)) {
+      return mapWindowsError(GetLastError());
+    }
+// TODO
+#else
     ssize_t NumRead = sys::RetryAfterSignal(-1, ::pread, FD, BufPtr, BytesLeft,
                                             MapSize - BytesLeft + Offset);
-#else
-    ssize_t NumRead = sys::RetryAfterSignal(-1, ::read, FD, BufPtr, BytesLeft);
 #endif
     if (NumRead == -1) {
       // Error while reading.
diff --git a/llvm/lib/Support/raw_ostream.cpp b/llvm/lib/Support/raw_ostream.cpp
index bfaf47645fc7..a1b207e3c0c7 100644
--- a/llvm/lib/Support/raw_ostream.cpp
+++ b/llvm/lib/Support/raw_ostream.cpp
@@ -295,8 +295,11 @@ static int getFD(std::string_view Filename, std::error_code &EC,
     EC = std::error_code();
     // If user requested binary then put stdout into binary mode if
     // possible.
-    if (!(Flags & sys::fs::OF_Text))
-      sys::ChangeStdoutToBinary();
+    if (!(Flags & sys::fs::OF_Text)) {
+#if defined(_WIN32)
+      _setmode(_fileno(stdout), _O_BINARY);
+#endif
+    }
     return STDOUT_FILENO;
   }
 
@@ -365,10 +368,7 @@ raw_fd_ostream::raw_fd_ostream(int fd, bool shouldClose, bool unbuffered)
   // Get the starting position.
   off_t loc = ::lseek(FD, 0, SEEK_CUR);
 #ifdef _WIN32
-  // MSVCRT's _lseek(SEEK_CUR) doesn't return -1 for pipes.
-  sys::fs::file_status Status;
-  std::error_code EC = status(FD, Status);
-  SupportsSeeking = !EC && Status.type() == sys::fs::file_type::regular_file;
+  SupportsSeeking = loc != (off_t)-1 && ::GetFileType(reinterpret_cast<HANDLE>(::_get_osfhandle(FD))) != FILE_TYPE_PIPE;
 #else
   SupportsSeeking = loc != (off_t)-1;
 #endif
@@ -417,7 +417,7 @@ raw_fd_ostream::~raw_fd_ostream() {
 // the input is UTF-8 or transcode from the local codepage to UTF-8 before
 // quoting it. If they don't, this may mess up the encoding, but this is still
 // probably the best compromise we can make.
-static bool write_console_impl(int FD, StringRef Data) {
+static bool write_console_impl(int FD, std::string_view Data) {
   SmallVector<wchar_t, 256> WideText;
 
   // Fall back to ::write if it wasn't valid UTF-8.
@@ -477,7 +477,11 @@ void raw_fd_ostream::write_impl(const char *Ptr, size_t Size) {
 
   do {
     size_t ChunkSize = std::min(Size, MaxWriteSize);
+#ifdef _WIN32
+    int ret = ::_write(FD, Ptr, ChunkSize);
+#else
     ssize_t ret = ::write(FD, Ptr, ChunkSize);
+#endif
 
     if (ret < 0) {
       // If it's a recoverable error, swallow it and retry the write.
@@ -522,8 +526,6 @@ uint64_t raw_fd_ostream::seek(uint64_t off) {
   flush();
 #ifdef _WIN32
   pos = ::_lseeki64(FD, off, SEEK_SET);
-#elif defined(HAVE_LSEEK64)
-  pos = ::lseek64(FD, off, SEEK_SET);
 #else
   pos = ::lseek(FD, off, SEEK_SET);
 #endif
-- 
2.20.1.windows.1

