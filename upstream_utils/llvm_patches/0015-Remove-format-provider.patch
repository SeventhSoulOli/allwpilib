From 9b5db55e5b69ed953baac9d8e782cbe9503b4fd6 Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Tue, 3 May 2022 22:08:59 -0400
Subject: [PATCH 15/35] Remove format provider

---
 llvm/include/llvm/Support/Chrono.h      | 109 ---------
 llvm/include/llvm/Support/raw_ostream.h |  73 +-----
 llvm/lib/Support/raw_ostream.cpp        | 300 ------------------------
 llvm/unittests/Support/Chrono.cpp       |  61 -----
 4 files changed, 11 insertions(+), 532 deletions(-)

diff --git a/llvm/include/llvm/Support/Chrono.h b/llvm/include/llvm/Support/Chrono.h
index 004519a883fd..06829d1fbe14 100644
--- a/llvm/include/llvm/Support/Chrono.h
+++ b/llvm/include/llvm/Support/Chrono.h
@@ -10,7 +10,6 @@
 #define LLVM_SUPPORT_CHRONO_H
 
 #include "llvm/Support/Compiler.h"
-#include "llvm/Support/FormatProviders.h"
 
 #include <chrono>
 #include <ctime>
@@ -58,114 +57,6 @@ toTimePoint(std::time_t T, uint32_t nsec) {
 
 raw_ostream &operator<<(raw_ostream &OS, sys::TimePoint<> TP);
 
-/// Format provider for TimePoint<>
-///
-/// The options string is a strftime format string, with extensions:
-///   - %L is millis: 000-999
-///   - %f is micros: 000000-999999
-///   - %N is nanos: 000000000 - 999999999
-///
-/// If no options are given, the default format is "%Y-%m-%d %H:%M:%S.%N".
-template <>
-struct format_provider<sys::TimePoint<>> {
-  static void format(const sys::TimePoint<> &TP, llvm::raw_ostream &OS,
-                     StringRef Style);
-};
-
-namespace detail {
-template <typename Period> struct unit { static const char value[]; };
-template <typename Period> const char unit<Period>::value[] = "";
-
-template <> struct unit<std::ratio<3600>> { static const char value[]; };
-template <> struct unit<std::ratio<60>> { static const char value[]; };
-template <> struct unit<std::ratio<1>> { static const char value[]; };
-template <> struct unit<std::milli> { static const char value[]; };
-template <> struct unit<std::micro> { static const char value[]; };
-template <> struct unit<std::nano> { static const char value[]; };
-} // namespace detail
-
-/// Implementation of format_provider<T> for duration types.
-///
-/// The options string of a duration type has the grammar:
-///
-///   duration_options  ::= [unit][show_unit [number_options]]
-///   unit              ::= `h`|`m`|`s`|`ms|`us`|`ns`
-///   show_unit         ::= `+` | `-`
-///   number_options    ::= options string for a integral or floating point type
-///
-///   Examples
-///   =================================
-///   |  options  | Input | Output    |
-///   =================================
-///   | ""        | 1s    | 1 s       |
-///   | "ms"      | 1s    | 1000 ms   |
-///   | "ms-"     | 1s    | 1000      |
-///   | "ms-n"    | 1s    | 1,000     |
-///   | ""        | 1.0s  | 1.00 s    |
-///   =================================
-///
-///  If the unit of the duration type is not one of the units specified above,
-///  it is still possible to format it, provided you explicitly request a
-///  display unit or you request that the unit is not displayed.
-
-template <typename Rep, typename Period>
-struct format_provider<std::chrono::duration<Rep, Period>> {
-private:
-  typedef std::chrono::duration<Rep, Period> Dur;
-  typedef std::conditional_t<std::chrono::treat_as_floating_point<Rep>::value,
-                             double, intmax_t>
-      InternalRep;
-
-  template <typename AsPeriod> static InternalRep getAs(const Dur &D) {
-    using namespace std::chrono;
-    return duration_cast<duration<InternalRep, AsPeriod>>(D).count();
-  }
-
-  static std::pair<InternalRep, StringRef> consumeUnit(StringRef &Style,
-                                                        const Dur &D) {
-    using namespace std::chrono;
-    if (Style.consume_front("ns"))
-      return {getAs<std::nano>(D), "ns"};
-    if (Style.consume_front("us"))
-      return {getAs<std::micro>(D), "us"};
-    if (Style.consume_front("ms"))
-      return {getAs<std::milli>(D), "ms"};
-    if (Style.consume_front("s"))
-      return {getAs<std::ratio<1>>(D), "s"};
-    if (Style.consume_front("m"))
-      return {getAs<std::ratio<60>>(D), "m"};
-    if (Style.consume_front("h"))
-      return {getAs<std::ratio<3600>>(D), "h"};
-    return {D.count(), detail::unit<Period>::value};
-  }
-
-  static bool consumeShowUnit(StringRef &Style) {
-    if (Style.empty())
-      return true;
-    if (Style.consume_front("-"))
-      return false;
-    if (Style.consume_front("+"))
-      return true;
-    assert(0 && "Unrecognised duration format");
-    return true;
-  }
-
-public:
-  static void format(const Dur &D, llvm::raw_ostream &Stream, StringRef Style) {
-    InternalRep count;
-    StringRef unit;
-    std::tie(count, unit) = consumeUnit(Style, D);
-    bool show_unit = consumeShowUnit(Style);
-
-    format_provider<InternalRep>::format(count, Stream, Style);
-
-    if (show_unit) {
-      assert(!unit.empty());
-      Stream << " " << unit;
-    }
-  }
-};
-
 } // namespace llvm
 
 #endif // LLVM_SUPPORT_CHRONO_H
diff --git a/llvm/include/llvm/Support/raw_ostream.h b/llvm/include/llvm/Support/raw_ostream.h
index 027c04ff24ba..212cd945758f 100644
--- a/llvm/include/llvm/Support/raw_ostream.h
+++ b/llvm/include/llvm/Support/raw_ostream.h
@@ -29,13 +29,6 @@
 
 namespace llvm {
 
-class formatv_object_base;
-class format_object_base;
-class FormattedString;
-class FormattedNumber;
-class FormattedBytes;
-template <class T> class LLVM_NODISCARD Expected;
-
 namespace sys {
 namespace fs {
 enum FileAccess : unsigned;
@@ -79,7 +72,6 @@ private:
   /// for a \see write_impl() call to handle the data which has been put into
   /// this buffer.
   char *OutBufStart, *OutBufEnd, *OutBufCur;
-  bool ColorEnabled = false;
 
   /// Optional stream this stream is tied to. If this stream is written to, the
   /// tied-to stream will be flushed first.
@@ -254,32 +246,6 @@ public:
     return write(Str.data(), Str.size());
   }
 
-  raw_ostream &operator<<(unsigned long N);
-  raw_ostream &operator<<(long N);
-  raw_ostream &operator<<(unsigned long long N);
-  raw_ostream &operator<<(long long N);
-  raw_ostream &operator<<(const void *P);
-
-  raw_ostream &operator<<(unsigned int N) {
-    return this->operator<<(static_cast<unsigned long>(N));
-  }
-
-  raw_ostream &operator<<(int N) {
-    return this->operator<<(static_cast<long>(N));
-  }
-
-  raw_ostream &operator<<(double N);
-
-  /// Output \p N in hexadecimal, without any prefix or padding.
-  raw_ostream &write_hex(unsigned long long N);
-
-  // Change the foreground color of text.
-  raw_ostream &operator<<(Colors C);
-
-  /// Output a formatted UUID with dash separators.
-  using uuid_t = uint8_t[16];
-  raw_ostream &write_uuid(const uuid_t UUID);
-
   /// Output \p Str, turning '\\', '\t', '\n', '"', and anything that doesn't
   /// satisfy llvm::isPrint into an escape sequence.
   raw_ostream &write_escaped(std::string_view Str, bool UseHexEscapes = false);
@@ -287,21 +253,6 @@ public:
   raw_ostream &write(unsigned char C);
   raw_ostream &write(const char *Ptr, size_t Size);
 
-  // Formatted output, see the format() function in Support/Format.h.
-  raw_ostream &operator<<(const format_object_base &Fmt);
-
-  // Formatted output, see the leftJustify() function in Support/Format.h.
-  raw_ostream &operator<<(const FormattedString &);
-
-  // Formatted output, see the formatHex() function in Support/Format.h.
-  raw_ostream &operator<<(const FormattedNumber &);
-
-  // Formatted output, see the formatv() function in Support/FormatVariadic.h.
-  raw_ostream &operator<<(const formatv_object_base &);
-
-  // Formatted output, see the format_bytes() function in Support/Format.h.
-  raw_ostream &operator<<(const FormattedBytes &);
-
   /// indent - Insert 'NumSpaces' spaces.
   raw_ostream &indent(unsigned NumSpaces);
 
@@ -315,15 +266,21 @@ public:
   /// @param Bold bold/brighter text, default false
   /// @param BG if true change the background, default: change foreground
   /// @returns itself so it can be used within << invocations
-  virtual raw_ostream &changeColor(enum Colors Color, bool Bold = false,
-                                   bool BG = false);
+  virtual raw_ostream &changeColor(enum Colors Color,
+                                   bool Bold = false,
+                                   bool BG = false) {
+    (void)Color;
+    (void)Bold;
+    (void)BG;
+    return *this;
+  }
 
   /// Resets the colors to terminal defaults. Call this when you are done
   /// outputting colored text, or before program exit.
-  virtual raw_ostream &resetColor();
+  virtual raw_ostream &resetColor() { return *this; }
 
   /// Reverses the foreground and background colors.
-  virtual raw_ostream &reverseColor();
+  virtual raw_ostream &reverseColor() { return *this; }
 
   /// This function determines if this stream is connected to a "tty" or
   /// "console" window. That is, the output would be displayed to the user
@@ -336,7 +293,7 @@ public:
 
   // Enable or disable colors. Once enable_colors(false) is called,
   // changeColor() has no effect until enable_colors(true) is called.
-  virtual void enable_colors(bool enable) { ColorEnabled = enable; }
+  virtual void enable_colors(bool /*enable*/) {}
 
   /// Tie this stream to the specified stream. Replaces any existing tied-to
   /// stream. Specifying a nullptr unties the stream.
@@ -396,10 +353,6 @@ private:
   /// unused bytes in the buffer.
   void copy_to_buffer(const char *Ptr, size_t Size);
 
-  /// Compute whether colors should be used and do the necessary work such as
-  /// flushing. The result is affected by calls to enable_color().
-  bool prepare_colors();
-
   /// Flush the tied-to stream (if present) and then write the required data.
   void flush_tied_then_write(const char *Ptr, size_t Size);
 
@@ -524,10 +477,6 @@ public:
   /// to the offset specified from the beginning of the file.
   uint64_t seek(uint64_t off);
 
-  bool is_displayed() const override;
-
-  bool has_colors() const override;
-
   std::error_code error() const { return EC; }
 
   /// Return the value of the flag in this raw_fd_ostream indicating whether an
diff --git a/llvm/lib/Support/raw_ostream.cpp b/llvm/lib/Support/raw_ostream.cpp
index 5a9cf40dcb1d..440213004632 100644
--- a/llvm/lib/Support/raw_ostream.cpp
+++ b/llvm/lib/Support/raw_ostream.cpp
@@ -117,49 +117,6 @@ void raw_ostream::SetBufferAndMode(char *BufferStart, size_t Size,
   assert(OutBufStart <= OutBufEnd && "Invalid size!");
 }
 
-raw_ostream &raw_ostream::operator<<(unsigned long N) {
-  write_integer(*this, static_cast<uint64_t>(N), 0, IntegerStyle::Integer);
-  return *this;
-}
-
-raw_ostream &raw_ostream::operator<<(long N) {
-  write_integer(*this, static_cast<int64_t>(N), 0, IntegerStyle::Integer);
-  return *this;
-}
-
-raw_ostream &raw_ostream::operator<<(unsigned long long N) {
-  write_integer(*this, static_cast<uint64_t>(N), 0, IntegerStyle::Integer);
-  return *this;
-}
-
-raw_ostream &raw_ostream::operator<<(long long N) {
-  write_integer(*this, static_cast<int64_t>(N), 0, IntegerStyle::Integer);
-  return *this;
-}
-
-raw_ostream &raw_ostream::write_hex(unsigned long long N) {
-  llvm::write_hex(*this, N, HexPrintStyle::Lower);
-  return *this;
-}
-
-raw_ostream &raw_ostream::operator<<(Colors C) {
-  if (C == Colors::RESET)
-    resetColor();
-  else
-    changeColor(C);
-  return *this;
-}
-
-raw_ostream &raw_ostream::write_uuid(const uuid_t UUID) {
-  for (int Idx = 0; Idx < 16; ++Idx) {
-    *this << format("%02" PRIX32, UUID[Idx]);
-    if (Idx == 3 || Idx == 5 || Idx == 7 || Idx == 9)
-      *this << "-";
-  }
-  return *this;
-}
-
-
 raw_ostream &raw_ostream::write_escaped(std::string_view Str,
                                         bool UseHexEscapes) {
   for (unsigned char c : Str) {
@@ -200,16 +157,6 @@ raw_ostream &raw_ostream::write_escaped(std::string_view Str,
   return *this;
 }
 
-raw_ostream &raw_ostream::operator<<(const void *P) {
-  llvm::write_hex(*this, (uintptr_t)P, HexPrintStyle::PrefixLower);
-  return *this;
-}
-
-raw_ostream &raw_ostream::operator<<(double N) {
-  llvm::write_double(*this, N, FloatStyle::Exponent);
-  return *this;
-}
-
 void raw_ostream::flush_nonempty() {
   assert(OutBufCur > OutBufStart && "Invalid call to flush_nonempty.");
   size_t Length = OutBufCur - OutBufStart;
@@ -305,173 +252,6 @@ void raw_ostream::flush_tied_then_write(const char *Ptr, size_t Size) {
   write_impl(Ptr, Size);
 }
 
-// Formatted output.
-raw_ostream &raw_ostream::operator<<(const format_object_base &Fmt) {
-  // If we have more than a few bytes left in our output buffer, try
-  // formatting directly onto its end.
-  size_t NextBufferSize = 127;
-  size_t BufferBytesLeft = OutBufEnd - OutBufCur;
-  if (BufferBytesLeft > 3) {
-    size_t BytesUsed = Fmt.print(OutBufCur, BufferBytesLeft);
-
-    // Common case is that we have plenty of space.
-    if (BytesUsed <= BufferBytesLeft) {
-      OutBufCur += BytesUsed;
-      return *this;
-    }
-
-    // Otherwise, we overflowed and the return value tells us the size to try
-    // again with.
-    NextBufferSize = BytesUsed;
-  }
-
-  // If we got here, we didn't have enough space in the output buffer for the
-  // string.  Try printing into a SmallVector that is resized to have enough
-  // space.  Iterate until we win.
-  SmallVector<char, 128> V;
-
-  while (true) {
-    V.resize(NextBufferSize);
-
-    // Try formatting into the SmallVector.
-    size_t BytesUsed = Fmt.print(V.data(), NextBufferSize);
-
-    // If BytesUsed fit into the vector, we win.
-    if (BytesUsed <= NextBufferSize)
-      return write(V.data(), BytesUsed);
-
-    // Otherwise, try again with a new size.
-    assert(BytesUsed > NextBufferSize && "Didn't grow buffer!?");
-    NextBufferSize = BytesUsed;
-  }
-}
-
-raw_ostream &raw_ostream::operator<<(const formatv_object_base &Obj) {
-  Obj.format(*this);
-  return *this;
-}
-
-raw_ostream &raw_ostream::operator<<(const FormattedString &FS) {
-  unsigned LeftIndent = 0;
-  unsigned RightIndent = 0;
-  const ssize_t Difference = FS.Width - FS.Str.size();
-  if (Difference > 0) {
-    switch (FS.Justify) {
-    case FormattedString::JustifyNone:
-      break;
-    case FormattedString::JustifyLeft:
-      RightIndent = Difference;
-      break;
-    case FormattedString::JustifyRight:
-      LeftIndent = Difference;
-      break;
-    case FormattedString::JustifyCenter:
-      LeftIndent = Difference / 2;
-      RightIndent = Difference - LeftIndent;
-      break;
-    }
-  }
-  indent(LeftIndent);
-  (*this) << FS.Str;
-  indent(RightIndent);
-  return *this;
-}
-
-raw_ostream &raw_ostream::operator<<(const FormattedNumber &FN) {
-  if (FN.Hex) {
-    HexPrintStyle Style;
-    if (FN.Upper && FN.HexPrefix)
-      Style = HexPrintStyle::PrefixUpper;
-    else if (FN.Upper && !FN.HexPrefix)
-      Style = HexPrintStyle::Upper;
-    else if (!FN.Upper && FN.HexPrefix)
-      Style = HexPrintStyle::PrefixLower;
-    else
-      Style = HexPrintStyle::Lower;
-    llvm::write_hex(*this, FN.HexValue, Style, FN.Width);
-  } else {
-    llvm::SmallString<16> Buffer;
-    llvm::raw_svector_ostream Stream(Buffer);
-    llvm::write_integer(Stream, FN.DecValue, 0, IntegerStyle::Integer);
-    if (Buffer.size() < FN.Width)
-      indent(FN.Width - Buffer.size());
-    (*this) << Buffer;
-  }
-  return *this;
-}
-
-raw_ostream &raw_ostream::operator<<(const FormattedBytes &FB) {
-  if (FB.Bytes.empty())
-    return *this;
-
-  size_t LineIndex = 0;
-  auto Bytes = FB.Bytes;
-  const size_t Size = Bytes.size();
-  HexPrintStyle HPS = FB.Upper ? HexPrintStyle::Upper : HexPrintStyle::Lower;
-  uint64_t OffsetWidth = 0;
-  if (FB.FirstByteOffset.hasValue()) {
-    // Figure out how many nibbles are needed to print the largest offset
-    // represented by this data set, so that we can align the offset field
-    // to the right width.
-    size_t Lines = Size / FB.NumPerLine;
-    uint64_t MaxOffset = *FB.FirstByteOffset + Lines * FB.NumPerLine;
-    unsigned Power = 0;
-    if (MaxOffset > 0)
-      Power = llvm::Log2_64_Ceil(MaxOffset);
-    OffsetWidth = std::max<uint64_t>(4, llvm::alignTo(Power, 4) / 4);
-  }
-
-  // The width of a block of data including all spaces for group separators.
-  unsigned NumByteGroups =
-      alignTo(FB.NumPerLine, FB.ByteGroupSize) / FB.ByteGroupSize;
-  unsigned BlockCharWidth = FB.NumPerLine * 2 + NumByteGroups - 1;
-
-  while (!Bytes.empty()) {
-    indent(FB.IndentLevel);
-
-    if (FB.FirstByteOffset.hasValue()) {
-      uint64_t Offset = FB.FirstByteOffset.getValue();
-      llvm::write_hex(*this, Offset + LineIndex, HPS, OffsetWidth);
-      *this << ": ";
-    }
-
-    auto Line = Bytes.take_front(FB.NumPerLine);
-
-    size_t CharsPrinted = 0;
-    // Print the hex bytes for this line in groups
-    for (size_t I = 0; I < Line.size(); ++I, CharsPrinted += 2) {
-      if (I && (I % FB.ByteGroupSize) == 0) {
-        ++CharsPrinted;
-        *this << " ";
-      }
-      llvm::write_hex(*this, Line[I], HPS, 2);
-    }
-
-    if (FB.ASCII) {
-      // Print any spaces needed for any bytes that we didn't print on this
-      // line so that the ASCII bytes are correctly aligned.
-      assert(BlockCharWidth >= CharsPrinted);
-      indent(BlockCharWidth - CharsPrinted + 2);
-      *this << "|";
-
-      // Print the ASCII char values for each byte on this line
-      for (uint8_t Byte : Line) {
-        if (isPrint(Byte))
-          *this << static_cast<char>(Byte);
-        else
-          *this << '.';
-      }
-      *this << '|';
-    }
-
-    Bytes = Bytes.drop_front(Line.size());
-    LineIndex += Line.size();
-    if (LineIndex < Size)
-      *this << '\n';
-  }
-  return *this;
-}
-
 template <char C>
 static raw_ostream &write_padding(raw_ostream &OS, unsigned NumChars) {
   static const char Chars[] = {C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C,
@@ -503,63 +283,8 @@ raw_ostream &raw_ostream::write_zeros(unsigned NumZeros) {
   return write_padding<'\0'>(*this, NumZeros);
 }
 
-bool raw_ostream::prepare_colors() {
-  // Colors were explicitly disabled.
-  if (!ColorEnabled)
-    return false;
-
-  // Colors require changing the terminal but this stream is not going to a
-  // terminal.
-  if (sys::Process::ColorNeedsFlush() && !is_displayed())
-    return false;
-
-  if (sys::Process::ColorNeedsFlush())
-    flush();
-
-  return true;
-}
-
-raw_ostream &raw_ostream::changeColor(enum Colors colors, bool bold, bool bg) {
-  if (!prepare_colors())
-    return *this;
-
-  const char *colorcode =
-      (colors == SAVEDCOLOR)
-          ? sys::Process::OutputBold(bg)
-          : sys::Process::OutputColor(static_cast<char>(colors), bold, bg);
-  if (colorcode)
-    write(colorcode, strlen(colorcode));
-  return *this;
-}
-
-raw_ostream &raw_ostream::resetColor() {
-  if (!prepare_colors())
-    return *this;
-
-  if (const char *colorcode = sys::Process::ResetColor())
-    write(colorcode, strlen(colorcode));
-  return *this;
-}
-
-raw_ostream &raw_ostream::reverseColor() {
-  if (!prepare_colors())
-    return *this;
-
-  if (const char *colorcode = sys::Process::OutputReverse())
-    write(colorcode, strlen(colorcode));
-  return *this;
-}
-
 void raw_ostream::anchor() {}
 
-//===----------------------------------------------------------------------===//
-//  Formatted Output
-//===----------------------------------------------------------------------===//
-
-// Out of line virtual method.
-void format_object_base::home() {
-}
-
 //===----------------------------------------------------------------------===//
 //  raw_fd_ostream
 //===----------------------------------------------------------------------===//
@@ -850,31 +575,6 @@ size_t raw_fd_ostream::preferred_buffer_size() const {
 #endif
 }
 
-bool raw_fd_ostream::is_displayed() const {
-  return sys::Process::FileDescriptorIsDisplayed(FD);
-}
-
-bool raw_fd_ostream::has_colors() const {
-  if (!HasColors)
-    HasColors = sys::Process::FileDescriptorHasColors(FD);
-  return *HasColors;
-}
-
-Expected<sys::fs::FileLocker> raw_fd_ostream::lock() {
-  std::error_code EC = sys::fs::lockFile(FD);
-  if (!EC)
-    return sys::fs::FileLocker(FD);
-  return errorCodeToError(EC);
-}
-
-Expected<sys::fs::FileLocker>
-raw_fd_ostream::tryLockFor(std::chrono::milliseconds Timeout) {
-  std::error_code EC = sys::fs::tryLockFile(FD, Timeout);
-  if (!EC)
-    return sys::fs::FileLocker(FD);
-  return errorCodeToError(EC);
-}
-
 void raw_fd_ostream::anchor() {}
 
 //===----------------------------------------------------------------------===//
diff --git a/llvm/unittests/Support/Chrono.cpp b/llvm/unittests/Support/Chrono.cpp
index 9a08a5c1bfdf..3c049de18c0a 100644
--- a/llvm/unittests/Support/Chrono.cpp
+++ b/llvm/unittests/Support/Chrono.cpp
@@ -30,37 +30,6 @@ TEST(Chrono, TimeTConversion) {
   EXPECT_EQ(TP, toTimePoint(toTimeT(TP)));
 }
 
-TEST(Chrono, TimePointFormat) {
-  using namespace std::chrono;
-  struct tm TM {};
-  TM.tm_year = 106;
-  TM.tm_mon = 0;
-  TM.tm_mday = 2;
-  TM.tm_hour = 15;
-  TM.tm_min = 4;
-  TM.tm_sec = 5;
-  TM.tm_isdst = -1;
-  TimePoint<> T =
-      system_clock::from_time_t(mktime(&TM)) + nanoseconds(123456789);
-
-  // operator<< uses the format YYYY-MM-DD HH:MM:SS.NNNNNNNNN
-  std::string S;
-  raw_string_ostream OS(S);
-  OS << T;
-  EXPECT_EQ("2006-01-02 15:04:05.123456789", OS.str());
-
-  // formatv default style matches operator<<.
-  EXPECT_EQ("2006-01-02 15:04:05.123456789", formatv("{0}", T).str());
-  // formatv supports strftime-style format strings.
-  EXPECT_EQ("15:04:05", formatv("{0:%H:%M:%S}", T).str());
-  // formatv supports our strftime extensions for sub-second precision.
-  EXPECT_EQ("123", formatv("{0:%L}", T).str());
-  EXPECT_EQ("123456", formatv("{0:%f}", T).str());
-  EXPECT_EQ("123456789", formatv("{0:%N}", T).str());
-  // our extensions don't interfere with %% escaping.
-  EXPECT_EQ("%foo", formatv("{0:%%foo}", T).str());
-}
-
 // Test that toTimePoint and toTimeT can be called with a arguments with varying
 // precisions.
 TEST(Chrono, ImplicitConversions) {
@@ -78,34 +47,4 @@ TEST(Chrono, ImplicitConversions) {
   EXPECT_EQ(TimeT, toTimeT(Nano));
 }
 
-TEST(Chrono, DurationFormat) {
-  EXPECT_EQ("1 h", formatv("{0}", hours(1)).str());
-  EXPECT_EQ("1 m", formatv("{0}", minutes(1)).str());
-  EXPECT_EQ("1 s", formatv("{0}", seconds(1)).str());
-  EXPECT_EQ("1 ms", formatv("{0}", milliseconds(1)).str());
-  EXPECT_EQ("1 us", formatv("{0}", microseconds(1)).str());
-  EXPECT_EQ("1 ns", formatv("{0}", nanoseconds(1)).str());
-
-  EXPECT_EQ("1 s", formatv("{0:+}", seconds(1)).str());
-  EXPECT_EQ("1", formatv("{0:-}", seconds(1)).str());
-
-  EXPECT_EQ("1000 ms", formatv("{0:ms}", seconds(1)).str());
-  EXPECT_EQ("1000000 us", formatv("{0:us}", seconds(1)).str());
-  EXPECT_EQ("1000", formatv("{0:ms-}", seconds(1)).str());
-
-  EXPECT_EQ("1,000 ms", formatv("{0:+n}", milliseconds(1000)).str());
-  EXPECT_EQ("0x3e8", formatv("{0:-x}", milliseconds(1000)).str());
-  EXPECT_EQ("010", formatv("{0:-3}", milliseconds(10)).str());
-  EXPECT_EQ("10,000", formatv("{0:ms-n}", seconds(10)).str());
-
-  EXPECT_EQ("1.00 s", formatv("{0}", duration<float>(1)).str());
-  EXPECT_EQ("0.123 s", formatv("{0:+3}", duration<float>(0.123f)).str());
-  EXPECT_EQ("1.230e-01 s", formatv("{0:+e3}", duration<float>(0.123f)).str());
-
-  typedef duration<float, std::ratio<60 * 60 * 24 * 14, 1000000>>
-      microfortnights;
-  EXPECT_EQ("1.00", formatv("{0:-}", microfortnights(1)).str());
-  EXPECT_EQ("1209.60 ms", formatv("{0:ms}", microfortnights(1)).str());
-}
-
 } // anonymous namespace
-- 
2.20.1.windows.1

