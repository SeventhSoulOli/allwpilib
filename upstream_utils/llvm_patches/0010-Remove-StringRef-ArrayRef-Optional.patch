From f815496497dcd6cbe5a986bbfd5d620fb0c18cb6 Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Tue, 3 May 2022 21:42:38 -0400
Subject: [PATCH 10/35] Remove StringRef, ArrayRef, Optional

---
 llvm/include/llvm/ADT/DenseMapInfo.h          |   1 +
 llvm/include/llvm/ADT/SmallSet.h              |  12 +-
 llvm/include/llvm/ADT/SmallString.h           |  76 ++--
 llvm/include/llvm/ADT/StringMap.h             |  34 +-
 llvm/include/llvm/ADT/StringMapEntry.h        |  21 +-
 llvm/include/llvm/Support/ConvertUTF.h        |  43 +-
 llvm/include/llvm/Support/ErrorHandling.h     |   7 +-
 llvm/include/llvm/Support/MemoryBuffer.h      |  42 +-
 llvm/include/llvm/Support/MemoryBufferRef.h   |  14 +-
 .../llvm/Support/SmallVectorMemoryBuffer.h    |   6 +-
 llvm/include/llvm/Support/VersionTuple.h      |  19 +-
 .../llvm/Support/Windows/WindowsSupport.h     |   4 +-
 llvm/include/llvm/Support/raw_ostream.h       |  46 ++-
 llvm/lib/Support/ConvertUTFWrapper.cpp        |  37 +-
 llvm/lib/Support/ErrorHandling.cpp            |  13 +-
 llvm/lib/Support/MemoryBuffer.cpp             |  76 ++--
 llvm/lib/Support/StringMap.cpp                |  12 +-
 llvm/lib/Support/raw_ostream.cpp              |  18 +-
 llvm/unittests/ADT/DenseMapTest.cpp           |  14 +-
 llvm/unittests/ADT/FunctionExtrasTest.cpp     |  12 +-
 llvm/unittests/ADT/HashingTest.cpp            |   2 +-
 llvm/unittests/ADT/SmallStringTest.cpp        | 142 +------
 llvm/unittests/ADT/SmallVectorTest.cpp        | 384 +-----------------
 llvm/unittests/ADT/StringMapTest.cpp          |  60 +--
 llvm/unittests/Support/ConvertUTFTest.cpp     |  25 +-
 25 files changed, 278 insertions(+), 842 deletions(-)

diff --git a/llvm/include/llvm/ADT/DenseMapInfo.h b/llvm/include/llvm/ADT/DenseMapInfo.h
index 0040ac36217e..cb05dd6c0054 100644
--- a/llvm/include/llvm/ADT/DenseMapInfo.h
+++ b/llvm/include/llvm/ADT/DenseMapInfo.h
@@ -17,6 +17,7 @@
 #include <cassert>
 #include <cstddef>
 #include <cstdint>
+#include <string_view>
 #include <utility>
 
 namespace llvm {
diff --git a/llvm/include/llvm/ADT/SmallSet.h b/llvm/include/llvm/ADT/SmallSet.h
index 0600e528ee69..e4c209c5f2a9 100644
--- a/llvm/include/llvm/ADT/SmallSet.h
+++ b/llvm/include/llvm/ADT/SmallSet.h
@@ -13,7 +13,6 @@
 #ifndef LLVM_ADT_SMALLSET_H
 #define LLVM_ADT_SMALLSET_H
 
-#include "llvm/ADT/None.h"
 #include "llvm/ADT/SmallPtrSet.h"
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/ADT/iterator.h"
@@ -21,6 +20,7 @@
 #include "llvm/Support/type_traits.h"
 #include <cstddef>
 #include <functional>
+#include <optional>
 #include <set>
 #include <type_traits>
 #include <utility>
@@ -177,16 +177,16 @@ public:
   /// concept.
   // FIXME: Add iterators that abstract over the small and large form, and then
   // return those here.
-  std::pair<NoneType, bool> insert(const T &V) {
+  std::pair<std::nullopt_t, bool> insert(const T &V) {
     if (!isSmall())
-      return std::make_pair(None, Set.insert(V).second);
+      return std::make_pair(std::nullopt, Set.insert(V).second);
 
     VIterator I = vfind(V);
     if (I != Vector.end())    // Don't reinsert if it already exists.
-      return std::make_pair(None, false);
+      return std::make_pair(std::nullopt, false);
     if (Vector.size() < N) {
       Vector.push_back(V);
-      return std::make_pair(None, true);
+      return std::make_pair(std::nullopt, true);
     }
 
     // Otherwise, grow from vector to set.
@@ -195,7 +195,7 @@ public:
       Vector.pop_back();
     }
     Set.insert(V);
-    return std::make_pair(None, true);
+    return std::make_pair(std::nullopt, true);
   }
 
   template <typename IterT>
diff --git a/llvm/include/llvm/ADT/SmallString.h b/llvm/include/llvm/ADT/SmallString.h
index 56b0639b98cc..8112741dd01d 100644
--- a/llvm/include/llvm/ADT/SmallString.h
+++ b/llvm/include/llvm/ADT/SmallString.h
@@ -14,8 +14,8 @@
 #define LLVM_ADT_SMALLSTRING_H
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/StringRef.h"
 #include <cstddef>
+#include <string_view>
 
 namespace llvm {
 
@@ -27,11 +27,11 @@ public:
   /// Default ctor - Initialize to empty.
   SmallString() = default;
 
-  /// Initialize from a StringRef.
-  SmallString(StringRef S) : SmallVector<char, InternalLen>(S.begin(), S.end()) {}
+  /// Initialize from a std::string_view.
+  SmallString(std::string_view S) : SmallVector<char, InternalLen>(S.begin(), S.end()) {}
 
-  /// Initialize by concatenating a list of StringRefs.
-  SmallString(std::initializer_list<StringRef> Refs)
+  /// Initialize by concatenating a list of std::string_views.
+  SmallString(std::initializer_list<std::string_view> Refs)
       : SmallVector<char, InternalLen>() {
     this->append(Refs);
   }
@@ -46,13 +46,13 @@ public:
 
   using SmallVector<char, InternalLen>::assign;
 
-  /// Assign from a StringRef.
-  void assign(StringRef RHS) {
+  /// Assign from a std::string_view.
+  void assign(std::string_view RHS) {
     SmallVectorImpl<char>::assign(RHS.begin(), RHS.end());
   }
 
-  /// Assign from a list of StringRefs.
-  void assign(std::initializer_list<StringRef> Refs) {
+  /// Assign from a list of std::string_views.
+  void assign(std::initializer_list<std::string_view> Refs) {
     this->clear();
     append(Refs);
   }
@@ -63,19 +63,19 @@ public:
 
   using SmallVector<char, InternalLen>::append;
 
-  /// Append from a StringRef.
-  void append(StringRef RHS) {
+  /// Append from a std::string_view.
+  void append(std::string_view RHS) {
     SmallVectorImpl<char>::append(RHS.begin(), RHS.end());
   }
 
-  /// Append from a list of StringRefs.
-  void append(std::initializer_list<StringRef> Refs) {
+  /// Append from a list of std::string_views.
+  void append(std::initializer_list<std::string_view> Refs) {
     size_t SizeNeeded = this->size();
-    for (const StringRef &Ref : Refs)
+    for (const std::string_view &Ref : Refs)
       SizeNeeded += Ref.size();
     this->reserve(SizeNeeded);
     auto CurEnd = this->end();
-    for (const StringRef &Ref : Refs) {
+    for (const std::string_view &Ref : Refs) {
       this->uninitialized_copy(Ref.begin(), Ref.end(), CurEnd);
       CurEnd += Ref.size();
     }
@@ -88,29 +88,29 @@ public:
 
   /// Check for string equality.  This is more efficient than compare() when
   /// the relative ordering of inequal strings isn't needed.
-  bool equals(StringRef RHS) const {
+  bool equals(std::string_view RHS) const {
     return str().equals(RHS);
   }
 
   /// Check for string equality, ignoring case.
-  bool equals_insensitive(StringRef RHS) const {
+  bool equals_insensitive(std::string_view RHS) const {
     return str().equals_insensitive(RHS);
   }
 
   /// Compare two strings; the result is -1, 0, or 1 if this string is
   /// lexicographically less than, equal to, or greater than the \p RHS.
-  int compare(StringRef RHS) const {
+  int compare(std::string_view RHS) const {
     return str().compare(RHS);
   }
 
   /// compare_insensitive - Compare two strings, ignoring case.
-  int compare_insensitive(StringRef RHS) const {
+  int compare_insensitive(std::string_view RHS) const {
     return str().compare_insensitive(RHS);
   }
 
   /// compare_numeric - Compare two strings, treating sequences of digits as
   /// numbers.
-  int compare_numeric(StringRef RHS) const {
+  int compare_numeric(std::string_view RHS) const {
     return str().compare_numeric(RHS);
   }
 
@@ -119,12 +119,12 @@ public:
   /// @{
 
   /// startswith - Check if this string starts with the given \p Prefix.
-  bool startswith(StringRef Prefix) const {
+  bool startswith(std::string_view Prefix) const {
     return str().startswith(Prefix);
   }
 
   /// endswith - Check if this string ends with the given \p Suffix.
-  bool endswith(StringRef Suffix) const {
+  bool endswith(std::string_view Suffix) const {
     return str().endswith(Suffix);
   }
 
@@ -144,7 +144,7 @@ public:
   ///
   /// \returns The index of the first occurrence of \p Str, or npos if not
   /// found.
-  size_t find(StringRef Str, size_t From = 0) const {
+  size_t find(std::string_view Str, size_t From = 0) const {
     return str().find(Str, From);
   }
 
@@ -152,7 +152,7 @@ public:
   ///
   /// \returns The index of the last occurrence of \p C, or npos if not
   /// found.
-  size_t rfind(char C, size_t From = StringRef::npos) const {
+  size_t rfind(char C, size_t From = std::string_view::npos) const {
     return str().rfind(C, From);
   }
 
@@ -160,7 +160,7 @@ public:
   ///
   /// \returns The index of the last occurrence of \p Str, or npos if not
   /// found.
-  size_t rfind(StringRef Str) const {
+  size_t rfind(std::string_view Str) const {
     return str().rfind(Str);
   }
 
@@ -174,7 +174,7 @@ public:
   /// not found.
   ///
   /// Complexity: O(size() + Chars.size())
-  size_t find_first_of(StringRef Chars, size_t From = 0) const {
+  size_t find_first_of(std::string_view Chars, size_t From = 0) const {
     return str().find_first_of(Chars, From);
   }
 
@@ -188,13 +188,13 @@ public:
   /// \p Chars, or npos if not found.
   ///
   /// Complexity: O(size() + Chars.size())
-  size_t find_first_not_of(StringRef Chars, size_t From = 0) const {
+  size_t find_first_not_of(std::string_view Chars, size_t From = 0) const {
     return str().find_first_not_of(Chars, From);
   }
 
   /// Find the last character in the string that is \p C, or npos if not
   /// found.
-  size_t find_last_of(char C, size_t From = StringRef::npos) const {
+  size_t find_last_of(char C, size_t From = std::string_view::npos) const {
     return str().find_last_of(C, From);
   }
 
@@ -203,7 +203,7 @@ public:
   ///
   /// Complexity: O(size() + Chars.size())
   size_t find_last_of(
-      StringRef Chars, size_t From = StringRef::npos) const {
+      std::string_view Chars, size_t From = std::string_view::npos) const {
     return str().find_last_of(Chars, From);
   }
 
@@ -218,7 +218,7 @@ public:
 
   /// Return the number of non-overlapped occurrences of \p Str in the
   /// string.
-  size_t count(StringRef Str) const {
+  size_t count(std::string_view Str) const {
     return str().count(Str);
   }
 
@@ -235,7 +235,7 @@ public:
   /// \param N The number of characters to included in the substring. If \p N
   /// exceeds the number of characters remaining in the string, the string
   /// suffix (starting with \p Start) will be returned.
-  StringRef substr(size_t Start, size_t N = StringRef::npos) const {
+  std::string_view substr(size_t Start, size_t N = std::string_view::npos) const {
     return str().substr(Start, N);
   }
 
@@ -249,14 +249,14 @@ public:
   /// substring. If this is npos, or less than \p Start, or exceeds the
   /// number of characters remaining in the string, the string suffix
   /// (starting with \p Start) will be returned.
-  StringRef slice(size_t Start, size_t End) const {
+  std::string_view slice(size_t Start, size_t End) const {
     return str().slice(Start, End);
   }
 
   // Extra methods.
 
-  /// Explicit conversion to StringRef.
-  StringRef str() const { return StringRef(this->data(), this->size()); }
+  /// Explicit conversion to std::string_view.
+  std::string_view str() const { return std::string_view(this->begin(), this->size()); }
 
   // TODO: Make this const, if it's safe...
   const char* c_str() {
@@ -265,20 +265,20 @@ public:
     return this->data();
   }
 
-  /// Implicit conversion to StringRef.
-  operator StringRef() const { return str(); }
+  /// Implicit conversion to std::string_view.
+  operator std::string_view() const { return str(); }
 
   explicit operator std::string() const {
     return std::string(this->data(), this->size());
   }
 
   // Extra operators.
-  SmallString &operator=(StringRef RHS) {
+  SmallString &operator=(std::string_view RHS) {
     this->assign(RHS);
     return *this;
   }
 
-  SmallString &operator+=(StringRef RHS) {
+  SmallString &operator+=(std::string_view RHS) {
     this->append(RHS.begin(), RHS.end());
     return *this;
   }
diff --git a/llvm/include/llvm/ADT/StringMap.h b/llvm/include/llvm/ADT/StringMap.h
index a97b5660da53..7b0fc072f935 100644
--- a/llvm/include/llvm/ADT/StringMap.h
+++ b/llvm/include/llvm/ADT/StringMap.h
@@ -58,12 +58,12 @@ protected:
   /// specified bucket will be non-null.  Otherwise, it will be null.  In either
   /// case, the FullHashValue field of the bucket will be set to the hash value
   /// of the string.
-  unsigned LookupBucketFor(StringRef Key);
+  unsigned LookupBucketFor(std::string_view Key);
 
   /// FindKey - Look up the bucket that contains the specified key. If it exists
   /// in the map, return the bucket number of the key.  Otherwise return -1.
   /// This does not modify the map.
-  int FindKey(StringRef Key) const;
+  int FindKey(std::string_view Key) const;
 
   /// RemoveKey - Remove the specified StringMapEntry from the table, but do not
   /// delete it.  This aborts if the value isn't in the table.
@@ -71,7 +71,7 @@ protected:
 
   /// RemoveKey - Remove the StringMapEntry for the specified key from the
   /// table, returning it.  If the key is not in the table, this returns null.
-  StringMapEntryBase *RemoveKey(StringRef Key);
+  StringMapEntryBase *RemoveKey(std::string_view Key);
 
   /// Allocate the table with the specified number of buckets and otherwise
   /// setup the map as empty.
@@ -114,7 +114,7 @@ public:
   explicit StringMap(unsigned InitialSize)
       : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))) {}
 
-  StringMap(std::initializer_list<std::pair<StringRef, ValueTy>> List)
+  StringMap(std::initializer_list<std::pair<std::string_view, ValueTy>> List)
       : StringMapImpl(List.size(), static_cast<unsigned>(sizeof(MapEntryTy))) {
     for (const auto &P : List) {
       insert(P);
@@ -200,14 +200,14 @@ public:
                       StringMapKeyIterator<ValueTy>(end()));
   }
 
-  iterator find(StringRef Key) {
+  iterator find(std::string_view Key) {
     int Bucket = FindKey(Key);
     if (Bucket == -1)
       return end();
     return iterator(TheTable + Bucket, true);
   }
 
-  const_iterator find(StringRef Key) const {
+  const_iterator find(std::string_view Key) const {
     int Bucket = FindKey(Key);
     if (Bucket == -1)
       return end();
@@ -216,7 +216,7 @@ public:
 
   /// lookup - Return the entry for the specified key, or a default
   /// constructed value if no such entry exists.
-  ValueTy lookup(StringRef Key) const {
+  ValueTy lookup(std::string_view Key) const {
     const_iterator it = find(Key);
     if (it != end())
       return it->second;
@@ -225,10 +225,10 @@ public:
 
   /// Lookup the ValueTy for the \p Key, or create a default constructed value
   /// if the key is not in the map.
-  ValueTy &operator[](StringRef Key) { return try_emplace(Key).first->second; }
+  ValueTy &operator[](std::string_view Key) { return try_emplace(Key).first->second; }
 
   /// count - Return 1 if the element is in the map, 0 otherwise.
-  size_type count(StringRef Key) const { return find(Key) == end() ? 0 : 1; }
+  size_type count(std::string_view Key) const { return find(Key) == end() ? 0 : 1; }
 
   template <typename InputTy>
   size_type count(const StringMapEntry<InputTy> &MapEntry) const {
@@ -278,14 +278,14 @@ public:
   /// isn't already in the map. The bool component of the returned pair is true
   /// if and only if the insertion takes place, and the iterator component of
   /// the pair points to the element with key equivalent to the key of the pair.
-  std::pair<iterator, bool> insert(std::pair<StringRef, ValueTy> KV) {
+  std::pair<iterator, bool> insert(std::pair<std::string_view, ValueTy> KV) {
     return try_emplace(KV.first, std::move(KV.second));
   }
 
   /// Inserts an element or assigns to the current element if the key already
   /// exists. The return type is the same as try_emplace.
   template <typename V>
-  std::pair<iterator, bool> insert_or_assign(StringRef Key, V &&Val) {
+  std::pair<iterator, bool> insert_or_assign(std::string_view Key, V &&Val) {
     auto Ret = try_emplace(Key, std::forward<V>(Val));
     if (!Ret.second)
       Ret.first->second = std::forward<V>(Val);
@@ -297,7 +297,7 @@ public:
   /// if and only if the insertion takes place, and the iterator component of
   /// the pair points to the element with key equivalent to the key of the pair.
   template <typename... ArgsTy>
-  std::pair<iterator, bool> try_emplace(StringRef Key, ArgsTy &&... Args) {
+  std::pair<iterator, bool> try_emplace(std::string_view Key, ArgsTy &&... Args) {
     unsigned BucketNo = LookupBucketFor(Key);
     StringMapEntryBase *&Bucket = TheTable[BucketNo];
     if (Bucket && Bucket != getTombstoneVal())
@@ -343,7 +343,7 @@ public:
     V.Destroy();
   }
 
-  bool erase(StringRef Key) {
+  bool erase(std::string_view Key) {
     iterator I = find(Key);
     if (I == end())
       return false;
@@ -440,23 +440,23 @@ template <typename ValueTy>
 class StringMapKeyIterator
     : public iterator_adaptor_base<StringMapKeyIterator<ValueTy>,
                                    StringMapConstIterator<ValueTy>,
-                                   std::forward_iterator_tag, StringRef> {
+                                   std::forward_iterator_tag, std::string_view> {
   using base = iterator_adaptor_base<StringMapKeyIterator<ValueTy>,
                                      StringMapConstIterator<ValueTy>,
-                                     std::forward_iterator_tag, StringRef>;
+                                     std::forward_iterator_tag, std::string_view>;
 
 public:
   StringMapKeyIterator() = default;
   explicit StringMapKeyIterator(StringMapConstIterator<ValueTy> Iter)
       : base(std::move(Iter)) {}
 
-  StringRef &operator*() {
+  std::string_view &operator*() {
     Key = this->wrapped()->getKey();
     return Key;
   }
 
 private:
-  StringRef Key;
+  std::string_view Key;
 };
 
 } // end namespace llvm
diff --git a/llvm/include/llvm/ADT/StringMapEntry.h b/llvm/include/llvm/ADT/StringMapEntry.h
index 633404af394d..66a30698d787 100644
--- a/llvm/include/llvm/ADT/StringMapEntry.h
+++ b/llvm/include/llvm/ADT/StringMapEntry.h
@@ -15,7 +15,8 @@
 #ifndef LLVM_ADT_STRINGMAPENTRY_H
 #define LLVM_ADT_STRINGMAPENTRY_H
 
-#include "llvm/ADT/StringRef.h"
+#include <optional>
+#include <string_view>
 
 namespace llvm {
 
@@ -33,7 +34,7 @@ protected:
   /// could be reused elsewhere, maybe even taking an llvm::function_ref to
   /// type-erase the allocator and put it in a source file.
   static void *allocateWithKey(size_t EntrySize, size_t EntryAlign,
-                               StringRef Key) {
+                               std::string_view Key) {
   size_t KeyLength = Key.size();
 
   // Allocate a new item with space for the string at the end and a null
@@ -75,13 +76,13 @@ public:
   void setValue(const ValueTy &V) { second = V; }
 };
 
-template <> class StringMapEntryStorage<NoneType> : public StringMapEntryBase {
+template <> class StringMapEntryStorage<std::nullopt_t> : public StringMapEntryBase {
 public:
-  explicit StringMapEntryStorage(size_t keyLength, NoneType = None)
+  explicit StringMapEntryStorage(size_t keyLength, std::nullopt_t = std::nullopt)
       : StringMapEntryBase(keyLength) {}
   StringMapEntryStorage(StringMapEntryStorage &entry) = delete;
 
-  NoneType getValue() const { return None; }
+  std::nullopt_t getValue() const { return std::nullopt; }
 };
 
 /// StringMapEntry - This is used to represent one value that is inserted into
@@ -92,8 +93,8 @@ class StringMapEntry final : public StringMapEntryStorage<ValueTy> {
 public:
   using StringMapEntryStorage<ValueTy>::StringMapEntryStorage;
 
-  StringRef getKey() const {
-    return StringRef(getKeyData(), this->getKeyLength());
+  std::string_view getKey() const {
+    return std::string_view(getKeyData(), this->getKeyLength());
   }
 
   /// getKeyData - Return the start of the string data that is the key for this
@@ -103,14 +104,14 @@ public:
     return reinterpret_cast<const char *>(this + 1);
   }
 
-  StringRef first() const {
-    return StringRef(getKeyData(), this->getKeyLength());
+  std::string_view first() const {
+    return std::string_view(getKeyData(), this->getKeyLength());
   }
 
   /// Create a StringMapEntry for the specified key construct the value using
   /// \p InitiVals.
   template <typename... InitTy>
-  static StringMapEntry *Create(StringRef key,
+  static StringMapEntry *Create(std::string_view key,
                                 InitTy &&... initVals) {
     return new (StringMapEntryBase::allocateWithKey(
         sizeof(StringMapEntry), alignof(StringMapEntry), key))
diff --git a/llvm/include/llvm/Support/ConvertUTF.h b/llvm/include/llvm/Support/ConvertUTF.h
index c83ba81fa2e2..48435fbb6f30 100644
--- a/llvm/include/llvm/Support/ConvertUTF.h
+++ b/llvm/include/llvm/Support/ConvertUTF.h
@@ -89,8 +89,11 @@
 #ifndef LLVM_SUPPORT_CONVERTUTF_H
 #define LLVM_SUPPORT_CONVERTUTF_H
 
+#include "wpi/span.h"
+
 #include <cstddef>
 #include <string>
+#include <string_view>
 #include <system_error>
 
 // Wrap everything in namespace llvm so that programs can link with llvm and
@@ -180,27 +183,7 @@ unsigned getNumBytesForUTF8(UTF8 firstByte);
 /*************************************************************************/
 /* Below are LLVM-specific wrappers of the functions above. */
 
-template <typename T> class ArrayRef;
 template <typename T> class SmallVectorImpl;
-class StringRef;
-
-/**
- * Convert an UTF8 StringRef to UTF8, UTF16, or UTF32 depending on
- * WideCharWidth. The converted data is written to ResultPtr, which needs to
- * point to at least WideCharWidth * (Source.Size() + 1) bytes. On success,
- * ResultPtr will point one after the end of the copied string. On failure,
- * ResultPtr will not be changed, and ErrorPtr will be set to the location of
- * the first character which could not be converted.
- * \return true on success.
- */
-bool ConvertUTF8toWide(unsigned WideCharWidth, llvm::StringRef Source,
-                       char *&ResultPtr, const UTF8 *&ErrorPtr);
-
-/**
-* Converts a UTF-8 StringRef to a std::wstring.
-* \return true on success.
-*/
-bool ConvertUTF8toWide(llvm::StringRef Source, std::wstring &Result);
 
 /**
 * Converts a UTF-8 C-string to a std::wstring.
@@ -258,7 +241,7 @@ inline ConversionResult convertUTF8Sequence(const UTF8 **source,
  * Returns true if a blob of text starts with a UTF-16 big or little endian byte
  * order mark.
  */
-bool hasUTF16ByteOrderMark(ArrayRef<char> SrcBytes);
+bool hasUTF16ByteOrderMark(span<const char> SrcBytes);
 
 /**
  * Converts a stream of raw bytes assumed to be UTF16 into a UTF8 std::string.
@@ -267,31 +250,23 @@ bool hasUTF16ByteOrderMark(ArrayRef<char> SrcBytes);
  * \param [out] Out Converted UTF-8 is stored here on success.
  * \returns true on success
  */
-bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out);
-
-/**
-* Converts a UTF16 string into a UTF8 std::string.
-*
-* \param [in] Src A buffer of UTF-16 encoded text.
-* \param [out] Out Converted UTF-8 is stored here on success.
-* \returns true on success
-*/
-bool convertUTF16ToUTF8String(ArrayRef<UTF16> Src, std::string &Out);
+bool convertUTF16ToUTF8String(span<const UTF16> SrcBytes,
+                              SmallVectorImpl<char> &Out);
 
 /**
  * Converts a UTF-8 string into a UTF-16 string with native endianness.
  *
  * \returns true on success
  */
-bool convertUTF8ToUTF16String(StringRef SrcUTF8,
+bool convertUTF8ToUTF16String(std::string_view SrcUTF8,
                               SmallVectorImpl<UTF16> &DstUTF16);
 
 #if defined(_WIN32)
 namespace sys {
 namespace windows {
-std::error_code UTF8ToUTF16(StringRef utf8, SmallVectorImpl<wchar_t> &utf16);
+std::error_code UTF8ToUTF16(std::string_view utf8, SmallVectorImpl<wchar_t> &utf16);
 /// Convert to UTF16 from the current code page used in the system
-std::error_code CurCPToUTF16(StringRef utf8, SmallVectorImpl<wchar_t> &utf16);
+std::error_code CurCPToUTF16(std::string_view utf8, SmallVectorImpl<wchar_t> &utf16);
 std::error_code UTF16ToUTF8(const wchar_t *utf16, size_t utf16_len,
                             SmallVectorImpl<char> &utf8);
 /// Convert from UTF16 to the current code page used in the system
diff --git a/llvm/include/llvm/Support/ErrorHandling.h b/llvm/include/llvm/Support/ErrorHandling.h
index dd85a5892e01..411c78a81b24 100644
--- a/llvm/include/llvm/Support/ErrorHandling.h
+++ b/llvm/include/llvm/Support/ErrorHandling.h
@@ -16,10 +16,9 @@
 
 #include "llvm/Support/Compiler.h"
 #include <string>
+#include <string_view>
 
 namespace llvm {
-class StringRef;
-  class Twine;
 
   /// An error handler callback.
   typedef void (*fatal_error_handler_t)(void *user_data,
@@ -72,9 +71,7 @@ LLVM_ATTRIBUTE_NORETURN void report_fatal_error(const char *reason,
                                                 bool gen_crash_diag = true);
 LLVM_ATTRIBUTE_NORETURN void report_fatal_error(const std::string &reason,
                                                 bool gen_crash_diag = true);
-LLVM_ATTRIBUTE_NORETURN void report_fatal_error(StringRef reason,
-                                                bool gen_crash_diag = true);
-LLVM_ATTRIBUTE_NORETURN void report_fatal_error(const Twine &reason,
+LLVM_ATTRIBUTE_NORETURN void report_fatal_error(std::string_view reason,
                                                 bool gen_crash_diag = true);
 
 /// Installs a new bad alloc error handler that should be used whenever a
diff --git a/llvm/include/llvm/Support/MemoryBuffer.h b/llvm/include/llvm/Support/MemoryBuffer.h
index 96b836591c46..98a48aaaa5cc 100644
--- a/llvm/include/llvm/Support/MemoryBuffer.h
+++ b/llvm/include/llvm/Support/MemoryBuffer.h
@@ -14,15 +14,13 @@
 #define LLVM_SUPPORT_MEMORYBUFFER_H
 
 #include "llvm-c/Types.h"
-#include "llvm/ADT/ArrayRef.h"
-#include "llvm/ADT/StringRef.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Support/CBindingWrapping.h"
 #include "llvm/Support/ErrorOr.h"
 #include "llvm/Support/MemoryBufferRef.h"
 #include <cstddef>
 #include <cstdint>
 #include <memory>
+#include <string_view>
 
 namespace llvm {
 namespace sys {
@@ -66,13 +64,13 @@ public:
   const char *getBufferEnd() const   { return BufferEnd; }
   size_t getBufferSize() const { return BufferEnd-BufferStart; }
 
-  StringRef getBuffer() const {
-    return StringRef(BufferStart, getBufferSize());
+  span<const uint8_t> getBuffer() const {
+    return {BufferStart, getBufferSize()};
   }
 
   /// Return an identifier for this buffer, typically the filename it was read
   /// from.
-  virtual StringRef getBufferIdentifier() const { return "Unknown buffer"; }
+  virtual std::string_view getBufferIdentifier() const { return "Unknown buffer"; }
 
   /// Open the specified file as a MemoryBuffer, returning a new MemoryBuffer
   /// if successful, otherwise returning null.
@@ -84,20 +82,20 @@ public:
   /// can change outside the user's control, e.g. when libclang tries to parse
   /// while the user is editing/updating the file or if the file is on an NFS.
   static ErrorOr<std::unique_ptr<MemoryBuffer>>
-  getFile(const Twine &Filename, bool IsText = false,
+  getFile(const std::string_view &Filename, bool IsText = false,
           bool RequiresNullTerminator = true, bool IsVolatile = false);
 
   /// Read all of the specified file into a MemoryBuffer as a stream
   /// (i.e. until EOF reached). This is useful for special files that
   /// look like a regular file but have 0 size (e.g. /proc/cpuinfo on Linux).
   static ErrorOr<std::unique_ptr<MemoryBuffer>>
-  getFileAsStream(const Twine &Filename);
+  getFileAsStream(const std::string_view &Filename);
 
   /// Given an already-open file descriptor, map some slice of it into a
   /// MemoryBuffer. The slice is specified by an \p Offset and \p MapSize.
   /// Since this is in the middle of a file, the buffer is not null terminated.
   static ErrorOr<std::unique_ptr<MemoryBuffer>>
-  getOpenFileSlice(sys::fs::file_t FD, const Twine &Filename, uint64_t MapSize,
+  getOpenFileSlice(sys::fs::file_t FD, const std::string_view &Filename, uint64_t MapSize,
                    int64_t Offset, bool IsVolatile = false);
 
   /// Given an already-open file descriptor, read the file and return a
@@ -107,13 +105,13 @@ public:
   /// can change outside the user's control, e.g. when libclang tries to parse
   /// while the user is editing/updating the file or if the file is on an NFS.
   static ErrorOr<std::unique_ptr<MemoryBuffer>>
-  getOpenFile(sys::fs::file_t FD, const Twine &Filename, uint64_t FileSize,
+  getOpenFile(sys::fs::file_t FD, const std::string_view &Filename, uint64_t FileSize,
               bool RequiresNullTerminator = true, bool IsVolatile = false);
 
   /// Open the specified memory range as a MemoryBuffer. Note that InputData
   /// must be null terminated if RequiresNullTerminator is true.
   static std::unique_ptr<MemoryBuffer>
-  getMemBuffer(StringRef InputData, StringRef BufferName = "",
+  getMemBuffer(span<const uint8_t> InputData, std::string_view BufferName = "",
                bool RequiresNullTerminator = true);
 
   static std::unique_ptr<MemoryBuffer>
@@ -122,7 +120,7 @@ public:
   /// Open the specified memory range as a MemoryBuffer, copying the contents
   /// and taking ownership of it. InputData does not have to be null terminated.
   static std::unique_ptr<MemoryBuffer>
-  getMemBufferCopy(StringRef InputData, const Twine &BufferName = "");
+  getMemBufferCopy(span<const uint8_t> InputData, const std::string_view &BufferName = "");
 
   /// Read all of stdin into a file buffer, and return it.
   static ErrorOr<std::unique_ptr<MemoryBuffer>> getSTDIN();
@@ -130,12 +128,12 @@ public:
   /// Open the specified file as a MemoryBuffer, or open stdin if the Filename
   /// is "-".
   static ErrorOr<std::unique_ptr<MemoryBuffer>>
-  getFileOrSTDIN(const Twine &Filename, bool IsText = false,
+  getFileOrSTDIN(const std::string_view &Filename, bool IsText = false,
                  bool RequiresNullTerminator = true);
 
   /// Map a subrange of the specified file as a MemoryBuffer.
   static ErrorOr<std::unique_ptr<MemoryBuffer>>
-  getFileSlice(const Twine &Filename, uint64_t MapSize, uint64_t Offset,
+  getFileSlice(const std::string_view &Filename, uint64_t MapSize, uint64_t Offset,
                bool IsVolatile = false);
 
   //===--------------------------------------------------------------------===//
@@ -176,29 +174,29 @@ public:
   char *getBufferEnd() {
     return const_cast<char *>(MemoryBuffer::getBufferEnd());
   }
-  MutableArrayRef<char> getBuffer() {
+  span<uint8_t> getBuffer() {
     return {getBufferStart(), getBufferEnd()};
   }
 
   static ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
-  getFile(const Twine &Filename, bool IsVolatile = false);
+  getFile(const std::string_view &Filename, bool IsVolatile = false);
 
   /// Map a subrange of the specified file as a WritableMemoryBuffer.
   static ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
-  getFileSlice(const Twine &Filename, uint64_t MapSize, uint64_t Offset,
+  getFileSlice(const std::string_view &Filename, uint64_t MapSize, uint64_t Offset,
                bool IsVolatile = false);
 
   /// Allocate a new MemoryBuffer of the specified size that is not initialized.
   /// Note that the caller should initialize the memory allocated by this
   /// method. The memory is owned by the MemoryBuffer object.
   static std::unique_ptr<WritableMemoryBuffer>
-  getNewUninitMemBuffer(size_t Size, const Twine &BufferName = "");
+  getNewUninitMemBuffer(size_t Size, const std::string_view &BufferName = "");
 
   /// Allocate a new zero-initialized MemoryBuffer of the specified size. Note
   /// that the caller need not initialize the memory allocated by this method.
   /// The memory is owned by the MemoryBuffer object.
   static std::unique_ptr<WritableMemoryBuffer>
-  getNewMemBuffer(size_t Size, const Twine &BufferName = "");
+  getNewMemBuffer(size_t Size, const std::string_view &BufferName = "");
 
 private:
   // Hide these base class factory function so one can't write
@@ -234,16 +232,16 @@ public:
   char *getBufferEnd() {
     return const_cast<char *>(MemoryBuffer::getBufferEnd());
   }
-  MutableArrayRef<char> getBuffer() {
+  span<uint8_t> getBuffer() {
     return {getBufferStart(), getBufferEnd()};
   }
 
   static ErrorOr<std::unique_ptr<WriteThroughMemoryBuffer>>
-  getFile(const Twine &Filename, int64_t FileSize = -1);
+  getFile(const std::string_view &Filename, int64_t FileSize = -1);
 
   /// Map a subrange of the specified file as a ReadWriteMemoryBuffer.
   static ErrorOr<std::unique_ptr<WriteThroughMemoryBuffer>>
-  getFileSlice(const Twine &Filename, uint64_t MapSize, uint64_t Offset);
+  getFileSlice(const std::string_view &Filename, uint64_t MapSize, uint64_t Offset);
 
 private:
   // Hide these base class factory function so one can't write
diff --git a/llvm/include/llvm/Support/MemoryBufferRef.h b/llvm/include/llvm/Support/MemoryBufferRef.h
index b38a1f3b6565..34fa70bc6f8e 100644
--- a/llvm/include/llvm/Support/MemoryBufferRef.h
+++ b/llvm/include/llvm/Support/MemoryBufferRef.h
@@ -13,24 +13,26 @@
 #ifndef LLVM_SUPPORT_MEMORYBUFFERREF_H
 #define LLVM_SUPPORT_MEMORYBUFFERREF_H
 
-#include "llvm/ADT/StringRef.h"
+#include "wpi/span.h"
+
+#include <cstdint>
 
 namespace llvm {
 
 class MemoryBuffer;
 
 class MemoryBufferRef {
-  StringRef Buffer;
-  StringRef Identifier;
+  span<const uint8_t> Buffer;
+  std::string_view Identifier;
 
 public:
   MemoryBufferRef() = default;
   MemoryBufferRef(const MemoryBuffer &Buffer);
-  MemoryBufferRef(StringRef Buffer, StringRef Identifier)
+  MemoryBufferRef(span<const uint8_t> Buffer, std::string_view Identifier)
       : Buffer(Buffer), Identifier(Identifier) {}
 
-  StringRef getBuffer() const { return Buffer; }
-  StringRef getBufferIdentifier() const { return Identifier; }
+  span<const uint8_t> getBuffer() const { return Buffer; }
+  std::string_view getBufferIdentifier() const { return Identifier; }
 
   const char *getBufferStart() const { return Buffer.begin(); }
   const char *getBufferEnd() const { return Buffer.end(); }
diff --git a/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h b/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
index 9aa4e9aec266..924ed77510fe 100644
--- a/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
+++ b/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
@@ -42,8 +42,8 @@ public:
   }
 
   /// Construct a named SmallVectorMemoryBuffer from the given
-  /// SmallVector r-value and StringRef.
-  SmallVectorMemoryBuffer(SmallVectorImpl<char> &&SV, StringRef Name)
+  /// SmallVector r-value and std::string_view.
+  SmallVectorMemoryBuffer(SmallVectorImpl<char> &&SV, std::string_view Name)
       : SV(std::move(SV)), BufferName(std::string(Name)) {
     init(this->SV.begin(), this->SV.end(), false);
   }
@@ -51,7 +51,7 @@ public:
   // Key function.
   ~SmallVectorMemoryBuffer() override;
 
-  StringRef getBufferIdentifier() const override { return BufferName; }
+  std::string_view getBufferIdentifier() const override { return BufferName; }
 
   BufferKind getBufferKind() const override { return MemoryBuffer_Malloc; }
 
diff --git a/llvm/include/llvm/Support/VersionTuple.h b/llvm/include/llvm/Support/VersionTuple.h
index a48ae0bf52bd..0eb464678d7e 100644
--- a/llvm/include/llvm/Support/VersionTuple.h
+++ b/llvm/include/llvm/Support/VersionTuple.h
@@ -16,7 +16,7 @@
 
 #include "llvm/ADT/DenseMapInfo.h"
 #include "llvm/ADT/Hashing.h"
-#include "llvm/ADT/Optional.h"
+#include <optional>
 #include <string>
 #include <tuple>
 
@@ -69,23 +69,23 @@ public:
   unsigned getMajor() const { return Major; }
 
   /// Retrieve the minor version number, if provided.
-  Optional<unsigned> getMinor() const {
+  std::optional<unsigned> getMinor() const {
     if (!HasMinor)
-      return None;
+      return std::nullopt;
     return Minor;
   }
 
   /// Retrieve the subminor version number, if provided.
-  Optional<unsigned> getSubminor() const {
+  std::optional<unsigned> getSubminor() const {
     if (!HasSubminor)
-      return None;
+      return std::nullopt;
     return Subminor;
   }
 
   /// Retrieve the build version number, if provided.
-  Optional<unsigned> getBuild() const {
+  std::optional<unsigned> getBuild() const {
     if (!HasBuild)
-      return None;
+      return std::nullopt;
     return Build;
   }
 
@@ -166,11 +166,6 @@ public:
 
   /// Retrieve a string representation of the version number.
   std::string getAsString() const;
-
-  /// Try to parse the given string as a version number.
-  /// \returns \c true if the string does not match the regular expression
-  ///   [0-9]+(\.[0-9]+){0,3}
-  bool tryParse(StringRef string);
 };
 
 /// Print a version number.
diff --git a/llvm/include/llvm/Support/Windows/WindowsSupport.h b/llvm/include/llvm/Support/Windows/WindowsSupport.h
index c972f10dcaa7..16975cfb16e8 100644
--- a/llvm/include/llvm/Support/Windows/WindowsSupport.h
+++ b/llvm/include/llvm/Support/Windows/WindowsSupport.h
@@ -35,9 +35,7 @@
 
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/ADT/StringExtras.h"
-#include "llvm/ADT/StringRef.h"
-#include "llvm/ADT/Twine.h"
-#include "llvm/Config/llvm-config.h" // Get build system configuration settings
+#include "llvm/Config/config.h" // Get build system configuration settings
 #include "llvm/Support/Allocator.h"
 #include "llvm/Support/Chrono.h"
 #include "llvm/Support/Compiler.h"
diff --git a/llvm/include/llvm/Support/raw_ostream.h b/llvm/include/llvm/Support/raw_ostream.h
index c669c2babad9..027c04ff24ba 100644
--- a/llvm/include/llvm/Support/raw_ostream.h
+++ b/llvm/include/llvm/Support/raw_ostream.h
@@ -14,8 +14,7 @@
 #define LLVM_SUPPORT_RAW_OSTREAM_H
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/StringRef.h"
-#include "llvm/Support/DataTypes.h"
+#include "llvm/ADT/span.h"
 #include <cassert>
 #include <chrono>
 #include <cstddef>
@@ -209,7 +208,22 @@ public:
     return *this;
   }
 
-  raw_ostream &operator<<(StringRef Str) {
+  raw_ostream &operator<<(span<const uint8_t> Arr) {
+    // Inline fast path, particularly for arrays with a known length.
+    size_t Size = Arr.size();
+
+    // Make sure we can use the fast path.
+    if (Size > (size_t)(OutBufEnd - OutBufCur))
+      return write(Arr.data(), Size);
+
+    if (Size) {
+      memcpy(OutBufCur, Arr.data(), Size);
+      OutBufCur += Size;
+    }
+    return *this;
+  }
+
+  raw_ostream &operator<<(std::string_view Str) {
     // Inline fast path, particularly for strings with a known length.
     size_t Size = Str.size();
 
@@ -228,7 +242,7 @@ public:
     // Inline fast path, particularly for constant strings where a sufficiently
     // smart compiler will simplify strlen.
 
-    return this->operator<<(StringRef(Str));
+    return this->operator<<(std::string_view(Str));
   }
 
   raw_ostream &operator<<(const std::string &Str) {
@@ -236,12 +250,6 @@ public:
     return write(Str.data(), Str.length());
   }
 
-#if __cplusplus > 201402L
-  raw_ostream &operator<<(const std::string_view &Str) {
-    return write(Str.data(), Str.length());
-  }
-#endif
-
   raw_ostream &operator<<(const SmallVectorImpl<char> &Str) {
     return write(Str.data(), Str.size());
   }
@@ -274,7 +282,7 @@ public:
 
   /// Output \p Str, turning '\\', '\t', '\n', '"', and anything that doesn't
   /// satisfy llvm::isPrint into an escape sequence.
-  raw_ostream &write_escaped(StringRef Str, bool UseHexEscapes = false);
+  raw_ostream &write_escaped(std::string_view Str, bool UseHexEscapes = false);
 
   raw_ostream &write(unsigned char C);
   raw_ostream &write(const char *Ptr, size_t Size);
@@ -487,14 +495,14 @@ public:
   /// As a special case, if Filename is "-", then the stream will use
   /// STDOUT_FILENO instead of opening a file. This will not close the stdout
   /// descriptor.
-  raw_fd_ostream(StringRef Filename, std::error_code &EC);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC);
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::CreationDisposition Disp);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::FileAccess Access);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::OpenFlags Flags);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::CreationDisposition Disp, sys::fs::FileAccess Access,
                  sys::fs::OpenFlags Flags);
 
@@ -597,7 +605,7 @@ public:
   /// Open the specified file for reading/writing/seeking. If an error occurs,
   /// information about the error is put into EC, and the stream should be
   /// immediately destroyed.
-  raw_fd_stream(StringRef Filename, std::error_code &EC);
+  raw_fd_stream(std::string_view Filename, std::error_code &EC);
 
   /// This reads the \p Size bytes into a buffer pointed by \p Ptr.
   ///
@@ -677,8 +685,8 @@ public:
 
   void flush() = delete;
 
-  /// Return a StringRef for the vector contents.
-  StringRef str() const { return StringRef(OS.data(), OS.size()); }
+  /// Return a std::string_view for the vector contents.
+  std::string_view str() const { return std::string_view(OS.data(), OS.size()); }
 
   void reserveExtraSpace(uint64_t ExtraSize) override {
     OS.reserve(tell() + ExtraSize);
diff --git a/llvm/lib/Support/ConvertUTFWrapper.cpp b/llvm/lib/Support/ConvertUTFWrapper.cpp
index d8d46712a593..b1721ddeae6c 100644
--- a/llvm/lib/Support/ConvertUTFWrapper.cpp
+++ b/llvm/lib/Support/ConvertUTFWrapper.cpp
@@ -6,24 +6,24 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "llvm/ADT/ArrayRef.h"
-#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/span.h"
 #include "llvm/Support/ConvertUTF.h"
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm/Support/SwapByteOrder.h"
 #include <string>
+#include <string_view>
 #include <vector>
 
 namespace llvm {
 
-bool ConvertUTF8toWide(unsigned WideCharWidth, llvm::StringRef Source,
+bool ConvertUTF8toWide(unsigned WideCharWidth, std::string_view Source,
                        char *&ResultPtr, const UTF8 *&ErrorPtr) {
   assert(WideCharWidth == 1 || WideCharWidth == 2 || WideCharWidth == 4);
   ConversionResult result = conversionOK;
   // Copy the character span over.
   if (WideCharWidth == 1) {
-    const UTF8 *Pos = reinterpret_cast<const UTF8*>(Source.begin());
-    if (!isLegalUTF8String(&Pos, reinterpret_cast<const UTF8*>(Source.end()))) {
+    const UTF8 *Pos = reinterpret_cast<const UTF8*>(Source.data());
+    if (!isLegalUTF8String(&Pos, reinterpret_cast<const UTF8*>(Source.data() + Source.size()))) {
       result = sourceIllegal;
       ErrorPtr = Pos;
     } else {
@@ -77,13 +77,13 @@ bool ConvertCodePointToUTF8(unsigned Source, char *&ResultPtr) {
   return true;
 }
 
-bool hasUTF16ByteOrderMark(ArrayRef<char> S) {
+bool hasUTF16ByteOrderMark(span<const char> S) {
   return (S.size() >= 2 &&
           ((S[0] == '\xff' && S[1] == '\xfe') ||
            (S[0] == '\xfe' && S[1] == '\xff')));
 }
 
-bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out) {
+bool convertUTF16ToUTF8String(span<const UTF16> SrcBytes, SmallVectorImpl<char> &Out) {
   assert(Out.empty());
 
   // Error out on an uneven byte count.
@@ -94,8 +94,8 @@ bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out) {
   if (SrcBytes.empty())
     return true;
 
-  const UTF16 *Src = reinterpret_cast<const UTF16 *>(SrcBytes.begin());
-  const UTF16 *SrcEnd = reinterpret_cast<const UTF16 *>(SrcBytes.end());
+  const UTF16 *Src = SrcBytes.begin();
+  const UTF16 *SrcEnd = SrcBytes.end();
 
   assert((uintptr_t)Src % sizeof(UTF16) == 0);
 
@@ -134,14 +134,7 @@ bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out) {
   return true;
 }
 
-bool convertUTF16ToUTF8String(ArrayRef<UTF16> Src, std::string &Out)
-{
-  return convertUTF16ToUTF8String(
-      llvm::ArrayRef<char>(reinterpret_cast<const char *>(Src.data()),
-      Src.size() * sizeof(UTF16)), Out);
-}
-
-bool convertUTF8ToUTF16String(StringRef SrcUTF8,
+bool convertUTF8ToUTF16String(std::string_view SrcUTF8,
                               SmallVectorImpl<UTF16> &DstUTF16) {
   assert(DstUTF16.empty());
 
@@ -152,8 +145,8 @@ bool convertUTF8ToUTF16String(StringRef SrcUTF8,
     return true;
   }
 
-  const UTF8 *Src = reinterpret_cast<const UTF8 *>(SrcUTF8.begin());
-  const UTF8 *SrcEnd = reinterpret_cast<const UTF8 *>(SrcUTF8.end());
+  const UTF8 *Src = reinterpret_cast<const UTF8 *>(SrcUTF8.data());
+  const UTF8 *SrcEnd = reinterpret_cast<const UTF8 *>(SrcUTF8.data() + SrcUTF8.size());
 
   // Allocate the same number of UTF-16 code units as UTF-8 code units. Encoding
   // as UTF-16 should always require the same amount or less code units than the
@@ -184,7 +177,7 @@ static_assert(sizeof(wchar_t) == 1 || sizeof(wchar_t) == 2 ||
               "Expected wchar_t to be 1, 2, or 4 bytes");
 
 template <typename TResult>
-static inline bool ConvertUTF8toWideInternal(llvm::StringRef Source,
+static inline bool ConvertUTF8toWideInternal(std::string_view Source,
                                              TResult &Result) {
   // Even in the case of UTF-16, the number of bytes in a UTF-8 string is
   // at least as large as the number of elements in the resulting wide
@@ -200,7 +193,7 @@ static inline bool ConvertUTF8toWideInternal(llvm::StringRef Source,
   return true;
 }
 
-bool ConvertUTF8toWide(llvm::StringRef Source, std::wstring &Result) {
+bool ConvertUTF8toWide(std::string_view Source, std::wstring &Result) {
   return ConvertUTF8toWideInternal(Source, Result);
 }
 
@@ -209,7 +202,7 @@ bool ConvertUTF8toWide(const char *Source, std::wstring &Result) {
     Result.clear();
     return true;
   }
-  return ConvertUTF8toWide(llvm::StringRef(Source), Result);
+  return ConvertUTF8toWide(std::string_view(Source), Result);
 }
 
 bool convertWideToUTF8(const std::wstring &Source, std::string &Result) {
diff --git a/llvm/lib/Support/ErrorHandling.cpp b/llvm/lib/Support/ErrorHandling.cpp
index 756814416b91..4b91f214c841 100644
--- a/llvm/lib/Support/ErrorHandling.cpp
+++ b/llvm/lib/Support/ErrorHandling.cpp
@@ -14,7 +14,6 @@
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm-c/ErrorHandling.h"
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Config/config.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/Errc.h"
@@ -74,18 +73,14 @@ void llvm::remove_fatal_error_handler() {
 }
 
 void llvm::report_fatal_error(const char *Reason, bool GenCrashDiag) {
-  report_fatal_error(Twine(Reason), GenCrashDiag);
+  report_fatal_error(std::string_view(Reason), GenCrashDiag);
 }
 
 void llvm::report_fatal_error(const std::string &Reason, bool GenCrashDiag) {
-  report_fatal_error(Twine(Reason), GenCrashDiag);
+  report_fatal_error(std::string_view(Reason), GenCrashDiag);
 }
 
-void llvm::report_fatal_error(StringRef Reason, bool GenCrashDiag) {
-  report_fatal_error(Twine(Reason), GenCrashDiag);
-}
-
-void llvm::report_fatal_error(const Twine &Reason, bool GenCrashDiag) {
+void llvm::report_fatal_error(const std::string_view &Reason, bool GenCrashDiag) {
   llvm::fatal_error_handler_t handler = nullptr;
   void* handlerData = nullptr;
   {
@@ -97,7 +92,7 @@ void llvm::report_fatal_error(const Twine &Reason, bool GenCrashDiag) {
   }
 
   if (handler) {
-    handler(handlerData, Reason.str(), GenCrashDiag);
+    handler(handlerData, std::string{Reason}, GenCrashDiag);
   } else {
     // Blast the result out to stderr.  We don't try hard to make sure this
     // succeeds (e.g. handling EINTR) and we can't use errs() here because
diff --git a/llvm/lib/Support/MemoryBuffer.cpp b/llvm/lib/Support/MemoryBuffer.cpp
index cddad9ca0660..5a176249f427 100644
--- a/llvm/lib/Support/MemoryBuffer.cpp
+++ b/llvm/lib/Support/MemoryBuffer.cpp
@@ -55,9 +55,9 @@ void MemoryBuffer::init(const char *BufStart, const char *BufEnd,
 // MemoryBufferMem implementation.
 //===----------------------------------------------------------------------===//
 
-/// CopyStringRef - Copies contents of a StringRef into a block of memory and
+/// CopyStringView - Copies contents of a std::string_view into a block of memory and
 /// null-terminates it.
-static void CopyStringRef(char *Memory, StringRef Data) {
+static void CopyStringView(char *Memory, std::string_view Data) {
   if (!Data.empty())
     memcpy(Memory, Data.data(), Data.size());
   Memory[Data.size()] = 0; // Null terminate string.
@@ -65,17 +65,17 @@ static void CopyStringRef(char *Memory, StringRef Data) {
 
 namespace {
 struct NamedBufferAlloc {
-  const Twine &Name;
-  NamedBufferAlloc(const Twine &Name) : Name(Name) {}
+  std::string_view Name;
+  NamedBufferAlloc(std::string_view Name) : Name(Name) {}
 };
 } // namespace
 
 void *operator new(size_t N, const NamedBufferAlloc &Alloc) {
   SmallString<256> NameBuf;
-  StringRef NameRef = Alloc.Name.toStringRef(NameBuf);
+  std::string_view NameRef = Alloc.Name.tostd::string_view(NameBuf);
 
   char *Mem = static_cast<char *>(operator new(N + NameRef.size() + 1));
-  CopyStringRef(Mem + N, NameRef);
+  CopyStringView(Mem + N, NameRef);
   return Mem;
 }
 
@@ -84,7 +84,7 @@ namespace {
 template<typename MB>
 class MemoryBufferMem : public MB {
 public:
-  MemoryBufferMem(StringRef InputData, bool RequiresNullTerminator) {
+  MemoryBufferMem(span<const uint8_t> InputData, bool RequiresNullTerminator) {
     MemoryBuffer::init(InputData.begin(), InputData.end(),
                        RequiresNullTerminator);
   }
@@ -93,9 +93,9 @@ public:
   /// tail-allocated data.
   void operator delete(void *p) { ::operator delete(p); }
 
-  StringRef getBufferIdentifier() const override {
+  std::string_view getBufferIdentifier() const override {
     // The name is stored after the class itself.
-    return StringRef(reinterpret_cast<const char *>(this + 1));
+    return std::string_view(reinterpret_cast<const char *>(this + 1));
   }
 
   MemoryBuffer::BufferKind getBufferKind() const override {
@@ -106,11 +106,11 @@ public:
 
 template <typename MB>
 static ErrorOr<std::unique_ptr<MB>>
-getFileAux(const Twine &Filename, uint64_t MapSize, uint64_t Offset,
+getFileAux(std::string_view Filename, uint64_t MapSize, uint64_t Offset,
            bool IsText, bool RequiresNullTerminator, bool IsVolatile);
 
 std::unique_ptr<MemoryBuffer>
-MemoryBuffer::getMemBuffer(StringRef InputData, StringRef BufferName,
+MemoryBuffer::getMemBuffer(span<const uint8_t> InputData, std::string_view BufferName,
                            bool RequiresNullTerminator) {
   auto *Ret = new (NamedBufferAlloc(BufferName))
       MemoryBufferMem<MemoryBuffer>(InputData, RequiresNullTerminator);
@@ -124,7 +124,7 @@ MemoryBuffer::getMemBuffer(MemoryBufferRef Ref, bool RequiresNullTerminator) {
 }
 
 static ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
-getMemBufferCopyImpl(StringRef InputData, const Twine &BufferName) {
+getMemBufferCopyImpl(span<const uint8_t> InputData, std::string_view BufferName) {
   auto Buf = WritableMemoryBuffer::getNewUninitMemBuffer(InputData.size(), BufferName);
   if (!Buf)
     return make_error_code(errc::not_enough_memory);
@@ -133,7 +133,7 @@ getMemBufferCopyImpl(StringRef InputData, const Twine &BufferName) {
 }
 
 std::unique_ptr<MemoryBuffer>
-MemoryBuffer::getMemBufferCopy(StringRef InputData, const Twine &BufferName) {
+MemoryBuffer::getMemBufferCopy(span<const uint8_t> InputData, std::string_view BufferName) {
   auto Buf = getMemBufferCopyImpl(InputData, BufferName);
   if (Buf)
     return std::move(*Buf);
@@ -141,10 +141,10 @@ MemoryBuffer::getMemBufferCopy(StringRef InputData, const Twine &BufferName) {
 }
 
 ErrorOr<std::unique_ptr<MemoryBuffer>>
-MemoryBuffer::getFileOrSTDIN(const Twine &Filename, bool IsText,
+MemoryBuffer::getFileOrSTDIN(std::string_view Filename, bool IsText,
                              bool RequiresNullTerminator) {
   SmallString<256> NameBuf;
-  StringRef NameRef = Filename.toStringRef(NameBuf);
+  std::string_view NameRef = Filename.tostd::string_view(NameBuf);
 
   if (NameRef == "-")
     return getSTDIN();
@@ -153,7 +153,7 @@ MemoryBuffer::getFileOrSTDIN(const Twine &Filename, bool IsText,
 }
 
 ErrorOr<std::unique_ptr<MemoryBuffer>>
-MemoryBuffer::getFileSlice(const Twine &FilePath, uint64_t MapSize,
+MemoryBuffer::getFileSlice(std::string_view FilePath, uint64_t MapSize,
                            uint64_t Offset, bool IsVolatile) {
   return getFileAux<MemoryBuffer>(FilePath, MapSize, Offset, /*IsText=*/false,
                                   /*RequiresNullTerminator=*/false, IsVolatile);
@@ -212,9 +212,9 @@ public:
   /// tail-allocated data.
   void operator delete(void *p) { ::operator delete(p); }
 
-  StringRef getBufferIdentifier() const override {
+  std::string_view getBufferIdentifier() const override {
     // The name is stored after the class itself.
-    return StringRef(reinterpret_cast<const char *>(this + 1));
+    return std::string_view(reinterpret_cast<const char *>(this + 1));
   }
 
   MemoryBuffer::BufferKind getBufferKind() const override {
@@ -224,7 +224,7 @@ public:
 } // namespace
 
 static ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
-getMemoryBufferForStream(sys::fs::file_t FD, const Twine &BufferName) {
+getMemoryBufferForStream(sys::fs::file_t FD, std::string_view BufferName) {
   constexpr size_t ChunkSize = 4096*4;
   SmallVector<uint8_t, ChunkSize> Buffer;
   // Read into Buffer until we hit EOF.
@@ -243,7 +243,7 @@ getMemoryBufferForStream(sys::fs::file_t FD, const Twine &BufferName) {
 }
 
 ErrorOr<std::unique_ptr<MemoryBuffer>>
-MemoryBuffer::getFile(const Twine &Filename, bool IsText,
+MemoryBuffer::getFile(std::string_view Filename, bool IsText,
                       bool RequiresNullTerminator, bool IsVolatile) {
   return getFileAux<MemoryBuffer>(Filename, /*MapSize=*/-1, /*Offset=*/0,
                                   IsText, RequiresNullTerminator, IsVolatile);
@@ -251,13 +251,13 @@ MemoryBuffer::getFile(const Twine &Filename, bool IsText,
 
 template <typename MB>
 static ErrorOr<std::unique_ptr<MB>>
-getOpenFileImpl(sys::fs::file_t FD, const Twine &Filename, uint64_t FileSize,
+getOpenFileImpl(sys::fs::file_t FD, std::string_view Filename, uint64_t FileSize,
                 uint64_t MapSize, int64_t Offset, bool RequiresNullTerminator,
                 bool IsVolatile);
 
 template <typename MB>
 static ErrorOr<std::unique_ptr<MB>>
-getFileAux(const Twine &Filename, uint64_t MapSize, uint64_t Offset,
+getFileAux(std::string_view Filename, uint64_t MapSize, uint64_t Offset,
            bool IsText, bool RequiresNullTerminator, bool IsVolatile) {
   Expected<sys::fs::file_t> FDOrErr = sys::fs::openNativeFileForRead(
       Filename, IsText ? sys::fs::OF_TextWithCRLF : sys::fs::OF_None);
@@ -271,14 +271,14 @@ getFileAux(const Twine &Filename, uint64_t MapSize, uint64_t Offset,
 }
 
 ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
-WritableMemoryBuffer::getFile(const Twine &Filename, bool IsVolatile) {
+WritableMemoryBuffer::getFile(std::string_view Filename, bool IsVolatile) {
   return getFileAux<WritableMemoryBuffer>(
       Filename, /*MapSize=*/-1, /*Offset=*/0, /*IsText=*/false,
       /*RequiresNullTerminator=*/false, IsVolatile);
 }
 
 ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
-WritableMemoryBuffer::getFileSlice(const Twine &Filename, uint64_t MapSize,
+WritableMemoryBuffer::getFileSlice(std::string_view Filename, uint64_t MapSize,
                                    uint64_t Offset, bool IsVolatile) {
   return getFileAux<WritableMemoryBuffer>(
       Filename, MapSize, Offset, /*IsText=*/false,
@@ -286,14 +286,14 @@ WritableMemoryBuffer::getFileSlice(const Twine &Filename, uint64_t MapSize,
 }
 
 std::unique_ptr<WritableMemoryBuffer>
-WritableMemoryBuffer::getNewUninitMemBuffer(size_t Size, const Twine &BufferName) {
+WritableMemoryBuffer::getNewUninitMemBuffer(size_t Size, std::string_view BufferName) {
   using MemBuffer = MemoryBufferMem<WritableMemoryBuffer>;
   // Allocate space for the MemoryBuffer, the data and the name. It is important
   // that MemoryBuffer and data are aligned so PointerIntPair works with them.
   // TODO: Is 16-byte alignment enough?  We copy small object files with large
   // alignment expectations into this buffer.
   SmallString<256> NameBuf;
-  StringRef NameRef = BufferName.toStringRef(NameBuf);
+  std::string_view NameRef = BufferName.tostd::string_view(NameBuf);
   size_t AlignedStringLen = alignTo(sizeof(MemBuffer) + NameRef.size() + 1, 16);
   size_t RealLen = AlignedStringLen + Size + 1;
   char *Mem = static_cast<char*>(operator new(RealLen, std::nothrow));
@@ -301,18 +301,18 @@ WritableMemoryBuffer::getNewUninitMemBuffer(size_t Size, const Twine &BufferName
     return nullptr;
 
   // The name is stored after the class itself.
-  CopyStringRef(Mem + sizeof(MemBuffer), NameRef);
+  CopyStringView(Mem + sizeof(MemBuffer), NameRef);
 
   // The buffer begins after the name and must be aligned.
   char *Buf = Mem + AlignedStringLen;
   Buf[Size] = 0; // Null terminate buffer.
 
-  auto *Ret = new (Mem) MemBuffer(StringRef(Buf, Size), true);
+  auto *Ret = new (Mem) MemBuffer({Buf, Size}, true);
   return std::unique_ptr<WritableMemoryBuffer>(Ret);
 }
 
 std::unique_ptr<WritableMemoryBuffer>
-WritableMemoryBuffer::getNewMemBuffer(size_t Size, const Twine &BufferName) {
+WritableMemoryBuffer::getNewMemBuffer(size_t Size, std::string_view BufferName) {
   auto SB = WritableMemoryBuffer::getNewUninitMemBuffer(Size, BufferName);
   if (!SB)
     return nullptr;
@@ -376,7 +376,7 @@ static bool shouldUseMmap(sys::fs::file_t FD,
 }
 
 static ErrorOr<std::unique_ptr<WriteThroughMemoryBuffer>>
-getReadWriteFile(const Twine &Filename, uint64_t FileSize, uint64_t MapSize,
+getReadWriteFile(std::string_view Filename, uint64_t FileSize, uint64_t MapSize,
                  uint64_t Offset) {
   Expected<sys::fs::file_t> FDOrErr = sys::fs::openNativeFileForReadWrite(
       Filename, sys::fs::CD_OpenExisting, sys::fs::OF_None);
@@ -417,20 +417,20 @@ getReadWriteFile(const Twine &Filename, uint64_t FileSize, uint64_t MapSize,
 }
 
 ErrorOr<std::unique_ptr<WriteThroughMemoryBuffer>>
-WriteThroughMemoryBuffer::getFile(const Twine &Filename, int64_t FileSize) {
+WriteThroughMemoryBuffer::getFile(std::string_view Filename, int64_t FileSize) {
   return getReadWriteFile(Filename, FileSize, FileSize, 0);
 }
 
 /// Map a subrange of the specified file as a WritableMemoryBuffer.
 ErrorOr<std::unique_ptr<WriteThroughMemoryBuffer>>
-WriteThroughMemoryBuffer::getFileSlice(const Twine &Filename, uint64_t MapSize,
+WriteThroughMemoryBuffer::getFileSlice(std::string_view Filename, uint64_t MapSize,
                                        uint64_t Offset) {
   return getReadWriteFile(Filename, -1, MapSize, Offset);
 }
 
 template <typename MB>
 static ErrorOr<std::unique_ptr<MB>>
-getOpenFileImpl(sys::fs::file_t FD, const Twine &Filename, uint64_t FileSize,
+getOpenFileImpl(sys::fs::file_t FD, std::string_view Filename, uint64_t FileSize,
                 uint64_t MapSize, int64_t Offset, bool RequiresNullTerminator,
                 bool IsVolatile) {
   static int PageSize = sys::Process::getPageSizeEstimate();
@@ -500,14 +500,14 @@ getOpenFileImpl(sys::fs::file_t FD, const Twine &Filename, uint64_t FileSize,
 }
 
 ErrorOr<std::unique_ptr<MemoryBuffer>>
-MemoryBuffer::getOpenFile(sys::fs::file_t FD, const Twine &Filename, uint64_t FileSize,
+MemoryBuffer::getOpenFile(sys::fs::file_t FD, std::string_view Filename, uint64_t FileSize,
                           bool RequiresNullTerminator, bool IsVolatile) {
   return getOpenFileImpl<MemoryBuffer>(FD, Filename, FileSize, FileSize, 0,
                          RequiresNullTerminator, IsVolatile);
 }
 
 ErrorOr<std::unique_ptr<MemoryBuffer>>
-MemoryBuffer::getOpenFileSlice(sys::fs::file_t FD, const Twine &Filename, uint64_t MapSize,
+MemoryBuffer::getOpenFileSlice(sys::fs::file_t FD, std::string_view Filename, uint64_t MapSize,
                                int64_t Offset, bool IsVolatile) {
   assert(MapSize != uint64_t(-1));
   return getOpenFileImpl<MemoryBuffer>(FD, Filename, -1, MapSize, Offset, false,
@@ -525,7 +525,7 @@ ErrorOr<std::unique_ptr<MemoryBuffer>> MemoryBuffer::getSTDIN() {
 }
 
 ErrorOr<std::unique_ptr<MemoryBuffer>>
-MemoryBuffer::getFileAsStream(const Twine &Filename) {
+MemoryBuffer::getFileAsStream(const std::string_view &Filename) {
   Expected<sys::fs::file_t> FDOrErr =
       sys::fs::openNativeFileForRead(Filename, sys::fs::OF_None);
   if (!FDOrErr)
@@ -538,8 +538,8 @@ MemoryBuffer::getFileAsStream(const Twine &Filename) {
 }
 
 MemoryBufferRef MemoryBuffer::getMemBufferRef() const {
-  StringRef Data = getBuffer();
-  StringRef Identifier = getBufferIdentifier();
+  std::string_view Data = getBuffer();
+  std::string_view Identifier = getBufferIdentifier();
   return MemoryBufferRef(Data, Identifier);
 }
 
diff --git a/llvm/lib/Support/StringMap.cpp b/llvm/lib/Support/StringMap.cpp
index f65d3846623c..d9eeba619428 100644
--- a/llvm/lib/Support/StringMap.cpp
+++ b/llvm/lib/Support/StringMap.cpp
@@ -71,7 +71,7 @@ void StringMapImpl::init(unsigned InitSize) {
 /// specified bucket will be non-null.  Otherwise, it will be null.  In either
 /// case, the FullHashValue field of the bucket will be set to the hash value
 /// of the string.
-unsigned StringMapImpl::LookupBucketFor(StringRef Name) {
+unsigned StringMapImpl::LookupBucketFor(std::string_view Name) {
   unsigned HTSize = NumBuckets;
   if (HTSize == 0) { // Hash table unallocated so far?
     init(16);
@@ -111,7 +111,7 @@ unsigned StringMapImpl::LookupBucketFor(StringRef Name) {
       // Do the comparison like this because Name isn't necessarily
       // null-terminated!
       char *ItemStr = (char *)BucketItem + ItemSize;
-      if (Name == StringRef(ItemStr, BucketItem->getKeyLength())) {
+      if (Name == std::string_view(ItemStr, BucketItem->getKeyLength())) {
         // We found a match!
         return BucketNo;
       }
@@ -129,7 +129,7 @@ unsigned StringMapImpl::LookupBucketFor(StringRef Name) {
 /// FindKey - Look up the bucket that contains the specified key. If it exists
 /// in the map, return the bucket number of the key.  Otherwise return -1.
 /// This does not modify the map.
-int StringMapImpl::FindKey(StringRef Key) const {
+int StringMapImpl::FindKey(std::string_view Key) const {
   unsigned HTSize = NumBuckets;
   if (HTSize == 0)
     return -1; // Really empty table?
@@ -155,7 +155,7 @@ int StringMapImpl::FindKey(StringRef Key) const {
       // Do the comparison like this because NameStart isn't necessarily
       // null-terminated!
       char *ItemStr = (char *)BucketItem + ItemSize;
-      if (Key == StringRef(ItemStr, BucketItem->getKeyLength())) {
+      if (Key == std::string_view(ItemStr, BucketItem->getKeyLength())) {
         // We found a match!
         return BucketNo;
       }
@@ -174,14 +174,14 @@ int StringMapImpl::FindKey(StringRef Key) const {
 /// delete it.  This aborts if the value isn't in the table.
 void StringMapImpl::RemoveKey(StringMapEntryBase *V) {
   const char *VStr = (char *)V + ItemSize;
-  StringMapEntryBase *V2 = RemoveKey(StringRef(VStr, V->getKeyLength()));
+  StringMapEntryBase *V2 = RemoveKey(std::string_view(VStr, V->getKeyLength()));
   (void)V2;
   assert(V == V2 && "Didn't find key?");
 }
 
 /// RemoveKey - Remove the StringMapEntry for the specified key from the
 /// table, returning it.  If the key is not in the table, this returns null.
-StringMapEntryBase *StringMapImpl::RemoveKey(StringRef Key) {
+StringMapEntryBase *StringMapImpl::RemoveKey(std::string_view Key) {
   int Bucket = FindKey(Key);
   if (Bucket == -1)
     return nullptr;
diff --git a/llvm/lib/Support/raw_ostream.cpp b/llvm/lib/Support/raw_ostream.cpp
index d4e1c884d125..5a9cf40dcb1d 100644
--- a/llvm/lib/Support/raw_ostream.cpp
+++ b/llvm/lib/Support/raw_ostream.cpp
@@ -160,7 +160,7 @@ raw_ostream &raw_ostream::write_uuid(const uuid_t UUID) {
 }
 
 
-raw_ostream &raw_ostream::write_escaped(StringRef Str,
+raw_ostream &raw_ostream::write_escaped(std::string_view Str,
                                         bool UseHexEscapes) {
   for (unsigned char c : Str) {
     switch (c) {
@@ -564,7 +564,7 @@ void format_object_base::home() {
 //  raw_fd_ostream
 //===----------------------------------------------------------------------===//
 
-static int getFD(StringRef Filename, std::error_code &EC,
+static int getFD(std::string_view Filename, std::error_code &EC,
                  sys::fs::CreationDisposition Disp, sys::fs::FileAccess Access,
                  sys::fs::OpenFlags Flags) {
   assert((Access & sys::fs::FA_Write) &&
@@ -590,25 +590,25 @@ static int getFD(StringRef Filename, std::error_code &EC,
   return FD;
 }
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC)
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC)
     : raw_fd_ostream(Filename, EC, sys::fs::CD_CreateAlways, sys::fs::FA_Write,
                      sys::fs::OF_None) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::CreationDisposition Disp)
     : raw_fd_ostream(Filename, EC, Disp, sys::fs::FA_Write, sys::fs::OF_None) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::FileAccess Access)
     : raw_fd_ostream(Filename, EC, sys::fs::CD_CreateAlways, Access,
                      sys::fs::OF_None) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::OpenFlags Flags)
     : raw_fd_ostream(Filename, EC, sys::fs::CD_CreateAlways, sys::fs::FA_Write,
                      Flags) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::CreationDisposition Disp,
                                sys::fs::FileAccess Access,
                                sys::fs::OpenFlags Flags)
@@ -741,7 +741,7 @@ void raw_fd_ostream::write_impl(const char *Ptr, size_t Size) {
   // If this is a Windows console device, try re-encoding from UTF-8 to UTF-16
   // and using WriteConsoleW. If that fails, fall back to plain write().
   if (IsWindowsConsole)
-    if (write_console_impl(FD, StringRef(Ptr, Size)))
+    if (write_console_impl(FD, std::string_view(Ptr, Size)))
       return;
 #endif
 
@@ -905,7 +905,7 @@ raw_ostream &llvm::nulls() {
 // File Streams
 //===----------------------------------------------------------------------===//
 
-raw_fd_stream::raw_fd_stream(StringRef Filename, std::error_code &EC)
+raw_fd_stream::raw_fd_stream(std::string_view Filename, std::error_code &EC)
     : raw_fd_ostream(getFD(Filename, EC, sys::fs::CD_CreateAlways,
                            sys::fs::FA_Write | sys::fs::FA_Read,
                            sys::fs::OF_None),
diff --git a/llvm/unittests/ADT/DenseMapTest.cpp b/llvm/unittests/ADT/DenseMapTest.cpp
index 352270adec0f..689759833171 100644
--- a/llvm/unittests/ADT/DenseMapTest.cpp
+++ b/llvm/unittests/ADT/DenseMapTest.cpp
@@ -481,9 +481,9 @@ TEST(DenseMapCustomTest, ReserveTest) {
   }
 }
 
-// Make sure DenseMap works with StringRef keys.
-TEST(DenseMapCustomTest, StringRefTest) {
-  DenseMap<StringRef, int> M;
+// Make sure DenseMap works with std::string_view keys.
+TEST(DenseMapCustomTest, StringViewTest) {
+  DenseMap<std::string_view, int> M;
 
   M["a"] = 1;
   M["b"] = 2;
@@ -498,12 +498,12 @@ TEST(DenseMapCustomTest, StringRefTest) {
 
   // Test the empty string, spelled various ways.
   EXPECT_EQ(0, M.lookup(""));
-  EXPECT_EQ(0, M.lookup(StringRef()));
-  EXPECT_EQ(0, M.lookup(StringRef("a", 0)));
+  EXPECT_EQ(0, M.lookup(std::string_view()));
+  EXPECT_EQ(0, M.lookup(std::string_view("a", 0)));
   M[""] = 42;
   EXPECT_EQ(42, M.lookup(""));
-  EXPECT_EQ(42, M.lookup(StringRef()));
-  EXPECT_EQ(42, M.lookup(StringRef("a", 0)));
+  EXPECT_EQ(42, M.lookup(std::string_view()));
+  EXPECT_EQ(42, M.lookup(std::string_view("a", 0)));
 }
 
 // Key traits that allows lookup with either an unsigned or char* key;
diff --git a/llvm/unittests/ADT/FunctionExtrasTest.cpp b/llvm/unittests/ADT/FunctionExtrasTest.cpp
index 3c6f179c190f..899690b8aae8 100644
--- a/llvm/unittests/ADT/FunctionExtrasTest.cpp
+++ b/llvm/unittests/ADT/FunctionExtrasTest.cpp
@@ -249,23 +249,23 @@ TEST(UniqueFunctionTest, Const) {
 
   // Overloaded call operator correctly resolved.
   struct ChooseCorrectOverload {
-    StringRef operator()() { return "non-const"; }
-    StringRef operator()() const { return "const"; }
+    std::string_view operator()() { return "non-const"; }
+    std::string_view operator()() const { return "const"; }
   };
-  unique_function<StringRef()> ChooseMutable = ChooseCorrectOverload();
+  unique_function<std::string_view()> ChooseMutable = ChooseCorrectOverload();
   ChooseCorrectOverload A;
   EXPECT_EQ("non-const", ChooseMutable());
   EXPECT_EQ("non-const", A());
-  unique_function<StringRef() const> ChooseConst = ChooseCorrectOverload();
+  unique_function<std::string_view() const> ChooseConst = ChooseCorrectOverload();
   const ChooseCorrectOverload &X = A;
   EXPECT_EQ("const", ChooseConst());
   EXPECT_EQ("const", X());
 }
 
 // Test that overloads on unique_functions are resolved as expected.
-std::string returns(StringRef) { return "not a function"; }
+std::string returns(std::string_view) { return "not a function"; }
 std::string returns(unique_function<double()> F) { return "number"; }
-std::string returns(unique_function<StringRef()> F) { return "string"; }
+std::string returns(unique_function<std::string_view()> F) { return "string"; }
 
 TEST(UniqueFunctionTest, SFINAE) {
   EXPECT_EQ("not a function", returns("boo!"));
diff --git a/llvm/unittests/ADT/HashingTest.cpp b/llvm/unittests/ADT/HashingTest.cpp
index d2cda3afdda0..3605bbdcdfe3 100644
--- a/llvm/unittests/ADT/HashingTest.cpp
+++ b/llvm/unittests/ADT/HashingTest.cpp
@@ -276,7 +276,7 @@ TEST(HashingTest, HashCombineRangeGoldenTest) {
 #endif
   };
   for (unsigned i = 0; i < sizeof(golden_data)/sizeof(*golden_data); ++i) {
-    StringRef str = golden_data[i].s;
+    std::string_view str = golden_data[i].s;
     hash_code hash = hash_combine_range(str.begin(), str.end());
 #if 0 // Enable this to generate paste-able text for the above structure.
     std::string member_str = "\"" + str.str() + "\",";
diff --git a/llvm/unittests/ADT/SmallStringTest.cpp b/llvm/unittests/ADT/SmallStringTest.cpp
index b207f582e919..d692e88c70ed 100644
--- a/llvm/unittests/ADT/SmallStringTest.cpp
+++ b/llvm/unittests/ADT/SmallStringTest.cpp
@@ -50,21 +50,21 @@ TEST_F(SmallStringTest, AssignRepeated) {
 }
 
 TEST_F(SmallStringTest, AssignIterPair) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   theString.assign(abc.begin(), abc.end());
   EXPECT_EQ(3u, theString.size());
   EXPECT_STREQ("abc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AssignStringRef) {
-  StringRef abc = "abc";
+TEST_F(SmallStringTest, AssignStringView) {
+  std::string_view abc = "abc";
   theString.assign(abc);
   EXPECT_EQ(3u, theString.size());
   EXPECT_STREQ("abc", theString.c_str());
 }
 
 TEST_F(SmallStringTest, AssignSmallVector) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   SmallVector<char, 10> abcVec(abc.begin(), abc.end());
   theString.assign(abcVec);
   EXPECT_EQ(3u, theString.size());
@@ -78,15 +78,15 @@ TEST_F(SmallStringTest, AssignStringRefs) {
 }
 
 TEST_F(SmallStringTest, AppendIterPair) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   theString.append(abc.begin(), abc.end());
   theString.append(abc.begin(), abc.end());
   EXPECT_EQ(6u, theString.size());
   EXPECT_STREQ("abcabc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AppendStringRef) {
-  StringRef abc = "abc";
+TEST_F(SmallStringTest, AppendStringView) {
+  std::string_view abc = "abc";
   theString.append(abc);
   theString.append(abc);
   EXPECT_EQ(6u, theString.size());
@@ -94,7 +94,7 @@ TEST_F(SmallStringTest, AppendStringRef) {
 }
 
 TEST_F(SmallStringTest, AppendSmallVector) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   SmallVector<char, 10> abcVec(abc.begin(), abc.end());
   theString.append(abcVec);
   theString.append(abcVec);
@@ -102,76 +102,32 @@ TEST_F(SmallStringTest, AppendSmallVector) {
   EXPECT_STREQ("abcabc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AppendStringRefs) {
-  theString.append({"abc", "def", "ghi"});
-  EXPECT_EQ(9u, theString.size());
-  EXPECT_STREQ("abcdefghi", theString.c_str());
-  StringRef Jkl = "jkl";
-  std::string Mno = "mno";
-  SmallString<4> Pqr("pqr");
-  const char *Stu = "stu";
-  theString.append({Jkl, Mno, Pqr, Stu});
-  EXPECT_EQ(21u, theString.size());
-  EXPECT_STREQ("abcdefghijklmnopqrstu", theString.c_str());
-}
-
-TEST_F(SmallStringTest, StringRefConversion) {
-  StringRef abc = "abc";
-  theString.assign(abc.begin(), abc.end());
-  StringRef theStringRef = theString;
-  EXPECT_EQ("abc", theStringRef);
-}
-
-TEST_F(SmallStringTest, StdStringConversion) {
-  StringRef abc = "abc";
-  theString.assign(abc.begin(), abc.end());
-  std::string theStdString = std::string(theString);
-  EXPECT_EQ("abc", theStdString);
-}
-
-TEST_F(SmallStringTest, Substr) {
-  theString = "hello";
-  EXPECT_EQ("lo", theString.substr(3));
-  EXPECT_EQ("", theString.substr(100));
-  EXPECT_EQ("hello", theString.substr(0, 100));
-  EXPECT_EQ("o", theString.substr(4, 10));
-}
-
-TEST_F(SmallStringTest, Slice) {
-  theString = "hello";
-  EXPECT_EQ("l", theString.slice(2, 3));
-  EXPECT_EQ("ell", theString.slice(1, 4));
-  EXPECT_EQ("llo", theString.slice(2, 100));
-  EXPECT_EQ("", theString.slice(2, 1));
-  EXPECT_EQ("", theString.slice(10, 20));
-}
-
 TEST_F(SmallStringTest, Find) {
   theString = "hello";
   EXPECT_EQ(2U, theString.find('l'));
-  EXPECT_EQ(StringRef::npos, theString.find('z'));
-  EXPECT_EQ(StringRef::npos, theString.find("helloworld"));
+  EXPECT_EQ(std::string_view::npos, theString.find('z'));
+  EXPECT_EQ(std::string_view::npos, theString.find("helloworld"));
   EXPECT_EQ(0U, theString.find("hello"));
   EXPECT_EQ(1U, theString.find("ello"));
-  EXPECT_EQ(StringRef::npos, theString.find("zz"));
+  EXPECT_EQ(std::string_view::npos, theString.find("zz"));
   EXPECT_EQ(2U, theString.find("ll", 2));
-  EXPECT_EQ(StringRef::npos, theString.find("ll", 3));
+  EXPECT_EQ(std::string_view::npos, theString.find("ll", 3));
   EXPECT_EQ(0U, theString.find(""));
 
   EXPECT_EQ(3U, theString.rfind('l'));
-  EXPECT_EQ(StringRef::npos, theString.rfind('z'));
-  EXPECT_EQ(StringRef::npos, theString.rfind("helloworld"));
+  EXPECT_EQ(std::string_view::npos, theString.rfind('z'));
+  EXPECT_EQ(std::string_view::npos, theString.rfind("helloworld"));
   EXPECT_EQ(0U, theString.rfind("hello"));
   EXPECT_EQ(1U, theString.rfind("ello"));
-  EXPECT_EQ(StringRef::npos, theString.rfind("zz"));
+  EXPECT_EQ(std::string_view::npos, theString.rfind("zz"));
 
   EXPECT_EQ(2U, theString.find_first_of('l'));
   EXPECT_EQ(1U, theString.find_first_of("el"));
-  EXPECT_EQ(StringRef::npos, theString.find_first_of("xyz"));
+  EXPECT_EQ(std::string_view::npos, theString.find_first_of("xyz"));
 
   EXPECT_EQ(1U, theString.find_first_not_of('h'));
   EXPECT_EQ(4U, theString.find_first_not_of("hel"));
-  EXPECT_EQ(StringRef::npos, theString.find_first_not_of("hello"));
+  EXPECT_EQ(std::string_view::npos, theString.find_first_not_of("hello"));
 
   theString = "hellx xello hell ello world foo bar hello";
   EXPECT_EQ(36U, theString.find("hello"));
@@ -180,68 +136,4 @@ TEST_F(SmallStringTest, Find) {
   EXPECT_EQ(0U, theString.find(""));
 }
 
-TEST_F(SmallStringTest, Count) {
-  theString = "hello";
-  EXPECT_EQ(2U, theString.count('l'));
-  EXPECT_EQ(1U, theString.count('o'));
-  EXPECT_EQ(0U, theString.count('z'));
-  EXPECT_EQ(0U, theString.count("helloworld"));
-  EXPECT_EQ(1U, theString.count("hello"));
-  EXPECT_EQ(1U, theString.count("ello"));
-  EXPECT_EQ(0U, theString.count("zz"));
-}
-
-TEST_F(SmallStringTest, Realloc) {
-  theString = "abcd";
-  theString.reserve(100);
-  EXPECT_EQ("abcd", theString);
-  unsigned const N = 100000;
-  theString.reserve(N);
-  for (unsigned i = 0; i < N - 4; ++i)
-    theString.push_back('y');
-  EXPECT_EQ("abcdyyy", theString.slice(0, 7));
-}
-
-TEST_F(SmallStringTest, Comparisons) {
-  EXPECT_EQ(-1, SmallString<10>("aab").compare("aad"));
-  EXPECT_EQ( 0, SmallString<10>("aab").compare("aab"));
-  EXPECT_EQ( 1, SmallString<10>("aab").compare("aaa"));
-  EXPECT_EQ(-1, SmallString<10>("aab").compare("aabb"));
-  EXPECT_EQ( 1, SmallString<10>("aab").compare("aa"));
-  EXPECT_EQ( 1, SmallString<10>("\xFF").compare("\1"));
-
-  EXPECT_EQ(-1, SmallString<10>("AaB").compare_insensitive("aAd"));
-  EXPECT_EQ( 0, SmallString<10>("AaB").compare_insensitive("aab"));
-  EXPECT_EQ( 1, SmallString<10>("AaB").compare_insensitive("AAA"));
-  EXPECT_EQ(-1, SmallString<10>("AaB").compare_insensitive("aaBb"));
-  EXPECT_EQ( 1, SmallString<10>("AaB").compare_insensitive("aA"));
-  EXPECT_EQ( 1, SmallString<10>("\xFF").compare_insensitive("\1"));
-
-  EXPECT_EQ(-1, SmallString<10>("aab").compare_numeric("aad"));
-  EXPECT_EQ( 0, SmallString<10>("aab").compare_numeric("aab"));
-  EXPECT_EQ( 1, SmallString<10>("aab").compare_numeric("aaa"));
-  EXPECT_EQ(-1, SmallString<10>("aab").compare_numeric("aabb"));
-  EXPECT_EQ( 1, SmallString<10>("aab").compare_numeric("aa"));
-  EXPECT_EQ(-1, SmallString<10>("1").compare_numeric("10"));
-  EXPECT_EQ( 0, SmallString<10>("10").compare_numeric("10"));
-  EXPECT_EQ( 0, SmallString<10>("10a").compare_numeric("10a"));
-  EXPECT_EQ( 1, SmallString<10>("2").compare_numeric("1"));
-  EXPECT_EQ( 0, SmallString<10>("llvm_v1i64_ty").compare_numeric("llvm_v1i64_ty"));
-  EXPECT_EQ( 1, SmallString<10>("\xFF").compare_numeric("\1"));
-  EXPECT_EQ( 1, SmallString<10>("V16").compare_numeric("V1_q0"));
-  EXPECT_EQ(-1, SmallString<10>("V1_q0").compare_numeric("V16"));
-  EXPECT_EQ(-1, SmallString<10>("V8_q0").compare_numeric("V16"));
-  EXPECT_EQ( 1, SmallString<10>("V16").compare_numeric("V8_q0"));
-  EXPECT_EQ(-1, SmallString<10>("V1_q0").compare_numeric("V8_q0"));
-  EXPECT_EQ( 1, SmallString<10>("V8_q0").compare_numeric("V1_q0"));
-}
-
-// Check gtest prints SmallString as a string instead of a container of chars.
-// The code is in utils/unittest/googletest/internal/custom/gtest-printers.h
-TEST_F(SmallStringTest, GTestPrinter) {
-  EXPECT_EQ(R"("foo")", ::testing::PrintToString(SmallString<1>("foo")));
-  const SmallVectorImpl<char> &ErasedSmallString = SmallString<1>("foo");
-  EXPECT_EQ(R"("foo")", ::testing::PrintToString(ErasedSmallString));
-}
-
 } // namespace
diff --git a/llvm/unittests/ADT/SmallVectorTest.cpp b/llvm/unittests/ADT/SmallVectorTest.cpp
index 06b98efe66ef..dd62a64d149c 100644
--- a/llvm/unittests/ADT/SmallVectorTest.cpp
+++ b/llvm/unittests/ADT/SmallVectorTest.cpp
@@ -11,7 +11,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/span.h"
 #include "llvm/Support/Compiler.h"
 #include "gtest/gtest.h"
 #include <list>
@@ -1028,386 +1028,4 @@ TEST(SmallVectorTest, EmplaceBack) {
   }
 }
 
-TEST(SmallVectorTest, DefaultInlinedElements) {
-  SmallVector<int> V;
-  EXPECT_TRUE(V.empty());
-  V.push_back(7);
-  EXPECT_EQ(V[0], 7);
-
-  // Check that at least a couple layers of nested SmallVector<T>'s are allowed
-  // by the default inline elements policy. This pattern happens in practice
-  // with some frequency, and it seems fairly harmless even though each layer of
-  // SmallVector's will grow the total sizeof by a vector header beyond the
-  // "preferred" maximum sizeof.
-  SmallVector<SmallVector<SmallVector<int>>> NestedV;
-  NestedV.emplace_back().emplace_back().emplace_back(42);
-  EXPECT_EQ(NestedV[0][0][0], 42);
-}
-
-TEST(SmallVectorTest, InitializerList) {
-  SmallVector<int, 2> V1 = {};
-  EXPECT_TRUE(V1.empty());
-  V1 = {0, 0};
-  EXPECT_TRUE(makeArrayRef(V1).equals({0, 0}));
-  V1 = {-1, -1};
-  EXPECT_TRUE(makeArrayRef(V1).equals({-1, -1}));
-
-  SmallVector<int, 2> V2 = {1, 2, 3, 4};
-  EXPECT_TRUE(makeArrayRef(V2).equals({1, 2, 3, 4}));
-  V2.assign({4});
-  EXPECT_TRUE(makeArrayRef(V2).equals({4}));
-  V2.append({3, 2});
-  EXPECT_TRUE(makeArrayRef(V2).equals({4, 3, 2}));
-  V2.insert(V2.begin() + 1, 5);
-  EXPECT_TRUE(makeArrayRef(V2).equals({4, 5, 3, 2}));
-}
-
-template <class VectorT>
-class SmallVectorReferenceInvalidationTest : public SmallVectorTestBase {
-protected:
-  const char *AssertionMessage =
-      "Attempting to reference an element of the vector in an operation \" "
-      "\"that invalidates it";
-
-  VectorT V;
-
-  template <typename T, unsigned N>
-  static unsigned NumBuiltinElts(const SmallVector<T, N> &) {
-    return N;
-  }
-
-  template <class T> static bool isValueType() {
-    return std::is_same<T, typename VectorT::value_type>::value;
-  }
-
-  void SetUp() override {
-    SmallVectorTestBase::SetUp();
-
-    // Fill up the small size so that insertions move the elements.
-    for (int I = 0, E = NumBuiltinElts(V); I != E; ++I)
-      V.emplace_back(I + 1);
-  }
-};
-
-// Test one type that's trivially copyable (int) and one that isn't
-// (Constructable) since reference invalidation may be fixed differently for
-// each.
-using SmallVectorReferenceInvalidationTestTypes =
-    ::testing::Types<SmallVector<int, 3>, SmallVector<Constructable, 3>>;
-
-TYPED_TEST_SUITE(SmallVectorReferenceInvalidationTest,
-                 SmallVectorReferenceInvalidationTestTypes, );
-
-TYPED_TEST(SmallVectorReferenceInvalidationTest, PushBack) {
-  // Note: setup adds [1, 2, ...] to V until it's at capacity in small mode.
-  auto &V = this->V;
-  int N = this->NumBuiltinElts(V);
-
-  // Push back a reference to last element when growing from small storage.
-  V.push_back(V.back());
-  EXPECT_EQ(N, V.back());
-
-  // Check that the old value is still there (not moved away).
-  EXPECT_EQ(N, V[V.size() - 2]);
-
-  // Fill storage again.
-  V.back() = V.size();
-  while (V.size() < V.capacity())
-    V.push_back(V.size() + 1);
-
-  // Push back a reference to last element when growing from large storage.
-  V.push_back(V.back());
-  EXPECT_EQ(int(V.size()) - 1, V.back());
-}
-
-TYPED_TEST(SmallVectorReferenceInvalidationTest, PushBackMoved) {
-  // Note: setup adds [1, 2, ...] to V until it's at capacity in small mode.
-  auto &V = this->V;
-  int N = this->NumBuiltinElts(V);
-
-  // Push back a reference to last element when growing from small storage.
-  V.push_back(std::move(V.back()));
-  EXPECT_EQ(N, V.back());
-  if (this->template isValueType<Constructable>()) {
-    // Check that the value was moved (not copied).
-    EXPECT_EQ(0, V[V.size() - 2]);
-  }
-
-  // Fill storage again.
-  V.back() = V.size();
-  while (V.size() < V.capacity())
-    V.push_back(V.size() + 1);
-
-  // Push back a reference to last element when growing from large storage.
-  V.push_back(std::move(V.back()));
-
-  // Check the values.
-  EXPECT_EQ(int(V.size()) - 1, V.back());
-  if (this->template isValueType<Constructable>()) {
-    // Check the value got moved out.
-    EXPECT_EQ(0, V[V.size() - 2]);
-  }
-}
-
-TYPED_TEST(SmallVectorReferenceInvalidationTest, Resize) {
-  auto &V = this->V;
-  (void)V;
-  int N = this->NumBuiltinElts(V);
-  V.resize(N + 1, V.back());
-  EXPECT_EQ(N, V.back());
-
-  // Resize to add enough elements that V will grow again. If reference
-  // invalidation breaks in the future, sanitizers should be able to catch a
-  // use-after-free here.
-  V.resize(V.capacity() + 1, V.front());
-  EXPECT_EQ(1, V.back());
-}
-
-TYPED_TEST(SmallVectorReferenceInvalidationTest, Append) {
-  auto &V = this->V;
-  (void)V;
-  V.append(1, V.back());
-  int N = this->NumBuiltinElts(V);
-  EXPECT_EQ(N, V[N - 1]);
-
-  // Append enough more elements that V will grow again. This tests growing
-  // when already in large mode.
-  //
-  // If reference invalidation breaks in the future, sanitizers should be able
-  // to catch a use-after-free here.
-  V.append(V.capacity() - V.size() + 1, V.front());
-  EXPECT_EQ(1, V.back());
-}
-
-TYPED_TEST(SmallVectorReferenceInvalidationTest, AppendRange) {
-  auto &V = this->V;
-  (void)V;
-#if !defined(NDEBUG) && GTEST_HAS_DEATH_TEST
-  EXPECT_DEATH(V.append(V.begin(), V.begin() + 1), this->AssertionMessage);
-
-  ASSERT_EQ(3u, this->NumBuiltinElts(V));
-  ASSERT_EQ(3u, V.size());
-  V.pop_back();
-  ASSERT_EQ(2u, V.size());
-
-  // Confirm this checks for growth when there's more than one element
-  // appended.
-  EXPECT_DEATH(V.append(V.begin(), V.end()), this->AssertionMessage);
-#endif
-}
-
-TYPED_TEST(SmallVectorReferenceInvalidationTest, Assign) {
-  // Note: setup adds [1, 2, ...] to V until it's at capacity in small mode.
-  auto &V = this->V;
-  (void)V;
-  int N = this->NumBuiltinElts(V);
-  ASSERT_EQ(unsigned(N), V.size());
-  ASSERT_EQ(unsigned(N), V.capacity());
-
-  // Check assign that shrinks in small mode.
-  V.assign(1, V.back());
-  EXPECT_EQ(1u, V.size());
-  EXPECT_EQ(N, V[0]);
-
-  // Check assign that grows within small mode.
-  ASSERT_LT(V.size(), V.capacity());
-  V.assign(V.capacity(), V.back());
-  for (int I = 0, E = V.size(); I != E; ++I) {
-    EXPECT_EQ(N, V[I]);
-
-    // Reset to [1, 2, ...].
-    V[I] = I + 1;
-  }
-
-  // Check assign that grows to large mode.
-  ASSERT_EQ(2, V[1]);
-  V.assign(V.capacity() + 1, V[1]);
-  for (int I = 0, E = V.size(); I != E; ++I) {
-    EXPECT_EQ(2, V[I]);
-
-    // Reset to [1, 2, ...].
-    V[I] = I + 1;
-  }
-
-  // Check assign that shrinks in large mode.
-  V.assign(1, V[1]);
-  EXPECT_EQ(2, V[0]);
-}
-
-TYPED_TEST(SmallVectorReferenceInvalidationTest, AssignRange) {
-  auto &V = this->V;
-#if !defined(NDEBUG) && GTEST_HAS_DEATH_TEST
-  EXPECT_DEATH(V.assign(V.begin(), V.end()), this->AssertionMessage);
-  EXPECT_DEATH(V.assign(V.begin(), V.end() - 1), this->AssertionMessage);
-#endif
-  V.assign(V.begin(), V.begin());
-  EXPECT_TRUE(V.empty());
-}
-
-TYPED_TEST(SmallVectorReferenceInvalidationTest, Insert) {
-  // Note: setup adds [1, 2, ...] to V until it's at capacity in small mode.
-  auto &V = this->V;
-  (void)V;
-
-  // Insert a reference to the back (not at end() or else insert delegates to
-  // push_back()), growing out of small mode. Confirm the value was copied out
-  // (moving out Constructable sets it to 0).
-  V.insert(V.begin(), V.back());
-  EXPECT_EQ(int(V.size() - 1), V.front());
-  EXPECT_EQ(int(V.size() - 1), V.back());
-
-  // Fill up the vector again.
-  while (V.size() < V.capacity())
-    V.push_back(V.size() + 1);
-
-  // Grow again from large storage to large storage.
-  V.insert(V.begin(), V.back());
-  EXPECT_EQ(int(V.size() - 1), V.front());
-  EXPECT_EQ(int(V.size() - 1), V.back());
-}
-
-TYPED_TEST(SmallVectorReferenceInvalidationTest, InsertMoved) {
-  // Note: setup adds [1, 2, ...] to V until it's at capacity in small mode.
-  auto &V = this->V;
-  (void)V;
-
-  // Insert a reference to the back (not at end() or else insert delegates to
-  // push_back()), growing out of small mode. Confirm the value was copied out
-  // (moving out Constructable sets it to 0).
-  V.insert(V.begin(), std::move(V.back()));
-  EXPECT_EQ(int(V.size() - 1), V.front());
-  if (this->template isValueType<Constructable>()) {
-    // Check the value got moved out.
-    EXPECT_EQ(0, V.back());
-  }
-
-  // Fill up the vector again.
-  while (V.size() < V.capacity())
-    V.push_back(V.size() + 1);
-
-  // Grow again from large storage to large storage.
-  V.insert(V.begin(), std::move(V.back()));
-  EXPECT_EQ(int(V.size() - 1), V.front());
-  if (this->template isValueType<Constructable>()) {
-    // Check the value got moved out.
-    EXPECT_EQ(0, V.back());
-  }
-}
-
-TYPED_TEST(SmallVectorReferenceInvalidationTest, InsertN) {
-  auto &V = this->V;
-  (void)V;
-
-  // Cover NumToInsert <= this->end() - I.
-  V.insert(V.begin() + 1, 1, V.back());
-  int N = this->NumBuiltinElts(V);
-  EXPECT_EQ(N, V[1]);
-
-  // Cover NumToInsert > this->end() - I, inserting enough elements that V will
-  // also grow again; V.capacity() will be more elements than necessary but
-  // it's a simple way to cover both conditions.
-  //
-  // If reference invalidation breaks in the future, sanitizers should be able
-  // to catch a use-after-free here.
-  V.insert(V.begin(), V.capacity(), V.front());
-  EXPECT_EQ(1, V.front());
-}
-
-TYPED_TEST(SmallVectorReferenceInvalidationTest, InsertRange) {
-  auto &V = this->V;
-  (void)V;
-#if !defined(NDEBUG) && GTEST_HAS_DEATH_TEST
-  EXPECT_DEATH(V.insert(V.begin(), V.begin(), V.begin() + 1),
-               this->AssertionMessage);
-
-  ASSERT_EQ(3u, this->NumBuiltinElts(V));
-  ASSERT_EQ(3u, V.size());
-  V.pop_back();
-  ASSERT_EQ(2u, V.size());
-
-  // Confirm this checks for growth when there's more than one element
-  // inserted.
-  EXPECT_DEATH(V.insert(V.begin(), V.begin(), V.end()), this->AssertionMessage);
-#endif
-}
-
-TYPED_TEST(SmallVectorReferenceInvalidationTest, EmplaceBack) {
-  // Note: setup adds [1, 2, ...] to V until it's at capacity in small mode.
-  auto &V = this->V;
-  int N = this->NumBuiltinElts(V);
-
-  // Push back a reference to last element when growing from small storage.
-  V.emplace_back(V.back());
-  EXPECT_EQ(N, V.back());
-
-  // Check that the old value is still there (not moved away).
-  EXPECT_EQ(N, V[V.size() - 2]);
-
-  // Fill storage again.
-  V.back() = V.size();
-  while (V.size() < V.capacity())
-    V.push_back(V.size() + 1);
-
-  // Push back a reference to last element when growing from large storage.
-  V.emplace_back(V.back());
-  EXPECT_EQ(int(V.size()) - 1, V.back());
-}
-
-template <class VectorT>
-class SmallVectorInternalReferenceInvalidationTest
-    : public SmallVectorTestBase {
-protected:
-  const char *AssertionMessage =
-      "Attempting to reference an element of the vector in an operation \" "
-      "\"that invalidates it";
-
-  VectorT V;
-
-  template <typename T, unsigned N>
-  static unsigned NumBuiltinElts(const SmallVector<T, N> &) {
-    return N;
-  }
-
-  void SetUp() override {
-    SmallVectorTestBase::SetUp();
-
-    // Fill up the small size so that insertions move the elements.
-    for (int I = 0, E = NumBuiltinElts(V); I != E; ++I)
-      V.emplace_back(I + 1, I + 1);
-  }
-};
-
-// Test pairs of the same types from SmallVectorReferenceInvalidationTestTypes.
-using SmallVectorInternalReferenceInvalidationTestTypes =
-    ::testing::Types<SmallVector<std::pair<int, int>, 3>,
-                     SmallVector<std::pair<Constructable, Constructable>, 3>>;
-
-TYPED_TEST_SUITE(SmallVectorInternalReferenceInvalidationTest,
-                 SmallVectorInternalReferenceInvalidationTestTypes, );
-
-TYPED_TEST(SmallVectorInternalReferenceInvalidationTest, EmplaceBack) {
-  // Note: setup adds [1, 2, ...] to V until it's at capacity in small mode.
-  auto &V = this->V;
-  int N = this->NumBuiltinElts(V);
-
-  // Push back a reference to last element when growing from small storage.
-  V.emplace_back(V.back().first, V.back().second);
-  EXPECT_EQ(N, V.back().first);
-  EXPECT_EQ(N, V.back().second);
-
-  // Check that the old value is still there (not moved away).
-  EXPECT_EQ(N, V[V.size() - 2].first);
-  EXPECT_EQ(N, V[V.size() - 2].second);
-
-  // Fill storage again.
-  V.back().first = V.back().second = V.size();
-  while (V.size() < V.capacity())
-    V.emplace_back(V.size() + 1, V.size() + 1);
-
-  // Push back a reference to last element when growing from large storage.
-  V.emplace_back(V.back().first, V.back().second);
-  EXPECT_EQ(int(V.size()) - 1, V.back().first);
-  EXPECT_EQ(int(V.size()) - 1, V.back().second);
-}
-
 } // end namespace
diff --git a/llvm/unittests/ADT/StringMapTest.cpp b/llvm/unittests/ADT/StringMapTest.cpp
index bda3d4ff9679..b2d38baff568 100644
--- a/llvm/unittests/ADT/StringMapTest.cpp
+++ b/llvm/unittests/ADT/StringMapTest.cpp
@@ -7,7 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/ADT/StringMap.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Support/DataTypes.h"
 #include "gtest/gtest.h"
 #include <limits>
@@ -37,10 +36,10 @@ protected:
 
     // Lookup tests
     EXPECT_EQ(0u, testMap.count(testKey));
-    EXPECT_EQ(0u, testMap.count(StringRef(testKeyFirst, testKeyLength)));
+    EXPECT_EQ(0u, testMap.count(std::string_view(testKeyFirst, testKeyLength)));
     EXPECT_EQ(0u, testMap.count(testKeyStr));
     EXPECT_TRUE(testMap.find(testKey) == testMap.end());
-    EXPECT_TRUE(testMap.find(StringRef(testKeyFirst, testKeyLength)) == 
+    EXPECT_TRUE(testMap.find(std::string_view(testKeyFirst, testKeyLength)) == 
                 testMap.end());
     EXPECT_TRUE(testMap.find(testKeyStr) == testMap.end());
   }
@@ -60,10 +59,10 @@ protected:
 
     // Lookup tests
     EXPECT_EQ(1u, testMap.count(testKey));
-    EXPECT_EQ(1u, testMap.count(StringRef(testKeyFirst, testKeyLength)));
+    EXPECT_EQ(1u, testMap.count(std::string_view(testKeyFirst, testKeyLength)));
     EXPECT_EQ(1u, testMap.count(testKeyStr));
     EXPECT_TRUE(testMap.find(testKey) == testMap.begin());
-    EXPECT_TRUE(testMap.find(StringRef(testKeyFirst, testKeyLength)) == 
+    EXPECT_TRUE(testMap.find(std::string_view(testKeyFirst, testKeyLength)) == 
                 testMap.begin());
     EXPECT_TRUE(testMap.find(testKeyStr) == testMap.begin());
   }
@@ -103,10 +102,10 @@ TEST_F(StringMapTest, ConstEmptyMapTest) {
 
   // Lookup tests
   EXPECT_EQ(0u, constTestMap.count(testKey));
-  EXPECT_EQ(0u, constTestMap.count(StringRef(testKeyFirst, testKeyLength)));
+  EXPECT_EQ(0u, constTestMap.count(std::string_view(testKeyFirst, testKeyLength)));
   EXPECT_EQ(0u, constTestMap.count(testKeyStr));
   EXPECT_TRUE(constTestMap.find(testKey) == constTestMap.end());
-  EXPECT_TRUE(constTestMap.find(StringRef(testKeyFirst, testKeyLength)) ==
+  EXPECT_TRUE(constTestMap.find(std::string_view(testKeyFirst, testKeyLength)) ==
               constTestMap.end());
   EXPECT_TRUE(constTestMap.find(testKeyStr) == constTestMap.end());
 }
@@ -226,7 +225,7 @@ TEST_F(StringMapTest, IterationTest) {
 TEST_F(StringMapTest, StringMapEntryTest) {
   StringMap<uint32_t>::value_type *entry =
       StringMap<uint32_t>::value_type::Create(
-          StringRef(testKeyFirst, testKeyLength), Allocator, 1u);
+          std::string_view(testKeyFirst, testKeyLength), 1u);
   EXPECT_STREQ(testKey, entry->first().data());
   EXPECT_EQ(1u, entry->second);
   entry->Destroy();
@@ -237,7 +236,7 @@ TEST_F(StringMapTest, InsertTest) {
   SCOPED_TRACE("InsertTest");
   testMap.insert(
       StringMap<uint32_t>::value_type::Create(
-          StringRef(testKeyFirst, testKeyLength),
+          std::string_view(testKeyFirst, testKeyLength),
           testMap.getAllocator(), 1u));
   assertSingleItemMap();
 }
@@ -279,41 +278,6 @@ TEST_F(StringMapTest, InsertRehashingPairTest) {
   EXPECT_EQ(42u, It->second);
 }
 
-TEST_F(StringMapTest, InsertOrAssignTest) {
-  struct A : CountCopyAndMove {
-    A(int v) : v(v) {}
-    int v;
-  };
-  StringMap<A> t(0);
-
-  auto try1 = t.insert_or_assign("A", A(1));
-  EXPECT_TRUE(try1.second);
-  EXPECT_EQ(1, try1.first->second.v);
-  EXPECT_EQ(1, try1.first->second.move);
-
-  auto try2 = t.insert_or_assign("A", A(2));
-  EXPECT_FALSE(try2.second);
-  EXPECT_EQ(2, try2.first->second.v);
-  EXPECT_EQ(2, try1.first->second.move);
-
-  EXPECT_EQ(try1.first, try2.first);
-  EXPECT_EQ(0, try1.first->second.copy);
-}
-
-TEST_F(StringMapTest, IterMapKeys) {
-  StringMap<int> Map;
-  Map["A"] = 1;
-  Map["B"] = 2;
-  Map["C"] = 3;
-  Map["D"] = 3;
-
-  auto Keys = to_vector<4>(Map.keys());
-  llvm::sort(Keys);
-
-  SmallVector<StringRef, 4> Expected = {"A", "B", "C", "D"};
-  EXPECT_EQ(Expected, Keys);
-}
-
 // Create a non-default constructable value
 struct StringMapTestStruct {
   StringMapTestStruct(int i) : i(i) {}
@@ -352,13 +316,13 @@ private:
 TEST_F(StringMapTest, MoveOnly) {
   StringMap<MoveOnly> t;
   t.insert(std::make_pair("Test", MoveOnly(42)));
-  StringRef Key = "Test";
+  std::string_view Key = "Test";
   StringMapEntry<MoveOnly>::Create(Key, MoveOnly(42))
       ->Destroy();
 }
 
 TEST_F(StringMapTest, CtorArg) {
-  StringRef Key = "Test";
+  std::string_view Key = "Test";
   StringMapEntry<MoveOnly>::Create(Key, Immovable())
       ->Destroy();
 }
@@ -532,7 +496,7 @@ TEST(StringMapCustomTest, InitialSizeTest) {
     CountCtorCopyAndMove::Copy = 0;
     for (int i = 0; i < Size; ++i)
       Map.insert(std::pair<std::string, CountCtorCopyAndMove>(
-          std::piecewise_construct, std::forward_as_tuple(Twine(i).str()),
+          std::piecewise_construct, std::forward_as_tuple(std::to_string(i)),
           std::forward_as_tuple(i)));
     // After the initial move, the map will move the Elts in the Entry.
     EXPECT_EQ((unsigned)Size * 2, CountCtorCopyAndMove::Move);
@@ -601,7 +565,7 @@ TEST(StringMapCustomTest, StringMapEntrySize) {
   else
     LargeValue = std::numeric_limits<unsigned>::max() + 1ULL;
   StringMapEntry<int> LargeEntry(LargeValue);
-  StringRef Key = LargeEntry.getKey();
+  std::string_view Key = LargeEntry.getKey();
   EXPECT_EQ(LargeValue, Key.size());
 
   // Test that the entry can hold at least max size_t.
diff --git a/llvm/unittests/Support/ConvertUTFTest.cpp b/llvm/unittests/Support/ConvertUTFTest.cpp
index 7bda6ea28ad6..28d71414db6d 100644
--- a/llvm/unittests/Support/ConvertUTFTest.cpp
+++ b/llvm/unittests/Support/ConvertUTFTest.cpp
@@ -7,7 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/Support/ConvertUTF.h"
-#include "llvm/ADT/ArrayRef.h"
 #include "gtest/gtest.h"
 #include <string>
 #include <vector>
@@ -39,7 +38,7 @@ TEST(ConvertUTFTest, ConvertUTF16BigEndianToUTF8String) {
 TEST(ConvertUTFTest, ConvertUTF8ToUTF16String) {
   // Src is the look of disapproval.
   static const char Src[] = "\xe0\xb2\xa0_\xe0\xb2\xa0";
-  StringRef Ref(Src, sizeof(Src) - 1);
+  std::string_view Ref(Src, sizeof(Src) - 1);
   SmallVector<UTF16, 5> Result;
   bool Success = convertUTF8ToUTF16String(Ref, Result);
   EXPECT_TRUE(Success);
@@ -63,18 +62,18 @@ TEST(ConvertUTFTest, Empty) {
 }
 
 TEST(ConvertUTFTest, HasUTF16BOM) {
-  bool HasBOM = hasUTF16ByteOrderMark(makeArrayRef("\xff\xfe", 2));
+  bool HasBOM = hasUTF16ByteOrderMark("\xff\xfe");
   EXPECT_TRUE(HasBOM);
-  HasBOM = hasUTF16ByteOrderMark(makeArrayRef("\xfe\xff", 2));
+  HasBOM = hasUTF16ByteOrderMark("\xfe\xff");
   EXPECT_TRUE(HasBOM);
-  HasBOM = hasUTF16ByteOrderMark(makeArrayRef("\xfe\xff ", 3));
+  HasBOM = hasUTF16ByteOrderMark("\xfe\xff ");
   EXPECT_TRUE(HasBOM); // Don't care about odd lengths.
-  HasBOM = hasUTF16ByteOrderMark(makeArrayRef("\xfe\xff\x00asdf", 6));
+  HasBOM = hasUTF16ByteOrderMark("\xfe\xff\x00asdf");
   EXPECT_TRUE(HasBOM);
 
-  HasBOM = hasUTF16ByteOrderMark(None);
+  HasBOM = hasUTF16ByteOrderMark("");
   EXPECT_FALSE(HasBOM);
-  HasBOM = hasUTF16ByteOrderMark(makeArrayRef("\xfe", 1));
+  HasBOM = hasUTF16ByteOrderMark("\xfe");
   EXPECT_FALSE(HasBOM);
 }
 
@@ -147,7 +146,7 @@ struct ConvertUTFResultContainer {
 };
 
 std::pair<ConversionResult, std::vector<unsigned>>
-ConvertUTF8ToUnicodeScalarsLenient(StringRef S) {
+ConvertUTF8ToUnicodeScalarsLenient(std::string_view S) {
   const UTF8 *SourceStart = reinterpret_cast<const UTF8 *>(S.data());
 
   const UTF8 *SourceNext = SourceStart;
@@ -164,7 +163,7 @@ ConvertUTF8ToUnicodeScalarsLenient(StringRef S) {
 }
 
 std::pair<ConversionResult, std::vector<unsigned>>
-ConvertUTF8ToUnicodeScalarsPartialLenient(StringRef S) {
+ConvertUTF8ToUnicodeScalarsPartialLenient(std::string_view S) {
   const UTF8 *SourceStart = reinterpret_cast<const UTF8 *>(S.data());
 
   const UTF8 *SourceNext = SourceStart;
@@ -182,7 +181,7 @@ ConvertUTF8ToUnicodeScalarsPartialLenient(StringRef S) {
 
 ::testing::AssertionResult
 CheckConvertUTF8ToUnicodeScalars(ConvertUTFResultContainer Expected,
-                                 StringRef S, bool Partial = false) {
+                                 std::string_view S, bool Partial = false) {
   ConversionResult ErrorCode;
   std::vector<unsigned> Decoded;
   if (!Partial)
@@ -277,7 +276,7 @@ TEST(ConvertUTFTest, UTF8ToUTF32Lenient) {
   // U+0000 NULL
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
       ConvertUTFResultContainer(conversionOK).withScalars(0x0000),
-      StringRef("\x00", 1)));
+      std::string_view("\x00", 1)));
 
   // U+0080 PADDING CHARACTER
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
@@ -1051,7 +1050,7 @@ TEST(ConvertUTFTest, UTF8ToUTF32Lenient) {
   // U+0000 NULL
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
       ConvertUTFResultContainer(conversionOK).withScalars(0x0000),
-      StringRef("\x00", 1)));
+      std::string_view("\x00", 1)));
 
   // Overlong sequences of the above.
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
-- 
2.20.1.windows.1

