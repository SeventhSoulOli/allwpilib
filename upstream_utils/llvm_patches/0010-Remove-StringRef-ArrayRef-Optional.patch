From f2b12549f00bf95112fe10eb453dae0f3ba8fccd Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Tue, 3 May 2022 21:42:38 -0400
Subject: [PATCH 10/37] Remove StringRef, ArrayRef, Optional

---
 llvm/include/llvm/ADT/DenseMapInfo.h          |  38 +++---
 llvm/include/llvm/ADT/SmallSet.h              |  12 +-
 llvm/include/llvm/ADT/SmallString.h           |  60 ++++----
 llvm/include/llvm/ADT/StringMap.h             |  34 ++---
 llvm/include/llvm/ADT/StringMapEntry.h        |  19 +--
 llvm/include/llvm/Support/ConvertUTF.h        |  43 ++----
 llvm/include/llvm/Support/ErrorHandling.h     |   7 +-
 llvm/include/llvm/Support/MemoryBuffer.h      |  52 ++++---
 .../llvm/Support/SmallVectorMemoryBuffer.h    |   6 +-
 llvm/include/llvm/Support/VersionTuple.h      |  21 ++-
 .../llvm/Support/Windows/WindowsSupport.h     |   2 -
 llvm/include/llvm/Support/raw_ostream.h       |  38 ++++--
 llvm/lib/Support/ConvertUTFWrapper.cpp        |  37 ++---
 llvm/lib/Support/ErrorHandling.cpp            |  13 +-
 llvm/lib/Support/MemoryBuffer.cpp             |  76 +++++------
 llvm/lib/Support/StringMap.cpp                |  12 +-
 llvm/lib/Support/raw_ostream.cpp              |  16 +--
 llvm/unittests/ADT/DenseMapTest.cpp           |  14 +-
 llvm/unittests/ADT/FunctionExtrasTest.cpp     |   8 +-
 llvm/unittests/ADT/HashingTest.cpp            |   2 +-
 llvm/unittests/ADT/SmallStringTest.cpp        | 129 +++---------------
 llvm/unittests/ADT/SmallVectorTest.cpp        |  20 +--
 llvm/unittests/ADT/StringMapTest.cpp          |  60 ++------
 llvm/unittests/Support/ConvertUTFTest.cpp     |  25 ++--
 24 files changed, 282 insertions(+), 462 deletions(-)

diff --git a/llvm/include/llvm/ADT/DenseMapInfo.h b/llvm/include/llvm/ADT/DenseMapInfo.h
index c3e6d1d9b1d6..e3343a552340 100644
--- a/llvm/include/llvm/ADT/DenseMapInfo.h
+++ b/llvm/include/llvm/ADT/DenseMapInfo.h
@@ -13,12 +13,14 @@
 #ifndef LLVM_ADT_DENSEMAPINFO_H
 #define LLVM_ADT_DENSEMAPINFO_H
 
-#include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/Hashing.h"
-#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/span.h"
+#include "llvm/Support/PointerLikeTypeTraits.h"
+#include "llvm/Support/TypeSize.h"
 #include <cassert>
 #include <cstddef>
 #include <cstdint>
+#include <string_view>
 #include <utility>
 
 namespace llvm {
@@ -284,26 +286,26 @@ template <typename... Ts> struct DenseMapInfo<std::tuple<Ts...>> {
   }
 };
 
-// Provide DenseMapInfo for StringRefs.
-template <> struct DenseMapInfo<StringRef> {
-  static inline StringRef getEmptyKey() {
-    return StringRef(reinterpret_cast<const char *>(~static_cast<uintptr_t>(0)),
+// Provide DenseMapInfo for std::string_views.
+template <> struct DenseMapInfo<std::string_view> {
+  static inline std::string_view getEmptyKey() {
+    return std::string_view(reinterpret_cast<const char *>(~static_cast<uintptr_t>(0)),
                      0);
   }
 
-  static inline StringRef getTombstoneKey() {
-    return StringRef(reinterpret_cast<const char *>(~static_cast<uintptr_t>(1)),
+  static inline std::string_view getTombstoneKey() {
+    return std::string_view(reinterpret_cast<const char *>(~static_cast<uintptr_t>(1)),
                      0);
   }
 
-  static unsigned getHashValue(StringRef Val) {
+  static unsigned getHashValue(std::string_view Val) {
     assert(Val.data() != getEmptyKey().data() && "Cannot hash the empty key!");
     assert(Val.data() != getTombstoneKey().data() &&
            "Cannot hash the tombstone key!");
     return (unsigned)(hash_value(Val));
   }
 
-  static bool isEqual(StringRef LHS, StringRef RHS) {
+  static bool isEqual(std::string_view LHS, std::string_view RHS) {
     if (RHS.data() == getEmptyKey().data())
       return LHS.data() == getEmptyKey().data();
     if (RHS.data() == getTombstoneKey().data())
@@ -312,26 +314,26 @@ template <> struct DenseMapInfo<StringRef> {
   }
 };
 
-// Provide DenseMapInfo for ArrayRefs.
-template <typename T> struct DenseMapInfo<ArrayRef<T>> {
-  static inline ArrayRef<T> getEmptyKey() {
-    return ArrayRef<T>(reinterpret_cast<const T *>(~static_cast<uintptr_t>(0)),
+// Provide DenseMapInfo for spans.
+template <typename T> struct DenseMapInfo<span<T>> {
+  static inline span<T> getEmptyKey() {
+    return span<T>(reinterpret_cast<const T *>(~static_cast<uintptr_t>(0)),
                        size_t(0));
   }
 
-  static inline ArrayRef<T> getTombstoneKey() {
-    return ArrayRef<T>(reinterpret_cast<const T *>(~static_cast<uintptr_t>(1)),
+  static inline span<T> getTombstoneKey() {
+    return span<T>(reinterpret_cast<const T *>(~static_cast<uintptr_t>(1)),
                        size_t(0));
   }
 
-  static unsigned getHashValue(ArrayRef<T> Val) {
+  static unsigned getHashValue(span<T> Val) {
     assert(Val.data() != getEmptyKey().data() && "Cannot hash the empty key!");
     assert(Val.data() != getTombstoneKey().data() &&
            "Cannot hash the tombstone key!");
     return (unsigned)(hash_value(Val));
   }
 
-  static bool isEqual(ArrayRef<T> LHS, ArrayRef<T> RHS) {
+  static bool isEqual(span<T> LHS, span<T> RHS) {
     if (RHS.data() == getEmptyKey().data())
       return LHS.data() == getEmptyKey().data();
     if (RHS.data() == getTombstoneKey().data())
diff --git a/llvm/include/llvm/ADT/SmallSet.h b/llvm/include/llvm/ADT/SmallSet.h
index a03fa7dd8423..8294a816f284 100644
--- a/llvm/include/llvm/ADT/SmallSet.h
+++ b/llvm/include/llvm/ADT/SmallSet.h
@@ -13,7 +13,6 @@
 #ifndef LLVM_ADT_SMALLSET_H
 #define LLVM_ADT_SMALLSET_H
 
-#include "llvm/ADT/None.h"
 #include "llvm/ADT/SmallPtrSet.h"
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/ADT/iterator.h"
@@ -21,6 +20,7 @@
 #include "llvm/Support/type_traits.h"
 #include <cstddef>
 #include <functional>
+#include <optional>
 #include <set>
 #include <type_traits>
 #include <utility>
@@ -177,16 +177,16 @@ public:
   /// concept.
   // FIXME: Add iterators that abstract over the small and large form, and then
   // return those here.
-  std::pair<NoneType, bool> insert(const T &V) {
+  std::pair<std::nullopt_t, bool> insert(const T &V) {
     if (!isSmall())
-      return std::make_pair(None, Set.insert(V).second);
+      return std::make_pair(std::nullopt, Set.insert(V).second);
 
     VIterator I = vfind(V);
     if (I != Vector.end())    // Don't reinsert if it already exists.
-      return std::make_pair(None, false);
+      return std::make_pair(std::nullopt, false);
     if (Vector.size() < N) {
       Vector.push_back(V);
-      return std::make_pair(None, true);
+      return std::make_pair(std::nullopt, true);
     }
 
     // Otherwise, grow from vector to set.
@@ -195,7 +195,7 @@ public:
       Vector.pop_back();
     }
     Set.insert(V);
-    return std::make_pair(None, true);
+    return std::make_pair(std::nullopt, true);
   }
 
   template <typename IterT>
diff --git a/llvm/include/llvm/ADT/SmallString.h b/llvm/include/llvm/ADT/SmallString.h
index cd6f2173d04f..e748015a514f 100644
--- a/llvm/include/llvm/ADT/SmallString.h
+++ b/llvm/include/llvm/ADT/SmallString.h
@@ -14,8 +14,8 @@
 #define LLVM_ADT_SMALLSTRING_H
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/StringRef.h"
 #include <cstddef>
+#include <string_view>
 
 namespace llvm {
 
@@ -27,8 +27,8 @@ public:
   /// Default ctor - Initialize to empty.
   SmallString() = default;
 
-  /// Initialize from a StringRef.
-  SmallString(StringRef S) : SmallVector<char, InternalLen>(S.begin(), S.end()) {}
+  /// Initialize from a std::string_view.
+  SmallString(std::string_view S) : SmallVector<char, InternalLen>(S.begin(), S.end()) {}
 
   /// Initialize with a range.
   template<typename ItTy>
@@ -53,8 +53,8 @@ public:
     SmallVectorImpl<char>::append(S, E);
   }
 
-  /// Assign from a StringRef.
-  void assign(StringRef RHS) {
+  /// Assign from a std::string_view.
+  void assign(std::string_view RHS) {
     this->clear();
     SmallVectorImpl<char>::append(RHS.begin(), RHS.end());
   }
@@ -79,8 +79,8 @@ public:
     SmallVectorImpl<char>::append(NumInputs, Elt);
   }
 
-  /// Append from a StringRef.
-  void append(StringRef RHS) {
+  /// Append from a std::string_view.
+  void append(std::string_view RHS) {
     SmallVectorImpl<char>::append(RHS.begin(), RHS.end());
   }
 
@@ -95,29 +95,29 @@ public:
 
   /// Check for string equality.  This is more efficient than compare() when
   /// the relative ordering of inequal strings isn't needed.
-  bool equals(StringRef RHS) const {
+  bool equals(std::string_view RHS) const {
     return str().equals(RHS);
   }
 
   /// Check for string equality, ignoring case.
-  bool equals_lower(StringRef RHS) const {
+  bool equals_lower(std::string_view RHS) const {
     return str().equals_lower(RHS);
   }
 
   /// Compare two strings; the result is -1, 0, or 1 if this string is
   /// lexicographically less than, equal to, or greater than the \p RHS.
-  int compare(StringRef RHS) const {
+  int compare(std::string_view RHS) const {
     return str().compare(RHS);
   }
 
   /// compare_lower - Compare two strings, ignoring case.
-  int compare_lower(StringRef RHS) const {
+  int compare_lower(std::string_view RHS) const {
     return str().compare_lower(RHS);
   }
 
   /// compare_numeric - Compare two strings, treating sequences of digits as
   /// numbers.
-  int compare_numeric(StringRef RHS) const {
+  int compare_numeric(std::string_view RHS) const {
     return str().compare_numeric(RHS);
   }
 
@@ -126,12 +126,12 @@ public:
   /// @{
 
   /// startswith - Check if this string starts with the given \p Prefix.
-  bool startswith(StringRef Prefix) const {
+  bool startswith(std::string_view Prefix) const {
     return str().startswith(Prefix);
   }
 
   /// endswith - Check if this string ends with the given \p Suffix.
-  bool endswith(StringRef Suffix) const {
+  bool endswith(std::string_view Suffix) const {
     return str().endswith(Suffix);
   }
 
@@ -151,7 +151,7 @@ public:
   ///
   /// \returns The index of the first occurrence of \p Str, or npos if not
   /// found.
-  size_t find(StringRef Str, size_t From = 0) const {
+  size_t find(std::string_view Str, size_t From = 0) const {
     return str().find(Str, From);
   }
 
@@ -159,7 +159,7 @@ public:
   ///
   /// \returns The index of the last occurrence of \p C, or npos if not
   /// found.
-  size_t rfind(char C, size_t From = StringRef::npos) const {
+  size_t rfind(char C, size_t From = std::string_view::npos) const {
     return str().rfind(C, From);
   }
 
@@ -167,7 +167,7 @@ public:
   ///
   /// \returns The index of the last occurrence of \p Str, or npos if not
   /// found.
-  size_t rfind(StringRef Str) const {
+  size_t rfind(std::string_view Str) const {
     return str().rfind(Str);
   }
 
@@ -181,7 +181,7 @@ public:
   /// not found.
   ///
   /// Complexity: O(size() + Chars.size())
-  size_t find_first_of(StringRef Chars, size_t From = 0) const {
+  size_t find_first_of(std::string_view Chars, size_t From = 0) const {
     return str().find_first_of(Chars, From);
   }
 
@@ -195,13 +195,13 @@ public:
   /// \p Chars, or npos if not found.
   ///
   /// Complexity: O(size() + Chars.size())
-  size_t find_first_not_of(StringRef Chars, size_t From = 0) const {
+  size_t find_first_not_of(std::string_view Chars, size_t From = 0) const {
     return str().find_first_not_of(Chars, From);
   }
 
   /// Find the last character in the string that is \p C, or npos if not
   /// found.
-  size_t find_last_of(char C, size_t From = StringRef::npos) const {
+  size_t find_last_of(char C, size_t From = std::string_view::npos) const {
     return str().find_last_of(C, From);
   }
 
@@ -210,7 +210,7 @@ public:
   ///
   /// Complexity: O(size() + Chars.size())
   size_t find_last_of(
-      StringRef Chars, size_t From = StringRef::npos) const {
+      std::string_view Chars, size_t From = std::string_view::npos) const {
     return str().find_last_of(Chars, From);
   }
 
@@ -225,7 +225,7 @@ public:
 
   /// Return the number of non-overlapped occurrences of \p Str in the
   /// string.
-  size_t count(StringRef Str) const {
+  size_t count(std::string_view Str) const {
     return str().count(Str);
   }
 
@@ -242,7 +242,7 @@ public:
   /// \param N The number of characters to included in the substring. If \p N
   /// exceeds the number of characters remaining in the string, the string
   /// suffix (starting with \p Start) will be returned.
-  StringRef substr(size_t Start, size_t N = StringRef::npos) const {
+  std::string_view substr(size_t Start, size_t N = std::string_view::npos) const {
     return str().substr(Start, N);
   }
 
@@ -256,14 +256,14 @@ public:
   /// substring. If this is npos, or less than \p Start, or exceeds the
   /// number of characters remaining in the string, the string suffix
   /// (starting with \p Start) will be returned.
-  StringRef slice(size_t Start, size_t End) const {
+  std::string_view slice(size_t Start, size_t End) const {
     return str().slice(Start, End);
   }
 
   // Extra methods.
 
-  /// Explicit conversion to StringRef.
-  StringRef str() const { return StringRef(this->data(), this->size()); }
+  /// Explicit conversion to std::string_view.
+  std::string_view str() const { return std::string_view(this->begin(), this->size()); }
 
   // TODO: Make this const, if it's safe...
   const char* c_str() {
@@ -272,20 +272,20 @@ public:
     return this->data();
   }
 
-  /// Implicit conversion to StringRef.
-  operator StringRef() const { return str(); }
+  /// Implicit conversion to std::string_view.
+  operator std::string_view() const { return str(); }
 
   explicit operator std::string() const {
     return std::string(this->data(), this->size());
   }
 
   // Extra operators.
-  const SmallString &operator=(StringRef RHS) {
+  const SmallString &operator=(std::string_view RHS) {
     this->clear();
     return *this += RHS;
   }
 
-  SmallString &operator+=(StringRef RHS) {
+  SmallString &operator+=(std::string_view RHS) {
     this->append(RHS.begin(), RHS.end());
     return *this;
   }
diff --git a/llvm/include/llvm/ADT/StringMap.h b/llvm/include/llvm/ADT/StringMap.h
index 87ce5a5e0dfa..a7281bd3a069 100644
--- a/llvm/include/llvm/ADT/StringMap.h
+++ b/llvm/include/llvm/ADT/StringMap.h
@@ -58,12 +58,12 @@ protected:
   /// specified bucket will be non-null.  Otherwise, it will be null.  In either
   /// case, the FullHashValue field of the bucket will be set to the hash value
   /// of the string.
-  unsigned LookupBucketFor(StringRef Key);
+  unsigned LookupBucketFor(std::string_view Key);
 
   /// FindKey - Look up the bucket that contains the specified key. If it exists
   /// in the map, return the bucket number of the key.  Otherwise return -1.
   /// This does not modify the map.
-  int FindKey(StringRef Key) const;
+  int FindKey(std::string_view Key) const;
 
   /// RemoveKey - Remove the specified StringMapEntry from the table, but do not
   /// delete it.  This aborts if the value isn't in the table.
@@ -71,7 +71,7 @@ protected:
 
   /// RemoveKey - Remove the StringMapEntry for the specified key from the
   /// table, returning it.  If the key is not in the table, this returns null.
-  StringMapEntryBase *RemoveKey(StringRef Key);
+  StringMapEntryBase *RemoveKey(std::string_view Key);
 
   /// Allocate the table with the specified number of buckets and otherwise
   /// setup the map as empty.
@@ -112,7 +112,7 @@ public:
   explicit StringMap(unsigned InitialSize)
       : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))) {}
 
-  StringMap(std::initializer_list<std::pair<StringRef, ValueTy>> List)
+  StringMap(std::initializer_list<std::pair<std::string_view, ValueTy>> List)
       : StringMapImpl(List.size(), static_cast<unsigned>(sizeof(MapEntryTy))) {
     for (const auto &P : List) {
       insert(P);
@@ -198,14 +198,14 @@ public:
                       StringMapKeyIterator<ValueTy>(end()));
   }
 
-  iterator find(StringRef Key) {
+  iterator find(std::string_view Key) {
     int Bucket = FindKey(Key);
     if (Bucket == -1)
       return end();
     return iterator(TheTable + Bucket, true);
   }
 
-  const_iterator find(StringRef Key) const {
+  const_iterator find(std::string_view Key) const {
     int Bucket = FindKey(Key);
     if (Bucket == -1)
       return end();
@@ -214,7 +214,7 @@ public:
 
   /// lookup - Return the entry for the specified key, or a default
   /// constructed value if no such entry exists.
-  ValueTy lookup(StringRef Key) const {
+  ValueTy lookup(std::string_view Key) const {
     const_iterator it = find(Key);
     if (it != end())
       return it->second;
@@ -223,10 +223,10 @@ public:
 
   /// Lookup the ValueTy for the \p Key, or create a default constructed value
   /// if the key is not in the map.
-  ValueTy &operator[](StringRef Key) { return try_emplace(Key).first->second; }
+  ValueTy &operator[](std::string_view Key) { return try_emplace(Key).first->second; }
 
   /// count - Return 1 if the element is in the map, 0 otherwise.
-  size_type count(StringRef Key) const { return find(Key) == end() ? 0 : 1; }
+  size_type count(std::string_view Key) const { return find(Key) == end() ? 0 : 1; }
 
   template <typename InputTy>
   size_type count(const StringMapEntry<InputTy> &MapEntry) const {
@@ -276,14 +276,14 @@ public:
   /// isn't already in the map. The bool component of the returned pair is true
   /// if and only if the insertion takes place, and the iterator component of
   /// the pair points to the element with key equivalent to the key of the pair.
-  std::pair<iterator, bool> insert(std::pair<StringRef, ValueTy> KV) {
+  std::pair<iterator, bool> insert(std::pair<std::string_view, ValueTy> KV) {
     return try_emplace(KV.first, std::move(KV.second));
   }
 
   /// Inserts an element or assigns to the current element if the key already
   /// exists. The return type is the same as try_emplace.
   template <typename V>
-  std::pair<iterator, bool> insert_or_assign(StringRef Key, V &&Val) {
+  std::pair<iterator, bool> insert_or_assign(std::string_view Key, V &&Val) {
     auto Ret = try_emplace(Key, std::forward<V>(Val));
     if (!Ret.second)
       Ret.first->second = std::forward<V>(Val);
@@ -295,7 +295,7 @@ public:
   /// if and only if the insertion takes place, and the iterator component of
   /// the pair points to the element with key equivalent to the key of the pair.
   template <typename... ArgsTy>
-  std::pair<iterator, bool> try_emplace(StringRef Key, ArgsTy &&... Args) {
+  std::pair<iterator, bool> try_emplace(std::string_view Key, ArgsTy &&... Args) {
     unsigned BucketNo = LookupBucketFor(Key);
     StringMapEntryBase *&Bucket = TheTable[BucketNo];
     if (Bucket && Bucket != getTombstoneVal())
@@ -341,7 +341,7 @@ public:
     V.Destroy();
   }
 
-  bool erase(StringRef Key) {
+  bool erase(std::string_view Key) {
     iterator I = find(Key);
     if (I == end())
       return false;
@@ -436,23 +436,23 @@ template <typename ValueTy>
 class StringMapKeyIterator
     : public iterator_adaptor_base<StringMapKeyIterator<ValueTy>,
                                    StringMapConstIterator<ValueTy>,
-                                   std::forward_iterator_tag, StringRef> {
+                                   std::forward_iterator_tag, std::string_view> {
   using base = iterator_adaptor_base<StringMapKeyIterator<ValueTy>,
                                      StringMapConstIterator<ValueTy>,
-                                     std::forward_iterator_tag, StringRef>;
+                                     std::forward_iterator_tag, std::string_view>;
 
 public:
   StringMapKeyIterator() = default;
   explicit StringMapKeyIterator(StringMapConstIterator<ValueTy> Iter)
       : base(std::move(Iter)) {}
 
-  StringRef &operator*() {
+  std::string_view &operator*() {
     Key = this->wrapped()->getKey();
     return Key;
   }
 
 private:
-  StringRef Key;
+  std::string_view Key;
 };
 
 } // end namespace llvm
diff --git a/llvm/include/llvm/ADT/StringMapEntry.h b/llvm/include/llvm/ADT/StringMapEntry.h
index e46e00b2f842..afc829de53d0 100644
--- a/llvm/include/llvm/ADT/StringMapEntry.h
+++ b/llvm/include/llvm/ADT/StringMapEntry.h
@@ -15,7 +15,8 @@
 #ifndef LLVM_ADT_STRINGMAPENTRY_H
 #define LLVM_ADT_STRINGMAPENTRY_H
 
-#include "llvm/ADT/StringRef.h"
+#include <optional>
+#include <string_view>
 
 namespace llvm {
 
@@ -53,13 +54,13 @@ public:
   void setValue(const ValueTy &V) { second = V; }
 };
 
-template <> class StringMapEntryStorage<NoneType> : public StringMapEntryBase {
+template <> class StringMapEntryStorage<std::nullopt_t> : public StringMapEntryBase {
 public:
-  explicit StringMapEntryStorage(size_t keyLength, NoneType none = None)
+  explicit StringMapEntryStorage(size_t keyLength, std::nullopt_t none = std::nullopt)
       : StringMapEntryBase(keyLength) {}
   StringMapEntryStorage(StringMapEntryStorage &entry) = delete;
 
-  NoneType getValue() const { return None; }
+  std::nullopt_t getValue() const { return std::nullopt; }
 };
 
 /// StringMapEntry - This is used to represent one value that is inserted into
@@ -70,8 +71,8 @@ class StringMapEntry final : public StringMapEntryStorage<ValueTy> {
 public:
   using StringMapEntryStorage<ValueTy>::StringMapEntryStorage;
 
-  StringRef getKey() const {
-    return StringRef(getKeyData(), this->getKeyLength());
+  std::string_view getKey() const {
+    return std::string_view(getKeyData(), this->getKeyLength());
   }
 
   /// getKeyData - Return the start of the string data that is the key for this
@@ -81,14 +82,14 @@ public:
     return reinterpret_cast<const char *>(this + 1);
   }
 
-  StringRef first() const {
-    return StringRef(getKeyData(), this->getKeyLength());
+  std::string_view first() const {
+    return std::string_view(getKeyData(), this->getKeyLength());
   }
 
   /// Create a StringMapEntry for the specified key construct the value using
   /// \p InitiVals.
   template <typename... InitTy>
-  static StringMapEntry *Create(StringRef key,
+  static StringMapEntry *Create(std::string_view key,
                                 InitTy &&... initVals) {
     size_t keyLength = key.size();
 
diff --git a/llvm/include/llvm/Support/ConvertUTF.h b/llvm/include/llvm/Support/ConvertUTF.h
index c83ba81fa2e2..48435fbb6f30 100644
--- a/llvm/include/llvm/Support/ConvertUTF.h
+++ b/llvm/include/llvm/Support/ConvertUTF.h
@@ -89,8 +89,11 @@
 #ifndef LLVM_SUPPORT_CONVERTUTF_H
 #define LLVM_SUPPORT_CONVERTUTF_H
 
+#include "wpi/span.h"
+
 #include <cstddef>
 #include <string>
+#include <string_view>
 #include <system_error>
 
 // Wrap everything in namespace llvm so that programs can link with llvm and
@@ -180,27 +183,7 @@ unsigned getNumBytesForUTF8(UTF8 firstByte);
 /*************************************************************************/
 /* Below are LLVM-specific wrappers of the functions above. */
 
-template <typename T> class ArrayRef;
 template <typename T> class SmallVectorImpl;
-class StringRef;
-
-/**
- * Convert an UTF8 StringRef to UTF8, UTF16, or UTF32 depending on
- * WideCharWidth. The converted data is written to ResultPtr, which needs to
- * point to at least WideCharWidth * (Source.Size() + 1) bytes. On success,
- * ResultPtr will point one after the end of the copied string. On failure,
- * ResultPtr will not be changed, and ErrorPtr will be set to the location of
- * the first character which could not be converted.
- * \return true on success.
- */
-bool ConvertUTF8toWide(unsigned WideCharWidth, llvm::StringRef Source,
-                       char *&ResultPtr, const UTF8 *&ErrorPtr);
-
-/**
-* Converts a UTF-8 StringRef to a std::wstring.
-* \return true on success.
-*/
-bool ConvertUTF8toWide(llvm::StringRef Source, std::wstring &Result);
 
 /**
 * Converts a UTF-8 C-string to a std::wstring.
@@ -258,7 +241,7 @@ inline ConversionResult convertUTF8Sequence(const UTF8 **source,
  * Returns true if a blob of text starts with a UTF-16 big or little endian byte
  * order mark.
  */
-bool hasUTF16ByteOrderMark(ArrayRef<char> SrcBytes);
+bool hasUTF16ByteOrderMark(span<const char> SrcBytes);
 
 /**
  * Converts a stream of raw bytes assumed to be UTF16 into a UTF8 std::string.
@@ -267,31 +250,23 @@ bool hasUTF16ByteOrderMark(ArrayRef<char> SrcBytes);
  * \param [out] Out Converted UTF-8 is stored here on success.
  * \returns true on success
  */
-bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out);
-
-/**
-* Converts a UTF16 string into a UTF8 std::string.
-*
-* \param [in] Src A buffer of UTF-16 encoded text.
-* \param [out] Out Converted UTF-8 is stored here on success.
-* \returns true on success
-*/
-bool convertUTF16ToUTF8String(ArrayRef<UTF16> Src, std::string &Out);
+bool convertUTF16ToUTF8String(span<const UTF16> SrcBytes,
+                              SmallVectorImpl<char> &Out);
 
 /**
  * Converts a UTF-8 string into a UTF-16 string with native endianness.
  *
  * \returns true on success
  */
-bool convertUTF8ToUTF16String(StringRef SrcUTF8,
+bool convertUTF8ToUTF16String(std::string_view SrcUTF8,
                               SmallVectorImpl<UTF16> &DstUTF16);
 
 #if defined(_WIN32)
 namespace sys {
 namespace windows {
-std::error_code UTF8ToUTF16(StringRef utf8, SmallVectorImpl<wchar_t> &utf16);
+std::error_code UTF8ToUTF16(std::string_view utf8, SmallVectorImpl<wchar_t> &utf16);
 /// Convert to UTF16 from the current code page used in the system
-std::error_code CurCPToUTF16(StringRef utf8, SmallVectorImpl<wchar_t> &utf16);
+std::error_code CurCPToUTF16(std::string_view utf8, SmallVectorImpl<wchar_t> &utf16);
 std::error_code UTF16ToUTF8(const wchar_t *utf16, size_t utf16_len,
                             SmallVectorImpl<char> &utf8);
 /// Convert from UTF16 to the current code page used in the system
diff --git a/llvm/include/llvm/Support/ErrorHandling.h b/llvm/include/llvm/Support/ErrorHandling.h
index d88d79b69440..8de61f6732f6 100644
--- a/llvm/include/llvm/Support/ErrorHandling.h
+++ b/llvm/include/llvm/Support/ErrorHandling.h
@@ -16,10 +16,9 @@
 
 #include "llvm/Support/Compiler.h"
 #include <string>
+#include <string_view>
 
 namespace llvm {
-class StringRef;
-  class Twine;
 
   /// An error handler callback.
   typedef void (*fatal_error_handler_t)(void *user_data,
@@ -72,9 +71,7 @@ LLVM_ATTRIBUTE_NORETURN void report_fatal_error(const char *reason,
                                                 bool gen_crash_diag = true);
 LLVM_ATTRIBUTE_NORETURN void report_fatal_error(const std::string &reason,
                                                 bool gen_crash_diag = true);
-LLVM_ATTRIBUTE_NORETURN void report_fatal_error(StringRef reason,
-                                                bool gen_crash_diag = true);
-LLVM_ATTRIBUTE_NORETURN void report_fatal_error(const Twine &reason,
+LLVM_ATTRIBUTE_NORETURN void report_fatal_error(std::string_view reason,
                                                 bool gen_crash_diag = true);
 
 /// Installs a new bad alloc error handler that should be used whenever a
diff --git a/llvm/include/llvm/Support/MemoryBuffer.h b/llvm/include/llvm/Support/MemoryBuffer.h
index 3b20fec3e136..07db11788512 100644
--- a/llvm/include/llvm/Support/MemoryBuffer.h
+++ b/llvm/include/llvm/Support/MemoryBuffer.h
@@ -14,14 +14,12 @@
 #define LLVM_SUPPORT_MEMORYBUFFER_H
 
 #include "llvm-c/Types.h"
-#include "llvm/ADT/ArrayRef.h"
-#include "llvm/ADT/StringRef.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Support/CBindingWrapping.h"
 #include "llvm/Support/ErrorOr.h"
 #include <cstddef>
 #include <cstdint>
 #include <memory>
+#include <string_view>
 
 namespace llvm {
 
@@ -68,13 +66,13 @@ public:
   const char *getBufferEnd() const   { return BufferEnd; }
   size_t getBufferSize() const { return BufferEnd-BufferStart; }
 
-  StringRef getBuffer() const {
-    return StringRef(BufferStart, getBufferSize());
+  span<const uint8_t> getBuffer() const {
+    return {BufferStart, getBufferSize()};
   }
 
   /// Return an identifier for this buffer, typically the filename it was read
   /// from.
-  virtual StringRef getBufferIdentifier() const { return "Unknown buffer"; }
+  virtual std::string_view getBufferIdentifier() const { return "Unknown buffer"; }
 
   /// Open the specified file as a MemoryBuffer, returning a new MemoryBuffer
   /// if successful, otherwise returning null. If FileSize is specified, this
@@ -85,20 +83,20 @@ public:
   /// can change outside the user's control, e.g. when libclang tries to parse
   /// while the user is editing/updating the file or if the file is on an NFS.
   static ErrorOr<std::unique_ptr<MemoryBuffer>>
-  getFile(const Twine &Filename, int64_t FileSize = -1,
+  getFile(const std::string_view &Filename, int64_t FileSize = -1,
           bool RequiresNullTerminator = true, bool IsVolatile = false);
 
   /// Read all of the specified file into a MemoryBuffer as a stream
   /// (i.e. until EOF reached). This is useful for special files that
   /// look like a regular file but have 0 size (e.g. /proc/cpuinfo on Linux).
   static ErrorOr<std::unique_ptr<MemoryBuffer>>
-  getFileAsStream(const Twine &Filename);
+  getFileAsStream(const std::string_view &Filename);
 
   /// Given an already-open file descriptor, map some slice of it into a
   /// MemoryBuffer. The slice is specified by an \p Offset and \p MapSize.
   /// Since this is in the middle of a file, the buffer is not null terminated.
   static ErrorOr<std::unique_ptr<MemoryBuffer>>
-  getOpenFileSlice(sys::fs::file_t FD, const Twine &Filename, uint64_t MapSize,
+  getOpenFileSlice(sys::fs::file_t FD, const std::string_view &Filename, uint64_t MapSize,
                    int64_t Offset, bool IsVolatile = false);
 
   /// Given an already-open file descriptor, read the file and return a
@@ -108,13 +106,13 @@ public:
   /// can change outside the user's control, e.g. when libclang tries to parse
   /// while the user is editing/updating the file or if the file is on an NFS.
   static ErrorOr<std::unique_ptr<MemoryBuffer>>
-  getOpenFile(sys::fs::file_t FD, const Twine &Filename, uint64_t FileSize,
+  getOpenFile(sys::fs::file_t FD, const std::string_view &Filename, uint64_t FileSize,
               bool RequiresNullTerminator = true, bool IsVolatile = false);
 
   /// Open the specified memory range as a MemoryBuffer. Note that InputData
   /// must be null terminated if RequiresNullTerminator is true.
   static std::unique_ptr<MemoryBuffer>
-  getMemBuffer(StringRef InputData, StringRef BufferName = "",
+  getMemBuffer(span<const uint8_t> InputData, std::string_view BufferName = "",
                bool RequiresNullTerminator = true);
 
   static std::unique_ptr<MemoryBuffer>
@@ -123,7 +121,7 @@ public:
   /// Open the specified memory range as a MemoryBuffer, copying the contents
   /// and taking ownership of it. InputData does not have to be null terminated.
   static std::unique_ptr<MemoryBuffer>
-  getMemBufferCopy(StringRef InputData, const Twine &BufferName = "");
+  getMemBufferCopy(span<const uint8_t> InputData, const std::string_view &BufferName = "");
 
   /// Read all of stdin into a file buffer, and return it.
   static ErrorOr<std::unique_ptr<MemoryBuffer>> getSTDIN();
@@ -131,12 +129,12 @@ public:
   /// Open the specified file as a MemoryBuffer, or open stdin if the Filename
   /// is "-".
   static ErrorOr<std::unique_ptr<MemoryBuffer>>
-  getFileOrSTDIN(const Twine &Filename, int64_t FileSize = -1,
+  getFileOrSTDIN(const std::string_view &Filename, int64_t FileSize = -1,
                  bool RequiresNullTerminator = true);
 
   /// Map a subrange of the specified file as a MemoryBuffer.
   static ErrorOr<std::unique_ptr<MemoryBuffer>>
-  getFileSlice(const Twine &Filename, uint64_t MapSize, uint64_t Offset,
+  getFileSlice(const std::string_view &Filename, uint64_t MapSize, uint64_t Offset,
                bool IsVolatile = false);
 
   //===--------------------------------------------------------------------===//
@@ -177,30 +175,30 @@ public:
   char *getBufferEnd() {
     return const_cast<char *>(MemoryBuffer::getBufferEnd());
   }
-  MutableArrayRef<char> getBuffer() {
+  span<uint8_t> getBuffer() {
     return {getBufferStart(), getBufferEnd()};
   }
 
   static ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
-  getFile(const Twine &Filename, int64_t FileSize = -1,
+  getFile(const std::string_view &Filename, int64_t FileSize = -1,
           bool IsVolatile = false);
 
   /// Map a subrange of the specified file as a WritableMemoryBuffer.
   static ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
-  getFileSlice(const Twine &Filename, uint64_t MapSize, uint64_t Offset,
+  getFileSlice(const std::string_view &Filename, uint64_t MapSize, uint64_t Offset,
                bool IsVolatile = false);
 
   /// Allocate a new MemoryBuffer of the specified size that is not initialized.
   /// Note that the caller should initialize the memory allocated by this
   /// method. The memory is owned by the MemoryBuffer object.
   static std::unique_ptr<WritableMemoryBuffer>
-  getNewUninitMemBuffer(size_t Size, const Twine &BufferName = "");
+  getNewUninitMemBuffer(size_t Size, const std::string_view &BufferName = "");
 
   /// Allocate a new zero-initialized MemoryBuffer of the specified size. Note
   /// that the caller need not initialize the memory allocated by this method.
   /// The memory is owned by the MemoryBuffer object.
   static std::unique_ptr<WritableMemoryBuffer>
-  getNewMemBuffer(size_t Size, const Twine &BufferName = "");
+  getNewMemBuffer(size_t Size, const std::string_view &BufferName = "");
 
 private:
   // Hide these base class factory function so one can't write
@@ -236,16 +234,16 @@ public:
   char *getBufferEnd() {
     return const_cast<char *>(MemoryBuffer::getBufferEnd());
   }
-  MutableArrayRef<char> getBuffer() {
+  span<uint8_t> getBuffer() {
     return {getBufferStart(), getBufferEnd()};
   }
 
   static ErrorOr<std::unique_ptr<WriteThroughMemoryBuffer>>
-  getFile(const Twine &Filename, int64_t FileSize = -1);
+  getFile(const std::string_view &Filename, int64_t FileSize = -1);
 
   /// Map a subrange of the specified file as a ReadWriteMemoryBuffer.
   static ErrorOr<std::unique_ptr<WriteThroughMemoryBuffer>>
-  getFileSlice(const Twine &Filename, uint64_t MapSize, uint64_t Offset);
+  getFileSlice(const std::string_view &Filename, uint64_t MapSize, uint64_t Offset);
 
 private:
   // Hide these base class factory function so one can't write
@@ -261,19 +259,19 @@ private:
 };
 
 class MemoryBufferRef {
-  StringRef Buffer;
-  StringRef Identifier;
+  span<const uint8_t> Buffer;
+  std::string_view Identifier;
 
 public:
   MemoryBufferRef() = default;
   MemoryBufferRef(const MemoryBuffer& Buffer)
       : Buffer(Buffer.getBuffer()), Identifier(Buffer.getBufferIdentifier()) {}
-  MemoryBufferRef(StringRef Buffer, StringRef Identifier)
+  MemoryBufferRef(span<const uint8_t> Buffer, std::string_view Identifier)
       : Buffer(Buffer), Identifier(Identifier) {}
 
-  StringRef getBuffer() const { return Buffer; }
+  span<const uint8_t> getBuffer() const { return Buffer; }
 
-  StringRef getBufferIdentifier() const { return Identifier; }
+  std::string_view getBufferIdentifier() const { return Identifier; }
 
   const char *getBufferStart() const { return Buffer.begin(); }
   const char *getBufferEnd() const { return Buffer.end(); }
diff --git a/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h b/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
index 62900b740b81..fe9bf46d12a5 100644
--- a/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
+++ b/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
@@ -42,8 +42,8 @@ public:
   }
 
   /// Construct a named SmallVectorMemoryBuffer from the given
-  /// SmallVector r-value and StringRef.
-  SmallVectorMemoryBuffer(SmallVectorImpl<char> &&SV, StringRef Name)
+  /// SmallVector r-value and std::string_view.
+  SmallVectorMemoryBuffer(SmallVectorImpl<char> &&SV, std::string_view Name)
       : SV(std::move(SV)), BufferName(std::string(Name)) {
     init(this->SV.begin(), this->SV.end(), false);
   }
@@ -51,7 +51,7 @@ public:
   // Key function.
   ~SmallVectorMemoryBuffer() override;
 
-  StringRef getBufferIdentifier() const override { return BufferName; }
+  std::string_view getBufferIdentifier() const override { return BufferName; }
 
   BufferKind getBufferKind() const override { return MemoryBuffer_Malloc; }
 
diff --git a/llvm/include/llvm/Support/VersionTuple.h b/llvm/include/llvm/Support/VersionTuple.h
index 6f3711f06f1a..fb1ab4987564 100644
--- a/llvm/include/llvm/Support/VersionTuple.h
+++ b/llvm/include/llvm/Support/VersionTuple.h
@@ -14,8 +14,8 @@
 #ifndef LLVM_SUPPORT_VERSIONTUPLE_H
 #define LLVM_SUPPORT_VERSIONTUPLE_H
 
-#include "llvm/ADT/Hashing.h"
-#include "llvm/ADT/Optional.h"
+#include "llvm/Support/raw_ostream.h"
+#include <optional>
 #include <string>
 #include <tuple>
 
@@ -68,23 +68,23 @@ public:
   unsigned getMajor() const { return Major; }
 
   /// Retrieve the minor version number, if provided.
-  Optional<unsigned> getMinor() const {
+  std::optional<unsigned> getMinor() const {
     if (!HasMinor)
-      return None;
+      return std::nullopt;
     return Minor;
   }
 
   /// Retrieve the subminor version number, if provided.
-  Optional<unsigned> getSubminor() const {
+  std::optional<unsigned> getSubminor() const {
     if (!HasSubminor)
-      return None;
+      return std::nullopt;
     return Subminor;
   }
 
   /// Retrieve the build version number, if provided.
-  Optional<unsigned> getBuild() const {
+  std::optional<unsigned> getBuild() const {
     if (!HasBuild)
-      return None;
+      return std::nullopt;
     return Build;
   }
 
@@ -151,11 +151,6 @@ public:
 
   /// Retrieve a string representation of the version number.
   std::string getAsString() const;
-
-  /// Try to parse the given string as a version number.
-  /// \returns \c true if the string does not match the regular expression
-  ///   [0-9]+(\.[0-9]+){0,3}
-  bool tryParse(StringRef string);
 };
 
 /// Print a version number.
diff --git a/llvm/include/llvm/Support/Windows/WindowsSupport.h b/llvm/include/llvm/Support/Windows/WindowsSupport.h
index eff608d795a3..16975cfb16e8 100644
--- a/llvm/include/llvm/Support/Windows/WindowsSupport.h
+++ b/llvm/include/llvm/Support/Windows/WindowsSupport.h
@@ -35,8 +35,6 @@
 
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/ADT/StringExtras.h"
-#include "llvm/ADT/StringRef.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Config/config.h" // Get build system configuration settings
 #include "llvm/Support/Allocator.h"
 #include "llvm/Support/Chrono.h"
diff --git a/llvm/include/llvm/Support/raw_ostream.h b/llvm/include/llvm/Support/raw_ostream.h
index 8d289f7c765f..afdd94ed397d 100644
--- a/llvm/include/llvm/Support/raw_ostream.h
+++ b/llvm/include/llvm/Support/raw_ostream.h
@@ -14,12 +14,13 @@
 #define LLVM_SUPPORT_RAW_OSTREAM_H
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/span.h"
 #include <cassert>
 #include <cstddef>
 #include <cstdint>
 #include <cstring>
 #include <string>
+#include <string_view>
 #include <system_error>
 #include <type_traits>
 
@@ -183,7 +184,22 @@ public:
     return *this;
   }
 
-  raw_ostream &operator<<(StringRef Str) {
+  raw_ostream &operator<<(span<const uint8_t> Arr) {
+    // Inline fast path, particularly for arrays with a known length.
+    size_t Size = Arr.size();
+
+    // Make sure we can use the fast path.
+    if (Size > (size_t)(OutBufEnd - OutBufCur))
+      return write(Arr.data(), Size);
+
+    if (Size) {
+      memcpy(OutBufCur, Arr.data(), Size);
+      OutBufCur += Size;
+    }
+    return *this;
+  }
+
+  raw_ostream &operator<<(std::string_view Str) {
     // Inline fast path, particularly for strings with a known length.
     size_t Size = Str.size();
 
@@ -202,7 +218,7 @@ public:
     // Inline fast path, particularly for constant strings where a sufficiently
     // smart compiler will simplify strlen.
 
-    return this->operator<<(StringRef(Str));
+    return this->operator<<(std::string_view(Str));
   }
 
   raw_ostream &operator<<(const std::string &Str) {
@@ -242,7 +258,7 @@ public:
 
   /// Output \p Str, turning '\\', '\t', '\n', '"', and anything that doesn't
   /// satisfy llvm::isPrint into an escape sequence.
-  raw_ostream &write_escaped(StringRef Str, bool UseHexEscapes = false);
+  raw_ostream &write_escaped(std::string_view Str, bool UseHexEscapes = false);
 
   raw_ostream &write(unsigned char C);
   raw_ostream &write(const char *Ptr, size_t Size);
@@ -446,14 +462,14 @@ public:
   /// As a special case, if Filename is "-", then the stream will use
   /// STDOUT_FILENO instead of opening a file. This will not close the stdout
   /// descriptor.
-  raw_fd_ostream(StringRef Filename, std::error_code &EC);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC);
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::CreationDisposition Disp);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::FileAccess Access);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::OpenFlags Flags);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::CreationDisposition Disp, sys::fs::FileAccess Access,
                  sys::fs::OpenFlags Flags);
 
@@ -571,8 +587,8 @@ public:
 
   void flush() = delete;
 
-  /// Return a StringRef for the vector contents.
-  StringRef str() const { return StringRef(OS.data(), OS.size()); }
+  /// Return a std::string_view for the vector contents.
+  std::string_view str() const { return std::string_view(OS.data(), OS.size()); }
 };
 
 /// A raw_ostream that discards all output.
diff --git a/llvm/lib/Support/ConvertUTFWrapper.cpp b/llvm/lib/Support/ConvertUTFWrapper.cpp
index 6ec567882ea6..3c41886fbaba 100644
--- a/llvm/lib/Support/ConvertUTFWrapper.cpp
+++ b/llvm/lib/Support/ConvertUTFWrapper.cpp
@@ -6,24 +6,24 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "llvm/ADT/ArrayRef.h"
-#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/span.h"
 #include "llvm/Support/ConvertUTF.h"
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm/Support/SwapByteOrder.h"
 #include <string>
+#include <string_view>
 #include <vector>
 
 namespace llvm {
 
-bool ConvertUTF8toWide(unsigned WideCharWidth, llvm::StringRef Source,
+bool ConvertUTF8toWide(unsigned WideCharWidth, std::string_view Source,
                        char *&ResultPtr, const UTF8 *&ErrorPtr) {
   assert(WideCharWidth == 1 || WideCharWidth == 2 || WideCharWidth == 4);
   ConversionResult result = conversionOK;
   // Copy the character span over.
   if (WideCharWidth == 1) {
-    const UTF8 *Pos = reinterpret_cast<const UTF8*>(Source.begin());
-    if (!isLegalUTF8String(&Pos, reinterpret_cast<const UTF8*>(Source.end()))) {
+    const UTF8 *Pos = reinterpret_cast<const UTF8*>(Source.data());
+    if (!isLegalUTF8String(&Pos, reinterpret_cast<const UTF8*>(Source.data() + Source.size()))) {
       result = sourceIllegal;
       ErrorPtr = Pos;
     } else {
@@ -77,13 +77,13 @@ bool ConvertCodePointToUTF8(unsigned Source, char *&ResultPtr) {
   return true;
 }
 
-bool hasUTF16ByteOrderMark(ArrayRef<char> S) {
+bool hasUTF16ByteOrderMark(span<const char> S) {
   return (S.size() >= 2 &&
           ((S[0] == '\xff' && S[1] == '\xfe') ||
            (S[0] == '\xfe' && S[1] == '\xff')));
 }
 
-bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out) {
+bool convertUTF16ToUTF8String(span<const UTF16> SrcBytes, SmallVectorImpl<char> &Out) {
   assert(Out.empty());
 
   // Error out on an uneven byte count.
@@ -94,8 +94,8 @@ bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out) {
   if (SrcBytes.empty())
     return true;
 
-  const UTF16 *Src = reinterpret_cast<const UTF16 *>(SrcBytes.begin());
-  const UTF16 *SrcEnd = reinterpret_cast<const UTF16 *>(SrcBytes.end());
+  const UTF16 *Src = SrcBytes.begin();
+  const UTF16 *SrcEnd = SrcBytes.end();
 
   // Byteswap if necessary.
   std::vector<UTF16> ByteSwapped;
@@ -132,14 +132,7 @@ bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out) {
   return true;
 }
 
-bool convertUTF16ToUTF8String(ArrayRef<UTF16> Src, std::string &Out)
-{
-  return convertUTF16ToUTF8String(
-      llvm::ArrayRef<char>(reinterpret_cast<const char *>(Src.data()),
-      Src.size() * sizeof(UTF16)), Out);
-}
-
-bool convertUTF8ToUTF16String(StringRef SrcUTF8,
+bool convertUTF8ToUTF16String(std::string_view SrcUTF8,
                               SmallVectorImpl<UTF16> &DstUTF16) {
   assert(DstUTF16.empty());
 
@@ -150,8 +143,8 @@ bool convertUTF8ToUTF16String(StringRef SrcUTF8,
     return true;
   }
 
-  const UTF8 *Src = reinterpret_cast<const UTF8 *>(SrcUTF8.begin());
-  const UTF8 *SrcEnd = reinterpret_cast<const UTF8 *>(SrcUTF8.end());
+  const UTF8 *Src = reinterpret_cast<const UTF8 *>(SrcUTF8.data());
+  const UTF8 *SrcEnd = reinterpret_cast<const UTF8 *>(SrcUTF8.data() + SrcUTF8.size());
 
   // Allocate the same number of UTF-16 code units as UTF-8 code units. Encoding
   // as UTF-16 should always require the same amount or less code units than the
@@ -182,7 +175,7 @@ static_assert(sizeof(wchar_t) == 1 || sizeof(wchar_t) == 2 ||
               "Expected wchar_t to be 1, 2, or 4 bytes");
 
 template <typename TResult>
-static inline bool ConvertUTF8toWideInternal(llvm::StringRef Source,
+static inline bool ConvertUTF8toWideInternal(std::string_view Source,
                                              TResult &Result) {
   // Even in the case of UTF-16, the number of bytes in a UTF-8 string is
   // at least as large as the number of elements in the resulting wide
@@ -198,7 +191,7 @@ static inline bool ConvertUTF8toWideInternal(llvm::StringRef Source,
   return true;
 }
 
-bool ConvertUTF8toWide(llvm::StringRef Source, std::wstring &Result) {
+bool ConvertUTF8toWide(std::string_view Source, std::wstring &Result) {
   return ConvertUTF8toWideInternal(Source, Result);
 }
 
@@ -207,7 +200,7 @@ bool ConvertUTF8toWide(const char *Source, std::wstring &Result) {
     Result.clear();
     return true;
   }
-  return ConvertUTF8toWide(llvm::StringRef(Source), Result);
+  return ConvertUTF8toWide(std::string_view(Source), Result);
 }
 
 bool convertWideToUTF8(const std::wstring &Source, std::string &Result) {
diff --git a/llvm/lib/Support/ErrorHandling.cpp b/llvm/lib/Support/ErrorHandling.cpp
index d84bfb559931..d7c3dd75d71f 100644
--- a/llvm/lib/Support/ErrorHandling.cpp
+++ b/llvm/lib/Support/ErrorHandling.cpp
@@ -14,7 +14,6 @@
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm-c/ErrorHandling.h"
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Config/config.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/Errc.h"
@@ -74,18 +73,14 @@ void llvm::remove_fatal_error_handler() {
 }
 
 void llvm::report_fatal_error(const char *Reason, bool GenCrashDiag) {
-  report_fatal_error(Twine(Reason), GenCrashDiag);
+  report_fatal_error(std::string_view(Reason), GenCrashDiag);
 }
 
 void llvm::report_fatal_error(const std::string &Reason, bool GenCrashDiag) {
-  report_fatal_error(Twine(Reason), GenCrashDiag);
+  report_fatal_error(std::string_view(Reason), GenCrashDiag);
 }
 
-void llvm::report_fatal_error(StringRef Reason, bool GenCrashDiag) {
-  report_fatal_error(Twine(Reason), GenCrashDiag);
-}
-
-void llvm::report_fatal_error(const Twine &Reason, bool GenCrashDiag) {
+void llvm::report_fatal_error(const std::string_view &Reason, bool GenCrashDiag) {
   llvm::fatal_error_handler_t handler = nullptr;
   void* handlerData = nullptr;
   {
@@ -97,7 +92,7 @@ void llvm::report_fatal_error(const Twine &Reason, bool GenCrashDiag) {
   }
 
   if (handler) {
-    handler(handlerData, Reason.str(), GenCrashDiag);
+    handler(handlerData, std::string{Reason}, GenCrashDiag);
   } else {
     // Blast the result out to stderr.  We don't try hard to make sure this
     // succeeds (e.g. handling EINTR) and we can't use errs() here because
diff --git a/llvm/lib/Support/MemoryBuffer.cpp b/llvm/lib/Support/MemoryBuffer.cpp
index dca541d1dd5d..9d0050aebfad 100644
--- a/llvm/lib/Support/MemoryBuffer.cpp
+++ b/llvm/lib/Support/MemoryBuffer.cpp
@@ -54,9 +54,9 @@ void MemoryBuffer::init(const char *BufStart, const char *BufEnd,
 // MemoryBufferMem implementation.
 //===----------------------------------------------------------------------===//
 
-/// CopyStringRef - Copies contents of a StringRef into a block of memory and
+/// CopyStringView - Copies contents of a std::string_view into a block of memory and
 /// null-terminates it.
-static void CopyStringRef(char *Memory, StringRef Data) {
+static void CopyStringView(char *Memory, std::string_view Data) {
   if (!Data.empty())
     memcpy(Memory, Data.data(), Data.size());
   Memory[Data.size()] = 0; // Null terminate string.
@@ -64,17 +64,17 @@ static void CopyStringRef(char *Memory, StringRef Data) {
 
 namespace {
 struct NamedBufferAlloc {
-  const Twine &Name;
-  NamedBufferAlloc(const Twine &Name) : Name(Name) {}
+  std::string_view Name;
+  NamedBufferAlloc(std::string_view Name) : Name(Name) {}
 };
 }
 
 void *operator new(size_t N, const NamedBufferAlloc &Alloc) {
   SmallString<256> NameBuf;
-  StringRef NameRef = Alloc.Name.toStringRef(NameBuf);
+  std::string_view NameRef = Alloc.Name.tostd::string_view(NameBuf);
 
   char *Mem = static_cast<char *>(operator new(N + NameRef.size() + 1));
-  CopyStringRef(Mem + N, NameRef);
+  CopyStringView(Mem + N, NameRef);
   return Mem;
 }
 
@@ -83,7 +83,7 @@ namespace {
 template<typename MB>
 class MemoryBufferMem : public MB {
 public:
-  MemoryBufferMem(StringRef InputData, bool RequiresNullTerminator) {
+  MemoryBufferMem(span<const uint8_t> InputData, bool RequiresNullTerminator) {
     MemoryBuffer::init(InputData.begin(), InputData.end(),
                        RequiresNullTerminator);
   }
@@ -92,9 +92,9 @@ public:
   /// tail-allocated data.
   void operator delete(void *p) { ::operator delete(p); }
 
-  StringRef getBufferIdentifier() const override {
+  std::string_view getBufferIdentifier() const override {
     // The name is stored after the class itself.
-    return StringRef(reinterpret_cast<const char *>(this + 1));
+    return std::string_view(reinterpret_cast<const char *>(this + 1));
   }
 
   MemoryBuffer::BufferKind getBufferKind() const override {
@@ -105,11 +105,11 @@ public:
 
 template <typename MB>
 static ErrorOr<std::unique_ptr<MB>>
-getFileAux(const Twine &Filename, int64_t FileSize, uint64_t MapSize,
+getFileAux(std::string_view Filename, int64_t FileSize, uint64_t MapSize,
            uint64_t Offset, bool RequiresNullTerminator, bool IsVolatile);
 
 std::unique_ptr<MemoryBuffer>
-MemoryBuffer::getMemBuffer(StringRef InputData, StringRef BufferName,
+MemoryBuffer::getMemBuffer(span<const uint8_t> InputData, std::string_view BufferName,
                            bool RequiresNullTerminator) {
   auto *Ret = new (NamedBufferAlloc(BufferName))
       MemoryBufferMem<MemoryBuffer>(InputData, RequiresNullTerminator);
@@ -123,7 +123,7 @@ MemoryBuffer::getMemBuffer(MemoryBufferRef Ref, bool RequiresNullTerminator) {
 }
 
 static ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
-getMemBufferCopyImpl(StringRef InputData, const Twine &BufferName) {
+getMemBufferCopyImpl(span<const uint8_t> InputData, std::string_view BufferName) {
   auto Buf = WritableMemoryBuffer::getNewUninitMemBuffer(InputData.size(), BufferName);
   if (!Buf)
     return make_error_code(errc::not_enough_memory);
@@ -132,7 +132,7 @@ getMemBufferCopyImpl(StringRef InputData, const Twine &BufferName) {
 }
 
 std::unique_ptr<MemoryBuffer>
-MemoryBuffer::getMemBufferCopy(StringRef InputData, const Twine &BufferName) {
+MemoryBuffer::getMemBufferCopy(span<const uint8_t> InputData, std::string_view BufferName) {
   auto Buf = getMemBufferCopyImpl(InputData, BufferName);
   if (Buf)
     return std::move(*Buf);
@@ -140,10 +140,10 @@ MemoryBuffer::getMemBufferCopy(StringRef InputData, const Twine &BufferName) {
 }
 
 ErrorOr<std::unique_ptr<MemoryBuffer>>
-MemoryBuffer::getFileOrSTDIN(const Twine &Filename, int64_t FileSize,
+MemoryBuffer::getFileOrSTDIN(std::string_view Filename, int64_t FileSize,
                              bool RequiresNullTerminator) {
   SmallString<256> NameBuf;
-  StringRef NameRef = Filename.toStringRef(NameBuf);
+  std::string_view NameRef = Filename.tostd::string_view(NameBuf);
 
   if (NameRef == "-")
     return getSTDIN();
@@ -151,7 +151,7 @@ MemoryBuffer::getFileOrSTDIN(const Twine &Filename, int64_t FileSize,
 }
 
 ErrorOr<std::unique_ptr<MemoryBuffer>>
-MemoryBuffer::getFileSlice(const Twine &FilePath, uint64_t MapSize,
+MemoryBuffer::getFileSlice(std::string_view FilePath, uint64_t MapSize,
                            uint64_t Offset, bool IsVolatile) {
   return getFileAux<MemoryBuffer>(FilePath, -1, MapSize, Offset, false,
                                   IsVolatile);
@@ -210,9 +210,9 @@ public:
   /// tail-allocated data.
   void operator delete(void *p) { ::operator delete(p); }
 
-  StringRef getBufferIdentifier() const override {
+  std::string_view getBufferIdentifier() const override {
     // The name is stored after the class itself.
-    return StringRef(reinterpret_cast<const char *>(this + 1));
+    return std::string_view(reinterpret_cast<const char *>(this + 1));
   }
 
   MemoryBuffer::BufferKind getBufferKind() const override {
@@ -222,7 +222,7 @@ public:
 }
 
 static ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
-getMemoryBufferForStream(sys::fs::file_t FD, const Twine &BufferName) {
+getMemoryBufferForStream(sys::fs::file_t FD, std::string_view BufferName) {
   constexpr size_t ChunkSize = 4096*4;
   SmallVector<uint8_t, ChunkSize> Buffer;
   // Read into Buffer until we hit EOF.
@@ -242,7 +242,7 @@ getMemoryBufferForStream(sys::fs::file_t FD, const Twine &BufferName) {
 
 
 ErrorOr<std::unique_ptr<MemoryBuffer>>
-MemoryBuffer::getFile(const Twine &Filename, int64_t FileSize,
+MemoryBuffer::getFile(std::string_view Filename, int64_t FileSize,
                       bool RequiresNullTerminator, bool IsVolatile) {
   return getFileAux<MemoryBuffer>(Filename, FileSize, FileSize, 0,
                                   RequiresNullTerminator, IsVolatile);
@@ -250,13 +250,13 @@ MemoryBuffer::getFile(const Twine &Filename, int64_t FileSize,
 
 template <typename MB>
 static ErrorOr<std::unique_ptr<MB>>
-getOpenFileImpl(sys::fs::file_t FD, const Twine &Filename, uint64_t FileSize,
+getOpenFileImpl(sys::fs::file_t FD, std::string_view Filename, uint64_t FileSize,
                 uint64_t MapSize, int64_t Offset, bool RequiresNullTerminator,
                 bool IsVolatile);
 
 template <typename MB>
 static ErrorOr<std::unique_ptr<MB>>
-getFileAux(const Twine &Filename, int64_t FileSize, uint64_t MapSize,
+getFileAux(std::string_view Filename, int64_t FileSize, uint64_t MapSize,
            uint64_t Offset, bool RequiresNullTerminator, bool IsVolatile) {
   Expected<sys::fs::file_t> FDOrErr =
       sys::fs::openNativeFileForRead(Filename, sys::fs::OF_None);
@@ -270,7 +270,7 @@ getFileAux(const Twine &Filename, int64_t FileSize, uint64_t MapSize,
 }
 
 ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
-WritableMemoryBuffer::getFile(const Twine &Filename, int64_t FileSize,
+WritableMemoryBuffer::getFile(std::string_view Filename, int64_t FileSize,
                               bool IsVolatile) {
   return getFileAux<WritableMemoryBuffer>(Filename, FileSize, FileSize, 0,
                                           /*RequiresNullTerminator*/ false,
@@ -278,21 +278,21 @@ WritableMemoryBuffer::getFile(const Twine &Filename, int64_t FileSize,
 }
 
 ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
-WritableMemoryBuffer::getFileSlice(const Twine &Filename, uint64_t MapSize,
+WritableMemoryBuffer::getFileSlice(std::string_view Filename, uint64_t MapSize,
                                    uint64_t Offset, bool IsVolatile) {
   return getFileAux<WritableMemoryBuffer>(Filename, -1, MapSize, Offset, false,
                                           IsVolatile);
 }
 
 std::unique_ptr<WritableMemoryBuffer>
-WritableMemoryBuffer::getNewUninitMemBuffer(size_t Size, const Twine &BufferName) {
+WritableMemoryBuffer::getNewUninitMemBuffer(size_t Size, std::string_view BufferName) {
   using MemBuffer = MemoryBufferMem<WritableMemoryBuffer>;
   // Allocate space for the MemoryBuffer, the data and the name. It is important
   // that MemoryBuffer and data are aligned so PointerIntPair works with them.
   // TODO: Is 16-byte alignment enough?  We copy small object files with large
   // alignment expectations into this buffer.
   SmallString<256> NameBuf;
-  StringRef NameRef = BufferName.toStringRef(NameBuf);
+  std::string_view NameRef = BufferName.tostd::string_view(NameBuf);
   size_t AlignedStringLen = alignTo(sizeof(MemBuffer) + NameRef.size() + 1, 16);
   size_t RealLen = AlignedStringLen + Size + 1;
   char *Mem = static_cast<char*>(operator new(RealLen, std::nothrow));
@@ -300,18 +300,18 @@ WritableMemoryBuffer::getNewUninitMemBuffer(size_t Size, const Twine &BufferName
     return nullptr;
 
   // The name is stored after the class itself.
-  CopyStringRef(Mem + sizeof(MemBuffer), NameRef);
+  CopyStringView(Mem + sizeof(MemBuffer), NameRef);
 
   // The buffer begins after the name and must be aligned.
   char *Buf = Mem + AlignedStringLen;
   Buf[Size] = 0; // Null terminate buffer.
 
-  auto *Ret = new (Mem) MemBuffer(StringRef(Buf, Size), true);
+  auto *Ret = new (Mem) MemBuffer({Buf, Size}, true);
   return std::unique_ptr<WritableMemoryBuffer>(Ret);
 }
 
 std::unique_ptr<WritableMemoryBuffer>
-WritableMemoryBuffer::getNewMemBuffer(size_t Size, const Twine &BufferName) {
+WritableMemoryBuffer::getNewMemBuffer(size_t Size, std::string_view BufferName) {
   auto SB = WritableMemoryBuffer::getNewUninitMemBuffer(Size, BufferName);
   if (!SB)
     return nullptr;
@@ -375,7 +375,7 @@ static bool shouldUseMmap(sys::fs::file_t FD,
 }
 
 static ErrorOr<std::unique_ptr<WriteThroughMemoryBuffer>>
-getReadWriteFile(const Twine &Filename, uint64_t FileSize, uint64_t MapSize,
+getReadWriteFile(std::string_view Filename, uint64_t FileSize, uint64_t MapSize,
                  uint64_t Offset) {
   Expected<sys::fs::file_t> FDOrErr = sys::fs::openNativeFileForReadWrite(
       Filename, sys::fs::CD_OpenExisting, sys::fs::OF_None);
@@ -416,20 +416,20 @@ getReadWriteFile(const Twine &Filename, uint64_t FileSize, uint64_t MapSize,
 }
 
 ErrorOr<std::unique_ptr<WriteThroughMemoryBuffer>>
-WriteThroughMemoryBuffer::getFile(const Twine &Filename, int64_t FileSize) {
+WriteThroughMemoryBuffer::getFile(std::string_view Filename, int64_t FileSize) {
   return getReadWriteFile(Filename, FileSize, FileSize, 0);
 }
 
 /// Map a subrange of the specified file as a WritableMemoryBuffer.
 ErrorOr<std::unique_ptr<WriteThroughMemoryBuffer>>
-WriteThroughMemoryBuffer::getFileSlice(const Twine &Filename, uint64_t MapSize,
+WriteThroughMemoryBuffer::getFileSlice(std::string_view Filename, uint64_t MapSize,
                                        uint64_t Offset) {
   return getReadWriteFile(Filename, -1, MapSize, Offset);
 }
 
 template <typename MB>
 static ErrorOr<std::unique_ptr<MB>>
-getOpenFileImpl(sys::fs::file_t FD, const Twine &Filename, uint64_t FileSize,
+getOpenFileImpl(sys::fs::file_t FD, std::string_view Filename, uint64_t FileSize,
                 uint64_t MapSize, int64_t Offset, bool RequiresNullTerminator,
                 bool IsVolatile) {
   static int PageSize = sys::Process::getPageSizeEstimate();
@@ -493,14 +493,14 @@ getOpenFileImpl(sys::fs::file_t FD, const Twine &Filename, uint64_t FileSize,
 }
 
 ErrorOr<std::unique_ptr<MemoryBuffer>>
-MemoryBuffer::getOpenFile(sys::fs::file_t FD, const Twine &Filename, uint64_t FileSize,
+MemoryBuffer::getOpenFile(sys::fs::file_t FD, std::string_view Filename, uint64_t FileSize,
                           bool RequiresNullTerminator, bool IsVolatile) {
   return getOpenFileImpl<MemoryBuffer>(FD, Filename, FileSize, FileSize, 0,
                          RequiresNullTerminator, IsVolatile);
 }
 
 ErrorOr<std::unique_ptr<MemoryBuffer>>
-MemoryBuffer::getOpenFileSlice(sys::fs::file_t FD, const Twine &Filename, uint64_t MapSize,
+MemoryBuffer::getOpenFileSlice(sys::fs::file_t FD, std::string_view Filename, uint64_t MapSize,
                                int64_t Offset, bool IsVolatile) {
   assert(MapSize != uint64_t(-1));
   return getOpenFileImpl<MemoryBuffer>(FD, Filename, -1, MapSize, Offset, false,
@@ -518,7 +518,7 @@ ErrorOr<std::unique_ptr<MemoryBuffer>> MemoryBuffer::getSTDIN() {
 }
 
 ErrorOr<std::unique_ptr<MemoryBuffer>>
-MemoryBuffer::getFileAsStream(const Twine &Filename) {
+MemoryBuffer::getFileAsStream(const std::string_view &Filename) {
   Expected<sys::fs::file_t> FDOrErr =
       sys::fs::openNativeFileForRead(Filename, sys::fs::OF_None);
   if (!FDOrErr)
@@ -531,8 +531,8 @@ MemoryBuffer::getFileAsStream(const Twine &Filename) {
 }
 
 MemoryBufferRef MemoryBuffer::getMemBufferRef() const {
-  StringRef Data = getBuffer();
-  StringRef Identifier = getBufferIdentifier();
+  std::string_view Data = getBuffer();
+  std::string_view Identifier = getBufferIdentifier();
   return MemoryBufferRef(Data, Identifier);
 }
 
diff --git a/llvm/lib/Support/StringMap.cpp b/llvm/lib/Support/StringMap.cpp
index f65d3846623c..d9eeba619428 100644
--- a/llvm/lib/Support/StringMap.cpp
+++ b/llvm/lib/Support/StringMap.cpp
@@ -71,7 +71,7 @@ void StringMapImpl::init(unsigned InitSize) {
 /// specified bucket will be non-null.  Otherwise, it will be null.  In either
 /// case, the FullHashValue field of the bucket will be set to the hash value
 /// of the string.
-unsigned StringMapImpl::LookupBucketFor(StringRef Name) {
+unsigned StringMapImpl::LookupBucketFor(std::string_view Name) {
   unsigned HTSize = NumBuckets;
   if (HTSize == 0) { // Hash table unallocated so far?
     init(16);
@@ -111,7 +111,7 @@ unsigned StringMapImpl::LookupBucketFor(StringRef Name) {
       // Do the comparison like this because Name isn't necessarily
       // null-terminated!
       char *ItemStr = (char *)BucketItem + ItemSize;
-      if (Name == StringRef(ItemStr, BucketItem->getKeyLength())) {
+      if (Name == std::string_view(ItemStr, BucketItem->getKeyLength())) {
         // We found a match!
         return BucketNo;
       }
@@ -129,7 +129,7 @@ unsigned StringMapImpl::LookupBucketFor(StringRef Name) {
 /// FindKey - Look up the bucket that contains the specified key. If it exists
 /// in the map, return the bucket number of the key.  Otherwise return -1.
 /// This does not modify the map.
-int StringMapImpl::FindKey(StringRef Key) const {
+int StringMapImpl::FindKey(std::string_view Key) const {
   unsigned HTSize = NumBuckets;
   if (HTSize == 0)
     return -1; // Really empty table?
@@ -155,7 +155,7 @@ int StringMapImpl::FindKey(StringRef Key) const {
       // Do the comparison like this because NameStart isn't necessarily
       // null-terminated!
       char *ItemStr = (char *)BucketItem + ItemSize;
-      if (Key == StringRef(ItemStr, BucketItem->getKeyLength())) {
+      if (Key == std::string_view(ItemStr, BucketItem->getKeyLength())) {
         // We found a match!
         return BucketNo;
       }
@@ -174,14 +174,14 @@ int StringMapImpl::FindKey(StringRef Key) const {
 /// delete it.  This aborts if the value isn't in the table.
 void StringMapImpl::RemoveKey(StringMapEntryBase *V) {
   const char *VStr = (char *)V + ItemSize;
-  StringMapEntryBase *V2 = RemoveKey(StringRef(VStr, V->getKeyLength()));
+  StringMapEntryBase *V2 = RemoveKey(std::string_view(VStr, V->getKeyLength()));
   (void)V2;
   assert(V == V2 && "Didn't find key?");
 }
 
 /// RemoveKey - Remove the StringMapEntry for the specified key from the
 /// table, returning it.  If the key is not in the table, this returns null.
-StringMapEntryBase *StringMapImpl::RemoveKey(StringRef Key) {
+StringMapEntryBase *StringMapImpl::RemoveKey(std::string_view Key) {
   int Bucket = FindKey(Key);
   if (Bucket == -1)
     return nullptr;
diff --git a/llvm/lib/Support/raw_ostream.cpp b/llvm/lib/Support/raw_ostream.cpp
index f2d78d773239..a2f332cd9664 100644
--- a/llvm/lib/Support/raw_ostream.cpp
+++ b/llvm/lib/Support/raw_ostream.cpp
@@ -162,7 +162,7 @@ raw_ostream &raw_ostream::write_uuid(const uuid_t UUID) {
 }
 
 
-raw_ostream &raw_ostream::write_escaped(StringRef Str,
+raw_ostream &raw_ostream::write_escaped(std::string_view Str,
                                         bool UseHexEscapes) {
   for (unsigned char c : Str) {
     switch (c) {
@@ -566,7 +566,7 @@ void format_object_base::home() {
 //  raw_fd_ostream
 //===----------------------------------------------------------------------===//
 
-static int getFD(StringRef Filename, std::error_code &EC,
+static int getFD(std::string_view Filename, std::error_code &EC,
                  sys::fs::CreationDisposition Disp, sys::fs::FileAccess Access,
                  sys::fs::OpenFlags Flags) {
   assert((Access & sys::fs::FA_Write) &&
@@ -594,25 +594,25 @@ static int getFD(StringRef Filename, std::error_code &EC,
   return FD;
 }
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC)
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC)
     : raw_fd_ostream(Filename, EC, sys::fs::CD_CreateAlways, sys::fs::FA_Write,
                      sys::fs::OF_None) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::CreationDisposition Disp)
     : raw_fd_ostream(Filename, EC, Disp, sys::fs::FA_Write, sys::fs::OF_None) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::FileAccess Access)
     : raw_fd_ostream(Filename, EC, sys::fs::CD_CreateAlways, Access,
                      sys::fs::OF_None) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::OpenFlags Flags)
     : raw_fd_ostream(Filename, EC, sys::fs::CD_CreateAlways, sys::fs::FA_Write,
                      Flags) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::CreationDisposition Disp,
                                sys::fs::FileAccess Access,
                                sys::fs::OpenFlags Flags)
@@ -744,7 +744,7 @@ void raw_fd_ostream::write_impl(const char *Ptr, size_t Size) {
   // If this is a Windows console device, try re-encoding from UTF-8 to UTF-16
   // and using WriteConsoleW. If that fails, fall back to plain write().
   if (IsWindowsConsole)
-    if (write_console_impl(FD, StringRef(Ptr, Size)))
+    if (write_console_impl(FD, std::string_view(Ptr, Size)))
       return;
 #endif
 
diff --git a/llvm/unittests/ADT/DenseMapTest.cpp b/llvm/unittests/ADT/DenseMapTest.cpp
index 9cd974f5bac3..4e38bce4e64d 100644
--- a/llvm/unittests/ADT/DenseMapTest.cpp
+++ b/llvm/unittests/ADT/DenseMapTest.cpp
@@ -481,9 +481,9 @@ TEST(DenseMapCustomTest, ReserveTest) {
   }
 }
 
-// Make sure DenseMap works with StringRef keys.
-TEST(DenseMapCustomTest, StringRefTest) {
-  DenseMap<StringRef, int> M;
+// Make sure DenseMap works with std::string_view keys.
+TEST(DenseMapCustomTest, StringViewTest) {
+  DenseMap<std::string_view, int> M;
 
   M["a"] = 1;
   M["b"] = 2;
@@ -498,12 +498,12 @@ TEST(DenseMapCustomTest, StringRefTest) {
 
   // Test the empty string, spelled various ways.
   EXPECT_EQ(0, M.lookup(""));
-  EXPECT_EQ(0, M.lookup(StringRef()));
-  EXPECT_EQ(0, M.lookup(StringRef("a", 0)));
+  EXPECT_EQ(0, M.lookup(std::string_view()));
+  EXPECT_EQ(0, M.lookup(std::string_view("a", 0)));
   M[""] = 42;
   EXPECT_EQ(42, M.lookup(""));
-  EXPECT_EQ(42, M.lookup(StringRef()));
-  EXPECT_EQ(42, M.lookup(StringRef("a", 0)));
+  EXPECT_EQ(42, M.lookup(std::string_view()));
+  EXPECT_EQ(42, M.lookup(std::string_view("a", 0)));
 }
 
 // Key traits that allows lookup with either an unsigned or char* key;
diff --git a/llvm/unittests/ADT/FunctionExtrasTest.cpp b/llvm/unittests/ADT/FunctionExtrasTest.cpp
index 2ae0d1813858..6213c782171e 100644
--- a/llvm/unittests/ADT/FunctionExtrasTest.cpp
+++ b/llvm/unittests/ADT/FunctionExtrasTest.cpp
@@ -249,14 +249,14 @@ TEST(UniqueFunctionTest, Const) {
 
   // Overloaded call operator correctly resolved.
   struct ChooseCorrectOverload {
-    StringRef operator()() { return "non-const"; }
-    StringRef operator()() const { return "const"; }
+    std::string_view operator()() { return "non-const"; }
+    std::string_view operator()() const { return "const"; }
   };
-  unique_function<StringRef()> ChooseMutable = ChooseCorrectOverload();
+  unique_function<std::string_view()> ChooseMutable = ChooseCorrectOverload();
   ChooseCorrectOverload A;
   EXPECT_EQ("non-const", ChooseMutable());
   EXPECT_EQ("non-const", A());
-  unique_function<StringRef() const> ChooseConst = ChooseCorrectOverload();
+  unique_function<std::string_view() const> ChooseConst = ChooseCorrectOverload();
   const ChooseCorrectOverload &X = A;
   EXPECT_EQ("const", ChooseConst());
   EXPECT_EQ("const", X());
diff --git a/llvm/unittests/ADT/HashingTest.cpp b/llvm/unittests/ADT/HashingTest.cpp
index 66d63d437a46..2157754261e3 100644
--- a/llvm/unittests/ADT/HashingTest.cpp
+++ b/llvm/unittests/ADT/HashingTest.cpp
@@ -265,7 +265,7 @@ TEST(HashingTest, HashCombineRangeGoldenTest) {
 #endif
   };
   for (unsigned i = 0; i < sizeof(golden_data)/sizeof(*golden_data); ++i) {
-    StringRef str = golden_data[i].s;
+    std::string_view str = golden_data[i].s;
     hash_code hash = hash_combine_range(str.begin(), str.end());
 #if 0 // Enable this to generate paste-able text for the above structure.
     std::string member_str = "\"" + str.str() + "\",";
diff --git a/llvm/unittests/ADT/SmallStringTest.cpp b/llvm/unittests/ADT/SmallStringTest.cpp
index e78da9fe5289..af37122064cf 100644
--- a/llvm/unittests/ADT/SmallStringTest.cpp
+++ b/llvm/unittests/ADT/SmallStringTest.cpp
@@ -50,21 +50,21 @@ TEST_F(SmallStringTest, AssignRepeated) {
 }
 
 TEST_F(SmallStringTest, AssignIterPair) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   theString.assign(abc.begin(), abc.end());
   EXPECT_EQ(3u, theString.size());
   EXPECT_STREQ("abc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AssignStringRef) {
-  StringRef abc = "abc";
+TEST_F(SmallStringTest, AssignStringView) {
+  std::string_view abc = "abc";
   theString.assign(abc);
   EXPECT_EQ(3u, theString.size());
   EXPECT_STREQ("abc", theString.c_str());
 }
 
 TEST_F(SmallStringTest, AssignSmallVector) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   SmallVector<char, 10> abcVec(abc.begin(), abc.end());
   theString.assign(abcVec);
   EXPECT_EQ(3u, theString.size());
@@ -72,15 +72,15 @@ TEST_F(SmallStringTest, AssignSmallVector) {
 }
 
 TEST_F(SmallStringTest, AppendIterPair) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   theString.append(abc.begin(), abc.end());
   theString.append(abc.begin(), abc.end());
   EXPECT_EQ(6u, theString.size());
   EXPECT_STREQ("abcabc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AppendStringRef) {
-  StringRef abc = "abc";
+TEST_F(SmallStringTest, AppendStringView) {
+  std::string_view abc = "abc";
   theString.append(abc);
   theString.append(abc);
   EXPECT_EQ(6u, theString.size());
@@ -88,7 +88,7 @@ TEST_F(SmallStringTest, AppendStringRef) {
 }
 
 TEST_F(SmallStringTest, AppendSmallVector) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   SmallVector<char, 10> abcVec(abc.begin(), abc.end());
   theString.append(abcVec);
   theString.append(abcVec);
@@ -96,63 +96,32 @@ TEST_F(SmallStringTest, AppendSmallVector) {
   EXPECT_STREQ("abcabc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, StringRefConversion) {
-  StringRef abc = "abc";
-  theString.assign(abc.begin(), abc.end());
-  StringRef theStringRef = theString;
-  EXPECT_EQ("abc", theStringRef);
-}
-
-TEST_F(SmallStringTest, StdStringConversion) {
-  StringRef abc = "abc";
-  theString.assign(abc.begin(), abc.end());
-  std::string theStdString = std::string(theString);
-  EXPECT_EQ("abc", theStdString);
-}
-
-TEST_F(SmallStringTest, Substr) {
-  theString = "hello";
-  EXPECT_EQ("lo", theString.substr(3));
-  EXPECT_EQ("", theString.substr(100));
-  EXPECT_EQ("hello", theString.substr(0, 100));
-  EXPECT_EQ("o", theString.substr(4, 10));
-}
-
-TEST_F(SmallStringTest, Slice) {
-  theString = "hello";
-  EXPECT_EQ("l", theString.slice(2, 3));
-  EXPECT_EQ("ell", theString.slice(1, 4));
-  EXPECT_EQ("llo", theString.slice(2, 100));
-  EXPECT_EQ("", theString.slice(2, 1));
-  EXPECT_EQ("", theString.slice(10, 20));
-}
-
 TEST_F(SmallStringTest, Find) {
   theString = "hello";
   EXPECT_EQ(2U, theString.find('l'));
-  EXPECT_EQ(StringRef::npos, theString.find('z'));
-  EXPECT_EQ(StringRef::npos, theString.find("helloworld"));
+  EXPECT_EQ(std::string_view::npos, theString.find('z'));
+  EXPECT_EQ(std::string_view::npos, theString.find("helloworld"));
   EXPECT_EQ(0U, theString.find("hello"));
   EXPECT_EQ(1U, theString.find("ello"));
-  EXPECT_EQ(StringRef::npos, theString.find("zz"));
+  EXPECT_EQ(std::string_view::npos, theString.find("zz"));
   EXPECT_EQ(2U, theString.find("ll", 2));
-  EXPECT_EQ(StringRef::npos, theString.find("ll", 3));
+  EXPECT_EQ(std::string_view::npos, theString.find("ll", 3));
   EXPECT_EQ(0U, theString.find(""));
 
   EXPECT_EQ(3U, theString.rfind('l'));
-  EXPECT_EQ(StringRef::npos, theString.rfind('z'));
-  EXPECT_EQ(StringRef::npos, theString.rfind("helloworld"));
+  EXPECT_EQ(std::string_view::npos, theString.rfind('z'));
+  EXPECT_EQ(std::string_view::npos, theString.rfind("helloworld"));
   EXPECT_EQ(0U, theString.rfind("hello"));
   EXPECT_EQ(1U, theString.rfind("ello"));
-  EXPECT_EQ(StringRef::npos, theString.rfind("zz"));
+  EXPECT_EQ(std::string_view::npos, theString.rfind("zz"));
 
   EXPECT_EQ(2U, theString.find_first_of('l'));
   EXPECT_EQ(1U, theString.find_first_of("el"));
-  EXPECT_EQ(StringRef::npos, theString.find_first_of("xyz"));
+  EXPECT_EQ(std::string_view::npos, theString.find_first_of("xyz"));
 
   EXPECT_EQ(1U, theString.find_first_not_of('h'));
   EXPECT_EQ(4U, theString.find_first_not_of("hel"));
-  EXPECT_EQ(StringRef::npos, theString.find_first_not_of("hello"));
+  EXPECT_EQ(std::string_view::npos, theString.find_first_not_of("hello"));
 
   theString = "hellx xello hell ello world foo bar hello";
   EXPECT_EQ(36U, theString.find("hello"));
@@ -161,68 +130,4 @@ TEST_F(SmallStringTest, Find) {
   EXPECT_EQ(0U, theString.find(""));
 }
 
-TEST_F(SmallStringTest, Count) {
-  theString = "hello";
-  EXPECT_EQ(2U, theString.count('l'));
-  EXPECT_EQ(1U, theString.count('o'));
-  EXPECT_EQ(0U, theString.count('z'));
-  EXPECT_EQ(0U, theString.count("helloworld"));
-  EXPECT_EQ(1U, theString.count("hello"));
-  EXPECT_EQ(1U, theString.count("ello"));
-  EXPECT_EQ(0U, theString.count("zz"));
-}
-
-TEST_F(SmallStringTest, Realloc) {
-  theString = "abcd";
-  theString.reserve(100);
-  EXPECT_EQ("abcd", theString);
-  unsigned const N = 100000;
-  theString.reserve(N);
-  for (unsigned i = 0; i < N - 4; ++i)
-    theString.push_back('y');
-  EXPECT_EQ("abcdyyy", theString.slice(0, 7));
-}
-
-TEST_F(SmallStringTest, Comparisons) {
-  EXPECT_EQ(-1, SmallString<10>("aab").compare("aad"));
-  EXPECT_EQ( 0, SmallString<10>("aab").compare("aab"));
-  EXPECT_EQ( 1, SmallString<10>("aab").compare("aaa"));
-  EXPECT_EQ(-1, SmallString<10>("aab").compare("aabb"));
-  EXPECT_EQ( 1, SmallString<10>("aab").compare("aa"));
-  EXPECT_EQ( 1, SmallString<10>("\xFF").compare("\1"));
-
-  EXPECT_EQ(-1, SmallString<10>("AaB").compare_lower("aAd"));
-  EXPECT_EQ( 0, SmallString<10>("AaB").compare_lower("aab"));
-  EXPECT_EQ( 1, SmallString<10>("AaB").compare_lower("AAA"));
-  EXPECT_EQ(-1, SmallString<10>("AaB").compare_lower("aaBb"));
-  EXPECT_EQ( 1, SmallString<10>("AaB").compare_lower("aA"));
-  EXPECT_EQ( 1, SmallString<10>("\xFF").compare_lower("\1"));
-
-  EXPECT_EQ(-1, SmallString<10>("aab").compare_numeric("aad"));
-  EXPECT_EQ( 0, SmallString<10>("aab").compare_numeric("aab"));
-  EXPECT_EQ( 1, SmallString<10>("aab").compare_numeric("aaa"));
-  EXPECT_EQ(-1, SmallString<10>("aab").compare_numeric("aabb"));
-  EXPECT_EQ( 1, SmallString<10>("aab").compare_numeric("aa"));
-  EXPECT_EQ(-1, SmallString<10>("1").compare_numeric("10"));
-  EXPECT_EQ( 0, SmallString<10>("10").compare_numeric("10"));
-  EXPECT_EQ( 0, SmallString<10>("10a").compare_numeric("10a"));
-  EXPECT_EQ( 1, SmallString<10>("2").compare_numeric("1"));
-  EXPECT_EQ( 0, SmallString<10>("llvm_v1i64_ty").compare_numeric("llvm_v1i64_ty"));
-  EXPECT_EQ( 1, SmallString<10>("\xFF").compare_numeric("\1"));
-  EXPECT_EQ( 1, SmallString<10>("V16").compare_numeric("V1_q0"));
-  EXPECT_EQ(-1, SmallString<10>("V1_q0").compare_numeric("V16"));
-  EXPECT_EQ(-1, SmallString<10>("V8_q0").compare_numeric("V16"));
-  EXPECT_EQ( 1, SmallString<10>("V16").compare_numeric("V8_q0"));
-  EXPECT_EQ(-1, SmallString<10>("V1_q0").compare_numeric("V8_q0"));
-  EXPECT_EQ( 1, SmallString<10>("V8_q0").compare_numeric("V1_q0"));
-}
-
-// Check gtest prints SmallString as a string instead of a container of chars.
-// The code is in utils/unittest/googletest/internal/custom/gtest-printers.h
-TEST_F(SmallStringTest, GTestPrinter) {
-  EXPECT_EQ(R"("foo")", ::testing::PrintToString(SmallString<1>("foo")));
-  const SmallVectorImpl<char> &ErasedSmallString = SmallString<1>("foo");
-  EXPECT_EQ(R"("foo")", ::testing::PrintToString(ErasedSmallString));
-}
-
 } // namespace
diff --git a/llvm/unittests/ADT/SmallVectorTest.cpp b/llvm/unittests/ADT/SmallVectorTest.cpp
index dbe404869e2c..61682b50dea2 100644
--- a/llvm/unittests/ADT/SmallVectorTest.cpp
+++ b/llvm/unittests/ADT/SmallVectorTest.cpp
@@ -11,7 +11,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/span.h"
 #include "llvm/Support/Compiler.h"
 #include "gtest/gtest.h"
 #include <list>
@@ -982,22 +982,4 @@ TEST(SmallVectorTest, EmplaceBack) {
   }
 }
 
-TEST(SmallVectorTest, InitializerList) {
-  SmallVector<int, 2> V1 = {};
-  EXPECT_TRUE(V1.empty());
-  V1 = {0, 0};
-  EXPECT_TRUE(makeArrayRef(V1).equals({0, 0}));
-  V1 = {-1, -1};
-  EXPECT_TRUE(makeArrayRef(V1).equals({-1, -1}));
-
-  SmallVector<int, 2> V2 = {1, 2, 3, 4};
-  EXPECT_TRUE(makeArrayRef(V2).equals({1, 2, 3, 4}));
-  V2.assign({4});
-  EXPECT_TRUE(makeArrayRef(V2).equals({4}));
-  V2.append({3, 2});
-  EXPECT_TRUE(makeArrayRef(V2).equals({4, 3, 2}));
-  V2.insert(V2.begin() + 1, 5);
-  EXPECT_TRUE(makeArrayRef(V2).equals({4, 5, 3, 2}));
-}
-
 } // end namespace
diff --git a/llvm/unittests/ADT/StringMapTest.cpp b/llvm/unittests/ADT/StringMapTest.cpp
index bda3d4ff9679..b2d38baff568 100644
--- a/llvm/unittests/ADT/StringMapTest.cpp
+++ b/llvm/unittests/ADT/StringMapTest.cpp
@@ -7,7 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/ADT/StringMap.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Support/DataTypes.h"
 #include "gtest/gtest.h"
 #include <limits>
@@ -37,10 +36,10 @@ protected:
 
     // Lookup tests
     EXPECT_EQ(0u, testMap.count(testKey));
-    EXPECT_EQ(0u, testMap.count(StringRef(testKeyFirst, testKeyLength)));
+    EXPECT_EQ(0u, testMap.count(std::string_view(testKeyFirst, testKeyLength)));
     EXPECT_EQ(0u, testMap.count(testKeyStr));
     EXPECT_TRUE(testMap.find(testKey) == testMap.end());
-    EXPECT_TRUE(testMap.find(StringRef(testKeyFirst, testKeyLength)) == 
+    EXPECT_TRUE(testMap.find(std::string_view(testKeyFirst, testKeyLength)) == 
                 testMap.end());
     EXPECT_TRUE(testMap.find(testKeyStr) == testMap.end());
   }
@@ -60,10 +59,10 @@ protected:
 
     // Lookup tests
     EXPECT_EQ(1u, testMap.count(testKey));
-    EXPECT_EQ(1u, testMap.count(StringRef(testKeyFirst, testKeyLength)));
+    EXPECT_EQ(1u, testMap.count(std::string_view(testKeyFirst, testKeyLength)));
     EXPECT_EQ(1u, testMap.count(testKeyStr));
     EXPECT_TRUE(testMap.find(testKey) == testMap.begin());
-    EXPECT_TRUE(testMap.find(StringRef(testKeyFirst, testKeyLength)) == 
+    EXPECT_TRUE(testMap.find(std::string_view(testKeyFirst, testKeyLength)) == 
                 testMap.begin());
     EXPECT_TRUE(testMap.find(testKeyStr) == testMap.begin());
   }
@@ -103,10 +102,10 @@ TEST_F(StringMapTest, ConstEmptyMapTest) {
 
   // Lookup tests
   EXPECT_EQ(0u, constTestMap.count(testKey));
-  EXPECT_EQ(0u, constTestMap.count(StringRef(testKeyFirst, testKeyLength)));
+  EXPECT_EQ(0u, constTestMap.count(std::string_view(testKeyFirst, testKeyLength)));
   EXPECT_EQ(0u, constTestMap.count(testKeyStr));
   EXPECT_TRUE(constTestMap.find(testKey) == constTestMap.end());
-  EXPECT_TRUE(constTestMap.find(StringRef(testKeyFirst, testKeyLength)) ==
+  EXPECT_TRUE(constTestMap.find(std::string_view(testKeyFirst, testKeyLength)) ==
               constTestMap.end());
   EXPECT_TRUE(constTestMap.find(testKeyStr) == constTestMap.end());
 }
@@ -226,7 +225,7 @@ TEST_F(StringMapTest, IterationTest) {
 TEST_F(StringMapTest, StringMapEntryTest) {
   StringMap<uint32_t>::value_type *entry =
       StringMap<uint32_t>::value_type::Create(
-          StringRef(testKeyFirst, testKeyLength), Allocator, 1u);
+          std::string_view(testKeyFirst, testKeyLength), 1u);
   EXPECT_STREQ(testKey, entry->first().data());
   EXPECT_EQ(1u, entry->second);
   entry->Destroy();
@@ -237,7 +236,7 @@ TEST_F(StringMapTest, InsertTest) {
   SCOPED_TRACE("InsertTest");
   testMap.insert(
       StringMap<uint32_t>::value_type::Create(
-          StringRef(testKeyFirst, testKeyLength),
+          std::string_view(testKeyFirst, testKeyLength),
           testMap.getAllocator(), 1u));
   assertSingleItemMap();
 }
@@ -279,41 +278,6 @@ TEST_F(StringMapTest, InsertRehashingPairTest) {
   EXPECT_EQ(42u, It->second);
 }
 
-TEST_F(StringMapTest, InsertOrAssignTest) {
-  struct A : CountCopyAndMove {
-    A(int v) : v(v) {}
-    int v;
-  };
-  StringMap<A> t(0);
-
-  auto try1 = t.insert_or_assign("A", A(1));
-  EXPECT_TRUE(try1.second);
-  EXPECT_EQ(1, try1.first->second.v);
-  EXPECT_EQ(1, try1.first->second.move);
-
-  auto try2 = t.insert_or_assign("A", A(2));
-  EXPECT_FALSE(try2.second);
-  EXPECT_EQ(2, try2.first->second.v);
-  EXPECT_EQ(2, try1.first->second.move);
-
-  EXPECT_EQ(try1.first, try2.first);
-  EXPECT_EQ(0, try1.first->second.copy);
-}
-
-TEST_F(StringMapTest, IterMapKeys) {
-  StringMap<int> Map;
-  Map["A"] = 1;
-  Map["B"] = 2;
-  Map["C"] = 3;
-  Map["D"] = 3;
-
-  auto Keys = to_vector<4>(Map.keys());
-  llvm::sort(Keys);
-
-  SmallVector<StringRef, 4> Expected = {"A", "B", "C", "D"};
-  EXPECT_EQ(Expected, Keys);
-}
-
 // Create a non-default constructable value
 struct StringMapTestStruct {
   StringMapTestStruct(int i) : i(i) {}
@@ -352,13 +316,13 @@ private:
 TEST_F(StringMapTest, MoveOnly) {
   StringMap<MoveOnly> t;
   t.insert(std::make_pair("Test", MoveOnly(42)));
-  StringRef Key = "Test";
+  std::string_view Key = "Test";
   StringMapEntry<MoveOnly>::Create(Key, MoveOnly(42))
       ->Destroy();
 }
 
 TEST_F(StringMapTest, CtorArg) {
-  StringRef Key = "Test";
+  std::string_view Key = "Test";
   StringMapEntry<MoveOnly>::Create(Key, Immovable())
       ->Destroy();
 }
@@ -532,7 +496,7 @@ TEST(StringMapCustomTest, InitialSizeTest) {
     CountCtorCopyAndMove::Copy = 0;
     for (int i = 0; i < Size; ++i)
       Map.insert(std::pair<std::string, CountCtorCopyAndMove>(
-          std::piecewise_construct, std::forward_as_tuple(Twine(i).str()),
+          std::piecewise_construct, std::forward_as_tuple(std::to_string(i)),
           std::forward_as_tuple(i)));
     // After the initial move, the map will move the Elts in the Entry.
     EXPECT_EQ((unsigned)Size * 2, CountCtorCopyAndMove::Move);
@@ -601,7 +565,7 @@ TEST(StringMapCustomTest, StringMapEntrySize) {
   else
     LargeValue = std::numeric_limits<unsigned>::max() + 1ULL;
   StringMapEntry<int> LargeEntry(LargeValue);
-  StringRef Key = LargeEntry.getKey();
+  std::string_view Key = LargeEntry.getKey();
   EXPECT_EQ(LargeValue, Key.size());
 
   // Test that the entry can hold at least max size_t.
diff --git a/llvm/unittests/Support/ConvertUTFTest.cpp b/llvm/unittests/Support/ConvertUTFTest.cpp
index 83019722332d..6b6507e75d12 100644
--- a/llvm/unittests/Support/ConvertUTFTest.cpp
+++ b/llvm/unittests/Support/ConvertUTFTest.cpp
@@ -7,7 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/Support/ConvertUTF.h"
-#include "llvm/ADT/ArrayRef.h"
 #include "gtest/gtest.h"
 #include <string>
 #include <vector>
@@ -39,7 +38,7 @@ TEST(ConvertUTFTest, ConvertUTF16BigEndianToUTF8String) {
 TEST(ConvertUTFTest, ConvertUTF8ToUTF16String) {
   // Src is the look of disapproval.
   static const char Src[] = "\xe0\xb2\xa0_\xe0\xb2\xa0";
-  StringRef Ref(Src, sizeof(Src) - 1);
+  std::string_view Ref(Src, sizeof(Src) - 1);
   SmallVector<UTF16, 5> Result;
   bool Success = convertUTF8ToUTF16String(Ref, Result);
   EXPECT_TRUE(Success);
@@ -63,18 +62,18 @@ TEST(ConvertUTFTest, Empty) {
 }
 
 TEST(ConvertUTFTest, HasUTF16BOM) {
-  bool HasBOM = hasUTF16ByteOrderMark(makeArrayRef("\xff\xfe", 2));
+  bool HasBOM = hasUTF16ByteOrderMark("\xff\xfe");
   EXPECT_TRUE(HasBOM);
-  HasBOM = hasUTF16ByteOrderMark(makeArrayRef("\xfe\xff", 2));
+  HasBOM = hasUTF16ByteOrderMark("\xfe\xff");
   EXPECT_TRUE(HasBOM);
-  HasBOM = hasUTF16ByteOrderMark(makeArrayRef("\xfe\xff ", 3));
+  HasBOM = hasUTF16ByteOrderMark("\xfe\xff ");
   EXPECT_TRUE(HasBOM); // Don't care about odd lengths.
-  HasBOM = hasUTF16ByteOrderMark(makeArrayRef("\xfe\xff\x00asdf", 6));
+  HasBOM = hasUTF16ByteOrderMark("\xfe\xff\x00asdf");
   EXPECT_TRUE(HasBOM);
 
-  HasBOM = hasUTF16ByteOrderMark(None);
+  HasBOM = hasUTF16ByteOrderMark("");
   EXPECT_FALSE(HasBOM);
-  HasBOM = hasUTF16ByteOrderMark(makeArrayRef("\xfe", 1));
+  HasBOM = hasUTF16ByteOrderMark("\xfe");
   EXPECT_FALSE(HasBOM);
 }
 
@@ -147,7 +146,7 @@ struct ConvertUTFResultContainer {
 };
 
 std::pair<ConversionResult, std::vector<unsigned>>
-ConvertUTF8ToUnicodeScalarsLenient(StringRef S) {
+ConvertUTF8ToUnicodeScalarsLenient(std::string_view S) {
   const UTF8 *SourceStart = reinterpret_cast<const UTF8 *>(S.data());
 
   const UTF8 *SourceNext = SourceStart;
@@ -164,7 +163,7 @@ ConvertUTF8ToUnicodeScalarsLenient(StringRef S) {
 }
 
 std::pair<ConversionResult, std::vector<unsigned>>
-ConvertUTF8ToUnicodeScalarsPartialLenient(StringRef S) {
+ConvertUTF8ToUnicodeScalarsPartialLenient(std::string_view S) {
   const UTF8 *SourceStart = reinterpret_cast<const UTF8 *>(S.data());
 
   const UTF8 *SourceNext = SourceStart;
@@ -182,7 +181,7 @@ ConvertUTF8ToUnicodeScalarsPartialLenient(StringRef S) {
 
 ::testing::AssertionResult
 CheckConvertUTF8ToUnicodeScalars(ConvertUTFResultContainer Expected,
-                                 StringRef S, bool Partial = false) {
+                                 std::string_view S, bool Partial = false) {
   ConversionResult ErrorCode;
   std::vector<unsigned> Decoded;
   if (!Partial)
@@ -277,7 +276,7 @@ TEST(ConvertUTFTest, UTF8ToUTF32Lenient) {
   // U+0000 NULL
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
       ConvertUTFResultContainer(conversionOK).withScalars(0x0000),
-      StringRef("\x00", 1)));
+      std::string_view("\x00", 1)));
 
   // U+0080 PADDING CHARACTER
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
@@ -1051,7 +1050,7 @@ TEST(ConvertUTFTest, UTF8ToUTF32Lenient) {
   // U+0000 NULL
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
       ConvertUTFResultContainer(conversionOK).withScalars(0x0000),
-      StringRef("\x00", 1)));
+      std::string_view("\x00", 1)));
 
   // Overlong sequences of the above.
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
-- 
2.20.1.windows.1

