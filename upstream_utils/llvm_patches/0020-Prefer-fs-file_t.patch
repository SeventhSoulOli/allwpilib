From 154385db292a453a3961c5cc76c5cda869618c9d Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Tue, 3 May 2022 22:58:49 -0400
Subject: [PATCH 20/36] Prefer fs::file_t

---
 llvm/include/llvm/Support/MemoryBuffer.h | 12 ++++++++--
 llvm/include/llvm/Support/raw_ostream.h  |  6 ++---
 llvm/lib/Support/MemoryBuffer.cpp        | 29 +++++++++++-------------
 llvm/lib/Support/raw_ostream.cpp         |  9 +++++---
 4 files changed, 31 insertions(+), 25 deletions(-)

diff --git a/llvm/include/llvm/Support/MemoryBuffer.h b/llvm/include/llvm/Support/MemoryBuffer.h
index 12f301b9d791..918752587424 100644
--- a/llvm/include/llvm/Support/MemoryBuffer.h
+++ b/llvm/include/llvm/Support/MemoryBuffer.h
@@ -13,8 +13,6 @@
 #ifndef LLVM_SUPPORT_MEMORYBUFFER_H
 #define LLVM_SUPPORT_MEMORYBUFFER_H
 
-#include "llvm-c/Types.h"
-#include "llvm/Support/CBindingWrapping.h"
 #include "llvm/Support/ErrorOr.h"
 #include "llvm/Support/MemoryBufferRef.h"
 #include <cstddef>
@@ -22,6 +20,16 @@
 #include <memory>
 #include <string_view>
 
+// Duplicated from fs.h to avoid a dependency
+namespace fs {
+#if defined(_WIN32)
+// A Win32 HANDLE is a typedef of void*
+using file_t = void*;
+#else
+using file_t = int;
+#endif
+}  // namespace fs
+
 namespace llvm {
 namespace sys {
 namespace fs {
diff --git a/llvm/include/llvm/Support/raw_ostream.h b/llvm/include/llvm/Support/raw_ostream.h
index 99ff192edc5c..013367654a70 100644
--- a/llvm/include/llvm/Support/raw_ostream.h
+++ b/llvm/include/llvm/Support/raw_ostream.h
@@ -25,16 +25,14 @@
 #include <system_error>
 #include <type_traits>
 
-namespace llvm {
-
-namespace sys {
 namespace fs {
 enum FileAccess : unsigned;
 enum OpenFlags : unsigned;
 enum CreationDisposition : unsigned;
 class FileLocker;
 } // end namespace fs
-} // end namespace sys
+
+namespace llvm {
 
 /// This class implements an extremely fast bulk output stream that can *only*
 /// output to a stream.  It does not support seeking, reopening, rewinding, line
diff --git a/llvm/lib/Support/MemoryBuffer.cpp b/llvm/lib/Support/MemoryBuffer.cpp
index d0ee3ee9dedf..cbd1cf047815 100644
--- a/llvm/lib/Support/MemoryBuffer.cpp
+++ b/llvm/lib/Support/MemoryBuffer.cpp
@@ -269,11 +269,10 @@ template <typename MB>
 static ErrorOr<std::unique_ptr<MB>>
 getFileAux(std::string_view Filename, int64_t FileSize, uint64_t MapSize,
            uint64_t Offset, bool RequiresNullTerminator, bool IsVolatile) {
-  Expected<sys::fs::file_t> FDOrErr =
-      sys::fs::openNativeFileForRead(Filename, sys::fs::OF_None);
-  if (!FDOrErr)
-    return errorToErrorCode(FDOrErr.takeError());
-  sys::fs::file_t FD = *FDOrErr;
+  std::error_code EC;
+  fs::file_t FD = fs::OpenFileForRead(Filename, EC, fs::OF_None);
+  if (!EC)
+    return EC;
   auto Ret = getOpenFileImpl<MB>(FD, Filename, FileSize, MapSize, Offset,
                                  RequiresNullTerminator, IsVolatile);
   sys::fs::closeFile(FD);
@@ -388,11 +387,11 @@ static bool shouldUseMmap(sys::fs::file_t FD,
 static ErrorOr<std::unique_ptr<WriteThroughMemoryBuffer>>
 getReadWriteFile(std::string_view Filename, uint64_t FileSize, uint64_t MapSize,
                  uint64_t Offset) {
-  Expected<sys::fs::file_t> FDOrErr = sys::fs::openNativeFileForReadWrite(
-      Filename, sys::fs::CD_OpenExisting, sys::fs::OF_None);
-  if (!FDOrErr)
-    return errorToErrorCode(FDOrErr.takeError());
-  sys::fs::file_t FD = *FDOrErr;
+  std::error_code EC;
+  fs::file_t FD = fs::OpenFileForReadWrite(
+      Filename, EC, fs::CD_OpenExisting, fs::OF_None);
+  if (EC)
+    return EC;
 
   // Default is to map the full file.
   if (MapSize == uint64_t(-1)) {
@@ -416,7 +415,6 @@ getReadWriteFile(std::string_view Filename, uint64_t FileSize, uint64_t MapSize,
     MapSize = FileSize;
   }
 
-  std::error_code EC;
   std::unique_ptr<WriteThroughMemoryBuffer> Result(
       new (NamedBufferAlloc(Filename))
           MemoryBufferMMapFile<WriteThroughMemoryBuffer>(false, FD, MapSize,
@@ -530,11 +528,10 @@ ErrorOr<std::unique_ptr<MemoryBuffer>> MemoryBuffer::getSTDIN() {
 
 ErrorOr<std::unique_ptr<MemoryBuffer>>
 MemoryBuffer::getFileAsStream(const std::string_view &Filename) {
-  Expected<sys::fs::file_t> FDOrErr =
-      sys::fs::openNativeFileForRead(Filename, sys::fs::OF_None);
-  if (!FDOrErr)
-    return errorToErrorCode(FDOrErr.takeError());
-  sys::fs::file_t FD = *FDOrErr;
+  std::error_code EC;
+  fs::file_t FD = fs::OpenFileForRead(Filename, EC, fs::OF_None);
+  if (EC)
+    return EC;
   ErrorOr<std::unique_ptr<MemoryBuffer>> Ret =
       getMemoryBufferForStream(FD, Filename);
   sys::fs::closeFile(FD);
diff --git a/llvm/lib/Support/raw_ostream.cpp b/llvm/lib/Support/raw_ostream.cpp
index 3ecae08be081..588dac275b79 100644
--- a/llvm/lib/Support/raw_ostream.cpp
+++ b/llvm/lib/Support/raw_ostream.cpp
@@ -310,11 +310,14 @@ static int getFD(std::string_view Filename, std::error_code &EC,
     return STDOUT_FILENO;
   }
 
-  int FD;
+  fs::file_t FD;
   if (Access & sys::fs::FA_Read)
-    EC = sys::fs::openFileForReadWrite(Filename, FD, Disp, Flags);
+    FD = sys::fs::OpenFileForReadWrite(fs::path{std::string_view{Filename.data(), Filename.size()}}, EC, Disp, Flags);
   else
-    EC = sys::fs::openFileForWrite(Filename, FD, Disp, Flags);
+    FD = sys::fs::OpenFileForWrite(fs::path{std::string_view{Filename.data(), Filename.size()}}, EC, Disp, Flags);
+  if (EC)
+    return -1;
+  int FD = fs::FileToFd(F, EC, Flags);
   if (EC)
     return -1;
 
-- 
2.20.1.windows.1

