From 2eee50cfa40568e5478556b73586b966ed479e5a Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Tue, 3 May 2022 22:16:10 -0400
Subject: [PATCH 16/37] Extra collections features

---
 llvm/include/llvm/ADT/DenseMap.h       |  39 ++++++++++
 llvm/include/llvm/ADT/PointerIntPair.h |   2 +
 llvm/include/llvm/ADT/StringMap.h      | 103 ++++++++++++++++++++++++-
 3 files changed, 143 insertions(+), 1 deletion(-)

diff --git a/llvm/include/llvm/ADT/DenseMap.h b/llvm/include/llvm/ADT/DenseMap.h
index 52cdb4906e3d..bd48c2ed1a0e 100644
--- a/llvm/include/llvm/ADT/DenseMap.h
+++ b/llvm/include/llvm/ADT/DenseMap.h
@@ -627,6 +627,40 @@ public:
   }
 };
 
+/// Equality comparison for DenseMap.
+///
+/// Iterates over elements of LHS confirming that each (key, value) pair in LHS
+/// is also in RHS, and that no additional pairs are in RHS.
+/// Equivalent to N calls to RHS.find and N value comparisons. Amortized
+/// complexity is linear, worst case is O(N^2) (if every hash collides).
+template <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,
+          typename BucketT>
+bool operator==(
+    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,
+    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {
+  if (LHS.size() != RHS.size())
+    return false;
+
+  for (auto &KV : LHS) {
+    auto I = RHS.find(KV.first);
+    if (I == RHS.end() || I->second != KV.second)
+      return false;
+  }
+
+  return true;
+}
+
+/// Inequality comparison for DenseMap.
+///
+/// Equivalent to !(LHS == RHS). See operator== for performance notes.
+template <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,
+          typename BucketT>
+bool operator!=(
+    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,
+    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {
+  return !(LHS == RHS);
+}
+
 template <typename KeyT, typename ValueT,
           typename KeyInfoT = DenseMapInfo<KeyT>,
           typename BucketT = detail::DenseMapPair<KeyT, ValueT>>
@@ -664,6 +698,11 @@ public:
     this->insert(I, E);
   }
 
+  DenseMap(std::initializer_list<typename BaseT::value_type> Vals) {
+    init(Vals.size());
+    this->insert(Vals.begin(), Vals.end());
+  }
+
   ~DenseMap() {
     this->destroyAll();
     operator delete(Buckets);
diff --git a/llvm/include/llvm/ADT/PointerIntPair.h b/llvm/include/llvm/ADT/PointerIntPair.h
index 884d05155bff..6d1b53a90ad2 100644
--- a/llvm/include/llvm/ADT/PointerIntPair.h
+++ b/llvm/include/llvm/ADT/PointerIntPair.h
@@ -42,6 +42,8 @@ template <typename PointerTy, unsigned IntBits, typename IntType = unsigned,
           typename PtrTraits = PointerLikeTypeTraits<PointerTy>,
           typename Info = PointerIntPairInfo<PointerTy, IntBits, PtrTraits>>
 class PointerIntPair {
+  // Used by MSVC visualizer and generally helpful for debugging/visualizing.
+  using InfoTy = Info;
   intptr_t Value = 0;
 
 public:
diff --git a/llvm/include/llvm/ADT/StringMap.h b/llvm/include/llvm/ADT/StringMap.h
index 7d939f007279..df9f3da888da 100644
--- a/llvm/include/llvm/ADT/StringMap.h
+++ b/llvm/include/llvm/ADT/StringMap.h
@@ -61,7 +61,7 @@ protected:
 protected:
   explicit StringMapImpl(unsigned itemSize)
       : ItemSize(itemSize) {}
-  StringMapImpl(StringMapImpl &&RHS)
+  StringMapImpl(StringMapImpl &&RHS) noexcept
       : TheTable(RHS.TheTable), NumBuckets(RHS.NumBuckets),
         NumItems(RHS.NumItems), NumTombstones(RHS.NumTombstones),
         ItemSize(RHS.ItemSize) {
@@ -450,11 +450,27 @@ public:
     return Tmp;
   }
 
+  DerivedTy &operator--() { // Predecrement
+    --Ptr;
+    ReversePastEmptyBuckets();
+    return static_cast<DerivedTy &>(*this);
+  }
+
+  DerivedTy operator--(int) { // Post-decrement
+    DerivedTy Tmp(Ptr);
+    --*this;
+    return Tmp;
+  }
+
 private:
   void AdvancePastEmptyBuckets() {
     while (*Ptr == nullptr || *Ptr == StringMapImpl::getTombstoneVal())
       ++Ptr;
   }
+  void ReversePastEmptyBuckets() {
+    while (*Ptr == nullptr || *Ptr == StringMapImpl::getTombstoneVal())
+      --Ptr;
+  }
 };
 
 template <typename ValueTy>
@@ -519,6 +535,91 @@ private:
   std::string_view Key;
 };
 
+template <typename ValueTy>
+bool operator==(const StringMap<ValueTy>& lhs, const StringMap<ValueTy>& rhs) {
+  // same instance?
+  if (&lhs == &rhs) return true;
+
+  // first check that sizes are identical
+  if (lhs.size() != rhs.size()) return false;
+
+  // copy into vectors and sort by key
+  SmallVector<StringMapConstIterator<ValueTy>, 16> lhs_items;
+  lhs_items.reserve(lhs.size());
+  for (auto i = lhs.begin(), end = lhs.end(); i != end; ++i)
+    lhs_items.push_back(i);
+  std::sort(lhs_items.begin(), lhs_items.end(),
+            [](const StringMapConstIterator<ValueTy>& a,
+               const StringMapConstIterator<ValueTy>& b) {
+              return a->getKey() < b->getKey();
+            });
+
+  SmallVector<StringMapConstIterator<ValueTy>, 16> rhs_items;
+  rhs_items.reserve(rhs.size());
+  for (auto i = rhs.begin(), end = rhs.end(); i != end; ++i)
+    rhs_items.push_back(i);
+  std::sort(rhs_items.begin(), rhs_items.end(),
+            [](const StringMapConstIterator<ValueTy>& a,
+               const StringMapConstIterator<ValueTy>& b) {
+              return a->getKey() < b->getKey();
+            });
+
+  // compare vector keys and values
+  for (auto a = lhs_items.begin(), b = rhs_items.begin(),
+            aend = lhs_items.end(), bend = rhs_items.end();
+       a != aend && b != bend; ++a, ++b) {
+    if ((*a)->first() != (*b)->first() || (*a)->second != (*b)->second)
+      return false;
+  }
+  return true;
+}
+
+template <typename ValueTy>
+inline bool operator!=(const StringMap<ValueTy>& lhs,
+                       const StringMap<ValueTy>& rhs) {
+  return !(lhs == rhs);
+}
+
+template <typename ValueTy>
+bool operator<(const StringMap<ValueTy>& lhs, const StringMap<ValueTy>& rhs) {
+  // same instance?
+  if (&lhs == &rhs) return false;
+
+  // copy into vectors and sort by key
+  SmallVector<std::string_view, 16> lhs_keys;
+  lhs_keys.reserve(lhs.size());
+  for (auto i = lhs.begin(), end = lhs.end(); i != end; ++i)
+    lhs_keys.push_back(i->getKey());
+  std::sort(lhs_keys.begin(), lhs_keys.end());
+
+  SmallVector<std::string_view, 16> rhs_keys;
+  rhs_keys.reserve(rhs.size());
+  for (auto i = rhs.begin(), end = rhs.end(); i != end; ++i)
+    rhs_keys.push_back(i->getKey());
+  std::sort(rhs_keys.begin(), rhs_keys.end());
+
+  // use std::vector comparison
+  return lhs_keys < rhs_keys;
+}
+
+template <typename ValueTy>
+inline bool operator<=(const StringMap<ValueTy>& lhs,
+                       const StringMap<ValueTy>& rhs) {
+  return !(rhs < lhs);
+}
+
+template <typename ValueTy>
+inline bool operator>(const StringMap<ValueTy>& lhs,
+                      const StringMap<ValueTy>& rhs) {
+  return !(lhs <= rhs);
+}
+
+template <typename ValueTy>
+inline bool operator>=(const StringMap<ValueTy>& lhs,
+                       const StringMap<ValueTy>& rhs) {
+  return !(lhs < rhs);
+}
+
 } // end namespace llvm
 
 #endif // LLVM_ADT_STRINGMAP_H
-- 
2.20.1.windows.1

