From ab4a1f1e931e3ccd343070ca4cd96113d7562485 Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Tue, 3 May 2022 20:36:15 -0400
Subject: [PATCH 07/37] Safe #define guards in Compiler.h

---
 llvm/include/llvm/Support/Compiler.h    | 56 +++++++++++++++++++++++++
 llvm/include/llvm/Support/type_traits.h |  3 ++
 2 files changed, 59 insertions(+)

diff --git a/llvm/include/llvm/Support/Compiler.h b/llvm/include/llvm/Support/Compiler.h
index c90f8dd77417..a30c594a2afd 100644
--- a/llvm/include/llvm/Support/Compiler.h
+++ b/llvm/include/llvm/Support/Compiler.h
@@ -64,6 +64,7 @@
 /// Is the compiler MSVC of at least the specified version?
 /// The common \param version values to check for are:
 ///  * 1900: Microsoft Visual Studio 2015 / 14.0
+#ifndef LLVM_MSC_PREREQ
 #ifdef _MSC_VER
 #define LLVM_MSC_PREREQ(version) (_MSC_VER >= (version))
 
@@ -75,26 +76,31 @@
 #else
 #define LLVM_MSC_PREREQ(version) 0
 #endif
+#endif
 
 /// Does the compiler support ref-qualifiers for *this?
 ///
 /// Sadly, this is separate from just rvalue reference support because GCC
 /// and MSVC implemented this later than everything else.
+#ifndef LLVM_HAS_RVALUE_REFERENCE_THIS
 #if __has_feature(cxx_rvalue_references) || LLVM_GNUC_PREREQ(4, 8, 1)
 #define LLVM_HAS_RVALUE_REFERENCE_THIS 1
 #else
 #define LLVM_HAS_RVALUE_REFERENCE_THIS 0
 #endif
+#endif
 
 /// Expands to '&' if ref-qualifiers for *this are supported.
 ///
 /// This can be used to provide lvalue/rvalue overrides of member functions.
 /// The rvalue override should be guarded by LLVM_HAS_RVALUE_REFERENCE_THIS
+#ifndef LLVM_LVALUE_FUNCTION
 #if LLVM_HAS_RVALUE_REFERENCE_THIS
 #define LLVM_LVALUE_FUNCTION &
 #else
 #define LLVM_LVALUE_FUNCTION
 #endif
+#endif
 
 /// LLVM_LIBRARY_VISIBILITY - If a class marked with this attribute is linked
 /// into a shared library, then the class should be private to the library and
@@ -108,19 +114,24 @@
 #define LLVM_LIBRARY_VISIBILITY
 #endif
 
+#ifndef LLVM_PREFETCH
 #if defined(__GNUC__)
 #define LLVM_PREFETCH(addr, rw, locality) __builtin_prefetch(addr, rw, locality)
 #else
 #define LLVM_PREFETCH(addr, rw, locality)
 #endif
+#endif
 
+#ifndef LLVM_ATTRIBUTE_USED
 #if __has_attribute(used) || LLVM_GNUC_PREREQ(3, 1, 0)
 #define LLVM_ATTRIBUTE_USED __attribute__((__used__))
 #else
 #define LLVM_ATTRIBUTE_USED
 #endif
+#endif
 
 /// LLVM_NODISCARD - Warn if a type or return value is discarded.
+#ifndef LLVM_NODISCARD
 #if __cplusplus > 201402L && __has_cpp_attribute(nodiscard)
 #define LLVM_NODISCARD [[nodiscard]]
 #elif !__cplusplus
@@ -132,6 +143,7 @@
 #else
 #define LLVM_NODISCARD
 #endif
+#endif
 
 // Some compilers warn about unused functions. When a function is sometimes
 // used or not depending on build settings (e.g. a function only called from
@@ -141,11 +153,13 @@
 // more portable solution:
 //   (void)unused_var_name;
 // Prefer cast-to-void wherever it is sufficient.
+#ifndef LLVM_ATTRIBUTE_UNUSED
 #if __has_attribute(unused) || LLVM_GNUC_PREREQ(3, 1, 0)
 #define LLVM_ATTRIBUTE_UNUSED __attribute__((__unused__))
 #else
 #define LLVM_ATTRIBUTE_UNUSED
 #endif
+#endif
 
 // FIXME: Provide this for PE/COFF targets.
 #if (__has_attribute(weak) || LLVM_GNUC_PREREQ(4, 0, 0)) &&                    \
@@ -155,6 +169,7 @@
 #define LLVM_ATTRIBUTE_WEAK
 #endif
 
+#ifndef LLVM_READNONE
 // Prior to clang 3.2, clang did not accept any spelling of
 // __has_attribute(const), so assume it is supported.
 #if defined(__clang__) || defined(__GNUC__)
@@ -163,14 +178,18 @@
 #else
 #define LLVM_READNONE
 #endif
+#endif
 
+#ifndef LLVM_READONLY
 #if __has_attribute(pure) || defined(__GNUC__)
 // aka 'PURE' but following LLVM Conventions.
 #define LLVM_READONLY __attribute__((__pure__))
 #else
 #define LLVM_READONLY
 #endif
+#endif
 
+#ifndef LLVM_LIKELY
 #if __has_builtin(__builtin_expect) || LLVM_GNUC_PREREQ(4, 0, 0)
 #define LLVM_LIKELY(EXPR) __builtin_expect((bool)(EXPR), true)
 #define LLVM_UNLIKELY(EXPR) __builtin_expect((bool)(EXPR), false)
@@ -178,9 +197,11 @@
 #define LLVM_LIKELY(EXPR) (EXPR)
 #define LLVM_UNLIKELY(EXPR) (EXPR)
 #endif
+#endif
 
 /// LLVM_ATTRIBUTE_NOINLINE - On compilers where we have a directive to do so,
 /// mark a method "not for inlining".
+#ifndef LLVM_ATTRIBUTE_NOINLINE
 #if __has_attribute(noinline) || LLVM_GNUC_PREREQ(3, 4, 0)
 #define LLVM_ATTRIBUTE_NOINLINE __attribute__((noinline))
 #elif defined(_MSC_VER)
@@ -188,11 +209,13 @@
 #else
 #define LLVM_ATTRIBUTE_NOINLINE
 #endif
+#endif
 
 /// LLVM_ATTRIBUTE_ALWAYS_INLINE - On compilers where we have a directive to do
 /// so, mark a method "always inline" because it is performance sensitive. GCC
 /// 3.4 supported this but is buggy in various cases and produces unimplemented
 /// errors, just use it in GCC 4.0 and later.
+#ifndef LLVM_ATTRIBUTE_ALWAYS_INLINE
 #if __has_attribute(always_inline) || LLVM_GNUC_PREREQ(4, 0, 0)
 #define LLVM_ATTRIBUTE_ALWAYS_INLINE __attribute__((always_inline))
 #elif defined(_MSC_VER)
@@ -200,7 +223,9 @@
 #else
 #define LLVM_ATTRIBUTE_ALWAYS_INLINE
 #endif
+#endif
 
+#ifndef LLVM_ATTRIBUTE_NORETURN
 #ifdef __GNUC__
 #define LLVM_ATTRIBUTE_NORETURN __attribute__((noreturn))
 #elif defined(_MSC_VER)
@@ -208,7 +233,9 @@
 #else
 #define LLVM_ATTRIBUTE_NORETURN
 #endif
+#endif
 
+#ifndef LLVM_ATTRIBUTE_RETURNS_NONNULL
 #if __has_attribute(returns_nonnull) || LLVM_GNUC_PREREQ(4, 9, 0)
 #define LLVM_ATTRIBUTE_RETURNS_NONNULL __attribute__((returns_nonnull))
 #elif defined(_MSC_VER)
@@ -216,9 +243,11 @@
 #else
 #define LLVM_ATTRIBUTE_RETURNS_NONNULL
 #endif
+#endif
 
 /// \macro LLVM_ATTRIBUTE_RETURNS_NOALIAS Used to mark a function as returning a
 /// pointer that does not alias any other valid pointer.
+#ifndef LLVM_ATTRIBUTE_RETURNS_NOALIAS
 #ifdef __GNUC__
 #define LLVM_ATTRIBUTE_RETURNS_NOALIAS __attribute__((__malloc__))
 #elif defined(_MSC_VER)
@@ -226,8 +255,10 @@
 #else
 #define LLVM_ATTRIBUTE_RETURNS_NOALIAS
 #endif
+#endif
 
 /// LLVM_FALLTHROUGH - Mark fallthrough cases in switch statements.
+#ifndef LLVM_FALLTHROUGH
 #if __cplusplus > 201402L && __has_cpp_attribute(fallthrough)
 #define LLVM_FALLTHROUGH [[fallthrough]]
 #elif __has_cpp_attribute(gnu::fallthrough)
@@ -241,16 +272,20 @@
 #else
 #define LLVM_FALLTHROUGH
 #endif
+#endif
 
 /// LLVM_EXTENSION - Support compilers where we have a keyword to suppress
 /// pedantic diagnostics.
+#ifndef LLVM_EXTENSION
 #ifdef __GNUC__
 #define LLVM_EXTENSION __extension__
 #else
 #define LLVM_EXTENSION
 #endif
+#endif
 
 // LLVM_ATTRIBUTE_DEPRECATED(decl, "message")
+#ifndef LLVM_ATTRIBUTE_DEPRECATED
 #if __has_feature(attribute_deprecated_with_message)
 # define LLVM_ATTRIBUTE_DEPRECATED(decl, message) \
   decl __attribute__((deprecated(message)))
@@ -264,18 +299,22 @@
 # define LLVM_ATTRIBUTE_DEPRECATED(decl, message) \
   decl
 #endif
+#endif
 
 /// LLVM_BUILTIN_UNREACHABLE - On compilers which support it, expands
 /// to an expression which states that it is undefined behavior for the
 /// compiler to reach this point.  Otherwise is not defined.
+#ifndef LLVM_BUILTIN_UNREACHABLE
 #if __has_builtin(__builtin_unreachable) || LLVM_GNUC_PREREQ(4, 5, 0)
 # define LLVM_BUILTIN_UNREACHABLE __builtin_unreachable()
 #elif defined(_MSC_VER)
 # define LLVM_BUILTIN_UNREACHABLE __assume(false)
 #endif
+#endif
 
 /// LLVM_BUILTIN_TRAP - On compilers which support it, expands to an expression
 /// which causes the program to exit abnormally.
+#ifndef LLVM_BUILTIN_TRAP
 #if __has_builtin(__builtin_trap) || LLVM_GNUC_PREREQ(4, 3, 0)
 # define LLVM_BUILTIN_TRAP __builtin_trap()
 #elif defined(_MSC_VER)
@@ -287,10 +326,12 @@
 #else
 # define LLVM_BUILTIN_TRAP *(volatile int*)0x11 = 0
 #endif
+#endif
 
 /// LLVM_BUILTIN_DEBUGTRAP - On compilers which support it, expands to
 /// an expression which causes the program to break while running
 /// under a debugger.
+#ifndef LLVM_BUILTIN_DEBUGTRAP
 #if __has_builtin(__builtin_debugtrap)
 # define LLVM_BUILTIN_DEBUGTRAP __builtin_debugtrap()
 #elif defined(_MSC_VER)
@@ -304,9 +345,11 @@
 // program to abort if encountered.
 # define LLVM_BUILTIN_DEBUGTRAP
 #endif
+#endif
 
 /// \macro LLVM_ASSUME_ALIGNED
 /// Returns a pointer with an assumed alignment.
+#ifndef LLVM_ASSUME_ALIGNED
 #if __has_builtin(__builtin_assume_aligned) || LLVM_GNUC_PREREQ(4, 7, 0)
 # define LLVM_ASSUME_ALIGNED(p, a) __builtin_assume_aligned(p, a)
 #elif defined(LLVM_BUILTIN_UNREACHABLE)
@@ -316,14 +359,17 @@
 #else
 # define LLVM_ASSUME_ALIGNED(p, a) (p)
 #endif
+#endif
 
 /// \macro LLVM_ALIGNAS
 /// Used to specify a minimum alignment for a structure or variable.
+#ifndef LLVM_ALIGNAS
 #if __GNUC__ && !__has_feature(cxx_alignas) && !LLVM_GNUC_PREREQ(4, 8, 1)
 # define LLVM_ALIGNAS(x) __attribute__((aligned(x)))
 #else
 # define LLVM_ALIGNAS(x) alignas(x)
 #endif
+#endif
 
 /// \macro LLVM_PACKED
 /// Used to specify a packed structure.
@@ -343,6 +389,7 @@
 ///   long long l;
 /// };
 /// LLVM_PACKED_END
+#ifndef LLVM_PACKED
 #ifdef _MSC_VER
 # define LLVM_PACKED(d) __pragma(pack(push, 1)) d __pragma(pack(pop))
 # define LLVM_PACKED_START __pragma(pack(push, 1))
@@ -352,11 +399,13 @@
 # define LLVM_PACKED_START _Pragma("pack(push, 1)")
 # define LLVM_PACKED_END   _Pragma("pack(pop)")
 #endif
+#endif
 
 /// \macro LLVM_PTR_SIZE
 /// A constant integer equivalent to the value of sizeof(void*).
 /// Generally used in combination with LLVM_ALIGNAS or when doing computation in
 /// the preprocessor.
+#ifndef LLVM_PTR_SIZE
 #ifdef __SIZEOF_POINTER__
 # define LLVM_PTR_SIZE __SIZEOF_POINTER__
 #elif defined(_WIN64)
@@ -368,6 +417,7 @@
 #else
 # define LLVM_PTR_SIZE sizeof(void *)
 #endif
+#endif
 
 /// \macro LLVM_MEMORY_SANITIZER_BUILD
 /// Whether LLVM itself is built with MemorySanitizer instrumentation.
@@ -436,11 +486,13 @@ void AnnotateIgnoreWritesEnd(const char *file, int line);
 
 /// \macro LLVM_NO_SANITIZE
 /// Disable a particular sanitizer for a function.
+#ifndef LLVM_NO_SANITIZE
 #if __has_attribute(no_sanitize)
 #define LLVM_NO_SANITIZE(KIND) __attribute__((no_sanitize(KIND)))
 #else
 #define LLVM_NO_SANITIZE(KIND)
 #endif
+#endif
 
 /// Mark debug helper function definitions like dump() that should not be
 /// stripped from debug builds.
@@ -448,17 +500,20 @@ void AnnotateIgnoreWritesEnd(const char *file, int line);
 /// `#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)` so they do always
 /// get stripped in release builds.
 // FIXME: Move this to a private config.h as it's not usable in public headers.
+#ifndef LLVM_DUMP_METHOD
 #if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
 #define LLVM_DUMP_METHOD LLVM_ATTRIBUTE_NOINLINE LLVM_ATTRIBUTE_USED
 #else
 #define LLVM_DUMP_METHOD LLVM_ATTRIBUTE_NOINLINE
 #endif
+#endif
 
 /// \macro LLVM_PRETTY_FUNCTION
 /// Gets a user-friendly looking function signature for the current scope
 /// using the best available method on each platform.  The exact format of the
 /// resulting string is implementation specific and non-portable, so this should
 /// only be used, for example, for logging or diagnostics.
+#ifndef LLVM_PRETTY_FUNCTION
 #if defined(_MSC_VER)
 #define LLVM_PRETTY_FUNCTION __FUNCSIG__
 #elif defined(__GNUC__) || defined(__clang__)
@@ -466,6 +521,7 @@ void AnnotateIgnoreWritesEnd(const char *file, int line);
 #else
 #define LLVM_PRETTY_FUNCTION __func__
 #endif
+#endif
 
 /// \macro LLVM_THREAD_LOCAL
 /// A thread-local storage specifier which can be used with globals,
diff --git a/llvm/include/llvm/Support/type_traits.h b/llvm/include/llvm/Support/type_traits.h
index 55d84f138f07..27e27af260b2 100644
--- a/llvm/include/llvm/Support/type_traits.h
+++ b/llvm/include/llvm/Support/type_traits.h
@@ -148,14 +148,17 @@ struct is_trivially_move_constructible<T &&> : std::true_type {};
 // If the compiler supports detecting whether a class is final, define
 // an LLVM_IS_FINAL macro. If it cannot be defined properly, this
 // macro will be left undefined.
+#ifndef LLVM_IS_FINAL
 #if __cplusplus >= 201402L || defined(_MSC_VER)
 #define LLVM_IS_FINAL(Ty) std::is_final<Ty>()
 #elif __has_feature(is_final) || LLVM_GNUC_PREREQ(4, 7, 0)
 #define LLVM_IS_FINAL(Ty) __is_final(Ty)
 #endif
+#endif
 
 #ifdef LLVM_DEFINED_HAS_FEATURE
 #undef __has_feature
+#undef LLVM_DEFINED_HAS_FEATURE
 #endif
 
 #endif // LLVM_SUPPORT_TYPE_TRAITS_H
-- 
2.20.1.windows.1

