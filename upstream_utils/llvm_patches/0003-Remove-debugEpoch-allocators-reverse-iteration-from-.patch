From edbc7101e822e67a4fe7c03b93a81a9dc8f09fca Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Tue, 3 May 2022 19:58:29 -0400
Subject: [PATCH 03/35] Remove debugEpoch, allocators, reverse iteration from
 collections

---
 llvm/include/llvm/ADT/DenseMap.h       | 74 ++++----------------------
 llvm/include/llvm/ADT/SmallPtrSet.h    | 35 ++----------
 llvm/include/llvm/ADT/StringMap.h      | 33 ++++--------
 llvm/include/llvm/ADT/StringMapEntry.h | 25 +++------
 llvm/lib/Support/SmallPtrSet.cpp       |  1 -
 llvm/unittests/ADT/StringMapTest.cpp   | 12 ++---
 6 files changed, 37 insertions(+), 143 deletions(-)

diff --git a/llvm/include/llvm/ADT/DenseMap.h b/llvm/include/llvm/ADT/DenseMap.h
index 595eabd0ffb4..fc79bdb01d7d 100644
--- a/llvm/include/llvm/ADT/DenseMap.h
+++ b/llvm/include/llvm/ADT/DenseMap.h
@@ -76,8 +76,6 @@ public:
     // empty buckets.
     if (empty())
       return end();
-    if (shouldReverseIterate<KeyT>())
-      return makeIterator(getBucketsEnd() - 1, getBuckets(), *this);
     return makeIterator(getBuckets(), getBucketsEnd(), *this);
   }
   inline iterator end() {
@@ -86,8 +84,6 @@ public:
   inline const_iterator begin() const {
     if (empty())
       return end();
-    if (shouldReverseIterate<KeyT>())
-      return makeConstIterator(getBucketsEnd() - 1, getBuckets(), *this);
     return makeConstIterator(getBuckets(), getBucketsEnd(), *this);
   }
   inline const_iterator end() const {
@@ -150,18 +146,14 @@ public:
   iterator find(const_arg_type_t<KeyT> Val) {
     BucketT *TheBucket;
     if (LookupBucketFor(Val, TheBucket))
-      return makeIterator(TheBucket,
-                          shouldReverseIterate<KeyT>() ? getBuckets()
-                                                       : getBucketsEnd(),
+      return makeIterator(TheBucket, getBucketsEnd(),
                           *this, true);
     return end();
   }
   const_iterator find(const_arg_type_t<KeyT> Val) const {
     const BucketT *TheBucket;
     if (LookupBucketFor(Val, TheBucket))
-      return makeConstIterator(TheBucket,
-                               shouldReverseIterate<KeyT>() ? getBuckets()
-                                                            : getBucketsEnd(),
+      return makeConstIterator(TheBucket, getBucketsEnd(),
                                *this, true);
     return end();
   }
@@ -175,9 +167,7 @@ public:
   iterator find_as(const LookupKeyT &Val) {
     BucketT *TheBucket;
     if (LookupBucketFor(Val, TheBucket))
-      return makeIterator(TheBucket,
-                          shouldReverseIterate<KeyT>() ? getBuckets()
-                                                       : getBucketsEnd(),
+      return makeIterator(TheBucket, getBucketsEnd(),
                           *this, true);
     return end();
   }
@@ -185,9 +175,7 @@ public:
   const_iterator find_as(const LookupKeyT &Val) const {
     const BucketT *TheBucket;
     if (LookupBucketFor(Val, TheBucket))
-      return makeConstIterator(TheBucket,
-                               shouldReverseIterate<KeyT>() ? getBuckets()
-                                                            : getBucketsEnd(),
+      return makeConstIterator(TheBucket, getBucketsEnd(),
                                *this, true);
     return end();
   }
@@ -222,20 +210,14 @@ public:
   std::pair<iterator, bool> try_emplace(KeyT &&Key, Ts &&... Args) {
     BucketT *TheBucket;
     if (LookupBucketFor(Key, TheBucket))
-      return std::make_pair(makeIterator(TheBucket,
-                                         shouldReverseIterate<KeyT>()
-                                             ? getBuckets()
-                                             : getBucketsEnd(),
+      return std::make_pair(makeIterator(TheBucket, getBucketsEnd(),
                                          *this, true),
                             false); // Already in map.
 
     // Otherwise, insert the new element.
     TheBucket =
         InsertIntoBucket(TheBucket, std::move(Key), std::forward<Ts>(Args)...);
-    return std::make_pair(makeIterator(TheBucket,
-                                       shouldReverseIterate<KeyT>()
-                                           ? getBuckets()
-                                           : getBucketsEnd(),
+    return std::make_pair(makeIterator(TheBucket, getBucketsEnd(),
                                        *this, true),
                           true);
   }
@@ -247,19 +229,13 @@ public:
   std::pair<iterator, bool> try_emplace(const KeyT &Key, Ts &&... Args) {
     BucketT *TheBucket;
     if (LookupBucketFor(Key, TheBucket))
-      return std::make_pair(makeIterator(TheBucket,
-                                         shouldReverseIterate<KeyT>()
-                                             ? getBuckets()
-                                             : getBucketsEnd(),
+      return std::make_pair(makeIterator(TheBucket, getBucketsEnd(),
                                          *this, true),
                             false); // Already in map.
 
     // Otherwise, insert the new element.
     TheBucket = InsertIntoBucket(TheBucket, Key, std::forward<Ts>(Args)...);
-    return std::make_pair(makeIterator(TheBucket,
-                                       shouldReverseIterate<KeyT>()
-                                           ? getBuckets()
-                                           : getBucketsEnd(),
+    return std::make_pair(makeIterator(TheBucket, getBucketsEnd(),
                                        *this, true),
                           true);
   }
@@ -274,20 +250,14 @@ public:
                                       const LookupKeyT &Val) {
     BucketT *TheBucket;
     if (LookupBucketFor(Val, TheBucket))
-      return std::make_pair(makeIterator(TheBucket,
-                                         shouldReverseIterate<KeyT>()
-                                             ? getBuckets()
-                                             : getBucketsEnd(),
+      return std::make_pair(makeIterator(TheBucket, getBucketsEnd(),
                                          *this, true),
                             false); // Already in map.
 
     // Otherwise, insert the new element.
     TheBucket = InsertIntoBucketWithLookup(TheBucket, std::move(KV.first),
                                            std::move(KV.second), Val);
-    return std::make_pair(makeIterator(TheBucket,
-                                       shouldReverseIterate<KeyT>()
-                                           ? getBuckets()
-                                           : getBucketsEnd(),
+    return std::make_pair(makeIterator(TheBucket, getBucketsEnd(),
                                        *this, true),
                           true);
   }
@@ -464,20 +434,12 @@ private:
   iterator makeIterator(BucketT *P, BucketT *E,
                         DebugEpochBase &Epoch,
                         bool NoAdvance=false) {
-    if (shouldReverseIterate<KeyT>()) {
-      BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;
-      return iterator(B, E, Epoch, NoAdvance);
-    }
     return iterator(P, E, Epoch, NoAdvance);
   }
 
   const_iterator makeConstIterator(const BucketT *P, const BucketT *E,
                                    const DebugEpochBase &Epoch,
                                    const bool NoAdvance=false) const {
-    if (shouldReverseIterate<KeyT>()) {
-      const BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;
-      return const_iterator(B, E, Epoch, NoAdvance);
-    }
     return const_iterator(P, E, Epoch, NoAdvance);
   }
 
@@ -1214,10 +1176,6 @@ public:
     assert(isHandleInSync() && "invalid construction!");
 
     if (NoAdvance) return;
-    if (shouldReverseIterate<KeyT>()) {
-      RetreatPastEmptyBuckets();
-      return;
-    }
     AdvancePastEmptyBuckets();
   }
 
@@ -1232,16 +1190,10 @@ public:
 
   reference operator*() const {
     assert(isHandleInSync() && "invalid iterator access!");
-    assert(Ptr != End && "dereferencing end() iterator");
-    if (shouldReverseIterate<KeyT>())
-      return Ptr[-1];
     return *Ptr;
   }
   pointer operator->() const {
     assert(isHandleInSync() && "invalid iterator access!");
-    assert(Ptr != End && "dereferencing end() iterator");
-    if (shouldReverseIterate<KeyT>())
-      return &(Ptr[-1]);
     return Ptr;
   }
 
@@ -1261,12 +1213,6 @@ public:
 
   inline DenseMapIterator& operator++() {  // Preincrement
     assert(isHandleInSync() && "invalid iterator access!");
-    assert(Ptr != End && "incrementing end() iterator");
-    if (shouldReverseIterate<KeyT>()) {
-      --Ptr;
-      RetreatPastEmptyBuckets();
-      return *this;
-    }
     ++Ptr;
     AdvancePastEmptyBuckets();
     return *this;
diff --git a/llvm/include/llvm/ADT/SmallPtrSet.h b/llvm/include/llvm/ADT/SmallPtrSet.h
index 981b741669b0..2edc1f5e2066 100644
--- a/llvm/include/llvm/ADT/SmallPtrSet.h
+++ b/llvm/include/llvm/ADT/SmallPtrSet.h
@@ -14,7 +14,6 @@
 #ifndef LLVM_ADT_SMALLPTRSET_H
 #define LLVM_ADT_SMALLPTRSET_H
 
-#include "llvm/ADT/EpochTracker.h"
 #include "llvm/Support/Compiler.h"
 #include "llvm/Support/ReverseIteration.h"
 #include "llvm/Support/type_traits.h"
@@ -46,7 +45,7 @@ namespace llvm {
 /// (-2), to allow deletion.  The hash table is resized when the table is 3/4 or
 /// more.  When this happens, the table is doubled in size.
 ///
-class SmallPtrSetImplBase : public DebugEpochBase {
+class SmallPtrSetImplBase {
   friend class SmallPtrSetIteratorImpl;
 
 protected:
@@ -92,7 +91,6 @@ public:
   size_type size() const { return NumNonEmpty - NumTombstones; }
 
   void clear() {
-    incrementEpoch();
     // If the capacity of the array is huge, and the # elements used is small,
     // shrink the array.
     if (!isSmall()) {
@@ -139,14 +137,12 @@ protected:
       if (LastTombstone != nullptr) {
         *LastTombstone = Ptr;
         --NumTombstones;
-        incrementEpoch();
         return std::make_pair(LastTombstone, true);
       }
 
       // Nope, there isn't.  If we stay small, just 'pushback' now.
       if (NumNonEmpty < CurArraySize) {
         SmallArray[NumNonEmpty++] = Ptr;
-        incrementEpoch();
         return std::make_pair(SmallArray + (NumNonEmpty - 1), true);
       }
       // Otherwise, hit the big set case, which will call grow.
@@ -226,10 +222,6 @@ protected:
 public:
   explicit SmallPtrSetIteratorImpl(const void *const *BP, const void*const *E)
     : Bucket(BP), End(E) {
-    if (shouldReverseIterate()) {
-      RetreatIfNotValid();
-      return;
-    }
     AdvanceIfNotValid();
   }
 
@@ -263,8 +255,7 @@ protected:
 
 /// SmallPtrSetIterator - This implements a const_iterator for SmallPtrSet.
 template <typename PtrTy>
-class SmallPtrSetIterator : public SmallPtrSetIteratorImpl,
-                            DebugEpochBase::HandleBase {
+class SmallPtrSetIterator : public SmallPtrSetIteratorImpl {
   using PtrTraits = PointerLikeTypeTraits<PtrTy>;
 
 public:
@@ -274,29 +265,17 @@ public:
   using difference_type = std::ptrdiff_t;
   using iterator_category = std::forward_iterator_tag;
 
-  explicit SmallPtrSetIterator(const void *const *BP, const void *const *E,
-                               const DebugEpochBase &Epoch)
-      : SmallPtrSetIteratorImpl(BP, E), DebugEpochBase::HandleBase(&Epoch) {}
+  explicit SmallPtrSetIterator(const void *const *BP, const void *const *E)
+      : SmallPtrSetIteratorImpl(BP, E) {}
 
   // Most methods are provided by the base class.
 
   const PtrTy operator*() const {
-    assert(isHandleInSync() && "invalid iterator access!");
-    if (shouldReverseIterate()) {
-      assert(Bucket > End);
-      return PtrTraits::getFromVoidPointer(const_cast<void *>(Bucket[-1]));
-    }
     assert(Bucket < End);
     return PtrTraits::getFromVoidPointer(const_cast<void*>(*Bucket));
   }
 
   inline SmallPtrSetIterator& operator++() {          // Preincrement
-    assert(isHandleInSync() && "invalid iterator access!");
-    if (shouldReverseIterate()) {
-      --Bucket;
-      RetreatIfNotValid();
-      return *this;
-    }
     ++Bucket;
     AdvanceIfNotValid();
     return *this;
@@ -400,8 +379,6 @@ public:
   }
 
   iterator begin() const {
-    if (shouldReverseIterate())
-      return makeIterator(EndPointer() - 1);
     return makeIterator(CurArray);
   }
   iterator end() const { return makeIterator(EndPointer()); }
@@ -409,9 +386,7 @@ public:
 private:
   /// Create an iterator that dereferences to same place as the given pointer.
   iterator makeIterator(const void *const *P) const {
-    if (shouldReverseIterate())
-      return iterator(P == EndPointer() ? CurArray : P + 1, CurArray, *this);
-    return iterator(P, EndPointer(), *this);
+    return iterator(P, EndPointer());
   }
 };
 
diff --git a/llvm/include/llvm/ADT/StringMap.h b/llvm/include/llvm/ADT/StringMap.h
index a82afc9a817c..a97b5660da53 100644
--- a/llvm/include/llvm/ADT/StringMap.h
+++ b/llvm/include/llvm/ADT/StringMap.h
@@ -104,10 +104,8 @@ public:
 /// keys that are "strings", which are basically ranges of bytes. This does some
 /// funky memory allocation and hashing things to make it extremely efficient,
 /// storing the string data *after* the value in the map.
-template <typename ValueTy, typename AllocatorTy = MallocAllocator>
+template<typename ValueTy>
 class StringMap : public StringMapImpl {
-  AllocatorTy Allocator;
-
 public:
   using MapEntryTy = StringMapEntry<ValueTy>;
 
@@ -116,14 +114,6 @@ public:
   explicit StringMap(unsigned InitialSize)
       : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))) {}
 
-  explicit StringMap(AllocatorTy A)
-      : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))), Allocator(A) {
-  }
-
-  StringMap(unsigned InitialSize, AllocatorTy A)
-      : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))),
-        Allocator(A) {}
-
   StringMap(std::initializer_list<std::pair<StringRef, ValueTy>> List)
       : StringMapImpl(List.size(), static_cast<unsigned>(sizeof(MapEntryTy))) {
     for (const auto &P : List) {
@@ -132,11 +122,10 @@ public:
   }
 
   StringMap(StringMap &&RHS)
-      : StringMapImpl(std::move(RHS)), Allocator(std::move(RHS.Allocator)) {}
+      : StringMapImpl(std::move(RHS)) {}
 
-  StringMap(const StringMap &RHS)
-      : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))),
-        Allocator(RHS.Allocator) {
+  StringMap(const StringMap &RHS) :
+    StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))) {
     if (RHS.empty())
       return;
 
@@ -156,7 +145,7 @@ public:
       }
 
       TheTable[I] = MapEntryTy::Create(
-          static_cast<MapEntryTy *>(Bucket)->getKey(), Allocator,
+          static_cast<MapEntryTy *>(Bucket)->getKey(),
           static_cast<MapEntryTy *>(Bucket)->getValue());
       HashTable[I] = RHSHashTable[I];
     }
@@ -171,7 +160,6 @@ public:
 
   StringMap &operator=(StringMap RHS) {
     StringMapImpl::swap(RHS);
-    std::swap(Allocator, RHS.Allocator);
     return *this;
   }
 
@@ -183,16 +171,13 @@ public:
       for (unsigned I = 0, E = NumBuckets; I != E; ++I) {
         StringMapEntryBase *Bucket = TheTable[I];
         if (Bucket && Bucket != getTombstoneVal()) {
-          static_cast<MapEntryTy *>(Bucket)->Destroy(Allocator);
+          static_cast<MapEntryTy*>(Bucket)->Destroy();
         }
       }
     }
     free(TheTable);
   }
 
-  AllocatorTy &getAllocator() { return Allocator; }
-  const AllocatorTy &getAllocator() const { return Allocator; }
-
   using key_type = const char *;
   using mapped_type = ValueTy;
   using value_type = StringMapEntry<ValueTy>;
@@ -321,7 +306,7 @@ public:
 
     if (Bucket == getTombstoneVal())
       --NumTombstones;
-    Bucket = MapEntryTy::Create(Key, Allocator, std::forward<ArgsTy>(Args)...);
+    Bucket = MapEntryTy::Create(Key, std::forward<ArgsTy>(Args)...);
     ++NumItems;
     assert(NumItems + NumTombstones <= NumBuckets);
 
@@ -339,7 +324,7 @@ public:
     for (unsigned I = 0, E = NumBuckets; I != E; ++I) {
       StringMapEntryBase *&Bucket = TheTable[I];
       if (Bucket && Bucket != getTombstoneVal()) {
-        static_cast<MapEntryTy *>(Bucket)->Destroy(Allocator);
+        static_cast<MapEntryTy*>(Bucket)->Destroy();
       }
       Bucket = nullptr;
     }
@@ -355,7 +340,7 @@ public:
   void erase(iterator I) {
     MapEntryTy &V = *I;
     remove(&V);
-    V.Destroy(Allocator);
+    V.Destroy();
   }
 
   bool erase(StringRef Key) {
diff --git a/llvm/include/llvm/ADT/StringMapEntry.h b/llvm/include/llvm/ADT/StringMapEntry.h
index 8bfad5540230..633404af394d 100644
--- a/llvm/include/llvm/ADT/StringMapEntry.h
+++ b/llvm/include/llvm/ADT/StringMapEntry.h
@@ -32,22 +32,14 @@ protected:
   /// Helper to tail-allocate \p Key. It'd be nice to generalize this so it
   /// could be reused elsewhere, maybe even taking an llvm::function_ref to
   /// type-erase the allocator and put it in a source file.
-  template <typename AllocatorTy>
   static void *allocateWithKey(size_t EntrySize, size_t EntryAlign,
-                               StringRef Key, AllocatorTy &Allocator);
-};
-
-// Define out-of-line to dissuade inlining.
-template <typename AllocatorTy>
-void *StringMapEntryBase::allocateWithKey(size_t EntrySize, size_t EntryAlign,
-                                          StringRef Key,
-                                          AllocatorTy &Allocator) {
+                               StringRef Key) {
   size_t KeyLength = Key.size();
 
   // Allocate a new item with space for the string at the end and a null
   // terminator.
   size_t AllocSize = EntrySize + KeyLength + 1;
-  void *Allocation = Allocator.Allocate(AllocSize, EntryAlign);
+  void *Allocation = safe_malloc(AllocSize);
   assert(Allocation && "Unhandled out-of-memory");
 
   // Copy the string information.
@@ -57,6 +49,7 @@ void *StringMapEntryBase::allocateWithKey(size_t EntrySize, size_t EntryAlign,
   Buffer[KeyLength] = 0; // Null terminate for convenience of clients.
   return Allocation;
 }
+};
 
 /// StringMapEntryStorage - Holds the value in a StringMapEntry.
 ///
@@ -116,11 +109,11 @@ public:
 
   /// Create a StringMapEntry for the specified key construct the value using
   /// \p InitiVals.
-  template <typename AllocatorTy, typename... InitTy>
-  static StringMapEntry *Create(StringRef key, AllocatorTy &allocator,
+  template <typename... InitTy>
+  static StringMapEntry *Create(StringRef key,
                                 InitTy &&... initVals) {
     return new (StringMapEntryBase::allocateWithKey(
-        sizeof(StringMapEntry), alignof(StringMapEntry), key, allocator))
+        sizeof(StringMapEntry), alignof(StringMapEntry), key))
         StringMapEntry(key.size(), std::forward<InitTy>(initVals)...);
   }
 
@@ -133,12 +126,10 @@ public:
 
   /// Destroy - Destroy this StringMapEntry, releasing memory back to the
   /// specified allocator.
-  template <typename AllocatorTy> void Destroy(AllocatorTy &allocator) {
+  void Destroy() {
     // Free memory referenced by the item.
-    size_t AllocSize = sizeof(StringMapEntry) + this->getKeyLength() + 1;
     this->~StringMapEntry();
-    allocator.Deallocate(static_cast<void *>(this), AllocSize,
-                         alignof(StringMapEntry));
+    std::free(static_cast<void *>(this));
   }
 };
 
diff --git a/llvm/lib/Support/SmallPtrSet.cpp b/llvm/lib/Support/SmallPtrSet.cpp
index f6e2dfb8a6c9..4549db08e3ee 100644
--- a/llvm/lib/Support/SmallPtrSet.cpp
+++ b/llvm/lib/Support/SmallPtrSet.cpp
@@ -59,7 +59,6 @@ SmallPtrSetImplBase::insert_imp_big(const void *Ptr) {
   else
     ++NumNonEmpty; // Track density.
   *Bucket = Ptr;
-  incrementEpoch();
   return std::make_pair(Bucket, true);
 }
 
diff --git a/llvm/unittests/ADT/StringMapTest.cpp b/llvm/unittests/ADT/StringMapTest.cpp
index 98fbd6e1df5a..bda3d4ff9679 100644
--- a/llvm/unittests/ADT/StringMapTest.cpp
+++ b/llvm/unittests/ADT/StringMapTest.cpp
@@ -224,13 +224,12 @@ TEST_F(StringMapTest, IterationTest) {
 
 // Test StringMapEntry::Create() method.
 TEST_F(StringMapTest, StringMapEntryTest) {
-  MallocAllocator Allocator;
   StringMap<uint32_t>::value_type *entry =
       StringMap<uint32_t>::value_type::Create(
           StringRef(testKeyFirst, testKeyLength), Allocator, 1u);
   EXPECT_STREQ(testKey, entry->first().data());
   EXPECT_EQ(1u, entry->second);
-  entry->Destroy(Allocator);
+  entry->Destroy();
 }
 
 // Test insert() method.
@@ -354,15 +353,14 @@ TEST_F(StringMapTest, MoveOnly) {
   StringMap<MoveOnly> t;
   t.insert(std::make_pair("Test", MoveOnly(42)));
   StringRef Key = "Test";
-  StringMapEntry<MoveOnly>::Create(Key, t.getAllocator(), MoveOnly(42))
-      ->Destroy(t.getAllocator());
+  StringMapEntry<MoveOnly>::Create(Key, MoveOnly(42))
+      ->Destroy();
 }
 
 TEST_F(StringMapTest, CtorArg) {
   StringRef Key = "Test";
-  MallocAllocator Allocator;
-  StringMapEntry<MoveOnly>::Create(Key, Allocator, Immovable())
-      ->Destroy(Allocator);
+  StringMapEntry<MoveOnly>::Create(Key, Immovable())
+      ->Destroy();
 }
 
 TEST_F(StringMapTest, MoveConstruct) {
-- 
2.20.1.windows.1

