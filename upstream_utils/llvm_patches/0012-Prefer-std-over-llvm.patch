From 93af57ce33bb21449c9cd89a6128ab7b48a622c2 Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Tue, 3 May 2022 21:56:02 -0400
Subject: [PATCH 12/35] Prefer std:: over llvm::

---
 llvm/include/llvm/ADT/FunctionExtras.h  |   6 +-
 llvm/include/llvm/ADT/PointerIntPair.h  |  13 ---
 llvm/include/llvm/ADT/SmallVector.h     |   4 +-
 llvm/include/llvm/Support/MathExtras.h  |   2 +-
 llvm/include/llvm/Support/type_traits.h | 117 ------------------------
 llvm/lib/Support/ErrorHandling.cpp      |   3 +-
 llvm/unittests/ADT/SmallPtrSetTest.cpp  |   2 +-
 7 files changed, 9 insertions(+), 138 deletions(-)

diff --git a/llvm/include/llvm/ADT/FunctionExtras.h b/llvm/include/llvm/ADT/FunctionExtras.h
index e67ef7377c88..a120848f24bd 100644
--- a/llvm/include/llvm/ADT/FunctionExtras.h
+++ b/llvm/include/llvm/ADT/FunctionExtras.h
@@ -58,7 +58,7 @@ namespace detail {
 
 template <typename T>
 using EnableIfTrivial =
-    std::enable_if_t<llvm::is_trivially_move_constructible<T>::value &&
+    std::enable_if_t<std::is_trivially_move_constructible<T>::value &&
                      std::is_trivially_destructible<T>::value>;
 template <typename CallableT, typename ThisT>
 using EnableUnlessSameType =
@@ -94,8 +94,8 @@ protected:
     static_assert(!std::is_reference<T>::value,
                   "references should be handled by template specialization");
     using type = typename std::conditional<
-        llvm::is_trivially_copy_constructible<T>::value &&
-            llvm::is_trivially_move_constructible<T>::value &&
+        std::is_trivially_copy_constructible<T>::value &&
+            std::is_trivially_move_constructible<T>::value &&
             IsSizeLessThanThresholdT<T>::value,
         T, T &>::type;
   };
diff --git a/llvm/include/llvm/ADT/PointerIntPair.h b/llvm/include/llvm/ADT/PointerIntPair.h
index cb8b202c48b7..7c9cebb6754b 100644
--- a/llvm/include/llvm/ADT/PointerIntPair.h
+++ b/llvm/include/llvm/ADT/PointerIntPair.h
@@ -127,19 +127,6 @@ public:
   }
 };
 
-// Specialize is_trivially_copyable to avoid limitation of llvm::is_trivially_copyable
-// when compiled with gcc 4.9.
-template <typename PointerTy, unsigned IntBits, typename IntType,
-          typename PtrTraits,
-          typename Info>
-struct is_trivially_copyable<PointerIntPair<PointerTy, IntBits, IntType, PtrTraits, Info>> : std::true_type {
-#ifdef HAVE_STD_IS_TRIVIALLY_COPYABLE
-  static_assert(std::is_trivially_copyable<PointerIntPair<PointerTy, IntBits, IntType, PtrTraits, Info>>::value,
-                "inconsistent behavior between llvm:: and std:: implementation of is_trivially_copyable");
-#endif
-};
-
-
 template <typename PointerT, unsigned IntBits, typename PtrTraits>
 struct PointerIntPairInfo {
   static_assert(PtrTraits::NumLowBitsAvailable <
diff --git a/llvm/include/llvm/ADT/SmallVector.h b/llvm/include/llvm/ADT/SmallVector.h
index 602fcc5b7a98..af0b28eb14a9 100644
--- a/llvm/include/llvm/ADT/SmallVector.h
+++ b/llvm/include/llvm/ADT/SmallVector.h
@@ -309,8 +309,8 @@ public:
 /// copy these types with memcpy, there is no way for the type to observe this.
 /// This catches the important case of std::pair<POD, POD>, which is not
 /// trivially assignable.
-template <typename T, bool = (is_trivially_copy_constructible<T>::value) &&
-                             (is_trivially_move_constructible<T>::value) &&
+template <typename T, bool = (std::is_trivially_copy_constructible<T>::value) &&
+                             (std::is_trivially_move_constructible<T>::value) &&
                              std::is_trivially_destructible<T>::value>
 class SmallVectorTemplateBase : public SmallVectorTemplateCommon<T> {
   friend class SmallVectorTemplateCommon<T>;
diff --git a/llvm/include/llvm/Support/MathExtras.h b/llvm/include/llvm/Support/MathExtras.h
index db9fbc148ae3..da843ef79ff9 100644
--- a/llvm/include/llvm/Support/MathExtras.h
+++ b/llvm/include/llvm/Support/MathExtras.h
@@ -586,7 +586,7 @@ inline double Log2(double Value) {
 #if defined(__ANDROID_API__) && __ANDROID_API__ < 18
   return __builtin_log(Value) / __builtin_log(2.0);
 #else
-  return log2(Value);
+  return std::log2(Value);
 #endif
 }
 
diff --git a/llvm/include/llvm/Support/type_traits.h b/llvm/include/llvm/Support/type_traits.h
index 7b7d5d991f3f..0beab0128a40 100644
--- a/llvm/include/llvm/Support/type_traits.h
+++ b/llvm/include/llvm/Support/type_traits.h
@@ -69,123 +69,6 @@ struct const_pointer_or_const_ref<T,
   using type = typename add_const_past_pointer<T>::type;
 };
 
-namespace detail {
-/// Internal utility to detect trivial copy construction.
-template<typename T> union copy_construction_triviality_helper {
-    T t;
-    copy_construction_triviality_helper() = default;
-    copy_construction_triviality_helper(const copy_construction_triviality_helper&) = default;
-    ~copy_construction_triviality_helper() = default;
-};
-/// Internal utility to detect trivial move construction.
-template<typename T> union move_construction_triviality_helper {
-    T t;
-    move_construction_triviality_helper() = default;
-    move_construction_triviality_helper(move_construction_triviality_helper&&) = default;
-    ~move_construction_triviality_helper() = default;
-};
-
-template<class T>
-union trivial_helper {
-    T t;
-};
-
-} // end namespace detail
-
-/// An implementation of `std::is_trivially_copy_constructible` since we have
-/// users with STLs that don't yet include it.
-template <typename T>
-struct is_trivially_copy_constructible
-    : std::is_copy_constructible<
-          ::llvm::detail::copy_construction_triviality_helper<T>> {};
-template <typename T>
-struct is_trivially_copy_constructible<T &> : std::true_type {};
-template <typename T>
-struct is_trivially_copy_constructible<T &&> : std::false_type {};
-
-/// An implementation of `std::is_trivially_move_constructible` since we have
-/// users with STLs that don't yet include it.
-template <typename T>
-struct is_trivially_move_constructible
-    : std::is_move_constructible<
-          ::llvm::detail::move_construction_triviality_helper<T>> {};
-template <typename T>
-struct is_trivially_move_constructible<T &> : std::true_type {};
-template <typename T>
-struct is_trivially_move_constructible<T &&> : std::true_type {};
-
-
-template <typename T>
-struct is_copy_assignable {
-  template<class F>
-    static auto get(F*) -> decltype(std::declval<F &>() = std::declval<const F &>(), std::true_type{});
-    static std::false_type get(...);
-    static constexpr bool value = decltype(get((T*)nullptr))::value;
-};
-
-template <typename T>
-struct is_move_assignable {
-  template<class F>
-    static auto get(F*) -> decltype(std::declval<F &>() = std::declval<F &&>(), std::true_type{});
-    static std::false_type get(...);
-    static constexpr bool value = decltype(get((T*)nullptr))::value;
-};
-
-
-// An implementation of `std::is_trivially_copyable` since STL version
-// is not equally supported by all compilers, especially GCC 4.9.
-// Uniform implementation of this trait is important for ABI compatibility
-// as it has an impact on SmallVector's ABI (among others).
-template <typename T>
-class is_trivially_copyable {
-
-  // copy constructors
-  static constexpr bool has_trivial_copy_constructor =
-      std::is_copy_constructible<detail::trivial_helper<T>>::value;
-  static constexpr bool has_deleted_copy_constructor =
-      !std::is_copy_constructible<T>::value;
-
-  // move constructors
-  static constexpr bool has_trivial_move_constructor =
-      std::is_move_constructible<detail::trivial_helper<T>>::value;
-  static constexpr bool has_deleted_move_constructor =
-      !std::is_move_constructible<T>::value;
-
-  // copy assign
-  static constexpr bool has_trivial_copy_assign =
-      is_copy_assignable<detail::trivial_helper<T>>::value;
-  static constexpr bool has_deleted_copy_assign =
-      !is_copy_assignable<T>::value;
-
-  // move assign
-  static constexpr bool has_trivial_move_assign =
-      is_move_assignable<detail::trivial_helper<T>>::value;
-  static constexpr bool has_deleted_move_assign =
-      !is_move_assignable<T>::value;
-
-  // destructor
-  static constexpr bool has_trivial_destructor =
-      std::is_destructible<detail::trivial_helper<T>>::value;
-
-  public:
-
-  static constexpr bool value =
-      has_trivial_destructor &&
-      (has_deleted_move_assign || has_trivial_move_assign) &&
-      (has_deleted_move_constructor || has_trivial_move_constructor) &&
-      (has_deleted_copy_assign || has_trivial_copy_assign) &&
-      (has_deleted_copy_constructor || has_trivial_copy_constructor);
-
-#ifdef HAVE_STD_IS_TRIVIALLY_COPYABLE
-  static_assert(value == std::is_trivially_copyable<T>::value,
-                "inconsistent behavior between llvm:: and std:: implementation of is_trivially_copyable");
-#endif
-};
-template <typename T>
-class is_trivially_copyable<T*> : public std::true_type {
-};
-
-
 } // end namespace llvm
 
 #endif // LLVM_SUPPORT_TYPE_TRAITS_H
diff --git a/llvm/lib/Support/ErrorHandling.cpp b/llvm/lib/Support/ErrorHandling.cpp
index 4b91f214c841..0420b54b0a85 100644
--- a/llvm/lib/Support/ErrorHandling.cpp
+++ b/llvm/lib/Support/ErrorHandling.cpp
@@ -205,12 +205,13 @@ void LLVMResetFatalErrorHandler() {
 
 #ifdef _WIN32
 
+#include <system_error>
 #include <winerror.h>
 
 // I'd rather not double the line count of the following.
 #define MAP_ERR_TO_COND(x, y)                                                  \
   case x:                                                                      \
-    return make_error_code(errc::y)
+    return std::make_error_code(std::errc::y)
 
 std::error_code llvm::mapWindowsError(unsigned EV) {
   switch (EV) {
diff --git a/llvm/unittests/ADT/SmallPtrSetTest.cpp b/llvm/unittests/ADT/SmallPtrSetTest.cpp
index 6f3c94eed273..531f81ab5b3f 100644
--- a/llvm/unittests/ADT/SmallPtrSetTest.cpp
+++ b/llvm/unittests/ADT/SmallPtrSetTest.cpp
@@ -298,7 +298,7 @@ TEST(SmallPtrSetTest, dereferenceAndIterate) {
 
   // Sort.  We should hit the first element just once and the final element N
   // times.
-  llvm::sort(std::begin(Found), std::end(Found));
+  std::sort(std::begin(Found), std::end(Found));
   for (auto F = std::begin(Found), E = std::end(Found); F != E; ++F)
     EXPECT_EQ(F - Found + 1, *F);
 }
-- 
2.20.1.windows.1

